! -*- mode: f90 -*-
!
! $Id: revcomp.ifc,v 1.4 2005-10-20 21:37:12 sgeard-guest Exp $ ; $Name:  $
!
! The Great Computer Language Shootout
! http://shootout.alioth.debian.org/
!
! contributed by Simon Geard, 25/03/2005
!
! ifort rev-comp.f90 -O3 -static-libcxa -o rev-comp
!
! $Id: revcomp.ifc,v 1.4 2005-10-20 21:37:12 sgeard-guest Exp $ ; $Name:  $
!
program revcomp
  implicit none
  character(len=1), parameter                         :: end_str = '>'
  integer, parameter                                  :: lineWidth = 60
  logical                                             :: insection
  integer                                             :: as, bcount
  character(len=lineWidth)                            :: line
  character(len=lineWidth)                            :: title
  character(len=lineWidth), dimension(:), allocatable :: data
  character(len=lineWidth), dimension(:), allocatable :: w
  
  ! Read and process
  insection = .false.
  allocate(data(100))  ! Allocate enough lines so that we don't have to grow the array for the test
  readFile: do
     read(*,'(a)',end=100) line
     if (line(1:1) == end_str) then
        if (insection) then
           write(*,'(a)') trim(title)
           call printReverseFasta(data, bcount)
        else
           insection = .true.
        end if
        title = line
        bcount = 0
        cycle readFile
     end if
     bcount = bcount + 1
     if (bcount > size(data)) then ! Included for completeness - it shouldn't be called in the test
        allocate(w(size(data)))
        w = data
        deallocate(data)
        allocate(data(2*size(w)),stat=as)
        if (as > 0) then
           write(*,'(a,i0)') '***failed to allocate ',2*size(w)
        end if
        data = w
        deallocate(w)
     end if
     data(bcount) = line
  end do readFile
100 continue
  write(*,'(a)') trim(title)
  call printReverseFasta(data, bcount)
  stop

contains
  subroutine printReverseFasta(data, bcount)
    ! Output the data in reverse order and with the complement
    character(len=*), dimension(:), allocatable, intent(in) :: data
    integer, intent(in) :: bcount
    integer :: i, j, k

    k = 0
    do i=bcount,1,-1
       do j=len(trim(data(i))),1,-1
          k = k+1
          if (k == lineWidth) then
             write(*,'(a1)') complement(data(i)(j:j))
             k = 0
          else
             write(*,'(a1)',advance='no') complement(data(i)(j:j))
          end if
       end do
    end do
    if (k /= 0) write(*,'(a)') ''
  end subroutine printReverseFasta

  character(len=1) function complement(c)
    ! Return the complement of c
    character(len=*), intent(in) :: c
    select case(c)
       case('T','U','t','u')
          complement = 'A'
       case('V','v')
          complement = 'B'
       case('G','g')
          complement = 'C'
       case('H','h')
          complement = 'D'
       case('C','c')
          complement = 'G'
       case('D','d')
          complement = 'H'
       case('M','m')
          complement = 'K'
       case('K','k')
          complement = 'M'
       case('N','n')
          complement = 'N'
       case('Y','y')
          complement = 'R'
       case('S','s')
          complement = 'S'
       case('A','a')
          complement = 'T'
       case('B','b')
          complement = 'V'
       case('W','w')
          complement = 'W'
       case('R','r')
          complement = 'Y'
       case default
          print *,'*** no complement for',c ! Should never reach here
          complement = c
       end select
     end function complement
end program revcomp
