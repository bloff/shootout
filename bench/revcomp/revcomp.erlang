% ----------------------------------------------------------------------
% The Great Computer Language Shootout                              
% http://shootout.alioth.debian.org/                                
%                                                                   
% Assumes execution using the following command-line usage:
%
%   erl -noshell -run MODULENAME ENTRYPOINT USERARG1 ... < in > out
%
% Based on SWI Prolog implementation by Anthony Borla
% 
% Contributed by Anthony Borla
% ----------------------------------------------------------------------

-module(revcomp).
-export([main/0]).

% ------------------------------- %

main() ->
  revcomp(get_line(), []),
  halt().

% ------------------------------- %

revcomp(eof, Seg) -> dump_segment(Seg), io:nl();

revcomp(Seq, Seg) -> 
  case Seq of
    [$>|_] -> dump_segment(Seg), io:format('~n~s~n', [Seq]), revcomp(get_line(), []);
    _      -> revcomp(get_line(), lists:append(Seg, Seq))
  end.

% ------------------------------- %

%% 60 is output line length  

dump_segment(Seg) -> dump_segment_(lists:reverse(Seg), 1, 60).

% ------------- %

dump_segment_([], _, _) -> [];

dump_segment_([H|T], A, N) ->
  put_complement(H),
  if
     A < N           -> dump_segment_(T, (A + 1), N);
     A == N, T == [] -> [];
     true            -> io:nl(), dump_segment_(T, 1, N)
  end.

% ------------------------------- %

%% Return line with trailing newline removed [Note: There probably
%% exists a more efficient means of chopping the trailing newline]

get_line() ->
  Line = io:get_line(''),
  case Line of
    eof -> eof;
    _   -> lists:reverse(lists:nthtail(1, lists:reverse(Line)))
  end.

% ------------------------------- %

put_complement(Code) -> io:put_chars([complement(Code)]).

% ------------- %

%%      "wsatug cyrkmb dhvnAT UGCYRK MBDHVN"
%%  to:
%%      "WSTAAC GRYMKV HDBNTA ACGRYM KVHDBN"

complement(Code) ->
  case to_upper(Code) of
    $A -> $T; $C -> $G; $G -> $C; $T -> $A; $M -> $K;
    $R -> $Y; $W -> $W; $S -> $S; $Y -> $R; $K -> $M;
    $V -> $B; $H -> $D; $D -> $H; $B -> $V; $N -> $N;
    _  -> 0
  end.

% ------------- %

to_upper(Code) ->
  if
     Code > $Z -> Code - 32;
     true      -> Code
  end.

