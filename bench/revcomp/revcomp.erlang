% ----------------------------------------------------------------------
% The Great Computer Language Shootout                              
% http://shootout.alioth.debian.org/                                
%                                                                   
% Assumes execution using the following command-line usage:
%
%   erl -noshell -run MODULENAME ENTRYPOINT USERARG1 ... < in > out
%
% Loosely based on the SWI Prolog implementation by Anthony Borla
% 
% Contributed by Anthony Borla
% ----------------------------------------------------------------------

-module(revcomp).
-export([main/1]).

-define(SEGDIV, $>).
-define(LF, 10).
-define(SPACE, 32).
-define(LINE_LENGTH, 60).

% ------------------------------- %

main([Args]) ->
  revcomp(get_line()),
  halt().

% ------------------------------- %

revcomp(Seq) ->
  io:format('~s~n', [Seq]), revcomp_(get_line(), []).

% ------------- %

revcomp_(eof, Seg) -> dump_segment(Seg), io:nl();

revcomp_(Seq, Seg) -> 
  case Seq of
    [?SEGDIV|_] -> dump_segment(Seg), io:format('~n~s~n', [Seq]),
                   revcomp_(get_line(), []);
    _           -> revcomp_(get_line(), lists:append(Seg, Seq))
  end.

% ------------------------------- %

dump_segment(Seg) ->
  dump_segment_(lists:reverse(Seg), 1, ?LINE_LENGTH).

% ------------- %

dump_segment_([], _, _) -> [];

dump_segment_([H|T], A, N) ->
  put_complement(H),
  if
     A < N           -> dump_segment_(T, (A + 1), N);
     A == N, T == [] -> [];
     true            -> io:nl(), dump_segment_(T, 1, N)
  end.

% ------------------------------- %

%%
%% Return line with trailing newline removed. Code is *NIX-specific
%% assuming newline is LF - ASCII 0x0A (10). Each of the three
%% approaches for newline removal appear to work:
%%
%%    _   -> lists:delete(?LF, Line)
%%    _   -> lists:subtract(Line, [?LF])
%%    _   -> lists:reverse(lists:nthtail(1, lists:reverse(Line)))
%%

get_line() ->
  Line = io:get_line(''),
  case Line of
    eof -> eof;
    _   -> lists:subtract(Line, [?LF])
  end.

% ------------------------------- %

put_complement(Code) -> io:put_chars([complement(Code)]).

% ------------- %

%%      "wsatug cyrkmb dhvnAT UGCYRK MBDHVN"
%%  to:
%%      "WSTAAC GRYMKV HDBNTA ACGRYM KVHDBN"

complement(Code) ->
  case to_upper(Code) of
    $A -> $T; $C -> $G; $G -> $C; $T -> $A; $M -> $K;
    $R -> $Y; $W -> $W; $S -> $S; $Y -> $R; $K -> $M;
    $V -> $B; $H -> $D; $D -> $H; $B -> $V; $N -> $N;
    _  -> 0
  end.

% ------------- %

to_upper(Code) ->
  if
     Code > $Z -> Code - ?SPACE;
     true      -> Code
  end.

