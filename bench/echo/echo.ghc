-- $Id: echo.ghc,v 1.2 2004-05-21 02:59:37 bfulgham Exp $
-- http://www.bagley.org/~doug/shootout/
-- Haskell echo/client server
-- written by Brian Gregor
-- compile with:
--      ghc -O -o echo -package net -package concurrent -package lang echo.hs

module Main where

import Concurrent
import GHC.IOBase
import Exception(finally)
import IO
import MVar
import Network.Socket
import System (getArgs,exitFailure)
import System.IO.Error

server_sock = do
    s <- socket AF_INET Stream 6
    setSocketOption s ReuseAddr 1
    bindSocket s (SockAddrInet portnum iNADDR_ANY)
    listen s 2
    return s

echo_server s = do
    (s', clientAddr) <- accept s
    proc <- read_data s' 0
    putStrLn ("server processed "++(show proc)++" bytes")
    sClose s'
    where
       read_data sock totalbytes = do
	     str <- catch (recv sock 19) (\e -> if isEOFError e then return "" else ioError e)
	     if ((length str) >= 19)
	        then (do
	          writ <- send sock str
		  read_data sock (totalbytes+(length str)))
	        else (return totalbytes)

local	    = "127.0.0.1"		
message	    = "Hello there sailor\n"
portnum :: PortNumber  = 7001

client_sock = do
    s <- socket AF_INET Stream 6
    ia <- inet_addr local
    connect s (SockAddrInet portnum ia)
    return s

echo_client n = do
    s <- client_sock
    drop <- server_echo s n
    sClose s
    where
      server_echo sock n 
          | n > 0 =(do 
                       send sock message
		       str <- catch (recv sock 19) (\e -> if isEOFError e then return "" else ioError e)
                       if (str /= message) then (do exitFailure)
 	                  else server_echo sock (n-1))
          | otherwise = (return [])

main = do 
	 ~[n] <- getArgs
	 -- server & client semaphores
         --get the server socket
         ssock <- server_sock 
	 -- fork off the server
	 s <- myForkIO (echo_server ssock)
	 -- fork off the client
	 c <- myForkIO (echo_client (read n::Int))
	 -- let 'em run until they've signaled they're done
         join s ; join c
	 hFlush stdout

-- these are used to make the main thread wait until
-- the child threads have exited
myForkIO :: IO () -> IO (MVar ())
myForkIO io = do
  mvar <- newEmptyMVar
  forkIO (io `finally` putMVar mvar ())
  return mvar

join :: MVar () -> IO ()
join mvar = readMVar mvar
