#!/usr/bin/mzscheme -qu
;;; The Great Computer Language Shootout
;;; http://shootout.alioth.debian.org/
;;
;; Adapted from CMUCL code by Dima Dorfman; bit-vector stuff by Alex Shinn;
;; cobbled together by felix, converted to MzScheme by Brent Fulgham
;; Note:  Requires MzScheme 299+

(module nsievebits mzscheme

  (define (make-bit-vector size . o)
    (let* ((fill (if (and (pair? o) (car o)) #b11111111 0))
           (len (quotient (+ size 7) 8))
           (res (make-bytes len fill)))
      (box
       (if (zero? fill)
	   res
	   (let ((off (remainder size 8)))
	     (if (not (zero? off))
		 (bytes-set! res (- len 1) (- (arithmetic-shift 1 off) 1)))
	     res)))))

  (define (bit-vector-ref vec i)
    (let ((vec (unbox vec))
	  (byte (quotient i 8))
          (off (remainder i 8)))
      (and (< byte (bytes-length vec))
           (not (zero? (bitwise-and (bytes-ref vec byte)
                                    (arithmetic-shift 1 off)))))))

  (define (vector-grow vec n)
    (let ([v (make-bytes (quotient (+ n 7) 8) 0)])
      (bytes-copy! v (unbox vec))
      (box v)))

  (define (bit-vector-set! vec i x)
    (let ((byte (quotient i 8))
          (off (remainder i 8))
          (len (bytes-length (unbox vec))))
      (cond
        ((< byte len)
	 (let ([vec (unbox vec)])
	   (bytes-set! vec
		       byte
		       (if x
			   (bitwise-ior (bytes-ref vec byte)
					(arithmetic-shift 1 off))
			   (bitwise-and (bytes-ref vec byte)
					(bitwise-not (arithmetic-shift 1 off)))))))
        ((not x) vec)
        (else (bit-vector-set! (vector-grow vec i) i x)))))

  (define (nsievebits m)
    (let ((a (make-bit-vector m #t)))
      (define (clear i)
        (do ([j (+ i i) (+ j i)])
  	  ((>= j m))
           (bit-vector-set! a j #f) ) )
      (let ([c 0])
        (do ([i 2 (add1 i)])
            ((>= i m) c)
          (when (bit-vector-ref a i)
	    (clear i)
	    (set! c (add1 c)) ) ) ) ) )

  (define (string-pad s n)
    (string-append (make-string (- n (string-length s)) #\space)
		   s))

  (define (test n)
    (let ((m (* 10000 (arithmetic-shift 1 n))))
      (printf "Primes up to ~a ~a~%"
              (string-pad (number->string m) 8)
              (string-pad (number->string (nsievebits m)) 8))))

  (define (main args)
    (let ([n (string->number (vector-ref args 0))])
      (when (>= n 0) (test n))
      (when (>= n 1) (test (- n 1)))
      (when (>= n 2) (test (- n 2)))))

  (main (current-command-line-arguments)))
