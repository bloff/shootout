/** 
 * The Computer Language Benchmarks Game 
 * Based on the CAL Open Quark version
 * Contributed by Magnus Byne.
 */
module Nsievebits;

import Cal.Core.Prelude using
    typeClass = Inputable, Outputable;
    typeConstructor = Boolean, Int, String;
    dataConstructor = False, True;
    function = eager, seq, stringToInt;
    ;

import Cal.Core.Bits using
    function = shiftL, shiftR;
    ;

import Cal.Core.String using
    function = replicate;
    ;

import Cal.Collections.List using
    function = head;
    ;

import Cal.Core.Debug;


data foreign unsafe import jvm "java.util.BitSet" private JBitSet;

foreign unsafe import jvm "constructor" private createBitSet :: Int -> JBitSet;

foreign unsafe import jvm "method set" setAll :: JBitSet -> Int -> Int -> ();

foreign unsafe import jvm "method clear" clear :: JBitSet -> Int -> ();

foreign unsafe import jvm "method get" get :: JBitSet -> Int -> Boolean;

data foreign unsafe import jvm "java.io.PrintStream" private JPrintStream;

foreign unsafe import jvm "static field java.lang.System.out"
    private stdout :: JPrintStream;

foreign unsafe import jvm "method println"
    private printLn :: JPrintStream -> String -> ();

/**pad width number returns number padded to width with spaces*/
pad :: Int -> Int -> String;
pad !width !number =
    let
        str = Debug.show number;
    in
        replicate (width - String.length str) ' ' ++ str
    ;

nsieve :: Int -> JBitSet -> Int;
nsieve !n !isPrime =
    let
        nsieve_helper :: Int -> Int -> Int;
        nsieve_helper !i !numPrimesFound =
            if i == n then
                numPrimesFound
            else if get isPrime i then
                let
                    update :: Int -> Int -> Int -> ();
                    update !k !i !n =
                        if k > n then
                            ()
                        else
                            clear isPrime k
                            `seq`
                            update (k + i) i n
                        ;
                in
                    update (i + i) i n
                    `seq`
                    nsieve_helper (i + 1) (numPrimesFound + 1)
            else
                nsieve_helper (i + 1) numPrimesFound
            ;
    in
        setAll isPrime 0 (n + 1)
        `seq`
        nsieve_helper 2 0
    ;

main :: [String] -> ();
public main !args =
    let
        n = eager $ stringToInt (head args);

        showResult !n =
            printLn
                stdout
                ("Primes up to " ++ pad 8 n ++ " " ++ pad 8 (nsieve n bits))
            ;

        m :: Int;
        m = shiftL 1 n * 10000;

        bits = createBitSet (m + 1);
    in
        showResult m
        `seq`
        showResult (shiftR m 1)
        `seq`
        showResult (shiftR m 2)
    ;

