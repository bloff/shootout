/* The Great Computer Language Shootout 
   contributed by Isaac Gouy (Clean novice)

   http://shootout.alioth.debian.org/
   
   Clean is a functional programming language, 
   so there isn't language support for inheritance.
   Existential type variable have some vague similarity
   so NToggle delegates function calls to Toggle.

To compile:	
   cleanIDE.exe --batch-force-build "e:\shoot\contrib\clean\methcall.prj"

To run:
   methcall.exe -con 1000000
*/


module methcall

import StdEnv, ArgEnv, LanguageShootout

Start
	# toggle = makeToggle True
	# toggleValue = loop n toggle False
	# ntoggle = makeNToggle True 3
	# ntoggleValue = loop n ntoggle False	
	= toLString toggleValue +++ "\n" +++ 
	  toLString ntoggleValue +++ "\n"

	where 
	n = argi
	
	loop :: !Int !.Toggler !Bool -> Bool
	loop n t v
		| n == 0 = v
		# t = activate t
		# v = value t
		= loop (n-1) t v
		
	toLString b
		| b = "true"
		    = "false"


:: Toggler = E.a: { state :: a
                  , activate_ :: a -> a
                  , value_ :: a -> Bool
                  }
                 
value o=:{state,value_} = value_ state
activate o=:{state,activate_} = {o & state = activate_ state}

makeToggle b =
	{ state = b
	
	, activate_ = \ state -> not state
	
	, value_ = \ state -> state
	}

makeNToggle b max =
	{ state = (makeToggle(b), max, 0)
	
	, activate_ = \ (t, max, count) -> 
		if (count+1 >= max)
			(activate t, max, 0) (t, max, count+1)	
			
	, value_ = \ (t,_,_) -> value t
	}
