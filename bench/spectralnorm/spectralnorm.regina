/* The Great Computer Language Shootout
   http://shootout.alioth.debian.org/

   contributed by Dennis Decker Jensen
              and Vladimir Zabrodsky (the sqrt-function)

Vladimir Zabrodsky has a "Album of Algorithms and Techniques for
Standard Rexx" containing, among other things, the sqrt-function,
which has been slightly edited for this program:

http://www.geocities.com/SiliconValley/Garage/3323/aat/a_sqrt.html

Many Rexx (e.g. BRexx) implement mathematical functions not in
the standard, but Regina doesn't (yet).

*/

numeric digits 12 /* 15 digits precision isn't needed for this job */
arg n
PARSE VALUE 0.0 0.0 n n WITH vBv vv u.0 v.0

do i = 1 for u.0; u.i = 1.0; end
do 10
	call mulAtAv 'u.', 'v.'
	call mulAtAv 'v.', 'u.'
end

do i = 1 for u.0
	vBv = vBv + u.i*v.i
	vv = vv + v.i*v.i
end

say format(sqrt(vBv/vv), , 9);
exit

sqrt: procedure
parse arg N, P
if P \= "" then numeric digits P
parse value format(N, , , , 0) with N "E" Exp
	if Exp = "" then Exp = 0
if (Exp // 2) \= 0 then /* Odd exponent? */
	if Exp > 0
		then parse value N*10 Exp-1 with N Exp
		else parse value N/10 Exp+1 with N Exp
X = 0.5 * (N + 1) /* a "reasonable" start guess */
do forever
	NewX = 0.5 * (X + N/X)
	if X = NewX then return X * 10**(Exp % 2)
	X = NewX
end

A: procedure
parse arg i, j
parse value i-1 j-1 with i j /* calculation of A is zerobased */
return 1 / ((i+j)*(i+j+1) / 2 + i+1)

mulAv:
parse arg v, Av
procedure expose (v) (Av)
call value Av||0, value(v||0)
do i = 1 for value(Av||0)
	call value Av||i, 0.0
	do j = 1 for value(v||0)
		call value Av||i, ,
				value(Av||i) + A(i, j) * value(v||j)
	end
end
return

mulAtv:
parse arg v, Atv
procedure expose (v) (Atv)
call value Atv||0, value(v||0)
do i = 1 for value(Atv||0)
	call value Atv||i, 0.0
	do j = 1 for value(v||0)
		call value Atv||i, ,
				 value(Atv||i) + A(j, i) * value(v||j)
	end
end
return

mulAtAv:
parse arg v, AtAv
procedure expose (v) (AtAv)
call mulAv v, 'tmp.'
call mulAtv 'tmp.', AtAv
return

