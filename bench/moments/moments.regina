/* The Great Computer Language Shootout
   http://shootout.alioth.debian.org/

   Contributed by Dennis Decker Jensen
              and Vladimir Zabrodsky (the sqrt-function)

Vladimir Zabrodsky has a "Album of Algorithms and Techniques for
Standard Rexx" containing, among other things, the sqrt-function,
which has been slightly edited for this program.

http://www.geocities.com/SiliconValley/Garage/3323/aat/a_sqrt.html

*/

numeric digits 11 /* only 11 digits precision needed for correctness */
sum = 0
line = linein()
do n = 1 while line \= "" 
	sum = sum + line
	nums.n = line
	line = linein()
end
n = n - 1 /* last line blank */
nums.0 = n

mean = sum / n

parse value 0 0 0 0 with average_deviation variance skew kurtosis

do i = 1 for n
	deviation = nums.i - mean
	average_deviation = average_deviation + abs(deviation)
	variance = variance + deviation ** 2
	skew = skew + deviation ** 3
	kurtosis = kurtosis + deviation ** 4
end

average_deviation = average_deviation / n
variance = variance / (n - 1)
standard_deviation = sqrt(variance)
if variance > 0 then do
	skew = skew / (n * variance * standard_deviation)
	kurtosis = kurtosis / (n * variance * variance) - 3.0
end

call qsort 1, nums.0
mid = trunc(n / 2)
k = mid + 1
if n // 2 = 1 then
	median = nums.k
else
	median = (nums.mid + nums.k) / 2

say "n:                 " n
say "median:            " format(median, , 6)
say "mean:              " format(mean, , 6)
say "average_deviation: " format(average_deviation, , 6)
say "standard_deviation:" format(standard_deviation, , 6)
say "variance:          " format(variance, , 6)
say "skew:              " format(skew, , 6)
say "kurtosis:          " format(kurtosis, , 6)

exit

sqrt: procedure
parse arg N, P
if P \= "" then numeric digits P
parse value format(N, , , , 0) with N "E" Exp
	if Exp = "" then Exp = 0
if (Exp // 2) \= 0 then /* Odd exponent? */
	if Exp > 0
		then parse value N*10 Exp-1 with N Exp
		else parse value N/10 Exp+1 with N Exp
X = 0.5 * (N + 1) /* a "reasonable" start guess */
do forever
	NewX = 0.5 * (X + N/X)
	if X = NewX then return X * 10**(Exp % 2)
	X = NewX
end

qsort: procedure expose nums.
arg l, r
if r - l <= 1 then return /* nothing to do */
i = random(l, r) /* pick a random pivot */
parse value nums.l nums.i with nums.i nums.l /* swap pivot to start */
last = l
do i = l+1 to r /* partition */
	if nums.i < nums.l then do
		last = last + 1
		parse value nums.last nums.i with nums.i nums.last
	end
end
parse value nums.l nums.last with nums.last nums.l /* restore pivot */
call qsort l, last
call qsort last+1, r
return

