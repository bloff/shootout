(* binarytrees.ml
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Troestler Christophe
 *)


type int_tree = Empty of int | Node of int_tree * int * int_tree

let rec make item depth =
  if depth > 0 then let d = depth - 1 in Node(make item d, item, make item d)
  else Empty item

let rec sum = function
  | Empty i -> i
  | Node(left, i, right) -> i + (sum left + sum right)

let rec diff = function
  | Empty i -> i
  | Node(left, i, right) -> i + (diff left - diff right)


let min_depth = 4
let check_factor = 64
let max_depth =
  let n = try int_of_string(Array.get Sys.argv 1) with _ -> 10 in
  max (min_depth + 2) n
let stretch_depth = max_depth + 1

let () =
  let check = sum (make (-1) stretch_depth) in
  Printf.printf "stretch tree of depth %i\t check: %i\n" stretch_depth check

let long_lived_tree = make (-1) max_depth

let rec loop_depths d =
  if d <= max_depth then
    let iterations = 1 lsl (max_depth - d + min_depth + 1) in
    let check = ref 0 in
    for i = 1 to iterations do
      check := !check + diff (make i d) / check_factor
    done;
    Printf.printf "%i\t trees of depth %i\t check: %i\n" iterations d !check;
    loop_depths (d + 2)

let () =
  loop_depths min_depth;
  Printf.printf "long lived tree of depth %i\t check: %i\n"
    max_depth (sum long_lived_tree)

