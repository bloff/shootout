/* binarytrees.cpp
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Jon Harrop
 */

#include <iostream>

struct T {
  virtual ~T() {};
  virtual int check() const = 0;
};

struct Empty : public T {
  virtual int check() const { return 0; }
};

struct Node : public T {
  T *l, *r;
  int i;
  Node(T *l2, int i2, T *r2) : l(l2), i(i2), r(r2) {};
  virtual ~Node() { delete l; delete r; }
  virtual int check() const { return l->check() + i - r->check(); }
};

T *make(int i, int d) {
  if (d == 0) return new Node(new Empty(), i, new Empty());
  return new Node(make(2*i-1, d-1), i, make(2*i, d-1));
}

int main(int argc, char *argv[]) {
  int min_depth = 4,
    max_depth = std::max(min_depth+2,
			 (argc == 2 ? atoi(argv[1]) : 10)),
    stretch_depth = max_depth+1;

  {
    T *c = make(0, stretch_depth);
    std::cout << "stretch tree of depth " << stretch_depth << "\t "
      << "check: " << c->check() << std::endl;
    delete c;
  }

  T *long_lived_tree=make(0, max_depth);

  for (int d=min_depth; d<=max_depth; d+=2) {
    int iterations = 1 << (max_depth - d + min_depth), c=0;
    for (int i=1; i<=iterations; ++i) {
      T *a = make(i, d), *b = make(-i, d);
      c += a->check() + b->check();
      delete a;
      delete b;
    }
    std::cout << (2*iterations) << "\t trees of depth " << d << "\t "
	      << "check: " << c << std::endl;
  }

  std::cout << "long lived tree of depth " << max_depth << "\t "
	    << "check: " << (long_lived_tree->check()) << "\n";

  delete long_lived_tree;

  return 0;
}
