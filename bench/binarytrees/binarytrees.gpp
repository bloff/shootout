/* The Computer Language Shootout
 * http://shootout.alioth.debian.org/
 * Contributed by Paul Kitchin
 */


#include <iostream>
#include <sstream>

class Tree
{

      struct Node
      {

         Node(int value, std::size_t depth, std::size_t index, Node * nodes, std::size_t max)
            :
            value(value)
         {
            if (index * 2 + 2 < max)
            {
               new (nodes + index * 2 + 1) Node(2 * value - 1, depth - 1, index * 2 + 1, nodes, max);
               new (nodes + index * 2 + 2) Node(2 * value, depth - 1, index * 2 + 2, nodes, max);
            }
         }

         int check(std::size_t index, Node * nodes, std::size_t max) const
         {
            if (index * 2 + 2 < max)
            {
               return nodes[index * 2 + 1].check(index * 2 + 1, nodes, max) + value - nodes[index * 2 + 2].check(index * 2 + 2, nodes, max);
            }
            return value;
         }

         int value;

      };

   public:

      Tree(int value, std::size_t depth)
         :
         size((2 << depth) - 1),
         nodes(static_cast< Node * >(operator new(size * sizeof(Node))))
      {
         new (nodes) Node(value, depth, 0, nodes, size);
      }

      ~Tree()
      {
         operator delete(nodes);
      }

      int check() const
      {
         return nodes->check(0, nodes, size);
      }

   private:

      std::size_t size;
      Node * nodes;

};

int main(int argc, char * * argv)
{
   std::size_t user_depth = 10;
   if (argc == 2)
   {
      std::istringstream convertor(argv[1]);
      if (!(convertor >> user_depth) || !convertor.eof())
      {
         std::cerr << "Usage: " << argv[0] << " [n]\n";
         std::cerr << "\tn must be an integer\n";
         return 1;
      }
   }
   std::size_t minimum_depth = 4;
   std::size_t maximum_depth = std::max(minimum_depth + 2, user_depth);
   {
      Tree tree(0, maximum_depth + 1);
      std::cout << "stretch tree of depth " << (maximum_depth + 1) << "\t check: " << tree.check() << '\n';
   }
   Tree long_lived_tree(0, maximum_depth);
   for (std::size_t depth = minimum_depth; depth <= maximum_depth; depth += 2)
   {
      int iterations = 1 << (maximum_depth - depth + minimum_depth);
      int check = 0;
      for (int iteration = 1; iteration <= iterations; ++iteration)
      {
         Tree first(iteration, depth);
         Tree second(-iteration, depth);
         check += first.check() + second.check();
      }
      std::cout << (2 * iterations) << "\t trees of depth " << depth << "\t check: " << check << '\n';
   }
   std::cout << "long lived tree of depth " << maximum_depth << "\t check: " << long_lived_tree.check() << '\n';
}
