(* binarytrees.ml
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Troestler Christophe
 * Ported to MLton/SML by sweeks@sweeks.com.
 *)
datatype 'a tree = Empty of 'a | Node of 'a tree * 'a * 'a tree

fun make (depth, item) =
   if 0 = depth then Empty item
   else let
	   val d = depth - 1
	   val item2 = 2 * item
	in
	   Node (make (d, item2 - 1), item, make (d, item2))
	end

val rec check =
  fn Empty i => i
   | Node (left, i, right) => i + check left - check right

val minDepth = 4
   
val maxDepth =
   Int.max (minDepth + 2,
	    valOf (Int.fromString (hd (CommandLine.arguments ())))
	    handle _ => 10)

val stretchDepth = maxDepth + 1

val () =
   print (concat ["stretch tree of depth ", Int.toString  stretchDepth,
		  "\t  check: ", Int.toString (check (make (stretchDepth, 0))),
		  "\n"])

val longLivedTree = make (maxDepth, 0)

fun loopDepths d =
   if d > maxDepth then ()
   else
      let
	 val iterations =
	    Word.toInt (Word.<< (0w1, Word.fromInt (maxDepth - d + minDepth)))
	 val c = ref 0
	 val () = Int.for (0, iterations, fn i =>
			   c := !c + check (make (d, i)) + check (make (d, ~i)))
	 val () = print (concat [Int.toString (2 * iterations),
				 "\t  trees of depth ", Int.toString d,
				 "\t  check: ", Int.toString (!c), "\n"])
      in
	 loopDepths (d + 2)
      end

val () = loopDepths minDepth

val () =
   print (concat ["long lived tree of depth ", Int.toString maxDepth,
		  "\t  check: ", Int.toString (check longLivedTree), "\n"])
