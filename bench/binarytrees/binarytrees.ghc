-- binarytrees.ghc
--
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org/
--
-- Modelled after the ocaml implementation 
-- by Einar Karttunen

import System

data Tree = Node Tree Int Tree | Empty Int

make item 0 = Empty item
make item d = Node c item c where c = make item (d-1)

tsum (Empty i)    = i
tsum (Node l i r) = i + tsum l + tsum r

diff (Empty i)    = i
diff (Node l i r) = i + (diff l - diff r)

minDepth = 4
checkFactor = 64

min_depth = 4
check_factor = 64

main = do [num]    <- getArgs
          let maxDepth = max (read num) (minDepth + 2)
          let scretchDepth = maxDepth + 1
          let check = tsum (make (-1) scretchDepth)
          putStrLn ("stretch tree of depth "++show scretchDepth++"\t check: "++show check)
          let longLivedTree = make (-1) maxDepth
          loopDepths maxDepth minDepth
          putStrLn ("long lived tree of depth "++show maxDepth++"\t check: "++show (tsum longLivedTree))

loopDepths :: Int -> Int -> IO ()
loopDepths maxDepth d = if d > maxDepth then return () else body
    where body = do let iterations = 2 ^ (maxDepth - d + minDepth + 1)
                    let loop 1 c   = c
                        loop i c   = loop (i-1) $! c + diff (make i d) `div` checkFactor
                    putStrLn (show iterations++"\t trees of depth "++show d++"\t check: "++show (loop iterations 0))
                    loopDepths maxDepth (d+2)