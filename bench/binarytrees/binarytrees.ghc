{-# OPTIONS -fbang-patterns #-}

--
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org/
--
-- Simon Marlow
-- Rewritten by Don Stewart
--

import System
import Data.Bits
import Text.Printf

data Tree = Nil | Node !Int Tree Tree

minDepth = 4

io s n t = printf "%s of depth %d\t check: %d\n" s n t

main = do
    maxDepth <- getArgs >>= return . max (minDepth+2) . read . head :: IO Int

    let stretch = make 0 (maxDepth+1)
    io "stretch tree" (maxDepth+1) (check stretch)

    let long    = make 0 maxDepth

    let vs = depth minDepth maxDepth
    mapM_ (\(P m d i) -> io (show m ++ "\t trees") d i) vs

    io "long lived tree" maxDepth (check long)

data P = P !Int !Int !Int

depth :: Int -> Int -> [P]
depth !d !m
    | d > m     = []
    | otherwise = P (2*n) d (sumT n d 0) : depth (d+2) m
  where
    n = 1 `shiftL` (m - d + minDepth)

sumT :: Int -> Int -> Int -> Int
sumT !0 !d !t = t
sumT i d t    = sumT (i-1) d (t + a + b)
    where a = check (make i    d)
          b = check (make (-i) d)

make :: Int -> Int -> Tree
make !i !0 = Node i Nil Nil
make  i  d = Node i (make (i2-1) d2) (make i2 d2)
    where
        i2 = 2*i
        d2 = d-1

check :: Tree -> Int
check Nil          = 0
check (Node i l r) = i + check l - check r
