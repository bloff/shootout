/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org/

   unoptimised reference implementation
   
   contributed by Isaac Gouy 
*/

using System;

class BinaryTrees
{
   const int minDepth = 4;
   const int checkFactor = 64; // keep check in int range

   public static void Main(String[] args) 
   {        
      int n = 0;
      if (args.Length > 0) n = Int32.Parse(args[0]);

      int maxDepth = Math.Max(minDepth + 2, n);
      int stretchDepth = maxDepth + 1;

      TreeNode stretchTree = TreeNode.topDownTree(0,stretchDepth);
      if (stretchTree!=null) stretchTree = null;

      TreeNode longLivedTree = TreeNode.topDownTree(-1,maxDepth);

      for (int depth=minDepth; depth<=maxDepth; depth+=2){
         int iterations = 1 << (maxDepth - depth + minDepth);

         int check = 0;
         for (int i=1; i<=iterations; i++){
            check += (TreeNode.topDownTree(i,depth)).nodeItem()/checkFactor;
            check += (TreeNode.bottomUpTree(i,depth)).nodeItem()/checkFactor;    
         }

         Console.WriteLine("{0}\t trees of depth {1}\t check: {2}", 
            iterations*2, depth, check);
      }
 
      if (longLivedTree!=null && stretchTree==null) 
         Console.WriteLine("OK");
   }


   class TreeNode 
   {     
      private TreeNode left, right;
      private int item;


      internal static TreeNode topDownTree(int item, int depth){
         return new TreeNode(item).to(depth);
      }

      TreeNode(int item){
         this.item = item;
      }

      private TreeNode to(int depth){
         if (depth>0){
            depth--;
            left = (new TreeNode(item)).to(depth);
            right = (new TreeNode(item)).to(depth);
         }
         return this;
      }


      internal static TreeNode bottomUpTree(int item, int depth){
         if (depth>0){
            return new TreeNode(
                 bottomUpTree(item, depth-1)
               , bottomUpTree(item, depth-1)
               , item
               );
         }
         else {
            return new TreeNode(item);
         }
      }

      TreeNode(TreeNode left, TreeNode right, int item){
         this.left = left; 
         this.right = right;
         this.item = item;
      }

      internal int nodeItem(){
         // if necessary deallocate here 
         if (left==null) return item;
         else return item + (left.nodeItem() - right.nodeItem());
      }
   }
}