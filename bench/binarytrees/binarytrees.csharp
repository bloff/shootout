/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy  
*/

using System;

class BinaryTrees
{
   const int minDepth = 4;

   public static void Main(String[] args) 
   {        
      int n = 0;
      if (args.Length > 0) n = Int32.Parse(args[0]);

      int maxDepth = Math.Max(minDepth + 2, n);
      int stretchDepth = maxDepth + 2;

      TreeNode stretchTree = TreeNode.topDownTree(0,stretchDepth);
      stretchTree = null;

      TreeNode longLivedOne = TreeNode.topDownTree(-1,maxDepth);
      TreeNode longLivedTwo = TreeNode.topDownTree(-2,maxDepth);

      for (int depth=minDepth; depth<=maxDepth; depth+=2){
         int iterations = 1 << (maxDepth - depth + minDepth);
         Console.WriteLine("{0}\t trees of depth {1}\t items sum: {2}", 
            iterations*2, depth, itemsSum(iterations,depth));
      }

      if (longLivedOne!=null && longLivedTwo!=null && stretchTree==null) 
         Console.WriteLine("OK");
   }


   static long itemsSum(int m, int depth){
      long sum = 0;
      for (int i=1; i<=m; i++){
         sum += (TreeNode.topDownTree(i,depth)).nodeItem();
         sum += (TreeNode.bottomUpTree(i,depth)).nodeItem();      
      }
      return sum;
   }


   class TreeNode 
   {     
      private TreeNode left, right;
      private int item;


      internal static TreeNode topDownTree(int item, int depth){
         return new TreeNode(item).to(depth);
      }

      TreeNode(int item){
         this.item = item;
      }

      private TreeNode to(int depth){
         if (depth>1){
            depth--;
            left = (new TreeNode(item)).to(depth);
            right = (new TreeNode(item)).to(depth);
         }
         return this;
      }


      internal static TreeNode bottomUpTree(int item, int depth){
         if (depth>1){
            return new TreeNode(
                 bottomUpTree(item, depth-1)
               , bottomUpTree(item, depth-1)
               , item
               );
         }
         else {
            return new TreeNode(item);
         }
      }

      TreeNode(TreeNode left, TreeNode right, int item){
         this.left = left; 
         this.right = right;
         this.item = item;
      }

      internal int nodeItem(){
         // if necessary deallocate here 
         if (left==null) return item;
         else return item + (left.nodeItem() - right.nodeItem());
      }
   }
}