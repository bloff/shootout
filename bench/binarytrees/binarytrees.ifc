! -*- mode: f90 -*-
!
! $Id: binarytrees.ifc,v 1.1 2005-06-12 22:17:05 sgeard-guest Exp $ ; $Name:  $
!
! The Great Computer Language Shootout
! http://shootout.alioth.debian.org/
!
! contributed by Simon Geard, 2005; translated from binarytrees.python by Kevin Carson
!
! Compile: ifort -O3 -u -static-libcxa -o binarytrees binarytrees.f90
!
module binaryTree
  !
  ! Tree data structure
  type Tree
     integer             :: data
     type(Tree), pointer :: left => null()
     type(Tree), pointer :: right => null()
  end type Tree

  interface assignment(=)
     module procedure equals_t_t
  end interface
contains

  recursive subroutine equals_t_t(t2, t1)
    type(Tree), intent(out) :: t2
    type(Tree), intent(in)  :: t1
    !print *,'equals_t_t'
    t2%data = t1%data
    if (.not. associated(t2%left)) then
       allocate(t2%left)
    end if
    t2%left => t1%left

    if (associated(t2%right)) then
       allocate(t2%right)
    end if
    t2%right => t1%right

  end subroutine equals_t_t

  ! Initialize tree nodes
  type(Tree) function init(left, right, item) result(t)
    type(Tree), intent(in)    :: left, right
    integer, intent(in)       :: item
    t%data = item
    allocate(t%left)
    t%left = left
    allocate(t%right)
    t%right = right
  end function init

  recursive function BottomUpTree(item, depth) result(bu)
    type(Tree)          :: bu
    integer, intent(in) :: item
    integer, intent(in) :: depth
    integer :: item_item
    !print *,depth
    if (depth > 0) then
       item_item = 2*item
       bu = init(BottomUpTree(item_item - 1, depth-1), &
            BottomUpTree(item_item, depth-1), &
            item)

    else
       bu = init(null(),null(),item)
    end if
  end function BottomUpTree

  recursive function ItemCheck(t) result(ic)
    integer ic
    type(Tree), intent(in) :: t

    if (.not. associated(t%left)) then
       ic = t%data
    else
       ic = t%data + ItemCheck(t%left) - ItemCheck(t%right)
    end if
  end function ItemCheck

  ! Free all allocated memory
  recursive subroutine tidy(t)
    type(Tree), intent(inout) :: t

    if (associated(t%left)) then
       call tidy(t%left)
    end if
    deallocate(t%left)
    if (associated(t%right)) then
       call tidy(t%right)
    end if
    deallocate(t%right)
  end subroutine tidy

!!$  recursive subroutine print(level, x, t)
!!$    ! Debugging code to examine the scene tree
!!$    integer, intent(in)    :: level
!!$    integer, intent(in)    :: x
!!$    type(Tree), intent(in) :: t
!!$    integer:: i
!!$    write(*,'(i0,a,i0,a,4f10.4)') level,' - ',x,': ',t%data%radius,(t%data%centre(i),i=1,3)
!!$    if (.not. associated(t%children)) then
!!$       return
!!$    end if
!!$    do i=1,t%num_children
!!$       call print(level+1,i,t%children(i))
!!$    end do
!!$  end subroutine print

end module binaryTree

! The program itself
program bTrees
  use binaryTree

  integer    :: N, minDepth, maxDepth, stretchDepth, depth, iterations, i, check
  type(Tree) :: stretchTree, longLivedTree, tempTree
  character(len=3) argv

  call getarg(1,argv)
  read(argv,*) N

  minDepth = 4

  if (minDepth + 2> N) then
     maxDepth = minDepth + 2
  else
     maxDepth = N
  end if

  stretchDepth = maxDepth + 1
  stretchTree = BottomUpTree(0, stretchDepth)
  write(*,'(a,i0,a,i0)') 'stretch tree of depth ',stretchDepth,achar(9)//' check: ',ItemCheck(stretchTree)

  longLivedTree = BottomUpTree(0, maxDepth)

  do depth = minDepth, maxDepth + 1, 2
     iterations = 2**(maxDepth - depth + minDepth)
     check = 0

     do i=1, iterations
        tempTree = BottomUpTree(i, depth)
        check = check + ItemCheck(tempTree)

        tempTree = BottomUpTree(-i, depth)
        check = check + ItemCheck(tempTree)

     end do
     write(*,'(i0,a,i0,a,i0)') iterations * 2,achar(9)//' trees of depth ',depth,achar(9)//' check: ',check
  end do
  write(*,'(a,i0,a,i0)') 'long lived tree of depth ',maxDepth,achar(9)//' check: ',ItemCheck(longLivedTree)

end program bTrees
