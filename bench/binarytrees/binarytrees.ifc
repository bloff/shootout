! -*- mode: f90 -*-
!
! $Id: binarytrees.ifc,v 1.9 2005-08-28 18:09:57 sgeard-guest Exp $ ; $Name:  $
!
! The Great Computer Language Shootout
! http://shootout.alioth.debian.org/ 
!
! contributed by Simon Geard, 2005; translated from binarytrees.python by Kevin Carson
!
! Tested and working with the following compilers (28/08/2005):
!
! /opt/intel/fc/9.0/bin/ifort -O3 -what -o binarytrees binarytrees.f90 -Wl,-rpath,/opt/intel/fc/9.0/lib
! => Intel Fortran 9.0-5238
!
! /opt/intel_fc_80/bin/ifort -O3 -what -o binarytrees binarytrees.f90 -Wl,-rpath,/opt/intel_fc_80/lib
! => Intel Fortran 8.1-5079
!
! g95 -O3 -o binarytrees binarytrees.f90
! => G95 (GCC 4.0.1 (g95!) Aug 27 2005)
!
! At these compiler revisions g95 is about 10x slower than the Intel compilers
!
module binaryTree
  !
  ! Tree data structure
  type Tree
     integer             :: data
     type(Tree), pointer :: left  => null()
     type(Tree), pointer :: right => null()
  end type Tree

  interface assignment(=)
     module procedure equals_t_t ! Tree = Tree
  end interface
contains

  ! Assignment
  recursive subroutine equals_t_t(t2, t1)
    type(Tree), intent(out) :: t2
    type(Tree), intent(in)  :: t1
    t2%data = t1%data
    t2%left => t1%left
    t2%right => t1%right
  end subroutine equals_t_t

  ! Initialize tree nodes
  type(Tree) function init(item, left, right) result(t)
    integer, intent(in)              :: item
    type(Tree), intent(in), optional :: left, right
    t%data = item
    if (present(left)) then
       allocate(t%left)
       t%left = left
    end if
    if (present(right)) then
       allocate(t%right)
       t%right = right
    end if
  end function init

  recursive function BottomUpTree(item, depth) result(bu)
    type(Tree)          :: bu
    integer, intent(in) :: item
    integer, intent(in) :: depth
    integer :: item_item
    if (depth > 0) then
       item_item = 2*item
       bu = init(item, BottomUpTree(item_item - 1, depth-1), BottomUpTree(item_item, depth-1))
    else
       bu = init(item)
    end if
  end function BottomUpTree

  recursive function ItemCheck(t) result(ic)
    integer ic
    type(Tree), intent(in) :: t

    if (.not. associated(t%left)) then
       ic = t%data
    else
       ic = t%data + ItemCheck(t%left) - ItemCheck(t%right)
    end if
  end function ItemCheck

  ! Free all allocated memory
  recursive subroutine tidy(t)
    type(Tree), intent(inout) :: t

    if (associated(t%left)) then
       call tidy(t%left)
       deallocate(t%left)
    end if
    if (associated(t%right)) then
       call tidy(t%right)
       deallocate(t%right)
    end if
  end subroutine tidy

end module binaryTree

! The program itself
program bTrees
  use binaryTree

  character(len=1), parameter :: tab = achar(9)
  integer    :: N, minDepth, maxDepth, stretchDepth, depth, iterations, i, check
  type(Tree) :: stretchTree, longLivedTree, tempTree
  character(len=3) argv

  call getarg(1,argv)
  read(argv,*) N

  minDepth = 4
  maxDepth = max(N,minDepth + 2)

  stretchDepth = maxDepth + 1
  stretchTree = BottomUpTree(0, stretchDepth)
  write(*,'(2(a,i0))') 'stretch tree of depth ',stretchDepth,tab//' check: ',ItemCheck(stretchTree)
  call tidy(stretchTree)
  longLivedTree = BottomUpTree(0, maxDepth)

  do depth = minDepth, maxDepth + 1, 2
     iterations = 2**(maxDepth - depth + minDepth)
     check = 0
     do i=1, iterations
        tempTree = BottomUpTree(i, depth)
        check = check + ItemCheck(tempTree)
        call tidy(tempTree)

        tempTree = BottomUpTree(-i, depth)
        check = check + ItemCheck(tempTree)
        call tidy(tempTree)
     end do
     write(*,'(2(i0,a),i0)') iterations * 2,tab//' trees of depth ',depth,tab//' check: ',check
  end do
  write(*,'(2(a,i0))') 'long lived tree of depth ',maxDepth,tab//' check: ',ItemCheck(longLivedTree)
  call tidy(longLivedTree)
end program bTrees
