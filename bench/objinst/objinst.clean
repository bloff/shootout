/* The Great Computer Language Shootout  
   contributed by Isaac Gouy (Clean novice)

   http://shootout.alioth.debian.org/
   
   Clean is a functional programming language, 
   so there isn't language support for inheritance.
   Existential type variable have some vague similarity
   so NToggle delegates function calls to Toggle.
   
   NOTE The compiler seems to optimize away creation 
        of identical toggle records... 

To compile:	
   cleanIDE.exe --batch-force-build "e:\shoot\contrib\clean\objinst.prj"

To run:
   objinst.exe -con 1000000
*/

module objinst

import StdEnv, ArgEnv, LanguageShootout

Start
	# toggle = makeToggleLoop n (makeToggle True)
	# lines = printLoop 5 toggle []
	# lines = ["\n":lines]	
	# ntoggle = makeNToggleLoop n (makeNToggle True 3)
	# lines = printLoop 8 ntoggle lines
	= reverse lines

	where 
	    n = toInt (argv.[1])
	    argv = getCommandLine

	    makeToggleLoop n t
	        | n == 0 = t
		| otherwise = makeToggleLoop (n-1) (makeToggle True)

	    makeNToggleLoop n t
	        | n == 0 = t
		| otherwise = makeNToggleLoop (n-1) (makeNToggle True 3)

	    printLoop n t ls
	        | n == 0 = ls
		| otherwise
			# t = activate t
			= printLoop (n-1) t [toLString (value t) :ls]
		where
		    toLString b
		        | b = "true\n"
			| otherwise = "false\n"

:: Toggler = E.a: { state :: a
                  , activate_ :: a -> a
                  , value_ :: a -> Bool
                  }
                 
value o=:{state,value_} = value_ state
activate o=:{state,activate_} = {o & state = activate_ state}

makeToggle b =
	{ state = b
	, activate_ = \ state -> not state
	, value_ = \ state -> state
	}

makeNToggle b max =
	{ state = (makeToggle(b), max, 0)
	, activate_ = \ (t, max, count) -> 
		if (count+1 >= max)
			(activate t, max, 0) (t, max, count+1)	
	, value_ = \ (t,_,_) -> value t
	}
