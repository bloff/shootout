-- $Id: nsieve.ghc,v 1.3 2005-03-05 15:43:22 ekarttun-guest Exp $
-- written by Einar Karttunen

import Data.Array.IO
import Data.Array.Base
import Data.Bits (shiftL)
import System (getArgs)

loop :: IOUArray Int Bool -> Int -> Int -> Int -> IO Int 
loop arr m n c | n == m    = return c
               | otherwise = do el <- unsafeRead arr n
                                if el then do mapM_ (\i -> unsafeWrite arr i False) (tail [n,n+n..m])
                                              loop arr m (n+1) $! c+1
                                      else do loop arr m (n+1) c

fmt width i = let is = show i in (take (width - length is) (repeat ' ')) ++ is

sieve n = do let m = (1 `shiftL` n) * 10000
             arr <- newArray (2,m) True
             c   <- loop arr m 2 0 
             putStrLn ("Primes up to "++fmt 8 m++" "++fmt 8 c)

main = do n <- getArgs >>= readIO.head
          sieve n >> sieve (n-1) >> sieve (n-2)
