-- $Id: nsieve.ghc,v 1.1 2004-12-21 11:27:58 ekarttun-guest Exp $
-- written by Einar Karttunen

import Data.Array.IO 
import Data.Array.Base
import Data.Bits (shiftL)
import System (getArgs)

loop :: Int -> Int -> IOUArray Int Bool -> Int -> IO Int 
loop n m arr c | n == m    = return c
               | otherwise = do el <- unsafeRead arr n
                                if el then do mapM_ (\i -> unsafeWrite arr i False) (tail [n,n+n..m])
                                              loop (n+1) m arr $! c+1
                                      else do loop (n+1) m arr c

sieve n = do let m = (1 `shiftL` n) * 10000
             arr <- newArray (2,m) True
             c   <- loop 2 m arr 0
             putStrLn ("Primes up to "++show m++" "++show c)

main = do n <- getArgs >>= readIO.head
          sieve n >> sieve (n-1) >> sieve (n-2)
