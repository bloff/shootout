(* nsieve.ml -- naïve Sieve of Eratosthenes
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Christophe TROESTLER
 *)

(* Make a new "array" of size [n] filled with [true].  Because OCaml
   can create arrays of size at most [Sys.max_array_length] (which is
   too small on 32 bits), a workaround is required.

   @return (get, set_false) accessors to that array. *)
let array_make n =
  if n <= Sys.max_array_length then
    let a = Array.make n true in
    (fun i -> a.(i)), (fun i -> a.(i) <- false)
  else
    let a = [| Array.make ((n+1)/2) true; Array.make ((n+1)/2) true|] in
    ( (fun i -> a.(i land 0x1).(i lsr 1)),
      (fun i -> a.(i land 0x1).(i lsr 1) <- false) )

let nsieve m =
  let get, set_false = array_make m in
  let count = ref 0 in
  for i = 2 to m - 1 do
    if get i then (
      incr count;
      let j = ref(i lsl 1) in while !j < m do set_false !j; j := !j + i done;
    )
  done;
  Printf.printf "Primes up to %8u %8u\n" m !count


let () =
  (* Use [Array.get] so it raises an exception even if compiled with -unsafe *)
  let n = try int_of_string (Array.get Sys.argv 1) with _ -> 2 in
  nsieve (10000 lsl n);
  nsieve (10000 lsl (n-1));
  nsieve (10000 lsl (n-2))
