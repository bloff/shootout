(* nsieve.ml -- naïve Sieve of Eratosthenes
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Christophe TROESTLER
 *)

(* Make a new "array" of size [n] filled with [true].  Because OCaml
   can create arrays of size at most [Sys.max_array_length] (which is
   too small on 32 bits), a workaround is required.

   @return (get, set_false) accessors to that array. *)
let array_make_true n =
  if n <= Sys.max_array_length then
    let a = Array.make n true in
    (fun i -> a.(i)), (fun i -> a.(i) <- false)
  else
    let n2 = (n+1) / 2 in
    let a1 = Array.make n2 true and a2 = Array.make n2 true in
    ( (fun i -> if i < n2 then a1.(i) else a2.(i - n2)),
      (fun i -> if i < n2 then a1.(i) <- false else a2.(i - n2) <- false) )

let nsieve m =
  let get, set_false = array_make_true m in
  let count = ref 0 in
  for i = 2 to m - 1 do
    if get i then (
      incr count;
      let j = ref(i lsl 1) in while !j < m do set_false !j; j := !j + i done;
    )
  done;
  Printf.printf "Primes up to %8u %8u\n" m !count


let () =
  (* Use [Array.get] so it raises an exception even if compiled with -unsafe *)
  let n = try int_of_string (Array.get Sys.argv 1) with _ -> 2 in
  for i = 0 to 2 do nsieve(10000 lsl (n-i)) done
