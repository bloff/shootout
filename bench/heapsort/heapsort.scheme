(define (heapsort! v)
  ;; sift-down process for each element
  (define (sift l size elt v)
    ;; compare with the larger of the two child nodes (if there are two)
    (define (best-of-pair j size v)
      (let ((k (+ j 1)))
        (if (< k size)
          (if (< (vector-ref v j) (vector-ref v k)) k j)
          j)))
    (let ((j (+ (* l 2) 1)))
      (if (< j size)
        (let ((i (best-of-pair j size v)))
          (if (>= elt (vector-ref v i))
            (vector-set! v l elt)
            (begin 
              (vector-set! v l (vector-ref v i)) 
              (sift i size elt v))))  ;; smaller than a child node; 
sift continues recursively
        (vector-set! v l elt))))

  ;; arrange into a heap
  (define (make-heap size v) 
    (define (aux l size v)
      (if (>= l 0)
        (begin 
          (sift l size (vector-ref v l) v) 
          (aux (- l 1) size v))))
    (aux (- (floor (/ size 2)) 1) size v))

  ;; iteratively extract head of the heap
  (define (sort-heap size v)
    (if (> size 1)
      (let ((new-size (- size 1)))
        (let ((elt (vector-ref v new-size)))
          (begin 
            (vector-set! v new-size (vector-ref v 0))
            (sift 0 new-size elt v)
            (sort-heap new-size v))))))
  
  ;; heapsort in two steps
  (let ((size (vector-length v)))
    (begin 
      (make-heap size v) 
      (sort-heap size v))))

-- Tom


We could add

(define (heapsort-list l)	;; this is purely applicative
  (let ((v (list->vector l)))
    (begin (heapsort! v) (vector->list v))))
