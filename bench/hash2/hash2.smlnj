(* -*- mode: sml -*-
 * $Id: hash2.smlnj,v 1.1 2004-05-19 18:10:02 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * Modified by Daniel Wang
 *)

structure Test : sig
    val main : (string * string list) -> OS.Process.status
end = struct

open HashTable;

fun hashtest2 n =
    let
	exception NotFound
	val h1 = mkTable (HashString.hashString, op =) (10000, NotFound)
	val h2 = mkTable (HashString.hashString, op =) (10000, NotFound)
	fun doinserts1 i =
	    if i < 10000 then (
		insert h1 ("foo_" ^ (Int.toString i), i);
		doinserts1 (i+1)
	    ) else ()
	fun addinto h k v1 =
	    case find h k of
		SOME valref => valref := (!valref) + v1
	      | NONE => insert h (k, ref v1)
	fun doinserts2 i =
	    if i < n then (
		appi (fn (k,v) => (addinto h2 k v)) h1;
		doinserts2 (i+1)
	    ) else ()
    in (
	doinserts1 0;
	doinserts2 0;
	print (Int.toString (lookup h1 "foo_1")); print " ";
	print (Int.toString (lookup h1 "foo_9999")); print " ";
	print (Int.toString (!(lookup h2 "foo_1"))); print " ";
	print (Int.toString (!(lookup h2 "foo_9999")));
	print "\n"
    ) end;

fun atoi s = case Int.fromString s of SOME num => num | NONE => 0;

fun main(name, args) = 
    let
	val arg = hd(args @ ["1"])
	val num = atoi arg
    in
	hashtest2 num;
	OS.Process.success
    end
end

val _ = SMLofNJ.exportFn("hash2", Test.main);
