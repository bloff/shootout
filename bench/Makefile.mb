# $Id: Makefile.mb,v 1.15 2004-06-18 07:02:44 bfulgham Exp $
include ../../../Make.header

############################################################
# common definitions go here
############################################################

# Eiffel needs a little work to get it going ...
SmallEiffel := /usr/lib/smarteiffel
SE := $(SmallEiffel)/bin/compile
CLEAN_SE := $(SmallEiffel)/bin/clean
SE_OPTS :=  -boost -no_split -O3 $(SE_OPTS)

GCCOPTS := -pipe -Wall -O3 -fomit-frame-pointer $(GCCOPTS)
GXXOPTS := -pipe -Wall -O2 -fomit-frame-pointer $(GXXOPTS)
GXXLDOPTS := -L/usr/local/lib $(GXXLDOPTS)
OCAMLOPTS := -noassert -unsafe -I /usr/lib/ocaml/contrib -ccopt -O3 $(OCAMLOPTS)
OCAMLBOPTS := -noassert -unsafe -I /usr/lib/ocaml/contrib $(OCAMLBOPTS)
BIGLOOOPTS := -fsharing -Obench -unsafe $(BIGLOOOPTS)
GHCOPTS  := -O $(GHCOPTS)
STALINOPTS := -I /usr/lib/stalin -d1 -Ob -Om -On -Or -Ot -copt -O3 -copt -fomit-frame-pointer -copt -Wall -copt -freg-struct-return $(STALINOPTS)

.EXPORT_ALL_VARIABLES:

##################################################
# common rules go here
##################################################

# some definitions used by the rules
.PHONY: plot show clean clobber test

############################################################
# Targets normally called by user
############################################################
show: plot
	@ee data/max.png &
	@ee data/cpu.png &
	@ee data/mem.png &
	@ee data/min.png &

clobber: clean
	@echo "Clobbering data/*"
	@rm -rf data

clean:
	@echo "Cleaning tmp/*"
	@rm -rf tmp

############################################################
# for source files that need to be built/compiled
############################################################

########################################
# bigloo
########################################
%.scm: $(MB_SRCDIR)/%.bigloo $(BIGLOO)
	cp $< $@

.PRECIOUS: %.scm

%.bigloo_run: %.scm
	$(BIGLOO) $(BIGLOOOPTS) $(<F) -o $(@F)

########################################
# gcc
########################################
%.c: $(MB_SRCDIR)/%.gcc $(GCC)
	@cp $< $@

%.gcc_run: %.c $(GCC)
	$(GCC) $(GCCOPTS) $< -o $@


########################################
# g++
########################################
%.c++: $(MB_SRCDIR)/%.g++ $(GXX)
	@cp $< $@

%.g++_run: %.c++
	$(GXX) -c $(GXXOPTS) $< -o $<.o &&  \
        $(GXX) $<.o -o $@ $(GXXLDOPTS) 

########################################
# Clean
########################################
%.icl: $(MB_SRCDIR)/%.clean $(CLM)
	cp $< $@

%.clean_run: %.icl
	$(CLM) -b -nt $(CLEANOPTS) $* -o $@

########################################
# CMUCL (Common Lisp)
########################################
# (Note: arg to compile-file for trace: ':trace-file t')
CMUCL_TRACE :=
#CMUCL_TRACE := :trace-file t
%.cmucl_run: $(MB_SRCDIR)/%.cmucl $(CMUCL_SRCS) $(CMUCL)
	@rm -f $@ ; \
	echo "(proclaim '(optimize (speed 3) (safety 0) (debug 0) (compilation-speed 0) (space 0)))" > $@ ; \
	echo "(setq *gc-verbose* nil)" >> $@ ; \
	COMPILE=$@; COMPILE=$${COMPILE%_run}_compile ; \
	FILES="" ; \
	for f in $(CMUCL_SRCS) ; do cp $$f . ; FILES="$$FILES $${f##*/}" ; done ; \
	echo "(proclaim '(optimize (speed 3) (safety 0) (debug 0) (compilation-speed 0) (space 0)))" > $$COMPILE ; \
	for src in $$FILES ; do \
	    echo "(compile-file \"$$src\" :block-compile t $(CMUCL_TRACE)) (load \"$$src\" :verbose nil :print nil)" >> $$COMPILE ; \
	    base=$${src%.*} ; \
	    echo "(load \"$$base.x86f\" :verbose nil :print nil)" >> $@ ; \
	done ; \
	cp $< . ; MAIN=$< ; MAIN=$${MAIN##*/} ; \
	(echo "(compile-file \"$$MAIN\" :block-compile t $(CMUCL_TRACE) :entry-points '(main))"; echo "(quit)") >> $$COMPILE ; \
	MAIN=$${MAIN%.*} ; MAIN="$${MAIN}.x86f" ; echo "(load \"$$MAIN\" :verbose nil :print nil)" >> $@ ; \
	echo "CMUCL built with: $(CMUCL) -noinit -batch -eval '(load \"$$COMPILE\")'" ; \
	echo "### START $$COMPILE" ; cat $$COMPILE ; echo "### END $$COMPILE" ; echo ; \
	$(CMUCL) -noinit -batch -eval "(load \"$$COMPILE\")" ; \
	echo "(main) (quit)" >> $@
	@echo "### START $@" ; cat $@ ; echo "### END $@" ; echo

########################################
# Erlang
########################################
%.erlang_run: $(MB_SRCDIR)/%.erlang $(ERLC)
	cp $< $(TEST).erl
	$(ERLC) $(TEST).erl
	touch $@

########################################
# Hipe
########################################
%.hipe_run: $(MB_SRCDIR)/%.hipe $(ERLC)
	-rm $(TEST).beam
	cp $< $(TEST).erl
	$(ERLC) +native +"{hipe, [o3]}" $(TEST).erl
	touch $@

########################################
# gforth (GNU Forth)
########################################
%.gforth: $(MB_SRCDIR)/%.gforth $(GFORTH)
	cp $< $@

%.gforth_run: %.gforth
	$(GFORTH) $< -e 'savesystem $@ bye'

########################################
# ghc (glasgow haskell compiler)
########################################
%.hs: $(MB_SRCDIR)/%.ghc $(GHC)
	cp $< $@

%.ghc_run: %.hs
	$(GHC) $(GHCOPTS) $< -o $@

########################################
# GNAT (GNU Ada)
########################################
%.adb: $(MB_SRCDIR)/%.gnat $(GNATB) $(GNATC) $(GNATL)
	cp $< $@

%.gnat_run: %.adb
	$(GNATC) -c $<
	$(GNATB) $*
	$(GNATL) $*
	mv $* $@

########################################
# Gwydion Dylan
########################################
%.dylan: $(MB_SRCDIR)/%.gwydion $(GWYDION)
	cp $< $@

%.gwydion_run: %.dylan
	$(GWYDION) $(GWYDION_OPTS) $<
	if [ "$*" = "random" ]; then	\
	    mv randum $@;		\
	else				\
	    mv $* $@;			\
	fi
	rm $*.[co]
	rm -r .libs

########################################
# icon
# - Note: I had a conflict with some of the environment
# variables icon uses, so I unset them all to be sure.
# Icon really ought to use less generic names for them.
########################################
%.icn: $(MB_SRCDIR)/%.icon $(ICON)
	cp $< $@

.PRECIOUS: %.icon_run

%.icon_run: %.icn
	unset STRSIZE BLOCKSIZE COEXPSIZE MSTKSIZE TRACE NOERRBUF ; \
	$(ICON) -o $@ $<

########################################
# java
########################################
%.java_run: $(MB_SRCDIR)/%.java $(JAVA)
	if [ ! -d $@ ] ; then mkdir $@ ; fi
	cp $< $@/$(TEST).java
	( cd $@ ; $(JAVAC) -classpath '.' $(TEST).java )
	touch $@

########################################
# lua
########################################
%.lua_run: $(MB_SRCDIR)/%.lua $(LUA)
	cp $< $@
	@echo "lua -e NUM=%ARG $@"

########################################
# mlton
########################################
%.sml: $(MB_SRCDIR)/%.mlton $(MLTON)
	cat $(MLTONDEPS) $< > $@

%.mlton_run: %.sml
	$(MLTON) $^ && mv $(basename $(<F)) $(basename $(<F)).mlton_run

########################################
# MzScheme
########################################
%.ss: $(MB_SRCDIR)/%.mzscheme $(MZSCHEME)
	cp $< $@

%.mzscheme_run: %.ss
	cp $< $@

########################################
# MzScheme (Compiled)
########################################
%.mzc_run: %.ss
	$(MZC) $<
	echo "#!/usr/bin/mzscheme -r" > $@
	echo "(load-extension \"$*.so\")" >> $@
	chmod a+rwx $@


########################################
# ocaml native code compiler
########################################
%.ml: $(MB_SRCDIR)/%.ocaml $(OCAML)
	cp $< $@

%.ocaml_run: %.ml
	$(OCAML) $(OCAMLOPTS) $< -o $@


########################################
# ocaml bytecode compiler
########################################
%.ml: $(MB_SRCDIR)/%.ocamlb $(OCAMLB)
	cp $< $@

%.ocamlb_run: %.ml
	$(OCAMLB) $(OCAMLBOPTS) $< -o $@

########################################
# Mozart/Oz compiler
########################################
%.oz: $(MB_SRCDIR)/%.oz $(OZC)
	cp $< $@

%.oz_run: %.oz
	$(OZC) $(OZOPTS) -x $<
	mv $* $@

########################################
# Python
########################################
%.py: $(MB_SRCDIR)/%.python $(PYTHON)
	-rm $(TEST).pyo
	cp $< $@

.PRECIOUS: %.pyo

%.pyo: %.py
	$(PYTHON) -OO -c "from py_compile import compile; compile('$<')"

%.python_run: %.pyo
	@:

########################################
# Psyco
########################################
%.py: $(MB_SRCDIR)/%.psyco $(PYTHON)
	-rm $(TEST).pyo
	cp $< $@

.PRECIOUS: %.pyo

%.pyo: %.py
	$(PYTHON) -OO -c "from py_compile import compile; compile('$<')"

%.psyco_run: %.pyo
	@:



########################################
# rep
########################################
%.jl: $(MB_SRCDIR)/%.rep $(REP)
	cp $< $@

.PRECIOUS: %.jlc

%.jcl: %.jl
	$(REP) --batch --no-rc -l compiler -f compile-batch $<

%.rep_run: %.jcl
	@:

########################################
# sablevm
########################################
%.sablevm_run: $(MB_SRCDIR)/%.sablevm $(JAVA)
	if [ ! -d $@ ] ; then mkdir $@ ; fi
	cp $< $@/$(TEST).java
	( cd $@ ; $(JAVAC) -classpath '.' $(TEST).java )
	touch $@

########################################
# SBCL (Common Lisp)
########################################
# (Note: arg to compile-file for trace: ':trace-file t')
SBCL_TRACE :=
#SBCL_TRACE := :trace-file t
%.sbcl_run: $(MB_SRCDIR)/%.sbcl $(SBCL_SRCS) $(SBCL)
	@rm -f $@ ; \
	echo "(proclaim '(optimize (speed 3) (safety 0) (debug 0) (compilation-speed 0) (space 0)))" > $@ ; \
	COMPILE=$@; COMPILE=$${COMPILE%_run}_compile ; \
	FILES="" ; \
	for f in $(SBCL_SRCS) ; do cp $$f . ; FILES="$$FILES $${f##*/}" ; done ; \
	echo "(proclaim '(optimize (speed 3) (safety 0) (debug 0) (compilation-speed 0) (space 0)))" > $$COMPILE ; \
	for src in $$FILES ; do \
	    echo "(compile-file \"$$src\" $(SBCL_TRACE)) (load \"$$src\" :verbose nil :print nil)" >> $$COMPILE ; \
	    base=$${src%.*} ; \
	    echo "(load \"$$base.faslmt\" :verbose nil :print nil)" >> $@ ; \
	done ; \
	cp $< . ; MAIN=$< ; MAIN=$${MAIN##*/} ; \
	(echo "(compile-file \"$$MAIN\" $(SBCL_TRACE))"; echo "(quit)") >> $$COMPILE ; \
	MAIN=$${MAIN%.*} ; MAIN="$${MAIN}.faslmt" ; echo "(load \"$$MAIN\" :verbose nil :print nil)" >> $@ ; \
	echo "SBCL built with: $(SBCL) -noinit -batch -eval '(load \"$$COMPILE\")'" ; \
	echo "### START $$COMPILE" ; cat $$COMPILE ; echo "### END $$COMPILE" ; echo ; \
	$(SBCL) --noinform --disable-debugger --load $$COMPILE; \
	echo "(main) (quit)" >> $@
	@echo "### START $@" ; cat $@ ; echo "### END $@" ; echo


########################################
# SmartEiffel
########################################
%.e: $(MB_SRCDIR)/%.se $(SE)
	@echo "copying $< to $(TEST).e"
	cp $< $(TEST).e

%.se_run: %.e
	rm -f $@
	(echo . ; echo ../ ; echo ../../Include/) > loadpath.se
	$(SE) $(SE_OPTS) -o $@ $(TEST) ; $(CLEAN_SE) $(TEST)

########################################
# sml/nj
########################################
%.x86-linux: $(MB_SRCDIR)/%.smlnj $(SMLNJ)
	@rm -f $@
	cat $< | $(SMLNJ)

.PRECIOUS: %.x86-linux

%.smlnj_run: %.x86-linux
	@:

########################################
# Stalin
########################################
%.stalin_run.sc: $(MB_SRCDIR)/%.stalin $(STALIN)
	cp $< $@

%.stalin_run: %.stalin_run.sc
	$(STALIN) $(STALINOPTS) $<

########################################
# XEmacs :-)
########################################
%.el: $(MB_SRCDIR)/%.xemacs $(XEMACS)
	cp $< $@

.PRECIOUS: %.elc

%.elc: %.el
	$(XEMACS) -vanilla -batch -f batch-byte-compile $<

%.xemacs_run: %.elc
	@:


