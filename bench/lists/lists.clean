/* The Great Computer Language Shootout 
   contributed by Isaac Gouy (Clean novice)

   http://shootout.alioth.debian.org/

To compile:	
   cleanIDE.exe --batch-force-build "e:\shoot\contrib\clean\lists.prj"

To run:
   lists.exe -con 16
*/


module lists
import StdEnv, ArgEnv, LanguageShootout

Start = toString (iter n listOps 10000) +++ "\n"
    where
        n = toInt (argv.[1])
	argv = getCommandLine


listOps size
   # l1 = (Dq (balance (size, [1..size], [])))
   # l2 = copy l1
   # (l2, l3) = headToTailLoop l2 emptyDq
   # (l3, l2) = tailToTailLoop l3 l2
   # l1 = reverseDq l1
   = if ((first l1 == size) && (equal l1 l2)) (length l1) (abort "Test Failed!")
   
   where   
      headToTailLoop :: !.(Deque a) !u:(Deque a) -> (.(Deque b),v:(Deque a)), [u <= v]
      headToTailLoop (Dq (0,[],[])) y = (emptyDq,y)
      headToTailLoop x y
         # (z,x) = popFirst x
         # y = addLast z y
         = headToTailLoop x y
   
      tailToTailLoop (Dq (0,[],[])) y = (emptyDq,y)
      tailToTailLoop x y
         # (z,x) = popLast x
         # y = addLast z y
         = tailToTailLoop x y


// To do this in the "same way" we need to define a Deque
// Let's only define the functions we need for this test

:: Deque a = Dq !(!Int,[a],[a])

emptyDq = Dq (0,[],[])

copy (Dq (n,xs,ys)) = Dq (n,xs,ys) // copy would be implicit 

addLast a (Dq (n,xs,ys)) = Dq (balance (n+1,xs,[a:ys]))

popFirst (Dq (n,[x:xs],ys)) = (x, (Dq (balance (n-1,xs,ys))))
popFirst (Dq (_,[],[y])) = (y, emptyDq)  

popLast (Dq (n,xs,[y:ys])) = (y, (Dq (balance (n-1,xs,ys))))
popLast (Dq (_,[x],[])) = (x, emptyDq)

first (Dq (_,[x:_],_)) = x
first (Dq (_,[],[y])) = y

reverseDq (Dq (n,xs,ys)) = (Dq (n,ys,xs))

equal (Dq (n1,x1,y1)) (Dq (n2,x2,y2)) = 
   n1==n2 && equal_ x1 (reverse y1) x2 (reverse y2)
      where      
      equal_ [] [] [] [] = True  
      equal_ [] y1 x2 y2
         | y1<>[] = equal_ y1 [] x2 y2
         = False
      equal_ x1 y1 [] y2 
          | y2<>[] = equal_ x1 y1 y2 []
          = False
      equal_ [a:as] y1 [b:bs] y2
         | a==b = equal_ as y1 bs y2
         = False

//   Instances of overloaded functions:
instance length Deque
   where length (Dq (n,_,_)) = n

// balance would be private to a Deque module
balance (n,[],ys)
   | n <= 1   = (n,[],ys)
   = (n, reverse f, r)
      where (r,f) = splitAt (n/2) ys
balance (n,xs,[])
   | n <= 1   = (n,xs,[])
   = (n, f, reverse r)
      where (f,r) = splitAt (n/2) xs
balance dq = dq
