-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org/
-- NBody based on Open Mutable Records
-- Contributed by Einar Karttunen

import Control.Monad.Reader
import Data.IORef
import System
import Text.Printf

-- This is a monad for open mutable records programming
newtype OO t r = OO (ReaderT t IO r) deriving(Monad, MonadReader t, MonadIO)

-- run a computation with a record (object)
with :: s -> OO s a -> OO b a
with this (OO c) = liftIO (runReaderT c this)

-- run an OO computation producing an IO value.
ooToIO :: OO s a -> IO a
ooToIO (OO c) = runReaderT c undefined

-- the plain record types
data a :.: r = RC !a !r
infixr :.:
data END = END

-- Next we define a field access method.
class Select r f t | r f -> t                 where (!) :: r -> f -> Ref t
instance Select (Field f t :.: r) f t        where (!) (RC (F x) _) _ = x
instance Select r f t => Select (a :.: r) f t where (!) (RC _ t) = (!) t

-- And finally the type of mutable fields.
type Ref a = IORef a
newtype Field name rtype = F (Ref rtype)

-- Next we define a way to construct record values.
infixr ##
(##) :: v -> OO s r -> OO s ((Field f v) :.: r)
(##) v r = do { h <- liftIO (newIORef v); t <- r; return (RC (F h) t) }
end = return END :: OO s END

-- Get the value of a field.
value :: Select s f t => f -> OO s t
value a  = do x <- asks (\s -> s!a) 
              liftIO (readIORef x)

-- Or set the value of a field.
(<-:) :: Select s f t => f -> t -> OO s () 
a <-: b  = do x <- asks (\s -> s!a)
              liftIO (writeIORef x b)

-- And as a convenience add value to an double field.
(+=) :: Select s f V3 => f -> V3 -> OO s V3
a += b   = do x <- asks (\s -> s!a)
              val <- liftIO (readIORef x)
              let z = val+b
              z `seq` liftIO (writeIORef x z)
              return z

-- V3 vector like things.
data V3 = V3 !Double !Double !Double deriving(Show,Eq)
instance Num V3 where
  (V3 x1 y1 z1) + (V3 x2 y2 z2) = V3 (x1+x2) (y1+y2) (z1+z2)
  (V3 x1 y1 z1) - (V3 x2 y2 z2) = V3 (x1-x2) (y1-y2) (z1-z2)
  (V3 x1 y1 z1) * (V3 x2 y2 z2) = V3 (x1*x2) (y1*y2) (z1*z2)
  fromInteger o = let v = fromInteger o in V3 v v v
instance Fractional V3 where
  (V3 x1 y1 z1) / (V3 x2 y2 z2) = V3 (x1/x2) (y1/y2) (z1/z2)

from field obj = with obj (value field)
dv3 v = V3 v v v
v3len (V3 x y z) = sqrt (x*x + y*y + z*z)

{-# RULE "dv3/mult" forall a b. dv3 a * (V3 x y z) = V3 (a*x) (a*y) (a*z) #-}

-- Bodies
data Base = Base; data Diff = Diff; data Mass = Mass
type Body = Field Base V3 :.: Field Diff V3 :.: Field Mass Double :.: END

-- Create a new body
newBody x1 y1 z1 x2 y2 z2 mass = 
  V3 x1 y1 z1 ## (dv3 year * V3 x2 y2 z2) ## (mass * solarMass) ## end :: OO s Body

offsetMomemtum bodies@(b:_) = foldM comp 0 bodies >>= (\d -> with b (Diff <-: (-d / dv3 solarMass)))
    where comp old body = do diff <- Diff `from` body
                             mass <- Mass `from` body
                             return (old + (dv3 mass * diff))

advance dt bodies = advanceLoop dt bodies >> mapM_ comp bodies
    where comp body = with body ((\diff -> Base += (dv3 dt * diff)) =<< value Diff)

advanceLoop :: Double -> [Body] -> OO s ()
advanceLoop dt []          = return ()
advanceLoop dt (b:bs)      = do
  bmass <- Mass `from` b
  bbase <- Base `from` b
  let inner []     = return ()
      inner (p:ps) = do diff <- (Base `from` p >>= \pbase -> return (bbase - pbase))
                        let dist = v3len diff
                        let magdiff = dv3 (dt / (dist * dist * dist)) * diff
                        pmass <- Mass `from` p
                        with b (Diff += (dv3 pmass * (-magdiff)))
                        with p (Diff += (dv3 bmass * magdiff))
                        inner ps
  inner bs >> advanceLoop dt bs

energy :: [Body] -> Double -> OO s Double
energy []     e = return e
energy (p:ps) e = do pdiff@(V3 x y z) <- Diff `from` p
                     pmass <- Mass `from` p
                     pbase <- Base `from` p
                     let e' = e + 0.5 * pmass * (x*x + y*y + z*z)
                     let inner []     e = return e
                         inner (j:js) e = do jmass <- Mass `from` j
                                             jbase <- Base `from` j
                                             inner js $! (e - ((pmass*jmass)/v3len(pbase - jbase)))
                     inner ps e' >>= energy ps

solarMass = 4*pi*pi :: Double
year = 365.24 :: Double

createBodies = do 
  b0 <- newBody 0 0 0 0 0 0 1
  b1 <- newBody 4.84143144246472090e+00 (-1.16032004402742839e+00) (-1.03622044471123109e-01) 
               (1.66007664274403694e-03) (7.69901118419740425e-03) (-6.90460016972063023e-05)
               9.54791938424326609e-04
  b2 <- newBody 8.34336671824457987e+00 4.12479856412430479e+00 (-4.03523417114321381e-01)
               (-2.76742510726862411e-03) (4.99852801234917238e-03) (2.30417297573763929e-05)
               (2.85885980666130812e-04)
  b3 <- newBody 1.28943695621391310e+01 (-1.51111514016986312e+01) (-2.23307578892655734e-01)
               2.96460137564761618e-03 2.37847173959480950e-03 (-2.96589568540237556e-05)
               4.36624404335156298e-05
  b4 <- newBody 1.53796971148509165e+01 (-2.59193146099879641e+01) 1.79258772950371181e-01
               2.68067772490389322e-03 1.62824170038242295e-03 (-9.51592254519715870e-05)
               5.15138902046611451e-05
  return [b0,b1,b2,b3,b4]

main = do ~[n] <- getArgs
          (e1,e2) <- ooToIO (do bodies <- createBodies
                                offsetMomemtum bodies
                                e1 <- energy bodies 0
                                sequence_ $ replicate (read n) $ advance 0.01 bodies
                                e2 <- energy bodies 0
                                return (e1,e2))
          printf "%.9f\n%.9f\n" e1 e2
