{-# OPTIONS -fexcess-precision #-}
--
-- The Computer Language Shootout
-- http://shootout.alioth.debian.org/
--
-- Contributed by Don Stewart
--
-- Compile with:
--  -O -fglasgow-exts -fbang-patterns -optc-O3 -optc-march=pentium4
--
import System
import System.IO.Unsafe
import Text.Printf
import Foreign.Marshal.Array
import Foreign
import Control.Monad
import Bits

import GHC.Exts

------------------------------------------------------------------------

main = do
    n <- getArgs >>= readIO . head
    offset_momentum
    printf "%.9f\n" =<< energy
    replicateM_ n advance
    printf "%.9f\n" =<< energy

------------------------------------------------------------------------

type Bodies = Ptr Double

nbodies = 5

bodies :: Bodies
bodies = unsafePerformIO . newArray . concat $
   [planet 1 0 0 0 0 0 0                -- sun
   ,planet 9.54791938424326609e-04      -- jupiter
        4.84143144246472090e+00  (-1.16032004402742839e+00) (-1.03622044471123109e-01)
      ( 1.66007664274403694e-03) ( 7.69901118419740425e-03) (-6.90460016972063023e-05)
   ,planet 2.85885980666130812e-04      -- saturn
        8.34336671824457987e+00    4.12479856412430479e+00  (-4.03523417114321381e-01)
      (-2.76742510726862411e-03) ( 4.99852801234917238e-03) ( 2.30417297573763929e-05)
   ,planet 4.36624404335156298e-05      -- uranus
        1.28943695621391310e+01  (-1.51111514016986312e+01) (-2.23307578892655734e-01)
      ( 2.96460137564761618e-03) ( 2.37847173959480950e-03) (-2.96589568540237556e-05)
   ,planet 5.15138902046611451e-05      -- neptune
        1.53796971148509165e+01  (-2.59193146099879641e+01)   1.79258772950371181e-01
      ( 2.68067772490389322e-03) ( 1.62824170038242295e-03) (-9.51592254519715870e-05)]
  where
    planet m x y z vx vy vz =
        [m*solar_mass,x, y, z, vx*days_per_year, vy*days_per_year, vz*days_per_year, 0]
    -- n.b widht of 8 doubles to make bitwise math nice

-- field access
(W# body) `at` (W# field) = I#
    (word2Int# (field `or#` (body `uncheckedShiftL#` 3#))) -- sizeof Double

put !body !field  = pokeElemOff bodies (body `at` field)
get !body !field  = peekElemOff bodies (body `at` field)

--
-- field offsets in flattened array
--
mass = 0
x    = 1
y    = 2
z    = 3
vx   = 4
vy   = 5
vz   = 6
solar_mass    = 4 * pi * pi
days_per_year = 365.24

------------------------------------------------------------------------
-- Offset momentum

offset_momentum :: IO ()
offset_momentum = do
    (px,py,pz) <- go 0 0 0 0
    put 0 vx (- px / solar_mass)
    put 0 vy (- py / solar_mass)
    put 0 vz (- pz / solar_mass)
  where
    go !i !px !py !pz
        | i >= nbodies = return (px,py,pz)
        | otherwise    = do
            imass <- look mass
            ivx   <- look vx
            ivy   <- look vy
            ivz   <- look vz
            go (i+1) (px + ivx * imass)
                     (py + ivy * imass)
                     (pz + ivz * imass)

        where look = get i

------------------------------------------------------------------------
-- Energy

energy = goI 0 0

goI :: Word -> Double -> IO Double
goI !i !e
    | i >= nbodies = return e
    | otherwise    = do
       im   <- look mass
       ix   <- look x      -- cache the body offset calculation?
       iy   <- look y
       iz   <- look z
       ivx  <- look vx
       ivy  <- look vy
       ivz  <- look vz
       e'   <- goJ ix iy iz im (i+1) (e + 0.5 * im * (ivx * ivx + ivy * ivy + ivz * ivz))
       goI (i+1) e'
    where
       look = get i

goJ !ix !iy !iz !im !j !e
    | j >= nbodies = return e
    | otherwise    = do

        b2m  <- look mass
        b2x  <- look x
        b2y  <- look y
        b2z  <- look z
        let dx   = ix - b2x
            dy   = iy - b2y
            dz   = iz - b2z
            distance = sqrt $! dx * dx + dy * dy + dz * dz
        goJ ix iy iz im (j+1) (e - ((im * b2m) / distance))
    where
        look = get j

------------------------------------------------------------------------
-- Advance

advance :: IO ()
advance = advanceI 0 >> update

advanceI i@(W# ii) = when (i < nbodies) $ do
    bm  <- lookI mass
    bx  <- lookI x      -- cache the body offset calculation!
    by  <- lookI y
    bz  <- lookI z
    bvx <- lookI vx              -- float these out to an accumultor
    bvy <- lookI vy
    bvz <- lookI vz
    advanceJ off bm bx by bz bvx bvy bvz (i+1)
    advanceI (i+1)
  where
    off   = W# (ii `uncheckedShiftL#` 3#)
    lookI x = peekElemOff bodies (fromIntegral $ x .|. off)
    setI  = put i

advanceJ !i_off !bm !bx !by !bz !bvx !bvy !bvz !j@(W# jj)
     | j >= nbodies = do
        let setI x = pokeElemOff bodies (fromIntegral $ x .|. i_off)
        setI vx bvx
        setI vy bvy
        setI vz bvz

     | otherwise    = do

        b2mass <- lookJ mass
        b2x    <- lookJ x
        b2y    <- lookJ y
        b2z    <- lookJ z
        b2vx   <- lookJ vx
        b2vy   <- lookJ vy
        b2vz   <- lookJ vz

        let dx = bx - b2x
            dy = by - b2y
            dz = bz - b2z
            distance = sqrt (dx * dx + dy * dy + dz * dz)
            mag      = 0.01 / (distance * distance * distance)
            massmag  = bm     * mag

        setJ vx (b2vx + dx * massmag)
        setJ vy (b2vy + dy * massmag)
        setJ vz (b2vz + dz * massmag)

        let mass2mag = - b2mass * mag

        advanceJ i_off bm bx by bz (bvx + dx * mass2mag)
                               (bvy + dy * mass2mag)
                               (bvz + dz * mass2mag) (j+1)
   where
    off   = W# (jj `uncheckedShiftL#` 3#)
    lookJ x = peekElemOff bodies (fromIntegral $ x .|. off)
    setJ  x = pokeElemOff bodies (fromIntegral $ x .|. off)

update = forM_ [0..nbodies-1] $ \i -> do
    let look  = get i
        set   = put i
    bx  <- look x
    by  <- look y
    bz  <- look z
    bvx <- look vx
    bvy <- look vy
    bvz <- look vz
    set x (bx + 0.01 * bvx)
    set y (by + 0.01 * bvy)
    set z (bz + 0.01 * bvz)
