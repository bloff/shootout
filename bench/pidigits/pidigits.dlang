/* The Great Computer Language Shootout
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy

   converted to D by Dave Fladebo

   compile: dmd -O -inline -release pidigits.d gmp4d/gmp.d gmp4d/gmppool.d gmp4d/mpz.d -L-lgmp
*/

import std.conv, std.stdio, std.string, mpz;

const int L = 10;

void main(char[][] args)
{
    int n = args.length > 1 ? atoi(args[1]) : 1;
    int j = 0;

    PiDigitSpigot digits = new PiDigitSpigot();

    while (n > 0){
       if (n >= L){
          for (int i = 0; i < L; i++) writef(digits.next());
          j += L;
       } else {
          for (int i = 0; i < n; i++) writef(digits.next());
          for (int i = n; i < L; i++) writef(" ");
          j += n;
       }
       writef("\t:"); writefln(j);
       n -= L;
    }
}

class PiDigitSpigot
{
private:
    Transformation z, x, inverse;

public:
    this()
    {
        z = new Transformation(1,0,0,1);
        x = new Transformation(0,0,0,0);
        inverse = new Transformation(0,0,0,0);
    }

    int next()
    {
        int y = digit();
        if(isSafe(y))
        {
            z = produce(y);
            return y;
        } else {
            z = consume( x.next() );
            return next();
        }
    }

    int digit()
    {
        return z.extract(3);
    }

    bool isSafe(int digit)
    {
        return digit == z.extract(4);
    }

    Transformation produce(int i)
    {
        return (inverse.qrst(10,-10*i,0,1)).compose(z);
    }

    Transformation consume(Transformation a){
        return z.compose(a);
    }
}

class Transformation
{
private:
    alias mpz BigInteger;
    BigInteger q, r, s, t;
    int k;

public:
    this(int q, int r, int s, int t)
    {
        this.q = new BigInteger(q);
        this.r = new BigInteger(r);
        this.s = new BigInteger(s);
        this.t = new BigInteger(t);
        k = 0;
    }

    this(BigInteger q, BigInteger r, BigInteger s, BigInteger t)
    {
        this.q = q;
        this.r = r;
        this.s = s;
        this.t = t;
        k = 0;
    }

    Transformation next()
    {
        k++;
        q = new BigInteger(k);
        r = new BigInteger(4 * k + 2);
        s = new BigInteger(0);
        t = new BigInteger(2 * k + 1);
        return this;
    }

    int extract(int j)
    {
        BigInteger numerator = new BigInteger(q);
        numerator *= j;
        numerator += r;

        BigInteger denominator = new BigInteger(s);
        denominator *= j;
        denominator += t;

        return atoi((numerator / denominator).toString());
    }

    Transformation qrst(int q, int r, int s, int t)
    {
        this.q = new BigInteger(q);
        this.r = new BigInteger(r);
        this.s = new BigInteger(s);
        this.t = new BigInteger(t);
        k = 0;
        return this;
    }

    Transformation compose(Transformation a)
    {
        BigInteger tq = new BigInteger(q);
        tq *= a.q;

        BigInteger tr = new BigInteger(q);
        tr *= a.r;
        BigInteger tr1 = new BigInteger(r);
        tr1 *= a.t;
        tr += tr1;

        BigInteger ts = new BigInteger(s);
        ts *= a.q;
        BigInteger ts1 = new BigInteger(t);
        ts1 *= a.s;
        ts += ts1;

        BigInteger tt = new BigInteger(s);
        tt *= a.r;
        BigInteger tt1 = new BigInteger(t);
        tt1 *= a.t;
        tt += tt1;

        return new Transformation(tq,tr,ts,tt);
    }
}
