/* The Computer Language Shootout
   http://shootout.alioth.debian.org/
 
   contributed by SebastiÃ¡n E. Peyrott - 16/01/2006 - v1
   Compilation & Linking: dmd -O -inline
*/

module regex_dna;

import std.cstream; //Includes standard C I/O functions.
import std.regexp;  //Regexp objects.

int main()
{	
	//We do static allocations once, to minimize GC cycles.
	char[] Buf_InputSequence = new char[100000];
	uint Var_SeqLen_Original, Var_SeqLen_NoFASTAInfo, Var_SeqLen_IUB;
	uint[9] Var_VarMatches;
	RegExp[9] SeqVariants;
	SeqVariants[0] = new RegExp("agggtaaa|tttaccct", null);
	SeqVariants[1] = new RegExp("[cgt]gggtaaa|tttaccc[acg]", null);
	SeqVariants[2] = new RegExp("a[act]ggtaaa|tttacc[agt]t", null);
	SeqVariants[3] = new RegExp("ag[act]gtaaa|tttac[agt]ct", null);
	SeqVariants[4] = new RegExp("agg[act]taaa|ttta[agt]cct", null);
	SeqVariants[5] = new RegExp("aggg[acg]aaa|ttt[cgt]ccct", null);
	SeqVariants[6] = new RegExp("agggt[cgt]aa|tt[acg]accct", null);
	SeqVariants[7] = new RegExp("agggta[cgt]a|t[acg]taccct", null);
	SeqVariants[8] = new RegExp("agggtaa[cgt]|[acg]ttaccct", null);
	RegExp Regex_FASTAInfo = new RegExp(">.*\n|\n", "gi");
	char[][char[]] IUB; 
	IUB["B"] = "(c|g|t)"; IUB["D"] = "(a|g|t)"; IUB["H"] = "(a|c|t)"; IUB["K"] = "(g|t)";
	IUB["M"] = "(a|c)"; IUB["N"] = "(a|c|g|t)"; IUB["R"] = "(a|g)"; IUB["S"] = "(c|g)";
	IUB["V"] = "(a|c|g)"; IUB["W"] = "(a|t)"; IUB["Y"] = "(c|t)";
	
	/* The buffer is allocated in chunks and then truncated to minimize the impact
	*  of dynamic allocations. It'd be useful to know the average size of FASTA Data.
	*/
	for(Var_SeqLen_Original = 0; !din.eof; Var_SeqLen_Original++)
	{
		if (Var_SeqLen_Original == Buf_InputSequence.length) 
			{ Buf_InputSequence.length = Buf_InputSequence.length * 2; }
		Buf_InputSequence[Var_SeqLen_Original] = din.getc();
	}
	
	//The last iteration should be ignored, as it doesn't write anything.
	Var_SeqLen_Original -= 1;
	Buf_InputSequence.length = Var_SeqLen_Original;
	
	//The new blank spaces generated by RegExp.replace are automatically removed.
	Buf_InputSequence = Regex_FASTAInfo.replace(Buf_InputSequence, null);
	Var_SeqLen_NoFASTAInfo = Buf_InputSequence.length;
	
	//We look for each sequence in the data provided.
	foreach(int Index, inout RegExp Variant; SeqVariants)
	{							
 		Variant.test(Buf_InputSequence, 0);		//Awful, but necessary.
		if (Variant.pmatch[0].rm_so == -1)
		{
			printf("%s %i\n", (Variant.pattern ~ "\0").ptr, Var_VarMatches[Index]);
			continue;
		}
		Var_VarMatches[Index]++;
		for(;;)
		{
			Variant.test(Buf_InputSequence, Variant.pmatch[0].rm_eo);
			if (Variant.pmatch[0].rm_so == -1) { break; }
			Var_VarMatches[Index]++;
		}
		printf("%s %i\n", (Variant.pattern ~ "\0").ptr, Var_VarMatches[Index]);
	}
	
	//IUB code replacement.
	foreach(char[] Code, inout char[] Alternative; IUB)
	{
		Buf_InputSequence = (new RegExp(Code, "g")).replace(Buf_InputSequence, Alternative);
	}
	
	//Output the length of each sequence.
	printf("\n%i\n%i\n%i\n", Var_SeqLen_Original, Var_SeqLen_NoFASTAInfo, Buf_InputSequence.length);
	return 0;
}