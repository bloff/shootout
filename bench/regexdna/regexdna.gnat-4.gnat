-----------------------------------------------------------------------
-- The Computer Language Shootout
-- http://shootout.alioth.debian.org/
--
-- Contributed by Jim Rogers
-- Modified by Georg Bauhaus
--
-- This version uses the GNAT Spitbol Pattern matching libraries
-- rather than the more commonly used Unix-style regex libraries
-----------------------------------------------------------------------

with Ada.Text_Io; use Ada.Text_Io;
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;
with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;
with Gnat.Spitbol.Patterns; use Gnat.Spitbol.Patterns;
use Gnat.Spitbol;

procedure Regexdna is
   Variant_Labels : constant array (Positive range 1..9) of Vstring := (
      To_Unbounded_String("agggtaaa|tttaccct"),
      To_Unbounded_String("[cgt]gggtaaa|tttaccc[acg]"),
      To_Unbounded_String("a[act]ggtaaa|tttacc[agt]t"),
      To_Unbounded_String("ag[act]gtaaa|tttac[agt]ct"),
      To_Unbounded_String("agg[act]taaa|ttta[agt]cct"),
      To_Unbounded_String("aggg[acg]aaa|ttt[cgt]ccct"),
      To_Unbounded_String("agggt[cgt]aa|tt[acg]accct"),
      To_Unbounded_String("agggta[cgt]a|t[acg]taccct"),
      To_Unbounded_String("agggtaa[cgt]|[acg]ttaccct"));

   Variant_Patterns : constant array(Positive range 1..9) of Pattern := (
      "agggtaaa" or "tttaccct",
      (Any("cgt") & "gggtaaa") or ("tttaccc" & Any("acg")),
      ("a" & Any("act") & "ggtaaa") or ("tttacc" & Any("agt") & "t"),
      ("ag" & Any("act") & "gtaaa") or ("tttac" & Any("agt") & "ct"),
      ("agg" & Any("act") & "taaa") or ("ttta" & Any("agt") & "cct"),
      ("aggg" & Any("acg") & "aaa") or ("ttt" & Any("cgt") & "ccct"),
      ("agggt" & Any("cgt") & "aa") or ("tt" & Any("acg") & "accct"),
      ("agggta" & Any("cgt") & "a") or ("t" & Any("acg") & "taccct"),
      ("agggtaa" & Any("cgt")) or (Any("acg") & "ttaccct"));

   type Iub is
      record
         Code         : Pattern;
         Alternatives : Unbounded_String;
   end record;
   subtype Codes_Index is Natural range 0..10;
   type Codes_Array is array (Codes_Index) of Iub;
   Codes : constant Codes_Array := (
      (Any("B"), To_Unbounded_String ("(c|g|t)")),
      (Any("D"), To_Unbounded_String ("(a|g|t)")),
      (Any("H"), To_Unbounded_String ("(a|c|t)")),
      (Any("K"), To_Unbounded_String ("(g|t)")),
      (Any("M"), To_Unbounded_String ("(a|c)")),
      (Any("N"), To_Unbounded_String ("(a|c|g|t)")),
      (Any("R"), To_Unbounded_String ("(a|g)")),
      (Any("S"), To_Unbounded_String ("(c|g)")),
      (Any("V"), To_Unbounded_String ("(a|c|g)")),
      (Any("W"), To_Unbounded_String ("(a|t)")),
      (Any("Y"), To_Unbounded_String ("(c|t)")));

   type Dna_Lines is array(Positive range <>) of Vstring;
   function Length(Item : in Dna_Lines) return Natural is
      Sum : Natural := 0;
   begin
      for I in Item'range loop
         Sum := Sum + Length(Item(I));
      end loop;
      return Sum;
   end Length;

   Initial_Length : Natural := 0;
   Code_Length : Natural;
   Line : String(1..80);
   Var_Line : Vstring_Var;
   Line_Length : Natural;
   Sequence : Vstring_Var;
   Fasta_Description : constant Pattern := Pos(0) & ">" & Rest;
   Descrip_Pattern : constant Pattern := (Fasta_Description);
   Num_Lines : Natural;
   Match_Found : Boolean;
begin

   -- Read FASTA Sequence
   -- Record length and remove the unwanted elements

   while not End_Of_File loop
      Get_Line(Item => Line, Last => Line_Length);
      Var_Line := To_Unbounded_String(Line(1..Line_Length));
      Initial_Length := Initial_Length + Length(Var_Line) + 1;
      Match(Subject => Var_Line,
         Pat => Descrip_Pattern, Replace => "");
      Append(Source => Sequence, New_Item => Var_Line);
   end loop;
   Code_Length := Length(Sequence);

   -- regex match
   declare
      Count : Natural := 0;
      function Inc_Count return Boolean is
      begin
         Count := Count + 1;
         return False;
      end Inc_Count;
   begin
      for I in Variant_Labels'range loop
         Count := 0;
         Match(Subject => Sequence,
            Pat => Variant_Patterns(I) & (+Inc_Count'unrestricted_access));
         Put(To_String(Variant_Labels(I)) & " ");
         Put(Item => Count, Width => 1);
         New_Line;
      end loop;
      New_Line;
   end;

   -- regex substitution

   Num_Lines := Length(Sequence) / 80;
   if Length(Sequence) mod 80 > 1 then
      Num_Lines := Num_Lines + 1;
   end if;
   declare
      Sequence_Lines : Dna_Lines(1..Num_Lines);
      Low, Sub_Len : Natural;
   begin
      -- Distribute Sequence to Sequence_Lines
      Low := 1;
      Sub_Len := 80;
      for I in Sequence_Lines'range loop
         Sequence_Lines(I) := Substr(Str => Sequence ,
            Start => Low, Len => Sub_Len );
         Low := Low + Sub_Len;
         if Low + Sub_Len > Length(Sequence) then
            Sub_Len := Length(Sequence) - Low + 1;
         end if;
      end loop;

      -- Perform the regex substitution
      for I in Sequence_Lines'range loop
         for C in Codes_Index loop
            loop
               Match_Found := Match(Subject => Sequence_Lines(I),
                  Pat => Codes(C).Code, Replace => Codes(C).Alternatives);
               exit when not Match_Found;
            end loop;
         end loop;
      end loop;
      Put(Item => Initial_Length, Width => 1);
      New_Line;
      Put(Item => Code_Length, Width => 1);
      New_Line;
      Put(Item => Length(Sequence_Lines), Width => 1);
      New_Line;
   end;


end Regexdna;
