/* The Great Computer Language Shootout
   http://shootout.alioth.debian.org/

   contributed by Dave Fladebo 

   compile: dmd -O -inline -release message.d
*/

import std.stdio, std.string, std.thread;

int main(char[][] args)
{
    const int threads = 500;
    int n = args.length > 1 ? atoi(args[1]) : 2;

    Link chain = null;
    Link.total = threads * n;
    for(int i = 0; i < threads; i++)
    {
        Link next = new Link(chain);
        chain = next;
    }

    Link first = chain;
    while(chain)
    {
        chain.start();
        chain = chain.next;
    }

    chain = first;
    while(n--) chain.put(0);

    while(chain)
    {
        chain.wait();
        chain = chain.next;
    }

    writefln(Link.sum);

    return 0;
}

class Link
{
private:
    pthread_t id;
    int message = -1;
    sem_t semr;
    static pthread_attr_t pa;
    static sem_t semw;
    static threads = 0;

    static this()
    {
        pthread_attr_init(&pa);
        pthread_attr_setstacksize(&pa,ushort.max);
        sem_init(&semw,0,0);
    }

    private int take()
    {
        int msg = 0;
        if(message > -1)
        {
            msg = message + 1;
            message = -1;
        }
        return msg;
    }

public:
    Link next;
    static int sum = 0, total = 0;

    this(Link next)
    {
        this.next = next;
        sem_init(&semr,0,0);
    }

    void start()
    {
        pthread_create(&id,&pa,&threadrun,this);
        threads++;
    }

    void wait()
    {
        pthread_join(id,null);
    }

    void run()
    {
        if(next)
        {
            while(sum < (total - threads))
            {
                sem_wait(&semr);
                next.message = take();
                sem_post(&next.semr);
            }
        }
        else
        {
            while(sum < total)
            {
                sem_wait(&semr);
                sum += take();
                sem_post(&semw);
            }
        }
    }

    void put(int msg)
    {
        message = msg;
        sem_post(&semr);
        sem_wait(&semw);
    }
}

extern(C)
{
void *threadrun(void *p)
{
    Link t = cast(Link)p;
    t.run();
    return null;
}
int pthread_attr_init(pthread_attr_t*);
int pthread_attr_setstacksize(pthread_attr_t*,size_t);
int pthread_yield();
struct pthread_attr_t
{
    int __detachstate;
    int __schedpolicy;
    struct __sched_param
    {
        int __sched_priority;
    }
    int __inheritsched;
    int __scope;
    size_t __guardsize;
    int __stackaddr_set;
    void* __stackaddr;
    size_t __stacksize;
}
} // extern(C)
