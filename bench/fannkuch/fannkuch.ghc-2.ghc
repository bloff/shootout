-- The Great Computer Language Shootout 
-- http://shootout.alioth.debian.org/
-- contributed by Don Stewart, translation from the C version

import Control.Monad
import Foreign
import System
import GHC.Base
import GHC.Ptr
import GHC.IOBase

main = do 
    n <- getArgs >>= return . read . head
    k <- if n < 1 then return (0::Int) else fannkuch n
    putStrLn $ "Pfannkuchen(" ++ show n ++ ") = " ++ show (k - 1)

fannkuch n@(I# n#) = do
    perm            <- mallocArray n       :: IO (Ptr Int)
    (Ptr c#)        <- mallocArray n       :: IO (Ptr Int)
    perm1@(Ptr p1#) <- newArray [0 .. n-1] :: IO (Ptr Int)
    (Ptr rP)        <- newArray [n]        :: IO (Ptr Int)
    (Ptr flipsMaxP) <- newArray [0]        :: IO (Ptr Int)

    let go didpr = do
            didpr' <- if didpr < (30 :: Int)
                      then ppr 0 n perm1 >> putStr "\n" >> return (didpr + 1)
                      else return didpr

            IO $ \s -> 
                case readIntOffAddr# rP 0# s of
                    (# s, r# #) -> case setcount c# r# s of
                        (# s, _ #) -> case writeIntOffAddr# rP 0# 1# s of
                            s -> (# s, () #)

            t <- IO $ \s -> 
                case readIntOffAddr# p1# 0# s of
                    (# s, p1 #) -> case readIntOffAddr# p1# (n# -# 1#) s of
                        (# s, pn #) -> (# s, not (p1 ==# 0# || pn ==# (n# -# 1#)) #)
            
            when t $ exchange n perm perm1 flipsMaxP

            fm   <- IO $ \s -> case readIntOffAddr# flipsMaxP 0# s of 
                                (# s, x #) -> (# s, I# x #)
            done <- IO $ \s -> rot rP n# p1# c# s
            if done then return fm else go didpr'
    go 0

------------------------------------------------------------------------

exchange n p@(Ptr a) p1@(Ptr b) fm = do
    copyArray (p `advancePtr` 1) (p1 `advancePtr` 1) (n-1) 
    IO $ \s -> 
        case readIntOffAddr# b 0# s  of { (# s, k #) -> 
        case doswap k a 0# s         of { (# s, f #) -> 
        case readIntOffAddr# fm 0# s of { (# s, m #) -> 
        if m <# f then case writeIntOffAddr# fm 0# f s of s -> (# s, () #)
                  else (# s, () #)
        } } }
{-# INLINE exchange #-}

doswap k a f s = 
    case swap 1# (k -# 1#) a s    of { (# s, _ #) -> 
    case readIntOffAddr# a k s    of { (# s, j #) -> 
    case writeIntOffAddr# a k k s of { s          -> 
    if k /=# 0# then doswap j a (f +# 1#) s else (# s, (f +# 1#) #)
    } } }
{-# INLINE doswap #-}

swap i j a s =
    if i <# j then case readIntOffAddr#  a i s   of { (# s, x #) -> 
                   case readIntOffAddr#  a j s   of { (# s, y #) -> 
                   case writeIntOffAddr# a j x s of { s          -> 
                   case writeIntOffAddr# a i y s of { s          -> 
                   swap (i +# 1#) (j -# 1#) a s 
                   } } } }
              else (# s, () #)
{-# INLINE swap #-}

loop r i a s = 
    if i <# r then case readIntOffAddr# a (i +# 1#) s of
                    (# s, x #) -> case writeIntOffAddr# a i x s of
                        s -> loop r (i +# 1#) a s
              else (# s, () #)
{-# INLINE loop #-}

setcount p r s =
    if r ==# 1# then (# s, () #)
                else case writeIntOffAddr# p (r -# 1#) r s of
                        s -> setcount p (r -# 1#) s
{-# INLINE setcount #-}

rot rP n a cp s =
  case readIntOffAddr# rP 0# s of { (# s, r #) -> 
  if r ==# n then (# s, True #) 
             else case readIntOffAddr# a 0# s             of { (# s, p0 #) -> 
                  case loop r 0# a s                      of { (# s, _ #)  -> 
                  case writeIntOffAddr# a r p0 s          of { s           -> 
                  case readIntOffAddr# cp r s             of { (# s, cr #) -> 
                  case writeIntOffAddr# cp r (cr -# 1#) s of { s           -> 
                  if cr -# 1# ># 0# then (# s, False #) 
   output left in -
                                 else case inc s of s -> rot rP n a cp s
  } } } } } }
  where inc s = case readIntOffAddr# rP 0# s of 
                  (# s, x #) -> writeIntOffAddr# rP 0# (x +# 1#) s
{-# INLINE rot #-}

ppr i n p = when (i < n) $ do
    putStr . show . (+1) =<< peek (p `advancePtr` i)
    ppr (i+1) n p

