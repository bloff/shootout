{-# OPTIONS -O2 -optc-O3 #-}
-- The Great Computer Language Shootout 
-- http://shootout.alioth.debian.org/
-- written by Bertram Felgenhauer, Don Stewart, Matthias Neubauer, Josh Goldfoot and David Place.

import System
import Data.List

rotate 2 (x1:x2:xs) = x2:x1:xs
rotate 3 (x1:x2:x3:xs) = x2:x3:x1:xs
rotate 4 (x1:x2:x3:x4:xs) = x2:x3:x4:x1:xs
rotate 5 (x1:x2:x3:x4:x5:xs) = x2:x3:x4:x5:x1:xs
rotate 6 (x1:x2:x3:x4:x5:x6:xs) = x2:x3:x4:x5:x6:x1:xs
rotate 7 (x1:x2:x3:x4:x5:x6:x7:xs) = x2:x3:x4:x5:x6:x7:x1:xs
rotate 8 (x1:x2:x3:x4:x5:x6:x7:x8:xs) = x2:x3:x4:x5:x6:x7:x8:x1:xs
rotate 9 (x1:x2:x3:x4:x5:x6:x7:x8:x9:xs) = x2:x3:x4:x5:x6:x7:x8:x9:x1:xs
rotate 10 (x1:x2:x3:x4:x5:x6:x7:x8:x9:x10:xs) = x2:x3:x4:x5:x6:x7:x8:x9:x10:x1:xs
rotate n (x:xs) = rotate' n xs
    where rotate' 1 xs     = x:xs
          rotate' n (x:xs) = x:rotate' (n-1) xs

permutations l = foldr permutations' [l] [2..length l]
    where permutations' n = foldr (takeIter n (rotate n)) []

takeIter 0 f x rest = rest
takeIter n f x rest = x : takeIter (n-1::Int) f (f x) rest

flop :: Int -> [Int] -> (Int, [Int])
flop 2  (x2:xs) = (x2, 2:xs)
flop 3  (x2:x3:xs) = (x3, x2:3:xs)
flop 4  (x2:x3:x4:xs) = (x4, x3:x2:4:xs)
flop 5  (x2:x3:x4:x5:xs) = (x5, x4:x3:x2:5:xs)
flop 6  (x2:x3:x4:x5:x6:xs) = (x6, x5:x4:x3:x2:6:xs)
flop 7  (x2:x3:x4:x5:x6:x7:xs) = (x7, x6:x5:x4:x3:x2:7:xs)
flop 8  (x2:x3:x4:x5:x6:x7:x8:xs) = (x8, x7:x6:x5:x4:x3:x2:8:xs)
flop 9  (x2:x3:x4:x5:x6:x7:x8:x9:xs) = (x9, x8:x7:x6:x5:x4:x3:x2:9:xs)
flop 10 (x2:x3:x4:x5:x6:x7:x8:x9:x10:xs) = (x10,x9:x8:x7:x6:x5:x4:x3:x2:10:xs)
flop n xs = rs
  where (rs, ys)          = flop' n xs ys
        flop' 2 (x:xs) ys = ((x, ys), n:xs)
        flop' n (x:xs) ys = flop' (n-1) xs (x:ys)

steps :: Int -> [Int] -> Int
steps n    (a:as) = steps' n (a,as)

steps' n (1,_)  = n
steps' n (t,ts) = steps' (n+1) (flop t ts)

main = do n <- getArgs >>= return . read . head
          let p = permutations [1..n]
          mapM_ (putStrLn . concatMap show) $ take 30 p
          putStr $ "Pfannkuchen(" ++ show n ++ ") = "
          putStrLn . show $ foldl' (flip (max . steps 0)) 0 p
