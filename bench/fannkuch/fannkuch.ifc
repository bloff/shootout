! -*- mode: f90 -*-
!
! $Id: fannkuch.ifc,v 1.3 2005-06-06 20:06:03 sgeard-guest Exp $ ; $Name:  $
!
! Fannkuch access function implementation
! Simon Geard, 1/12/04
!
! Building info.
! ==============
!
! Linux  - using the Intel Fortran90 compiler:
!
!          ifort fannkuch.f90 -O3 -static-libcxa -o fannkuch
!

program fannkuch
  implicit none
  integer count, i, num
  character(len=8) argv
  integer, dimension(:), allocatable :: data
  intrinsic max

  call getarg(1,argv)
  read(argv,*) num
  allocate(data(num))

  count = 0
  data = (/ (i,i=1,num) /) ! Must start with the smallest number
  do i=1,factorial(num)
     count = max(count,countFlips(data))
     call getNextPerm(data)
  end do
  
  deallocate(data)
  
  write(*,'(2(a,i0))') 'Pfannkuchen(',num,') = ',count

contains

  recursive integer function factorial(n) result(if)
    integer, intent(in) :: n
    if (n == 1) then
       if = 1
    else
       if = n*factorial(n-1)
    end if
  end function factorial

  ! Reverse an array
  subroutine reverse(data)
    integer, dimension(:), intent(inout) :: data
    integer, dimension(size(data)) :: work
    integer i
   ! print *,'reversing ',data
    forall (i=1:size(data))
       work(i) = data(size(data)-i+1)
    end forall
    data = work
  end subroutine reverse

  ! Count the number of flips in a permutation
  integer function countFlips(data)
    integer, dimension(:), intent(in) :: data
    integer, dimension(size(data)) :: work
    work = data
    countFlips = 0
    do
       if (work(1) <= 1) exit
       call reverse(work(1:work(1)))
       countFlips = countFlips + 1
    end do
  end function countFlips

  ! Get next permutation
  subroutine getNextPerm(data)
    integer, dimension(:), intent(inout) :: data
    integer :: i, kx, e, ci, ce, tmp, N

    ! Find largest k s.t. data(k) < data(k+1)
    N = size(data)
    kx = 0
    do i=1,N-1
       if (data(i) < data(i+1)) then
          kx = i
       end if
    end do

    ! Find smallest data(k+j) > data(k)
    e = data(kx)
    ci = kx
    do i=kx+1,N
       if (data(i) > e .and. (ci == kx .or. data(i) < ce)) then
          ci = i
          ce = data(i)
       end if
    end do

    ! Swap data(k) and data(k+j)
    tmp = data(kx)
    data(kx) = data(ci)
    data(ci) = tmp

    ! Reverse data(k+1) ... data(N)
    call reverse(data(kx+1:N))
    
  end subroutine getNextPerm

end program fannkuch
