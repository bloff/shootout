(* fasta.sml
 *
 *   Generate and write random "DNA" sequences.
 *
 * Copyright (c) 2004 by The Fellowship of SML/NJ
 *
 * Author: Matthias Blume (blume@tti-c.org)
 *)
structure Test:sig val main:string*string list->OS.Process.status end = struct

    val len = 60

    infix 8 $ % val (op $, op %) = (Unsafe.Array.sub, Unsafe.CharVector.sub)
    infix 3 <-  fun (a, i) <- x = Unsafe.Array.update (a, i, x)
    fun x - y = Word.toIntX (Word.- (Word.fromInt x, Word.fromInt y))
    fun succ x = Word.toIntX (Word.fromInt x + 0w1)

    fun out s = TextIO.output (TextIO.stdOut, s)
    fun out1 c = TextIO.output1 (TextIO.stdOut, c)

    (* word->real conversion *)
    val wreal = real o Word.toIntX
    (* the constants for the random number generator *)
    val (M, A, C) = (0w139968, 0w3877, 0w29573)     val M' = 1.0 / wreal M

    (* the random number generator *)
    val random = let val l = ref 0w42
		 in fn m=>let val c = (!l*A+C) mod M in l:=c; m*M'*wreal c end
		 end

    (* calculate cumulative probabilities *)
    fun mkCumul l =
	let val (cl, pl) = ListPair.unzip l
	    val (s, a) = (CharVector.fromList cl, Array.fromList pl)
	    fun upd (i, p, s) = let val s = s+p in (a,i)<-s; s end
	in ignore (Array.foldli upd 0.0 a); (s, a, Array.length a - 1) end

    (* the bases with their probabilities *)
    val dna1 = [(#"a", 0.3029549426680), (#"c", 0.1979883004921),
		(#"g", 0.1975473066391), (#"t", 0.3015094502008)]

    val dna2 = [(#"a", 0.250), (#"c", 0.125), (#"g", 0.125), (#"t", 0.250),
		(#"U", 0.019230769231), (#"R", 0.019230769231),
		(#"Y", 0.019230769231), (#"K", 0.019230769231),
		(#"M", 0.019230769231), (#"S", 0.019230769231),
		(#"W", 0.019230769231), (#"B", 0.019230769231),
		(#"D", 0.019230769231), (#"H", 0.019230769231),
		(#"V", 0.019230769231), (#"N", 0.019230769231),
		(#"-", 0.019230769231)]

    (* do the conversion *)
    val (sa1, sa2) = (mkCumul dna1, mkCumul dna2)

    (* select a random base *)
(*  (* using binary search *)
    fun mp(i,j) = Word.toIntX (Word.>> (Word.fromInt i + Word.fromInt j, 0w1))
    fun selRandom (s, a, n') =
	let val r = random 1.0
	    fun l (i,j) =	(* invariant: a$i < r <= a$j *)
		if i>=j-1 then s%j
		else let val m=mp(i,j) in if a$m<=r then l(m,j) else l(i,m) end
	in l (~1, n') end
*)

    (* Most of the weight is on small i, so binary search does not
     * buy much.  In fact, good old linear seach seems a bit faster: *)
    fun selRandom (s, a, n') =
	let val r = random 1.0
	    fun l i = if i >= n' orelse a$i > r then s%i else l (succ i)
	in l 0 end

    (* make fasta fragment *)
    fun mff (id, desc, sa, n) =
	let fun loop n = let val m = Int.min(n,len) in loop' (n-m,m) end
	    and loop' (n, 0) = (out1 #"\n"; if n>0 then loop n else ())
	      | loop' (n, m) = (out1 (selRandom sa); loop' (n,m-1))
	in app out [">", id, " ", desc, "\n"]; loop n end

    (* test harness *)
    fun make' n = (mff ("TestOne",   "test fragment", sa2, n*1);
		   mff ("TestTwo",   "test fragment", sa1, n*2);
		   mff ("TestThree", "test fragment", sa2, n*3);
		   mff ("TestFour",  "test fragment", sa1, n*4);
		   mff ("TestFive",  "test fragment", sa2, n*5);
		   OS.Process.success)

    (* driver *)
    fun main (_, []) = make' 1
      | main (_, arg :: _) = make' (getOpt (Int.fromString arg, 1))
end
