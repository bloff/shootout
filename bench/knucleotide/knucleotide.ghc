-- knucleotide.hs
--
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org/
--
-- Contributed by Einar Karttunen
-- This is a purely functional solution to the problem.
-- An alternative which keeps a mutable table of occurences would be faster.
--

import Data.Char
import Data.List
import Numeric

counts :: Int -> String -> [String]
counts k dna = filter (not.null) $ map (taker k []) (tails dna)
    where taker 0 acc _      = reverse acc
          taker i acc (x:xs) = taker (i-1) (x:acc) xs
          taker i acc []     = []

writeFrequencies k dna = 
  let cnt = counts k dna
      tot :: Float
      tot = fromIntegral $ length cnt
      frr = map (\ks -> (head ks, fromIntegral (length ks) * 100 / tot)) $ group $ sort cnt
      frq = sortBy (\(_,x) (_,y) -> y `compare` x) frr
      in mapM_ (\(k,f) -> putStr (k++" "++showFFloat (Just 3) f "\n")) frq >> putStrLn ""
      
writeCount sq dna = putStrLn (show cnt ++ "\t" ++ sq)
    where cnt = length $ filter (\c -> c==sq) $ counts (length sq) dna

dnaThree = process =<< getContents
    where process ls  = return $ ul $ takeNorm $ tail $ dropComment $ dropOther $ lines ls
          dropOther   = dropWhile (\str -> not (">THREE" `isPrefixOf` str))
          dropComment = dropWhile (\str -> head str == ';')
          takeNorm    = takeWhile (\str -> head str /= '>')
          ul str      = map toUpper $ concat str

main = do three <- dnaThree
          writeFrequencies 1 three
          writeFrequencies 2 three
          mapM_ (\k -> writeCount k three) ["GGT", "GGTA", "GGTATT", "GGTATTTTAATT", "GGTATTTTAATTTATAGT"]
