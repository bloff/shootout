import Data.Char
import qualified Data.Map as Map
import Data.List
-- The Computer Language Shootout
-- http://shootout.alioth.debian.org/
--
-- Contributed by anon


import Text.Printf(printf)
import qualified Data.ByteString.Char8 as B
import Data.Ord (comparing)
 
type FreqMap = Map.Map B.ByteString Int
 
loadMap :: Int -> [B.ByteString] -> FreqMap
loadMap i s = foldl' (\m w -> Map.insertWith (+) w 1 m) Map.empty snips
 where snips = filter (not . B.null ) $ map (B.take i) s
 
writeFrequencies i dna = 
  let mp = loadMap i dna
      total = fromIntegral (Map.fold (+) 0 mp ) / 100 :: Double
      res = map (\(a,b) -> (a, fromIntegral b / total)) (Map.toAscList mp)
      in mapM_ showFun . sortBy (flip (comparing snd)) $ res
 
showFun :: (B.ByteString, Double) -> IO ()
showFun (k,f) = printf "%s %.3f\n" (B.unpack k) f
 
writeCount dna sq = printf "%d\t%s\n" cnt (B.unpack sq)
      where cnt = length $ filter (B.isPrefixOf sq) dna
 
dnaThree :: IO [B.ByteString]
dnaThree = process =<< B.getContents
    where process     = return . B.tails . ul . takeNorm . tail . dropComment . dropOther . B.lines 
          dropOther   = dropWhile (\str -> not ((B.pack ">THREE") `B.isPrefixOf` str))
          dropComment = dropWhile (\str -> B.head str == ';')
          takeNorm    = takeWhile (\str -> B.head str /= '>')
          ul          = B.map toUpper . B.concat 
 
main = do three <- dnaThree
          writeFrequencies 1 three >> putStrLn ""
          writeFrequencies 2 three >> putStrLn ""
          mapM_ (writeCount three . B.pack) ["GGT", "GGTA", "GGTATT", "GGTATTTTAATT", "GGTATTTTAATTTATAGT"]

