/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy 
*/

using System;
using System.IO;
using System.Collections;
using System.Text;

class KNucleotide {
   private String sequence;
   private Hashtable frequencies;
   private int k;

   KNucleotide(String s) {
      sequence = s;
      frequencies = new Hashtable();
      k = 0;
   }

   static void Main(string[] args){
      // extract nucleotide sequence
      StringBuilder builder = new StringBuilder();
      String line;
      char c;

      using (StreamReader s = new StreamReader(Console.OpenStandardInput())){
         while ( (line = s.ReadLine()) != null ) {
            c = line[0];
            if ((c == '>') && (line.Substring(1,5)=="THREE")) break;
         }

         while ( (line = s.ReadLine()) != null ) {
            c = line[0];
            if (c == '>') 
               break;
            else if (c != ';') 
               builder.Append(line.ToUpper());
         }
      }

      // calculate nucleotide frequencies
      KNucleotide kn = new KNucleotide( builder.ToString() );
      kn.WriteFrequencies(1); 
      kn.WriteFrequencies(2); 

      kn.WriteCount("GGT"); 
      kn.WriteCount("GGTA");
      kn.WriteCount("GGTATT");
      kn.WriteCount("GGTATTTTAATT");
      kn.WriteCount("GGTATTTTAATTTATAGT"); 
   }


   void WriteFrequencies(int nucleotideLength) {
      GenerateFrequencies(nucleotideLength);

      KeyValue[] items = new KeyValue[frequencies.Count];
      frequencies.Values.CopyTo(items, 0);
      int sum = 0;
      foreach (KeyValue each in items) sum += (int)each.v;

      Array.Sort(items, new SortByFrequencyAndCode() );
      foreach (KeyValue each in items) {
         double percent = (double)((int)each.v)/(double)sum * 100.0;
         Console.WriteLine("{0} {1:f2}", (string)each.k, percent );
      } 
      Console.WriteLine("");
   }

   void WriteCount(String nucleotideFragment) {
      GenerateFrequencies(nucleotideFragment.Length);

      int count = 0;
      object item;
      if ((item = frequencies[nucleotideFragment]) != null) 
         count = ((KeyValue)item).v;
      Console.WriteLine("{0}\t{1}", count, nucleotideFragment );
   }


   private void GenerateFrequencies(int length) {
      k = length;
      frequencies.Clear();
      for(int frame=0; frame<k; frame++) KFrequency(frame);
   }

   private void KFrequency(int readingFrame) {
      int n = sequence.Length - k + 1;
      object item;
      for(int i=readingFrame; i<n; i+=k) {
         String knucleo = sequence.Substring(i,k);                 
         if ( (item = frequencies[knucleo]) != null) 
            ((KeyValue)item).v++;
         else 
            frequencies[knucleo] = new KeyValue(knucleo,1);
      }
   }

   private class KeyValue {
      internal String k;
      internal int v;

      internal KeyValue(String k, int v) {
         this.k = k;
         this.v = v;
      }
   }

   private class SortByFrequencyAndCode : IComparer {
      internal SortByFrequencyAndCode() {}

      // Sort descending by Frequency and if equal, sort ascending by Code
      int IComparer.Compare(object o1, object o2) {
         KeyValue item1 = (KeyValue)o1;
         KeyValue item2 = (KeyValue)o2;

         int comparison = item2.v.CompareTo(item1.v);
         if (comparison == 0) return item1.k.CompareTo(item2.k);
         else return comparison;
      }
   }
}




