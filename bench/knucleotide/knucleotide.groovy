#!/bin/env groovy
/*
	$Id: knucleotide.groovy,v 1.1 2005-09-18 05:01:24 igouy-guest Exp $

	The Great Computer Language Shootout
	http://shootout.alioth.debian.org/

	contributed by Jochen Hinrichsen
	modified by 

    Each program should
    
        * read line-by-line a redirected FASTA format file from stdin
        * extract DNA sequence THREE
        * define a procedure/function to update a hashtable of k-nucleotide keys and count values, for a particular reading-frame â€” even though we'll combine k-nucleotide counts for all reading-frames (grow the hashtable from a small default size)
        * write the code and percentage frequency, for all the 1-nucleotide and 2-nucleotide sequences, sorted by descending frequency and then ascending k-nucleotide key
        * count all the 3- 4- 6- 12- and 18-nucleotide sequences, and write the count and code for specific sequences
    
    We use FASTA files generated by the fasta benchmark as input for this benchmark. Note: the file may include both lowercase and uppercase codes.
    
    Correct output for this 100KB input file (generated with the fasta program N = 10000), is
    
    A 30.284
    T 29.796
    C 20.312
    G 19.608
    
    AA 9.212
    AT 8.950
    TT 8.948
    TA 8.936
    CA 6.166
    CT 6.100
    AC 6.086
    TC 6.042
    AG 6.036
    GA 5.968
    TG 5.868
    GT 5.798
    CC 4.140
    GC 4.044
    CG 3.906
    GG 3.798
    
    562     GGT
    152     GGTA
    15      GGTATT
    0       GGTATTTTAATT
    0       GGTATTTTAATTTATAGT
    
    
    In practice, less brute-force would be used to calculate k-nucleotide frequencies, for example Virus Classification using k-nucleotide Frequencies and A Fast Algorithm for the Exhaustive Analysis of 12-Nucleotide-Long DNA Sequences. Applications to Human Genomics (105KB pdf).
*/

def sequence = readSequence(System.in, ">THREE").toUpperCase()
assert sequence.size() > 1000

[1, 2].each() {
    writeFrequency(sequence, it)
}

[ "GGT", "GGTA", "GGTATT", "GGTATTTTAATT", "GGTATTTTAATTTATAGT" ].each() {
        println "${sequence.count(it)}\t${it}"
}

def readSequence(streamin, id) {
    def sequence = ""
    def record = false
    streamin.eachLine() { line ->
        switch (line) {
            case ~"^$id.*":
                record = true
                break

            case [~"^>.*", ~"^;.*"]:
                record = false
                break
            
            default:
                if (record) {
                    sequence += line
                }
        }
    }
    sequence
}

def writeFrequency(sequence, f) {
    def count = [:]
    def formater = new java.text.DecimalFormat("#0.000")
    for (offset in 0..<f) frequency(sequence, f, offset, count)

    // default sort() is smallest first
    // sort for multiple properties: [ it.value, it.key ]
    count.values().sort({ l, r -> r <=> l}).each() { value ->
        def entry = count.find() { entry ->
            entry.getValue() == value
        }
    
        println "${entry.key} ${formater.format(100.0*value/sequence.size())}"
    }

    println ""
}

def frequency(sequence, f, offset, count) {
    def n = sequence.size()
    def last = n - f + 1

    (offset..<last).step(f) { i ->
        def key = sequence[i..<i+f]
        // No automatic defaulting
        if (count[key] == null) count[key] = 1
        // ++ results in error
        else count[key] += 1
    }
}

// EOF

