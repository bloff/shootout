{-# OPTIONS -funbox-strict-fields #-}
--
-- http://shootout.alioth.debian.org/
--
-- By Chris Kuklewicz and Don Stewart
--
import Control.Monad
import Foreign
import Text.Printf      (printf)

import Data.List
import Data.Maybe       (maybe,fromMaybe)
import Data.Char        (ord,chr,toUpper)
import qualified Data.HashTable as Table

import GHC.Exts
import GHC.IOBase

type Base = Word8
c2b :: Char -> Base = fromIntegral . ord . toUpper
b2c :: Base -> Char = chr . fromIntegral

-- The ptr are usually into the main fasta data, which is read-only
data Seq = Seq !Int !(Ptr Base)

seqStrings = ["GGT","GGTA","GGTATT","GGTATTTTAATT","GGTATTTTAATTTATAGT"]

main = do section <- getSection ">THREE"
          mapM_ (writeFreq section) [1,2]
          mapM_ (writeFrame section) =<< mapM stringToSeq seqStrings

-- allocate, read, and return the main fasta data
getSection prefix = do findPrefix
                       baseArray <- newArray0 0 =<< getRest =<< skipComments
                       size      <- lengthArray0 0 baseArray
                       return (Seq size baseArray)

  where findPrefix   = do line <- getLine; unless (isPrefixOf prefix line) findPrefix
        skipComments = do line <- getLine
                          if ';' == head line then skipComments else return line
        getRest fl   = do all <- getContents
                          let asLines = takeWhile (('>'/=).head) (fl : lines all)
                          return $ concatMap (map c2b) asLines

-- Apply f at every subsequence of length frameSize inside bases
mapSeq (Seq size bases) frameSize f = mapM_ act [0..size-frameSize]
    where act i = f (Seq frameSize (advancePtr bases i))

-- This is most of the program time and memory
-- HashTable needs a spiffier API
countFrame table frame = do mOld <- Table.lookup table frame
                            Table.update table frame $! maybe 1 succ mOld

-- This nails down the type 'Int' for counting the frames
newTable = Table.new eqSeq hashSeq :: IO (Table.HashTable Seq Int)

-- (countFreq sb) satisfies "define a procedure/function to update a
-- hashtable of k-nucleotide keys and count values, for a particular
-- reading-frame"
countFreq sb frameSize table = mapSeq sb frameSize (countFrame table)

-- This builds the table for a given frameSize and prints the table
writeFreq sb@(Seq size bases) frameSize = do
    table    <- newTable
    countFreq sb frameSize table
    unsorted <- Table.toList table
    mapM_ printBSF (mySort unsorted) >> putChar '\n'

  where printBSF (bs,f) = printf "%s %.3f\n" (showSeq bs) (percent f)
        total     = fromIntegral (size - frameSize + 1)
        percent n = 100 * (fromIntegral n) / total :: Double
        mySort    = sortBy $ \(k1,x) (k2,y) -> case compare y x of 
                                                    EQ -> cmpSeq k1 k2
                                                    z  -> z

-- This builds the table for the size of the given frame and prints
-- that frame's frequency
writeFrame sb@(Seq size bases) frame@(Seq frameSize _) = do
    table   <- newTable
    countFreq sb frameSize table
    mAnswer <- Table.lookup table frame
    putStrLn $ show (fromMaybe 0 mAnswer) ++ '\t' : showSeq frame

-- Routines to convert strings to Seq and back
stringToSeq str =
    newArray0 0 (map c2b str) >>= \b -> lengthArray0 0 b >>= \s -> return (Seq s b)

showSeq (Seq size ptr) = inlinePerformIO $ peekArray size ptr >>= return.(map b2c)

--
-- Performance tweaked routines for (HashTable Seq Int)
--

{-# INLINE inlinePerformIO #-}
inlinePerformIO (IO m) = case m realWorld# of (# _, r #) -> r

hashSeq (Seq (I# size) (Ptr ptr)) = inlinePerformIO . IO $ hashmem size ptr 0#

eqSeq (Seq (I# size1) (Ptr ptr1)) (Seq (I# size2) (Ptr ptr2)) = 
    if size1 /=# size2 then False 
                       else inlinePerformIO . IO $ eqmem size1 ptr1 ptr2

cmpSeq (Seq size1 ptr1) (Seq size2 ptr2) = case compare size1 size2 of
    EQ -> inlinePerformIO $ cmpmem size1 ptr1 ptr2
    z  -> z

{-# INLINE hashmem #-}
hashmem i p h s = if i ==# 0# then (# s, toEnum (I# h) #) else 
    case readInt8OffAddr# p 0# s of
         (# s, i8  #) -> hashmem (i -# 1#) (plusAddr# p 1#) (17# *# h +# i8) s

{-# INLINE eqmem #-}
eqmem i ptr1 ptr2 s = if i ==# 0# then (# s , True #) else 
    case readInt8OffAddr# ptr1 0# s of { (# s, i8a #) ->
    case readInt8OffAddr# ptr2 0# s of { (# s, i8b #) ->
    if i8a ==# i8b
        then eqmem (i -# 1#) (plusAddr# ptr1 1#) (plusAddr# ptr2 1#) s
        else (# s, False #) } }

{-# INLINE cmpmem #-}
cmpmem i ptr1 ptr2 = if i == 0 then return EQ else do 
    cmp <- liftM2 compare (peek ptr1) (peek ptr2)
    case cmp of EQ -> cmpmem (pred i) (ptr1 `advancePtr` 1) (ptr2 `advancePtr` 1)
                z  -> return z

