/* The Computer Language Shootout
   http://shootout.alioth.debian.org/

   Contributed by Josh Goldfoot

   Converted to D by Dave Fladebo
   compile: dmd -O -inline -release knucleotide.d ../../Include/dlang/hashtable.d

   This revision uses "hashtable.d" available from
   http://cvs.alioth.debian.org/cgi-bin/cvsweb.cgi/shootout/bench/Include/?cvsroot=shootout
*/

import hashtable, std.stdio, std.string, std.c.string;

void main()
{
    char[] line = new char[256];
    while(fgets(line.ptr, 256, stdin))
        if(line[0] == '>' && line[1] == 'T' && line[2] == 'H')
            break;

    char[] buffer = new char[1024];
    char[] x = buffer;

    size_t seqlen = 0;
    while(fgets(x.ptr, 256, stdin))
    {
        size_t linelen = strlen(x.ptr);
        if(linelen)
        {
            if(x[linelen - 1] == '\n')
	        linelen--;
	    char c = x[0];
	    if(c == '>')
            {
                break;
            }
	    else if(c != ';')
	    {
	        seqlen += linelen;
	        if(seqlen + 512 >= buffer.length)
	        {
                    buffer.length = buffer.length * 2;
		    x = buffer[seqlen .. $];
		}
	        else
		    x = x[linelen .. $];
	        x[0] = 0;
	    }
         }
      }

    buffer = toupper(buffer[0 .. seqlen]);

    writeFrequency(1, buffer);
    writeFrequency(2, buffer);
    writeCount("GGT", buffer);
    writeCount("GGTA", buffer);
    writeCount("GGTATT", buffer);
    writeCount("GGTATTTTAATT", buffer);
    writeCount("GGTATTTTAATTTATAGT", buffer);
}

alias HashTable!(int) HT;

HT genFrequency(int keyLen, char[] buffer)
{
    if(keyLen > buffer.length)
        return null;

    HT ht = new HT(keyLen, buffer.length);
    for(int i = 0; i < buffer.length - keyLen + 1; i++)
    {
          ht.findNew(buffer[i .. i + keyLen]).value++;
    }

    return ht;
}

void writeFrequency(int keyLen, char[] buffer)
{
    size_t total = 0, size = 0;
    HT.HashTableNode nd;

    HT ht = genFrequency(keyLen, buffer);
    for(nd = ht.first; nd; nd = ht.next)
    {
        total = total + nd.value;
        size++;
    }

    size_t si = 0;
    struct sorter
    {
        char[] string;
        size_t num;
    }
    sorter[] s = new sorter[size];
    for(nd = ht.first; nd; nd = ht.next)
    {
        s[si].string = nd.key;
        s[si].num = nd.value;
        si++;
    }

    for(int i = 0; i < size - 1; i++)
    {
        for(int j = i + 1; j < size; j++)
        {
            if (s[i].num < s[j].num)
	    {
	        sorter tmp = s[i];
                s[i..i+1] = s[j..j+1];
                s[j] = tmp;
	    }
        }
    }

    for(int i = 0; i < size; i++)
    {
        writefln("%s %.3f", s[i].string, 100 * s[i].num / cast(float)total);
    }
    writefln();
}

void writeCount(char[] searchFor, char[] buffer)
{
    HT ht = genFrequency(searchFor.length, buffer);
    writefln("%d\t%s", ht.findNew(searchFor).value, searchFor);
}
