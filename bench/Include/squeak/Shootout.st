Object subclass: #Body	instanceVariableNames: 'x y z vx vy vz mass'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!Body methodsFor: 'accessing' stamp: '11/29/2006 19:23'!mass   ^mass! !!Body methodsFor: 'accessing' stamp: '11/29/2006 19:24'!x   ^x! !!Body methodsFor: 'accessing' stamp: '11/29/2006 19:24'!x: d1 y: d2 z: d3 vx: d4 vy: d5 vz: d6 mass: d7   x := d1.   y := d2.    z := d3.    vx := d4.   vy := d5.   vz := d6.   mass := d7! !!Body methodsFor: 'accessing' stamp: '11/29/2006 19:24'!y   ^y! !!Body methodsFor: 'accessing' stamp: '11/29/2006 19:24'!z   ^z! !!Body methodsFor: 'nbody' stamp: '11/29/2006 19:32'!addMomentumTo: anArray   anArray at: 1 put: (anArray at: 1) + (vx * mass).   anArray at: 2 put: (anArray at: 2) + (vy * mass).   anArray at: 3 put: (anArray at: 3) + (vz * mass).   ^anArray! !!Body methodsFor: 'nbody' stamp: '11/29/2006 19:32'!and: aBody velocityAfter: dt	        | dx dy dz distance mag |   dx := x - aBody x.   dy := y - aBody y.   dz := z - aBody z.      distance := ((dx*dx) + (dy*dy) + (dz*dz)) sqrt.   mag := dt / (distance * distance * distance).   self decreaseVelocity: dx y: dy z: dz m: aBody mass * mag.      aBody increaseVelocity: dx y: dy z: dz m: mass * mag! !!Body methodsFor: 'nbody' stamp: '11/29/2006 19:33'!decreaseVelocity: dx y: dy z: dz m: m   vx := vx - (dx * m).   vy := vy - (dy * m).   vz := vz - (dz * m)! !!Body methodsFor: 'nbody' stamp: '11/29/2006 19:33'!increaseVelocity: dx y: dy z: dz m: m   vx := vx + (dx * m).   vy := vy + (dy * m).   vz := vz + (dz * m)! !!Body methodsFor: 'nbody' stamp: 'isaac 11/29/2006 20:06'!kineticEnergy   ^0.5d0 * mass * ((vx * vx) + (vy * vy) + (vz * vz))! !!Body methodsFor: 'nbody' stamp: '11/29/2006 19:34'!offsetMomentum: anArray    | m |   m := self class solarMass.   vx := (anArray at: 1) negated / m.   vy := (anArray at: 2) negated / m.   vz := (anArray at: 3) negated / m! !!Body methodsFor: 'nbody' stamp: '11/29/2006 19:34'!positionAfter: dt   x := x + (dt * vx).   y := y + (dt * vy).   z := z + (dt * vz)! !!Body methodsFor: 'nbody' stamp: '11/29/2006 19:34'!potentialEnergy: aBody   | dx dy dz distance |   dx := x - aBody x.   dy := y - aBody y.   dz := z - aBody z.   distance := ((dx*dx) + (dy*dy) + (dz*dz)) sqrt.   ^mass * aBody mass / distance! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Body class	instanceVariableNames: ''!!Body class methodsFor: 'constants' stamp: '11/29/2006 19:26'!daysPerYear   ^365.24d0! !!Body class methodsFor: 'constants' stamp: '11/29/2006 19:27'!jupiter   ^self new      x: 4.84143144246472090d0      y: -1.16032004402742839d0      z: -1.03622044471123109d-1      vx: 1.66007664274403694d-3 * self daysPerYear      vy: 7.69901118419740425d-3 * self daysPerYear      vz: -6.90460016972063023d-5 * self daysPerYear      mass: 9.54791938424326609d-4 * self solarMass! !!Body class methodsFor: 'constants' stamp: '11/29/2006 19:27'!neptune   ^self new      x: 1.53796971148509165d1      y: -2.59193146099879641d1      z: 1.79258772950371181d-1      vx: 2.68067772490389322d-3 * self daysPerYear      vy: 1.62824170038242295d-3 * self daysPerYear      vz: -9.51592254519715870d-5 * self daysPerYear      mass: 5.15138902046611451d-5 * self solarMass! !!Body class methodsFor: 'constants' stamp: '11/29/2006 19:26'!pi   ^3.141592653589793d0! !!Body class methodsFor: 'constants' stamp: '11/29/2006 19:27'!saturn   ^self new      x: 8.34336671824457987d0      y: 4.12479856412430479d0      z: -4.03523417114321381d-1      vx: -2.76742510726862411d-3 * self daysPerYear      vy: 4.99852801234917238d-3 * self daysPerYear      vz: 2.30417297573763929d-5 * self daysPerYear      mass: 2.85885980666130812d-4 * self solarMass! !!Body class methodsFor: 'constants' stamp: '11/29/2006 19:27'!solarMass   ^4.0d0 * self pi * self pi! !!Body class methodsFor: 'constants' stamp: '11/29/2006 19:27'!sun   ^self new      x: 0.0d0      y: 0.0d0      z: 0.0d0      vx: 0.0d0      vy: 0.0d0      vz: 0.0d0      mass: self solarMass! !!Body class methodsFor: 'constants' stamp: '11/29/2006 19:28'!uranus   ^self new      x: 1.28943695621391310d1      y: -1.51111514016986312d1      z: -2.23307578892655734d-1      vx: 2.96460137564761618d-3 * self daysPerYear      vy: 2.37847173959480950d-3 * self daysPerYear      vz: -2.96589568540237556d-5 * self daysPerYear      mass: 4.36624404335156298d-5 * self solarMass! !Object subclass: #Chameleon	instanceVariableNames: 'meetings color semaphore waitingForPair'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!Chameleon methodsFor: 'initialize-release' stamp: '  11/29/2006 23:52'!initialize    meetings := 0.    waitingForPair := Semaphore new.    semaphore := Semaphore new! !!Chameleon methodsFor: 'changing colours' stamp: '  11/29/2006 23:53'!color: c    color := c! !!Chameleon methodsFor: 'changing colours' stamp: '  11/29/2006 23:53'!fade    color := #faded.    waitingForPair signal.    semaphore signal! !!Chameleon methodsFor: 'changing colours' stamp: '  11/29/2006 23:54'!met: other    | newColor |    meetings := meetings + 1.    color == #red ifTrue: [	newColor := other == #yellow ifTrue: [ #blue ] ifFalse: [ #yellow ] ].    color == #yellow ifTrue: [	newColor := other == #red ifTrue: [ #blue ] ifFalse: [ #red ] ].    color == #blue ifTrue: [	newColor := other == #red ifTrue: [ #yellow ] ifFalse: [ #red ] ].    color := newColor.    waitingForPair signal! !!Chameleon methodsFor: 'running' stamp: '  11/29/2006 23:54'!fork: meetingPlace    ^[ self run: meetingPlace ] fork! !!Chameleon methodsFor: 'running' stamp: '  11/29/2006 23:54'!run: meetingPlace    [ color == #faded ] whileFalse: [	meetingPlace reachedBy: self.	waitingForPair wait ]! !!Chameleon methodsFor: 'accessing' stamp: '  11/29/2006 23:52'!color    ^color! !!Chameleon methodsFor: 'accessing' stamp: '  11/29/2006 23:53'!meetings    ^meetings! !!Chameleon methodsFor: 'accessing' stamp: '  11/29/2006 23:53'!wait    semaphore wait! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Chameleon class	instanceVariableNames: ''!!Chameleon class methodsFor: 'instance creation' stamp: '  11/29/2006 23:55'!color: c    ^self new	initialize;	color: c! !Object subclass: #Consumer	instanceVariableNames: 'semaphore msg'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!Consumer methodsFor: 'accessing' stamp: '  11/29/2006 23:33'!msg    semaphore wait.    ^msg! !!Consumer methodsFor: 'accessing' stamp: '  11/29/2006 23:33'!msg: data    msg := data.    semaphore signal! !!Consumer methodsFor: 'accessing' stamp: '  11/29/2006 23:32'!semaphore: aSemaphore    semaphore := aSemaphore! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Consumer class	instanceVariableNames: ''!!Consumer class methodsFor: 'instance creation' stamp: '  11/29/2006 23:33'!new    | var |    var := self basicNew.    var semaphore: Semaphore new.    ^var! !Object subclass: #MeetingPlace	instanceVariableNames: 'mutex first total max'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!MeetingPlace methodsFor: 'running' stamp: '  11/29/2006 23:56'!max: maxMeetings    max := maxMeetings! !!MeetingPlace methodsFor: 'running' stamp: '  11/29/2006 23:56'!organizeMeetingWith: second    total >= max	ifTrue: [	    first fade.	    second fade ]	ifFalse: [	    first met: second color.	    second met: first color ].    total := total + 1! !!MeetingPlace methodsFor: 'running' stamp: '  11/29/2006 23:56'!reachedBy: chameleon    mutex critical: [	first isNil	    ifTrue: [ first := chameleon ]	    ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ]! !!MeetingPlace methodsFor: 'initialize-release' stamp: '  11/29/2006 23:55'!initialize    mutex := Semaphore forMutualExclusion.    total := 0! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MeetingPlace class	instanceVariableNames: ''!!MeetingPlace class methodsFor: 'instance creation' stamp: '  11/29/2006 23:57'!forMeetings: maxMeetings    ^super new	initialize;	max: maxMeetings;	yourself! !Object subclass: #NBodySystem	instanceVariableNames: 'bodies'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!NBodySystem methodsFor: 'nbody' stamp: '11/29/2006 19:35'!after: dt   1 to: bodies size do: [:i|      i+1 to: bodies size do: [:j|                                     (bodies at: i) and: (bodies at: j) velocityAfter: dt].   ].      bodies do: [:each| each positionAfter: dt]! !!NBodySystem methodsFor: 'nbody' stamp: 'isaac 11/29/2006 20:06'!energy   | e |   e := 0.0d0.   1 to: bodies size do: [:i|             e := e + (bodies at: i) kineticEnergy.      i+1 to: bodies size do: [:j|          e := e - ((bodies at: i) potentialEnergy: (bodies at: j))].   ].   ^e! !!NBodySystem methodsFor: 'initialize-release' stamp: 'isaac 11/29/2006 20:05'!initialize   bodies := OrderedCollection new      add: Body sun; add: Body jupiter; add: Body saturn;      add: Body uranus; add: Body neptune; yourself.   bodies first offsetMomentum:      (bodies inject: (Array with: 0.0d0 with: 0.0d0 with: 0.0d0)         into: [:m :each | each addMomentumTo: m])! !Object subclass: #PermGenerator	instanceVariableNames: 'timesRotated perm atEnd'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!PermGenerator methodsFor: 'initialize-release' stamp: '  11/29/2006 23:06'!initialize: size    perm := (1 to: size) asArray.    timesRotated := Array new: size withAll: 0.    atEnd := false! !!PermGenerator methodsFor: 'initialize-release' stamp: '  11/29/2006 23:07'!makeNext    | temp remainder |    "Generate the next permutation."    2 to: perm size do: [ :r |	"Rotate the first r items to the left."        temp := perm at: 1.        1 to: r - 1 do: [ :i | perm at: i put: (perm at: i + 1) ].        perm at: r put: temp.        remainder := timesRotated at: r put: ((timesRotated at: r) + 1) \\ r.        remainder = 0 ifFalse: [ ^self ].	"After r rotations, the first r items are in their original positions.	 Go on rotating the first r+1 items."    ].    "We are past the final permutation."    atEnd := true! !!PermGenerator methodsFor: 'accessing' stamp: '  11/29/2006 23:07'!atEnd    ^atEnd! !!PermGenerator methodsFor: 'accessing' stamp: '  11/29/2006 23:07'!next    | result |    result := perm copy.    self makeNext.    ^result! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PermGenerator class	instanceVariableNames: ''!!PermGenerator class methodsFor: 'instance creation' stamp: '  11/29/2006 23:06'!new: size    ^self new	initialize: size;	yourself! !Object subclass: #PiDigitSpigot	instanceVariableNames: 'z x inverse'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!PiDigitSpigot methodsFor: 'private' stamp: '  11/30/2006 16:56'!consume: aTransformation   ^z * aTransformation! !!PiDigitSpigot methodsFor: 'private' stamp: '  11/30/2006 16:56'!digit   ^(z extract: 3) floor! !!PiDigitSpigot methodsFor: 'private' stamp: '  11/30/2006 16:56'!isSafe: aDigit   ^aDigit = (z extract: 4) floor! !!PiDigitSpigot methodsFor: 'private' stamp: '  11/30/2006 16:56'!produce: anInteger   inverse q: 10 r: -10 * anInteger s: 0 t: 1.   ^inverse * z! !!PiDigitSpigot methodsFor: 'accessing' stamp: '  11/30/2006 16:55'!next   | y |   ^(self isSafe: (y := self digit))      ifTrue: [z := self produce: y. y]      ifFalse: [z := self consume: x next. self next]! !!PiDigitSpigot methodsFor: 'initialize-release' stamp: '  11/30/2006 16:55'!initialize   z := Transformation unity.   x := Transformation new.   inverse := Transformation new.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PiDigitSpigot class	instanceVariableNames: ''!!PiDigitSpigot class methodsFor: 'instance creation' stamp: '  11/30/2006 16:54'!new   ^super new initialize! !Consumer subclass: #ProducerConsumer	instanceVariableNames: 'consumer'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!ProducerConsumer methodsFor: 'accessing' stamp: '  11/29/2006 23:34'!consumer: aProcess    consumer := aProcess! !!ProducerConsumer methodsFor: 'accessing' stamp: '  11/29/2006 23:35'!fork    [ self run ] fork! !!ProducerConsumer methodsFor: 'accessing' stamp: '  11/29/2006 23:35'!run    [ consumer msg: self msg + 1 ] repeat! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ProducerConsumer class	instanceVariableNames: ''!!ProducerConsumer class methodsFor: 'instance creation' stamp: '  11/29/2006 23:35'!fork: consumer    | proc |    proc := self new.    proc consumer: consumer.    proc fork.    ^proc! !Object subclass: #Tests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Tests class	instanceVariableNames: ''!!Tests class methodsFor: 'benchmarking' stamp: '  4/11/2007 21:04'!binarytrees   | minDepth n maxDepth stretchDepth check longLivedTree iterations stdout |    minDepth := 4.   n := (SmalltalkImage current getSystemAttribute: 3) asInteger.   maxDepth := minDepth + 2 max: n.   stretchDepth := maxDepth + 1.   stdout := UnixProcess stdOut.   check := (TreeNode bottomUpTree: 0 depth: stretchDepth) itemCheck.   stdout       nextPutAll: 'stretch tree of depth '; nextPutAll: stretchDepth printString; nextPut: Character tab;      nextPutAll: ' check: '; nextPutAll: check printString; nextPut: Character lf.   longLivedTree := TreeNode bottomUpTree: 0 depth: maxDepth.   minDepth to: maxDepth by: 2 do: [:depth|      iterations := 1 bitShift: maxDepth - depth + minDepth.      check := 0.      1 to: iterations do: [:i|         check := check + (TreeNode bottomUpTree: i depth: depth) itemCheck.         check := check + (TreeNode bottomUpTree: -1*i depth: depth) itemCheck.      ].      stdout         nextPutAll:  (2*iterations) printString; nextPut: Character tab;          nextPutAll: ' trees of depth '; nextPutAll: depth printString; nextPut: Character tab;         nextPutAll: ' check: '; nextPutAll: check printString; nextPut: Character lf.   ].   stdout      nextPutAll: 'long lived tree of depth '; nextPutAll: maxDepth printString; nextPut: Character tab;      nextPutAll: ' check: '; nextPutAll: longLivedTree itemCheck printString; nextPut: Character lf. ! !!Tests class methodsFor: 'benchmarking' stamp: '  4/11/2007 21:12'!chameneos   | c1 c2 c3 c4 mp |   c1 := Chameleon color: #blue.   c2 := Chameleon color: #red.   c3 := Chameleon color: #yellow.   c4 := Chameleon color: #blue.   mp := MeetingPlace forMeetings: (SmalltalkImage current getSystemAttribute: 3) asInteger.   c1 fork: mp.   c2 fork: mp.   c3 fork: mp.   c4 fork: mp.   c1 wait.   c2 wait.   c3 wait.   c4 wait.   UnixProcess stdOut      nextPutAll: (c1 meetings + c2 meetings + c3 meetings + c4 meetings) printString;      nextPut: Character lf! !!Tests class methodsFor: 'benchmarking' stamp: '  4/11/2007 21:12'!fannkuch   | n stdout |   n := (SmalltalkImage current getSystemAttribute: 3) asInteger.   stdout := UnixProcess stdOut.   stdout      nextPutAll: 'Pfannkuchen(', n printString, ') = ',          (n maxPfannkuchen: stdout) printString;      nextPut: Character lf! !!Tests class methodsFor: 'benchmarking' stamp: '  4/11/2007 21:12'!mandelbrot   | width height m bits s zr zi cr ci i tr stepr stepi |   width := (SmalltalkImage current getSystemAttribute: 3) asInteger.   height := width.   m := 50.   s := UnixProcess stdOut.   s nextPutAll: 'P4'; nextPut: Character lf;       nextPutAll: width printString, ' ', height printString;       nextPut: Character lf.   stepr := 2.0 / width.   stepi := 2.0 / height.   0 to: height - 1 do: [ :y |      bits := 0.      ci := stepi * y asFloat - 1.0.      0 to: width - 1 do: [ :x |         cr := stepr * x asFloat - 1.5.         zr := cr. zi := ci.         bits := bits bitShift: 1.         i := 1.         [            tr := (zr*zr) - (zi*zi) + cr.            zi := 2.0 * zr * zi + ci.            zr := tr.            (zr*zr) + (zi*zi) < 4.0 and: [ (i := i + 1) < m ]         ] whileTrue.         i = m ifTrue: [ bits := bits + 1 ].         (x bitAnd: 7) == 7 ifTrue: [            s nextPut: (Character value: bits).            bits := 0.         ]      ].      (width bitAnd: 7) == 0 ifFalse: [         bits := bits bitShift: 8 - (width bitAnd: 7).         s nextPut: (Character value: bits).      ]]! !!Tests class methodsFor: 'benchmarking' stamp: '  4/11/2007 21:13'!message   | n tail head sum |   n := (SmalltalkImage current getSystemAttribute: 3) asInteger.   head := tail := Consumer new.   500 timesRepeat: [       head := ProducerConsumer fork: head ].   sum := 0.   n timesRepeat: [       head msg: 0.       sum := sum + tail msg ].   UnixProcess stdOut      nextPutAll: sum printString;      nextPut: Character lf! !!Tests class methodsFor: 'benchmarking' stamp: '  4/11/2007 21:13'!nbody   | n bodies stdout |   n := (SmalltalkImage current getSystemAttribute: 3) asInteger.   bodies := NBodySystem new initialize.   stdout := UnixProcess stdOut.   stdout nextPutAll: (bodies energy printShowingDecimalPlaces: 9); nextPut: Character lf.   n timesRepeat: [bodies after: 0.01d0].   stdout nextPutAll: (bodies energy printShowingDecimalPlaces: 9); nextPut: Character lf.! !!Tests class methodsFor: 'benchmarking' stamp: '  4/11/2007 21:14'!nsieve   | n stdout |   n := (SmalltalkImage current getSystemAttribute: 3) asInteger.   stdout := UnixProcess stdOut.   (n < 2) ifTrue: [n := 2].    n      primes: stdout.   (n - 1) primes: stdout.   (n - 2) primes: stdout.! !!Tests class methodsFor: 'benchmarking' stamp: '  4/11/2007 21:14'!partialsums   | n a1 a2 a3 a4 a5 a6 a7 a8 a9 twothirds alt stdout print |   n := (SmalltalkImage current getSystemAttribute: 3) asInteger.   a1 := 0.0d0. a2 := 0.0d0. a3 := 0.0d0. a4 := 0.0d0. a5 := 0.0d0.   a6 := 0.0d0. a7 := 0.0d0. a8 := 0.0d0. a9 := 0.0d0.   twothirds := 2.0d0/3.0d0.   alt := -1.0d0.   1.0d0 to: n do: [:k| | k2 k3 sk ck |      k2 := k*k.      k3 := k2*k.      sk := k sin.      ck := k cos.      alt := -1.0d0 * alt.      a1 := a1 + (twothirds raisedTo: k - 1.0d0).      a2 := a2 + (k raisedTo: -0.5d0).      a3 := a3 + (1.0d0/(k*(k+1.0d0))).      a4 := a4 + (1.0d0/(k3*sk*sk)).      a5 := a5 + (1.0d0/(k3*ck*ck)).      a6 := a6 + (1.0d0/k).      a7 := a7 + (1.0d0/k2).      a8 := a8 + (alt/k).      a9 := a9 + (alt/(2.0d0*k - 1.0d0)).   ].stdout := UnixProcess stdOut.print := [:answer :id |   stdout       nextPutAll: (answer printShowingDecimalPlaces: 9);      nextPut: Character tab;      nextPutAll: id;      nextPut: Character lf   ].print value: a1 value: '(2/3)^k'.print value: a2 value: 'k^-0.5'.print value: a3 value: '1/k(k+1)'.print value: a4 value: 'Flint Hills'.print value: a5 value: 'Cookson Hills'.print value: a6 value: 'Harmonic'.print value: a7 value: 'Riemann Zeta'.print value: a8 value: 'Alternating Harmonic'.print value: a9 value: 'Gregory'.! !!Tests class methodsFor: 'benchmarking' stamp: '  4/11/2007 21:14'!pidigits   | i length n pidigits stream |   n := (SmalltalkImage current getSystemAttribute: 3) asInteger.   i := 0.   length := 10.   pidigits := PiDigitSpigot new.   stream := UnixProcess stdOut.   [n > 0] whileTrue: [      (n < length)           ifTrue: [            n timesRepeat: [               stream nextPut: (Character digitValue: pidigits next)               ].            n to: length do: [:each| stream space].             i := i + n.            ]          ifFalse: [            length timesRepeat: [               stream nextPut: (Character digitValue: pidigits next)               ].            i := i + length.            ].      stream tab nextPut: $:.      i printOn: stream.       stream nextPut: Character lf.      n := n - length.   ].! !!Tests class methodsFor: 'benchmarking' stamp: '  4/11/2007 21:15'!recursive   | n stdout |   n := (SmalltalkImage current getSystemAttribute: 3) asInteger.   stdout := UnixProcess stdOut.   stdout       nextPutAll: 'Ack(3,', n printString, '): ', (3 ack: n) printString;       nextPut: Character lf;      nextPutAll: 'Fib(', ((27.0+n) asStringWith: 1), '): ',          ((27.0+n) fib asStringWith: 1);       nextPut: Character lf.   n := n - 1.   stdout       nextPutAll: 'Tak(', (3*n) printString, ',',         (2*n) printString, ',', n printString, '): ',           (3*n tak: 2*n z: n) printString;       nextPut: Character lf;      nextPutAll: 'Fib(3): ', 3 fib printString;      nextPut: Character lf;      nextPutAll: 'Tak(3.0,2.0,1.0): ',           ((3.0 tak: 2.0 z: 1.0) asStringWith: 1);       nextPut: Character lf.! !!Tests class methodsFor: 'benchmarking' stamp: '  4/11/2007 21:15'!spectralnorm   | n u v vBv vv |   n := (SmalltalkImage current getSystemAttribute: 3) asInteger.   u := Array new: n withAll: 1.0d0.   v := Array new: n withAll: 0.0d0.   10 timesRepeat: [      v := u multiplyAtAv.      u := v multiplyAtAv.   ].   vBv := 0.0d0.   vv := 0.0d0.   1 to: n do: [:i|       vBv := vBv + ((u at: i) * (v at: i)).      vv := vv + ((v at: i) * (v at: i)).   ].     UnixProcess stdOut      nextPutAll: ((vBv/vv) sqrt  printShowingDecimalPlaces: 9);      nextPut: Character lf! !!Tests class methodsFor: 'benchmarking' stamp: '  4/11/2007 21:33'!sumcol   | stdin sum |   stdin := UnixProcess stdIn.   sum := 0.   [stdin atEnd] whileFalse: [      sum := sum + (stdin upTo: Character cr) asNumber].   UnixProcess stdOut nextPutAll: sum printString; nextPut: Character cr. ! !Object subclass: #Transformation	instanceVariableNames: 'q r s t k'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!Transformation methodsFor: 'accessing' stamp: '  11/30/2006 16:51'!* aTransformation   ^self species       q: q * aTransformation q      r: q * aTransformation r + (r * aTransformation t)      s: s * aTransformation q + (t * aTransformation s)      t: s * aTransformation r + (t * aTransformation t)! !!Transformation methodsFor: 'accessing' stamp: '  11/30/2006 16:52'!extract: anInteger   ^(q * anInteger + r) // (s * anInteger + t)! !!Transformation methodsFor: 'accessing' stamp: '  11/30/2006 16:52'!next   k := k +1.   q := k.   r := 4 * k + 2.   s := 0.   t := 2 * k + 1.! !!Transformation methodsFor: 'accessing' stamp: '  11/30/2006 16:52'!q   ^q! !!Transformation methodsFor: 'accessing' stamp: '  11/30/2006 16:52'!q: anInteger1 r: anInteger2 s: anInteger3 t: anInteger4   q := anInteger1.   r := anInteger2.   s := anInteger3.   t := anInteger4.   k := 0.! !!Transformation methodsFor: 'accessing' stamp: '  11/30/2006 16:52'!r   ^r! !!Transformation methodsFor: 'accessing' stamp: '  11/30/2006 16:52'!s   ^s! !!Transformation methodsFor: 'accessing' stamp: '  11/30/2006 16:53'!t   ^t! !!Transformation methodsFor: 'initialize-release' stamp: '  11/30/2006 16:51'!initialize   q := 0.   r := 0.   s := 0.   t := 0.   k := 0.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Transformation class	instanceVariableNames: ''!!Transformation class methodsFor: 'instance creation' stamp: '  11/30/2006 16:53'!new   ^super new initialize! !!Transformation class methodsFor: 'instance creation' stamp: '  11/30/2006 16:53'!q: anInteger1 r: anInteger2 s: anInteger3 t: anInteger4   ^(super new) q: anInteger1 r: anInteger2 s: anInteger3 t: anInteger4! !!Transformation class methodsFor: 'instance creation' stamp: '  11/30/2006 16:53'!unity   ^self q: 1 r: 0 s: 0 t: 1! !Object subclass: #TreeNode	instanceVariableNames: 'left right item'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!TreeNode methodsFor: 'initialize-release' stamp: '  11/29/2006 22:18'!left: leftChild right: rightChild item: anItem   left := leftChild.   right := rightChild.   item := anItem! !!TreeNode methodsFor: 'accessing' stamp: '  11/29/2006 22:18'!itemCheck   ^left isNil       ifTrue: [item] ifFalse: [item + (left itemCheck - right itemCheck)]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TreeNode class	instanceVariableNames: ''!!TreeNode class methodsFor: 'instance creation' stamp: '  11/29/2006 22:17'!bottomUpTree: anItem depth: anInteger   ^(anInteger > 0)       ifTrue: [         self             left: (self bottomUpTree: 2*anItem - 1 depth: anInteger - 1)             right: (self bottomUpTree: 2*anItem depth: anInteger - 1)              item: anItem         ]      ifFalse: [self left: nil right: nil item: anItem]! !!TreeNode class methodsFor: 'instance creation' stamp: '  11/29/2006 22:18'!left: leftChild right: rightChild item: anItem         ^(super new) left: leftChild right: rightChild item: anItem! !
