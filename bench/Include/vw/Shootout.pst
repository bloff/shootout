"Name: ShootoutHideSource: falsePackageName: ComputerLanguageShootoutParcel: #('Shootout')SaveSource: trueDate: 7:31:41 am February 10, 2006"!'From VisualWorksÂ® NonCommercial, 7.4 of December 5, 2005 on February 10, 2006 at 7:31:41 am'!(Dialog confirm: 'You are filing-in a Parcel source file!!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']!Smalltalk defineNameSpace: #Shootout	private: false	imports: '			private Smalltalk.*			'	category: 'ComputerLanguageShootout'!Smalltalk.Shootout defineClass: #PiDigitSpigot	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'z x inverse '	classInstanceVariableNames: ''	imports: ''	category: 'ComputerLanguageShootout'!Shootout.PiDigitSpigot class	instanceVariableNames: ''!Smalltalk.Shootout defineClass: #NBodySystem	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'bodies '	classInstanceVariableNames: ''	imports: ''	category: 'ComputerLanguageShootout'!Shootout.NBodySystem class	instanceVariableNames: ''!Smalltalk.Shootout defineClass: #Transformation	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'q r s t k '	classInstanceVariableNames: ''	imports: ''	category: 'ComputerLanguageShootout'!Shootout.Transformation class	instanceVariableNames: ''!Smalltalk.Shootout defineClass: #RandomNumber	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'seed scale '	classInstanceVariableNames: ''	imports: ''	category: 'ComputerLanguageShootout'!Shootout.RandomNumber class	instanceVariableNames: ''!Smalltalk.Shootout defineClass: #TreeNode	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'left right item '	classInstanceVariableNames: ''	imports: ''	category: 'ComputerLanguageShootout'!Shootout.TreeNode class	instanceVariableNames: ''!Smalltalk.Shootout defineClass: #RepeatStream	superclass: #{Core.ReadStream}	indexedType: #none	private: false	instanceVariableNames: 'repeatPtr repeatLimit '	classInstanceVariableNames: ''	imports: ''	category: 'ComputerLanguageShootout'!Shootout.RepeatStream class	instanceVariableNames: ''!Smalltalk.Shootout defineClass: #RandomStream	superclass: #{Shootout.RepeatStream}	indexedType: #none	private: false	instanceVariableNames: 'random percentages '	classInstanceVariableNames: ''	imports: ''	category: 'ComputerLanguageShootout'!Shootout.RandomStream class	instanceVariableNames: ''!Smalltalk.Shootout defineClass: #Body	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'x y z vx vy vz mass '	classInstanceVariableNames: ''	imports: ''	category: 'ComputerLanguageShootout'!Shootout.Body class	instanceVariableNames: ''!Smalltalk.Shootout defineClass: #BitArray	superclass: #{Core.Object}	indexedType: #bytes	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'ComputerLanguageShootout'!Shootout.BitArray class	instanceVariableNames: ''!Smalltalk.Shootout defineClass: #Chameleon	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'meetings color semaphore waitingForPair '	classInstanceVariableNames: ''	imports: ''	category: 'ComputerLanguageShootout'!Shootout.Chameleon class	instanceVariableNames: ''!Smalltalk.Shootout defineClass: #Tests	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'ComputerLanguageShootout'!Shootout.Tests class	instanceVariableNames: ''!Smalltalk.Shootout defineClass: #Consumer	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'semaphore msg '	classInstanceVariableNames: ''	imports: ''	category: 'ComputerLanguageShootout'!Shootout.Consumer class	instanceVariableNames: ''!Smalltalk.Shootout defineClass: #ProducerConsumer	superclass: #{Shootout.Consumer}	indexedType: #none	private: false	instanceVariableNames: 'consumer '	classInstanceVariableNames: ''	imports: ''	category: 'ComputerLanguageShootout'!Shootout.ProducerConsumer class	instanceVariableNames: ''!Smalltalk.Shootout defineClass: #PermGenerator	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'timesRotated perm atEnd '	classInstanceVariableNames: ''	imports: ''	category: 'ComputerLanguageShootout'!Shootout.PermGenerator class	instanceVariableNames: ''!Smalltalk.Shootout defineClass: #MeetingPlace	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'mutex first total max '	classInstanceVariableNames: ''	imports: ''	category: 'ComputerLanguageShootout'!Shootout.MeetingPlace class	instanceVariableNames: ''!Shootout.RandomNumber defineSharedVariable: #FModulus	private: false	constant: false	category: 'computer language shootout'	initializer: '139968.0d'!Shootout.RandomNumber defineSharedVariable: #Increment	private: false	constant: false	category: 'computer language shootout'	initializer: '29573'!Shootout.RandomNumber defineSharedVariable: #Multiplier	private: false	constant: false	category: 'computer language shootout'	initializer: '3877'!Shootout.RandomNumber defineSharedVariable: #Modulus	private: false	constant: false	category: 'computer language shootout'	initializer: '139968'!!Shootout.PiDigitSpigot methodsFor: 'initialize-release'!initialize   z := Transformation unity.   x := Transformation new.   inverse := Transformation new.! !!Shootout.PiDigitSpigot methodsFor: 'accessing'!next   | y |   ^(self isSafe: (y := self digit))      ifTrue: [z := self produce: y. y]      ifFalse: [z := self consume: x next. self next]! !!Shootout.PiDigitSpigot methodsFor: 'private'!consume: aTransformation   ^z * aTransformation!digit   ^(z extract: 3) floor!isSafe: aDigit   ^aDigit = (z extract: 4) floor!produce: anInteger   inverse q: 10 r: -10 * anInteger s: 0 t: 1.   ^inverse * z! !!Shootout.PiDigitSpigot class methodsFor: 'instance creation'!new   ^super new initialize! !!Shootout.NBodySystem methodsFor: 'nbody'!after: dt   1 to: bodies size do: [:i|      i+1 to: bodies size do: [:j|                                     (bodies at: i) and: (bodies at: j) velocityAfter: dt].   ].      bodies do: [:each| each positionAfter: dt]!energy   | e |   e := 0.0d.   1 to: bodies size do: [:i|             e := e + (bodies at: i) kineticEnergy.      i+1 to: bodies size do: [:j|          e := e - ((bodies at: i) potentialEnergy: (bodies at: j))].   ].   ^e! !!Shootout.NBodySystem methodsFor: 'initialize-release'!initialize   bodies := OrderedCollection new      add: Body sun; add: Body jupiter; add: Body saturn;      add: Body uranus; add: Body neptune; yourself.   bodies first offsetMomentum:      (bodies inject: (Array with: 0.0d with: 0.0d with: 0.0d)         into: [:m :each | each addMomentumTo: m])! !!Shootout.Transformation methodsFor: 'initialize-release'!initialize   q := 0.   r := 0.   s := 0.   t := 0.   k := 0.! !!Shootout.Transformation methodsFor: 'accessing'!* aTransformation   ^self species       q: q * aTransformation q      r: q * aTransformation r + (r * aTransformation t)      s: s * aTransformation q + (t * aTransformation s)      t: s * aTransformation r + (t * aTransformation t)!extract: anInteger   ^(q * anInteger + r) // (s * anInteger + t)!next   k := k +1.   q := k.   r := 4 * k + 2.   s := 0.   t := 2 * k + 1.!q   ^q!q: anInteger1 r: anInteger2 s: anInteger3 t: anInteger4   q := anInteger1.   r := anInteger2.   s := anInteger3.   t := anInteger4.   k := 0.!r   ^r!s   ^s!t   ^t! !!Shootout.Transformation class methodsFor: 'instance creation'!new   ^super new initialize!q: anInteger1 r: anInteger2 s: anInteger3 t: anInteger4   ^(super new) q: anInteger1 r: anInteger2 s: anInteger3 t: anInteger4!unity   ^self q: 1 r: 0 s: 0 t: 1! !!Shootout.RandomNumber methodsFor: 'accessing'!next	seed := (seed * Multiplier + Increment) \\ Modulus.	^(seed * scale) asDouble / FModulus! !!Shootout.RandomNumber methodsFor: 'private'!to: anInteger   seed := 42.   scale := anInteger! !!Shootout.RandomNumber class methodsFor: 'instance creation'!to: anInteger   ^self basicNew to: anInteger! !!Shootout.TreeNode methodsFor: 'initialize-release'!left: leftChild right: rightChild item: anItem   left := leftChild.   right := rightChild.   item := anItem! !!Shootout.TreeNode methodsFor: 'accessing'!itemCheck   ^left isNil       ifTrue: [item] ifFalse: [item + (left itemCheck - right itemCheck)]! !!Shootout.TreeNode class methodsFor: 'instance creation'!bottomUpTree: anItem depth: anInteger   ^(anInteger > 0)       ifTrue: [         self             left: (self bottomUpTree: 2*anItem - 1 depth: anInteger - 1)             right: (self bottomUpTree: 2*anItem depth: anInteger - 1)              item: anItem         ]      ifFalse: [self left: nil right: nil item: anItem] !left: leftChild right: rightChild item: anItem         ^(super new) left: leftChild right: rightChild item: anItem! !!Shootout.RepeatStream methodsFor: 'accessing'!next   position >= readLimit ifTrue: [ self position: 0 ].   repeatPtr := repeatPtr + 1.   ^collection at: (position := position + 1)! !!Shootout.RepeatStream methodsFor: 'testing'!atEnd	^repeatPtr >= repeatLimit! !!Shootout.RepeatStream methodsFor: 'initialize-release'!to: anInteger   repeatPtr := 0.   repeatLimit := anInteger! !!Shootout.RepeatStream class methodsFor: 'instance creation'!to: anInteger on: aCollection    ^(super on: aCollection) to: anInteger! !!Shootout.RandomStream methodsFor: 'accessing'!next   | r |   r := random next.   repeatPtr := repeatPtr + 1.   1 to: percentages size do: [:i|       (r < (percentages at: i)) ifTrue: [^collection at: i]]!random: aRandomNumber"Share the random number generator so we can get the expected results."   random := aRandomNumber! !!Shootout.RandomStream methodsFor: 'initialize-release'!on: aCollection   | size cp |   repeatPtr := 0.   random := RandomNumber to: 1.0.   size := aCollection size.   percentages := Array new: size.   collection := Array new: size.   cp := 0.0d.   1 to: size do: [:i|       collection at: i put: (aCollection at: i) key.      percentages at: i put: (cp := cp + (aCollection at: i) value).   ]! !!Shootout.Body methodsFor: 'accessing'!mass   ^mass!x   ^x!x: d1 y: d2 z: d3 vx: d4 vy: d5 vz: d6 mass: d7   x := d1.   y := d2.    z := d3.    vx := d4.   vy := d5.   vz := d6.   mass := d7!y   ^y!z   ^z! !!Shootout.Body methodsFor: 'nbody'!addMomentumTo: anArray   anArray at: 1 put: (anArray at: 1) + (vx * mass).   anArray at: 2 put: (anArray at: 2) + (vy * mass).   anArray at: 3 put: (anArray at: 3) + (vz * mass).   ^anArray!and: aBody velocityAfter: dt	        | dx dy dz distance mag |   dx := x - aBody x.   dy := y - aBody y.   dz := z - aBody z.      distance := ((dx*dx) + (dy*dy) + (dz*dz)) sqrt.   mag := dt / (distance * distance * distance).   self decreaseVelocity: dx y: dy z: dz m: aBody mass * mag.      aBody increaseVelocity: dx y: dy z: dz m: mass * mag!decreaseVelocity: dx y: dy z: dz m: m   vx := vx - (dx * m).   vy := vy - (dy * m).   vz := vz - (dz * m)!increaseVelocity: dx y: dy z: dz m: m   vx := vx + (dx * m).   vy := vy + (dy * m).   vz := vz + (dz * m)!kineticEnergy   ^0.5d * mass * ((vx * vx) + (vy * vy) + (vz * vz))!offsetMomentum: anArray    | m |   m := self class solarMass.   vx := (anArray at: 1) negated / m.   vy := (anArray at: 2) negated / m.   vz := (anArray at: 3) negated / m!positionAfter: dt   x := x + (dt * vx).   y := y + (dt * vy).   z := z + (dt * vz)!potentialEnergy: aBody   | dx dy dz distance |   dx := x - aBody x.   dy := y - aBody y.   dz := z - aBody z.   distance := ((dx*dx) + (dy*dy) + (dz*dz)) sqrt.   ^mass * aBody mass / distance! !!Shootout.Body class methodsFor: 'constants'!daysPerYear   ^365.24d!jupiter   ^self new      x: 4.84143144246472090d0      y: -1.16032004402742839d0      z: -1.03622044471123109d-1      vx: 1.66007664274403694d-3 * self daysPerYear      vy: 7.69901118419740425d-3 * self daysPerYear      vz: -6.90460016972063023d-5 * self daysPerYear      mass: 9.54791938424326609d-4 * self solarMass!neptune   ^self new      x: 1.53796971148509165d1      y: -2.59193146099879641d1      z: 1.79258772950371181d-1      vx: 2.68067772490389322d-3 * self daysPerYear      vy: 1.62824170038242295d-3 * self daysPerYear      vz: -9.51592254519715870d-5 * self daysPerYear      mass: 5.15138902046611451d-5 * self solarMass!pi   ^3.141592653589793d!saturn   ^self new      x: 8.34336671824457987d0      y: 4.12479856412430479d0      z: -4.03523417114321381d-1      vx: -2.76742510726862411d-3 * self daysPerYear      vy: 4.99852801234917238d-3 * self daysPerYear      vz: 2.30417297573763929d-5 * self daysPerYear      mass: 2.85885980666130812d-4 * self solarMass!solarMass   ^4.0d * self pi * self pi!sun   ^self new      x: 0.0d0      y: 0.0d0      z: 0.0d0      vx: 0.0d0      vy: 0.0d0      vz: 0.0d0      mass: self solarMass!uranus   ^self new      x: 1.28943695621391310d1      y: -1.51111514016986312d1      z: -2.23307578892655734d-1      vx: 2.96460137564761618d-3 * self daysPerYear      vy: 2.37847173959480950d-3 * self daysPerYear      vz: -2.96589568540237556d-5 * self daysPerYear      mass: 4.36624404335156298d-5 * self solarMass! !!Shootout.BitArray methodsFor: 'accessing'!at: index    | wordIndex bitMask |    wordIndex := ((index - 1) bitShift: -3) + 1.    bitMask := 1 bitShift: (index - 1 bitAnd: 7).    ^((self basicAt: wordIndex) bitAnd: bitMask) > 0!at: index put: bit    | wordIndex bitMask word |    wordIndex := ((index - 1) bitShift: -3) + 1.    bitMask := 1 bitShift: (index - 1 bitAnd: 7).    word := self basicAt: wordIndex.    word := word bitOr: bitMask.    bit ifFalse: [word := word - bitMask].    self basicAt: wordIndex put: word.    ^bit! !!Shootout.BitArray class methodsFor: 'instance creation'!new: size    ^super new: (size + 7 bitShift: -3)! !!Shootout.Chameleon methodsFor: 'initialize-release'!initialize    meetings := 0.    waitingForPair := Semaphore new.    semaphore := Semaphore new! !!Shootout.Chameleon methodsFor: 'accessing'!color    ^color!meetings    ^meetings!wait    semaphore wait! !!Shootout.Chameleon methodsFor: 'running'!fork: meetingPlace    ^[ self run: meetingPlace ] fork!run: meetingPlace    [ color == #faded ] whileFalse: [	meetingPlace reachedBy: self.	waitingForPair wait ]! !!Shootout.Chameleon methodsFor: 'changing colors'!color: c    color := c!fade    color := #faded.    waitingForPair signal.    semaphore signal!met: other    | newColor |    meetings := meetings + 1.    color == #red ifTrue: [	newColor := other == #yellow ifTrue: [ #blue ] ifFalse: [ #yellow ] ].    color == #yellow ifTrue: [	newColor := other == #red ifTrue: [ #blue ] ifFalse: [ #red ] ].    color == #blue ifTrue: [	newColor := other == #red ifTrue: [ #yellow ] ifFalse: [ #red ] ].    color := newColor.    waitingForPair signal! !!Shootout.Chameleon class methodsFor: 'initialize-release'!color: c    ^self new	initialize;	color: c! !!Shootout.Tests class methodsFor: 'benchmarking'!ackermann   | n |   n := CEnvironment argv first asNumber.   ^'Ack(3,', n printString, '): ', (3 ackermann: n) printString withNl!binarytrees   | minDepth n maxDepth stretchDepth check longLivedTree iterations |    minDepth := 4.   n := CEnvironment argv first asNumber.   maxDepth := minDepth + 2 max: n.   stretchDepth := maxDepth + 1.   check := (TreeNode bottomUpTree: 0 depth: stretchDepth) itemCheck.   OS.Stdout       nextPutAll: 'stretch tree of depth '; nextPutAll: stretchDepth printString; nextPut: Character tab;      nextPutAll: ' check: '; nextPutAll: check printString; cr.   longLivedTree := TreeNode bottomUpTree: 0 depth: maxDepth.   minDepth to: maxDepth by: 2 do: [:depth|      iterations := 1 bitShift: maxDepth - depth + minDepth.      check := 0.      1 to: iterations do: [:i|         check := check + (TreeNode bottomUpTree: i depth: depth) itemCheck.         check := check + (TreeNode bottomUpTree: -1*i depth: depth) itemCheck.      ].      OS.Stdout         nextPutAll:  (2*iterations) printString; nextPut: Character tab;          nextPutAll: ' trees of depth '; nextPutAll: depth printString; nextPut: Character tab;         nextPutAll: ' check: '; nextPutAll: check printString; cr.   ].   OS.Stdout      nextPutAll: 'long lived tree of depth '; nextPutAll: maxDepth printString; nextPut: Character tab;      nextPutAll: ' check: '; nextPutAll: longLivedTree itemCheck printString; cr.    ^''!chameneos   | c1 c2 c3 c4 mp |   c1 := Chameleon color: #blue.   c2 := Chameleon color: #red.   c3 := Chameleon color: #yellow.   c4 := Chameleon color: #blue.   mp := MeetingPlace forMeetings: CEnvironment argv first asNumber.   c1 fork: mp.   c2 fork: mp.   c3 fork: mp.   c4 fork: mp.   c1 wait.   c2 wait.   c3 wait.   c4 wait.   ^(c1 meetings + c2 meetings + c3 meetings + c4 meetings) printString withNl!fannkuch   | n |   n := CEnvironment argv first asNumber.   ^'Pfannkuchen(', n printString, ') = ',  n maxPfannkuchen printString withNl!fasta   | n stdout r |   n := CEnvironment argv first asNumber.   stdout := ExternalWriteStream on:       (ExternalConnection ioAccessor: (UnixDiskFileAccessor new handle: 1)).   stdout writeFasta: 'ONE Homo sapiens alu' sequence:   ( RepeatStream to: n*2 on:      'GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG',      'GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA',      'CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT',      'ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA',      'GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG',      'AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC',      'AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA' ).   r := RandomNumber to: 1. "Shared random sequence"   stdout writeFasta: 'TWO IUB ambiguity codes' sequence:   (( RandomStream to: n*3 on: (      OrderedCollection new         add: (Association key: $a value: 0.27d);         add: (Association key: $c value: 0.12d);         add: (Association key: $g value: 0.12d);         add: (Association key: $t value: 0.27d);         add: (Association key: $B value: 0.02d);         add: (Association key: $D value: 0.02d);         add: (Association key: $H value: 0.02d);         add: (Association key: $K value: 0.02d);         add: (Association key: $M value: 0.02d);         add: (Association key: $N value: 0.02d);         add: (Association key: $R value: 0.02d);         add: (Association key: $S value: 0.02d);         add: (Association key: $V value: 0.02d);         add: (Association key: $W value: 0.02d);         add: (Association key: $Y value: 0.02d);         yourself )) random: r).   stdout writeFasta: 'THREE Homo sapiens frequency' sequence:   (( RandomStream to: n*5 on: (      OrderedCollection new         add: (Association key: $a value: 0.3029549426680d);         add: (Association key: $c value: 0.1979883004921d);         add: (Association key: $g value: 0.1975473066391d);         add: (Association key: $t value: 0.3015094502008d);         yourself )) random: r).   stdout flush.   ^''!harmonic   | n partialSum |   n := CEnvironment argv first asNumber.   partialSum := 0.0d.   1 to: n do: [:i| partialSum := partialSum + (1.0d/i)].   ^((partialSum asFixedPoint: 9) printString copyWithout: $s) withNl!hello   ^'hello world' withNl!knucleotide   | stdin sequence writeFrequencies writeCount |   stdin := ExternalReadStream on:       (ExternalConnection ioAccessor: (UnixDiskFileAccessor new handle: 0)).   sequence := (stdin readFasta: 'THREE') value asUppercase.   writeFrequencies := [:k | | frequencies count |      frequencies := SortedCollection sortBlock: [:a :b|         (a value = b value) ifTrue: [b key < a key] ifFalse: [b value < a value]].      count := 0.0.      (sequence substringFrequencies: k)         associationsDo: [:each| frequencies add: each. count := count + each value].      frequencies do: [:each | | percentage |         percentage := (each value / count) * 100.0.         OS.Stdout nextPutAll: each key; nextPutAll: ' ';            nextPutAll: (percentage asStringWith: 3); cr.         ].   ].   writeCount := [:nucleotideFragment | | frequencies count |      frequencies := sequence substringFrequencies: nucleotideFragment size.      count := frequencies at: nucleotideFragment asSymbol ifAbsent: [0].      OS.Stdout nextPutAll: count printString; nextPut: Character tab;          nextPutAll: nucleotideFragment; cr   ].   writeFrequencies value: 1. OS.Stdout cr.   writeFrequencies value: 2. OS.Stdout cr.   writeCount value: 'GGT'.   writeCount value: 'GGTA'.   writeCount value: 'GGTATT'.   writeCount value: 'GGTATTTTAATT'.   writeCount value: 'GGTATTTTAATTTATAGT'.   ^''!knucleotide1   | stdin sequence writeFrequencies writeCount |   stdin := ExternalReadStream on:       (ExternalConnection ioAccessor: (UnixDiskFileAccessor new handle: 0)).   sequence := (stdin readFasta: 'THREE') value asUppercase.   writeFrequencies := [:k | | frequencies count |      frequencies := SortedCollection sortBlock: [:a :b|         (a value = b value) ifTrue: [b key < a key] ifFalse: [b value < a value]].      count := 0.0.      (sequence substringFrequencies: k)         associationsDo: [:each| frequencies add: each. count := count + each value].      frequencies do: [:each | | percentage |         percentage := (each value / count) * 100.0.         OS.Stdout nextPutAll: each key; nextPutAll: ' ';            nextPutAll: (percentage asStringWith: 3); cr.         ].   ].   writeCount := [:nucleotideFragment | | frequencies count |      frequencies := sequence substringFrequencies: nucleotideFragment size.      count := frequencies at: nucleotideFragment ifAbsent: [0].      OS.Stdout nextPutAll: count printString; nextPut: Character tab;          nextPutAll: nucleotideFragment; cr   ].   writeFrequencies value: 1. OS.Stdout cr.   writeFrequencies value: 2. OS.Stdout cr.   writeCount value: 'GGT'.   writeCount value: 'GGTA'.   writeCount value: 'GGTATT'.   writeCount value: 'GGTATTTTAATT'.   writeCount value: 'GGTATTTTAATTTATAGT'.   ^''!knucleotide2   | stdin sequence writeFrequencies writeCount |   stdin := ExternalReadStream on:       (ExternalConnection ioAccessor: (UnixDiskFileAccessor new handle: 0)).   sequence := (stdin readFasta: 'THREE') value asUppercase.   writeFrequencies := [:k | | frequencies count |      frequencies := SortedCollection sortBlock: [:a :b|         (a value = b value) ifTrue: [b key < a key] ifFalse: [b value < a value]].      count := 0.0.      (sequence substringFrequencies2: k)         associationsDo: [:each| frequencies add: each. count := count + each value].      frequencies do: [:each | | percentage |         percentage := (each value / count) * 100.0.         OS.Stdout nextPutAll: each key; nextPutAll: ' ';            nextPutAll: (percentage asStringWith: 3); cr.         ].   ].   writeCount := [:nucleotideFragment | | frequencies count |      frequencies := sequence substringFrequencies2: nucleotideFragment size.      count := frequencies at: nucleotideFragment asSymbol ifAbsent: [0].      OS.Stdout nextPutAll: count printString; nextPut: Character tab;          nextPutAll: nucleotideFragment; cr   ].   writeFrequencies value: 1. OS.Stdout cr.   writeFrequencies value: 2. OS.Stdout cr.   writeCount value: 'GGT'.   writeCount value: 'GGTA'.   writeCount value: 'GGTATT'.   writeCount value: 'GGTATTTTAATT'.   writeCount value: 'GGTATTTTAATTTATAGT'.   ^''!mandelbrot   | width height limit2 isOverLimit m bits bitnum s |   width := CEnvironment argv first asNumber.   height := width.   limit2 := 4.0d.   isOverLimit := False.   m := 50.   bits := 0.   bitnum := 0.   s := ExternalWriteStream on:       (ExternalConnection ioAccessor: (UnixDiskFileAccessor new handle: 1)).   s nextPutAll: 'P4'; cr; nextPutAll: width printString, ' ', height printString; cr.   s binary.   width := width asDouble. height := height  asDouble.   0.0d to: height - 1.0d  do: [:y|      0.0d to: width - 1.0d do: [:x| | zr zi cr ci i |         zr := 0.0d. zi := 0.0d.         cr := 2.0d * x / width - 1.5d.         ci := 2.0d * y / height - 1.0d.         i := 0.         [ | tr ti |            tr := (zr*zr) - (zi*zi) + cr.            ti := 2.0d * zr * zi + ci.            zr := tr.            zi := ti.            isOverLimit := (zr*zr) + (zi*zi) > limit2.            (isOverLimit not) and: [(i := i+1) < m]         ] whileTrue.         bits := bits bitShift: 1.         (isOverLimit not) ifTrue: [bits := bits + 1].         bitnum := bitnum + 1.         (x = (width - 1)) ifTrue: [            bits := bits bitShift: (8 - bitnum).            bitnum := 8.            ].         (bitnum = 8) ifTrue: [            s nextPut: bits.            bits := 0. bitnum := 0.            ].         ].      ].   s flush.   ^''!message   | n tail head sum |   n := CEnvironment argv first asNumber.   head := tail := Consumer new.   500 timesRepeat: [       head := ProducerConsumer fork: head ].   sum := 0.   n timesRepeat: [       head msg: 0.       sum := sum + tail msg ].   ^sum printString withNl!nbody   | n bodies |   n := CEnvironment argv first asNumber.   bodies := NBodySystem new initialize.   OS.Stdout nextPutAll: (bodies energy asStringWith: 9); cr.   n timesRepeat: [bodies after: 0.01d].   OS.Stdout nextPutAll: (bodies energy asStringWith: 9); cr.   ^''!nsieve   | n |   n := CEnvironment argv first asNumber.   (n < 2) ifTrue: [n := 2].    n      primes.   (n - 1) primes.   (n - 2) primes.   ^''!nsievebits   | n |   n := CEnvironment argv first asNumber.   (n < 2) ifTrue: [n := 2].    n      primesBits.   (n - 1) primesBits.   (n - 2) primesBits.   ^''!partialsums   | n a1 a2 a3 a4 a5 a6 a7 a8 a9 twothirds alt |   n := CEnvironment argv first asNumber asDouble.   a1 := 0.0d. a2 := 0.0d. a3 := 0.0d. a4 := 0.0d. a5 := 0.0d.   a6 := 0.0d. a7 := 0.0d. a8 := 0.0d. a9 := 0.0d.   twothirds := 2.0d/3.0d.   alt := -1.0d.   1.0d to: n do: [:k| | k2 k3 sk ck |      k2 := k*k.      k3 := k2*k.      sk := k sin.      ck := k cos.      alt := -1.0d * alt.      a1 := a1 + (twothirds raisedTo: k - 1.0d).      a2 := a2 + (k raisedTo: -0.5d).      a3 := a3 + (1.0d/(k*(k+1.0d))).      a4 := a4 + (1.0d/(k3*sk*sk)).      a5 := a5 + (1.0d/(k3*ck*ck)).      a6 := a6 + (1.0d/k).      a7 := a7 + (1.0d/k2).      a8 := a8 + (alt/k).      a9 := a9 + (alt/(2.0d*k - 1.0d)).   ].   a1 printWithName: '(2/3)^k'.   a2 printWithName: 'k^-0.5'.   a3 printWithName: '1/k(k+1)'.   a4 printWithName: 'Flint Hills'.   a5 printWithName: 'Cookson Hills'.   a6 printWithName: 'Harmonic'.   a7 printWithName: 'Riemann Zeta'.   a8 printWithName: 'Alternating Harmonic'.   a9 printWithName: 'Gregory'.   ^''!pidigits   | i length n pidigits stream |   n := CEnvironment argv first asNumber.   i := 0.   length := 10.   pidigits := PiDigitSpigot new.   stream := ReadWriteStream on: (String new: 30).   [n > 0] whileTrue: [      (n < length)           ifTrue: [            n timesRepeat: [               stream nextPut: (Character digitValue: pidigits next)               ].            n to: length do: [:each| stream space].             i := i + n.            ]          ifFalse: [            length timesRepeat: [               stream nextPut: (Character digitValue: pidigits next)               ].            i := i + length.            ].     stream tab nextPut: $:.      i printOn: stream.       stream cr.      OS.Stdout nextPutAll: stream contents.      stream reset.      n := n - length.   ].   ^''!random   | n random answer |   n := CEnvironment argv first asNumber.   random := RandomNumber to: 100.   n timesRepeat: [answer := random next].   ^(answer asStringWith: 9) withNl!recursive   | n |   n := CEnvironment argv first asNumber.   OS.Stdout       nextPutAll: 'Ack(3,', n printString, '): ', (3 ack: n) printString; cr;      nextPutAll: 'Fib(', ((27.0d+n) asStringWith: 1), '): ', ((27.0d+n) fib asStringWith: 1); cr.   n := n - 1.   OS.Stdout       nextPutAll: 'Tak(', (3*n) printString, ',', (2*n) printString, ',', n printString, '): ',  (3*n tak: 2*n z: n) printString; cr;      nextPutAll: 'Fib(3): ', 3 fib printString; cr;      nextPutAll: 'Tak(3.0,2.0,1.0): ',  ((3.0d tak: 2.0d z: 1.0d) asStringWith: 1); cr.   ^''!revcomp   | stdin stdout fasta |   stdin := ExternalReadStream on:       (ExternalConnection ioAccessor: (UnixDiskFileAccessor new handle: 0)).   stdout := ExternalWriteStream on:       (ExternalConnection ioAccessor: (UnixDiskFileAccessor new handle: 1)).   fasta := stdin readFasta: 'ONE'.   stdout writeReverseComplementFasta: fasta key sequence: fasta value.   fasta := stdin readFasta: 'TWO'.   stdout writeReverseComplementFasta: fasta key sequence: fasta value.   fasta := stdin readFasta: 'THREE'.   stdout writeReverseComplementFasta: fasta key sequence: fasta value.   stdout flush.    ^''!spectralnorm   | n u v vBv vv |   n := CEnvironment argv first asNumber.   u := Array new: n withAll: 1.0d.   v := Array new: n withAll: 0.0d.   10 timesRepeat: [      v := u multiplyAtAv.      u := v multiplyAtAv.   ].   vBv := 0.0d.   vv := 0.0d.   1 to: n do: [:i|       vBv := vBv + ((u at: i) * (v at: i)).      vv := vv + ((v at: i) * (v at: i)).   ].      ^((vBv/vv) sqrt asStringWith: 9) withNl!sumcol   | stdin sum |   stdin := ExternalReadStream on:       (ExternalConnection ioAccessor: (UnixDiskFileAccessor new handle: 0)).   sum := 0.   [stdin atEnd] whileFalse: [      sum := sum + (stdin upTo: Character cr) asNumber].   ^sum printString withNl!takfp   | n |   n := CEnvironment argv first asNumber.   ^(((n * 3.0) takfp: (n * 2.0) z: (n * 1.0)) asStringWith: 1) withNl! !!Shootout.Consumer methodsFor: 'process'!msg    semaphore wait.    ^msg!msg: data    msg := data.    semaphore signal!semaphore: aSemaphore    semaphore := aSemaphore! !!Shootout.Consumer class methodsFor: 'process'!new    | var |    var := self basicNew.    var semaphore: Semaphore new.    ^var! !!Shootout.ProducerConsumer methodsFor: 'process'!consumer: aProcess    consumer := aProcess!fork    [ self run ] fork!run    [ consumer msg: self msg + 1 ] repeat! !!Shootout.ProducerConsumer class methodsFor: 'process'!fork: consumer    | proc |    proc := self new.    proc consumer: consumer.    proc fork.    ^proc! !!Shootout.PermGenerator methodsFor: 'initialize-release'!initialize: size    perm := (1 to: size) asArray.    timesRotated := Array new: size withAll: 0.    atEnd := false!makeNext    | temp remainder |    "Generate the next permutation."    2 to: perm size do: [ :r |	"Rotate the first r items to the left."        temp := perm at: 1.        1 to: r - 1 do: [ :i | perm at: i put: (perm at: i + 1) ].        perm at: r put: temp.        remainder := timesRotated at: r put: ((timesRotated at: r) + 1) \\ r.        remainder = 0 ifFalse: [ ^self ].	"After r rotations, the first r items are in their original positions.	 Go on rotating the first r+1 items."    ].    "We are past the final permutation."    atEnd := true! !!Shootout.PermGenerator methodsFor: 'accessing'!atEnd    ^atEnd!next    | result |    result := perm copy.    self makeNext.    ^result! !!Shootout.PermGenerator class methodsFor: 'instance creation'!new: size    ^self new	initialize: size;	yourself! !!Shootout.MeetingPlace methodsFor: 'initialize-release'!initialize    mutex := Semaphore forMutualExclusion.    total := 0! !!Shootout.MeetingPlace methodsFor: 'running'!max: maxMeetings    max := maxMeetings!organizeMeetingWith: second    total >= max	ifTrue: [	    first fade.	    second fade ]	ifFalse: [	    first met: second color.	    second met: first color ].    total := total + 1!reachedBy: chameleon    mutex critical: [	first isNil	    ifTrue: [ first := chameleon ]	    ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ]! !!Shootout.MeetingPlace class methodsFor: 'instance creation'!forMeetings: maxMeetings    ^super new	initialize;	max: maxMeetings;	yourself! !!OS.ExternalReadStream methodsFor: 'accessing'!readFasta: anId    | idString newline buffer description line char |   idString := '>',anId.   newline := Character cr.   "find start of particular fasta sequence"   [(self atEnd) or: [         (self peek = $>)             ifTrue: [((line := self upTo: newline)                indexOfSubCollection: idString startingAt: 1) = 1]            ifFalse: [self skipThrough: newline. false]]      ] whileFalse.   "line-by-line read - it would be a lot faster to block read"   description := line.   buffer := ReadWriteStream on: (String new: 1028).   [(self atEnd) or: [(char := self peek) = $>]] whileFalse: [      (char = $;)          ifTrue: [self upTo: newline]          ifFalse: [buffer nextPutAll: (self upTo: newline)]      ].   ^Association key: description value: buffer contents! !!Core.SmallInteger methodsFor: 'computer language shootout'!matrixA: anInteger"fixup one-based indexing to zero-based indexing - cleanup later"   | i j |   i := self - 1.    j := anInteger - 1.   ^1.0d / (i + j * (i + j + 1) /2  + i + 1) asDouble! !!Core.Double methodsFor: 'computer language shootout'!tak: y z: z   ^y < self       ifTrue: [((self - 1.0d) tak: y z: z) tak: ((y - 1.0d) tak: z z: self) z: ((z - 1.0d) tak: self z: y)]      ifFalse: [z]! !!Core.String methodsFor: 'computer language shootout'!inject2: aDictionary intoSubstringFrequencies: aLength offset: anInteger   anInteger to: self size - aLength + 1 by: aLength do: [:i |      | fragment value |      fragment := (self copyFrom: i to: i + aLength - 1) asSymbol.      value := aDictionary at: fragment ifAbsent: [ aDictionary at: fragment put: 0 ].      aDictionary at: fragment put: value + 1    ]! !!Core.SmallInteger methodsFor: 'computer language shootout'!fib   ^self < 2 ifTrue: [1] ifFalse: [(self - 2) fib + (self - 1) fib]! !!Core.String methodsFor: 'converting'!withNl   ^self,  String withNl! !!OS.ExternalWriteStream methodsFor: 'accessing'!writeReverseComplementFasta: aString sequence: aSequence   | lineLength n iub |   (aString isNil) ifTrue: [^self].   lineLength := 60. n := aSequence size.   iub := String new: 128 withAll: $*.   iub at: $a asInteger put: $T. iub at: $A asInteger put: $T.   iub at: $b asInteger put: $V. iub at: $B asInteger put: $V.   iub at: $c asInteger put: $G. iub at: $C asInteger put: $G.   iub at: $d asInteger put: $H. iub at: $D asInteger put: $H.   iub at: $g asInteger put: $C. iub at: $G asInteger put: $C.   iub at: $h asInteger put: $D. iub at: $H asInteger put: $D.   iub at: $k asInteger put: $M. iub at: $K asInteger put: $M.   iub at: $m asInteger put: $K. iub at: $M asInteger put: $K.   iub at: $n asInteger put: $N. iub at: $N asInteger put: $N.   iub at: $r asInteger put: $Y. iub at: $R asInteger put: $Y.   iub at: $s asInteger put: $S. iub at: $S asInteger put: $S.   iub at: $t asInteger put: $A. iub at: $T asInteger put: $A.   iub at: $v asInteger put: $B. iub at: $V asInteger put: $B.   iub at: $w asInteger put: $W. iub at: $W asInteger put: $W.   iub at: $y asInteger put: $R. iub at: $Y asInteger put: $R.   self nextPutAll: aString; cr.   [n > 0] whileTrue: [          1 to: ((n < lineLength) ifTrue: [n] ifFalse: [lineLength]) do:            [:i | self nextPut: (iub at: (aSequence at: n - i + 1) asInteger)].         self cr.         n := n - lineLength.       ]! !!Core.Array methodsFor: 'computer language shootout'!pfannkuchen    | first complement a b k |    k := 0.    [ (first := self at: 1) == 1 ] whileFalse: [	k := k + 1.	complement := first + 1.	1 to: first // 2 do: [ :i |	    a := self at: i.	    b := self at: complement - i.	    self at: i put: b.	    self at: complement - i put: a.	]    ].    ^k! !!Core.LimitedPrecisionReal methodsFor: 'printing'!printWithName: aString   OS.Stdout  nextPutAll: (self asStringWith: 9); nextPut: Character tab; nextPutAll: aString; cr.! !!Core.Double methodsFor: 'computer language shootout'!fib   ^self < 2.0d ifTrue: [1.0d] ifFalse: [(self - 2.0d) fib + (self - 1.0d) fib]! !!Core.SmallInteger methodsFor: 'computer language shootout'!ackermann: anInteger   ^self = 0      ifTrue: [anInteger + 1]      ifFalse: [         anInteger = 0            ifTrue: [self - 1 ackermann:  1]            ifFalse: [self - 1 ackermann: (self ackermann: anInteger - 1)] ]! !!OS.ExternalWriteStream methodsFor: 'accessing'!writeFasta: aString sequence: aStream   | i |   self nextPut: $>; nextPutAll: aString; cr.   i := 0.   [aStream atEnd] whileFalse: [      (i == 60) ifTrue: [self cr. i := 0].      self nextPut: aStream next.      i := i + 1.      ].   self cr! !!Core.SmallInteger methodsFor: 'computer language shootout'!primesBits   | m |   m := (2 raisedTo: self) * 10000.   OS.Stdout      nextPutAll: 'Primes up to '; nextPutAll: (m asPaddedString: 8);      nextPutAll: ((m nsieveBits) asPaddedString: 9); cr! !!Core.String methodsFor: 'computer language shootout'!substringFrequencies: aLength   | answer |   answer := IdentityDictionary new.   1 to: aLength do: [:i |      self inject: answer intoSubstringFrequencies: aLength offset: i].   ^answer! !!Core.SmallInteger methodsFor: 'computer language shootout'!asPaddedString: aWidth   | s |   s := WriteStream on: (String new: 10).   self printOn: s paddedWith: $  to: aWidth base: 10.   ^s contents! !!OS.CEnvironment class methodsFor: 'class accessing'!argv   | answer isArg |   isArg := false.   answer := OrderedCollection new.   CEnvironment commandLine       do: [:each|         isArg            ifTrue: [               (each first isAlphaNumeric)                   ifTrue: [answer add: each]                  ifFalse: [isArg := false]                   ]            ifFalse: [isArg := each = '-a']      ].   ^answer! !!Core.String methodsFor: 'computer language shootout'!inject: aDictionary intoSubstringFrequencies: aLength offset: anInteger   anInteger to: self size - aLength + 1 by: aLength do: [:i |      | fragment value |      fragment := (self copyFrom: i to: i + aLength - 1) asSymbol.      value := aDictionary at: fragment ifAbsent: [ aDictionary at: fragment put: 0 ].      aDictionary at: fragment put: value + 1    ]! !!Core.SmallInteger methodsFor: 'computer language shootout'!primes   | m |   m := (2 raisedTo: self) * 10000.   OS.Stdout      nextPutAll: 'Primes up to '; nextPutAll: (m asPaddedString: 8);      nextPutAll: ((m nsieve) asPaddedString: 9); cr! !!Core.LimitedPrecisionReal methodsFor: 'converting'!asStringWith: anInteger   ^(self asFixedPoint: anInteger) printString copyWithout: $s! !!Core.String methodsFor: 'computer language shootout'!substringFrequencies1: aLength   | answer |   answer := Dictionary new.   1 to: aLength do: [:i |      self inject1: answer intoSubstringFrequencies: aLength offset: i].   ^answer! !!Core.String class methodsFor: 'instance creation'!withNl   ^super with: Character lf! !!Core.SmallInteger methodsFor: 'computer language shootout'!nsieve    | count isPrime |   count := 0.   isPrime := Array new: self withAll: true.   2 to: self do: [:i|      (isPrime at: i) ifTrue: [         i+i to: self by: i do: [:k| isPrime at: k put: false].         count := count + 1.         ].      ].   ^count! !!Core.Float methodsFor: 'computer language shootout'!takfp: aFloatY z: aFloatZ   ^aFloatY < self       ifTrue: [          ((self - 1.0) takfp: aFloatY z: aFloatZ)                  takfp: ((aFloatY - 1.0) takfp: aFloatZ z: self)             z: ((aFloatZ - 1.0) takfp: self z: aFloatY)         ]      ifFalse: [aFloatZ]! !!Core.Array methodsFor: 'computer language shootout'!multiplyAtv   | n atv |   n := self size.   atv := Array new: n withAll: 0.0d.   1 to: n do: [:i| 	      1 to: n do: [:j|         atv at: i put: (atv at: i) + ((j matrixA: i) * (self at: j)) ]].   ^atv! !!Core.SmallInteger methodsFor: 'computer language shootout'!maxPfannkuchen    | max gen perm check |    max := 0.    check := 0.    gen := Shootout.PermGenerator new: self.    [ gen atEnd ] whileFalse: [	perm := gen next.        check < 30 ifTrue: [	    perm do: [ :each | OS.Stdout nextPutAll: each printString ]. 	    OS.Stdout cr.	    check := check + 1 ].	max := max max: perm pfannkuchen    ].    ^max! !!Core.String methodsFor: 'computer language shootout'!inject1: aDictionary intoSubstringFrequencies: aLength offset: anInteger   anInteger to: self size - aLength + 1 by: aLength do: [:i |      | fragment assoc |      fragment := self copyFrom: i to: i + aLength - 1.      (assoc := aDictionary associationAt: fragment ifAbsent: []) isNil         ifTrue: [aDictionary at: fragment put: 1]         ifFalse: [assoc value: (assoc value + 1)] ]! !!Core.SmallInteger methodsFor: 'computer language shootout'!ack: aSmallInteger   ^self == 0      ifTrue: [aSmallInteger + 1]      ifFalse: [         aSmallInteger == 0            ifTrue: [self - 1 ack:  1]            ifFalse: [self - 1 ack: (self ack: aSmallInteger - 1)] ]! !!Core.String methodsFor: 'computer language shootout'!substringFrequencies2: aLength   | answer |   answer := IdentityDictionary new.   1 to: aLength do: [:i |      self inject2: answer intoSubstringFrequencies: aLength offset: i].   ^answer! !!Core.Array methodsFor: 'computer language shootout'!multiplyAv   | n av |   n := self size.   av := Array new: n withAll: 0.0d.   1 to: n do: [:i| 	      1 to: n do: [:j|         av at: i put: (av at: i) + ((i matrixA: j) * (self at: j)) ]].   ^av! !!Core.SmallInteger methodsFor: 'computer language shootout'!tak: y z: z   ^y < self       ifTrue: [((self - 1) tak: y z: z) tak: ((y - 1) tak: z z: self) z: ((z - 1) tak: self z: y)]      ifFalse: [z]!nsieveBits    | count isComposite |    self < 2 ifTrue: [ ^0 ].    isComposite := Shootout.BitArray new: self.    count := 0.    2 to: self do: [ :i |	(isComposite at: i) ifFalse: [	    count := count + 1.	    i + i to: self by: i do: [ :k |		isComposite at: k put: true ] ].    ].    ^count! !!Core.Array methodsFor: 'computer language shootout'!multiplyAtAv   ^(self multiplyAv) multiplyAtv! !"Imported Classes:"!self error: 'Attempting to file-in parcel imports.  Choose terminate or close'!Smalltalk.Core defineClass: #Object	superclass: nil	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Kernel-Objects'!Smalltalk.OS defineClass: #ExternalReadStream	superclass: #{OS.BufferedExternalStream}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: '			private OS.IOConstants.*			'	category: 'OS-Streaming'!Smalltalk.Core defineClass: #ReadStream	superclass: #{Core.InternalStream}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Collections-Streams'!Smalltalk.OS defineClass: #ExternalWriteStream	superclass: #{OS.BufferedExternalStream}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: '			private OS.IOConstants.*			'	category: 'OS-Streaming'!Smalltalk.Core defineClass: #Array	superclass: #{Core.ArrayedCollection}	indexedType: #objects	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Collections-Arrayed'!Smalltalk.Core defineClass: #SmallInteger	superclass: #{Core.Integer}	indexedType: #immediate	private: false	instanceVariableNames: ''	classInstanceVariableNames: 'minVal maxVal maxBits maxBytes '	imports: ''	category: 'Magnitude-Numbers'!Smalltalk.Core defineClass: #String	superclass: #{Core.CharacterArray}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Collections-Text'!Core.String class	instanceVariableNames: ''!OS.CEnvironment class	instanceVariableNames: ''!Smalltalk.Core defineClass: #LimitedPrecisionReal	superclass: #{Core.Number}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Magnitude-Numbers'!Smalltalk.Core defineClass: #Float	superclass: #{Core.LimitedPrecisionReal}	indexedType: #bytes	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Magnitude-Numbers'!Smalltalk.Core defineClass: #Double	superclass: #{Core.LimitedPrecisionReal}	indexedType: #bytes	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Magnitude-Numbers'!