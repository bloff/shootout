<!--#set var="TITLE" value="Array Access" -->
<!--#set var="KEYWORDS" value="performance, benchmark, 
computer, language, compare, cpu, memory, array access" --> 
<!--#include virtual="../../html/header.shtml" -->
<!--#include virtual="../../html/nav.shtml" -->

<table width="70%"><tr>
<td>
  <!--#if expr="$QUERY_STRING = mem" -->
    <!--#include virtual="data/all_mem.html" -->
  <!--#elif expr="$QUERY_STRING = loc" -->
    <!--#include virtual="data/all_loc.html" -->
  <!--#else -->
    <!--#include virtual="data/all.html" -->
  <!--#endif -->
</td>
<td>
  <img src="data/max.png">
  <!--#include virtual="../../html/graph_note.shtml" -->
  <p><small>[Results last updated: <!--#include virtual=".up_date" --> CDT]</small>
</td>
</tr></table>
<p>

<hr noshade size="5">

<h4>About this test</h4>
<p>
  <b>This test has been obsoleted.  Please see the <a
  href="../ary3/">new Array Test</a>.</b>
<p>
  For this test, each program should be implemented in the <a
  href="../../method.shtml#sameway"><i>same way</i></a>.
<p>
  This test is basically the same as the array test from <a
  href="http://cm.bell-labs.com/cm/cs/who/bwk/interps/pap.html">
  Timing Trials, or, the Trials of Timing: Experiments with Scripting
  and User-Interface Languages</a> by Brian W. Kernighan and
  Christopher J. Van Wyk.
<p>
  This test is supposed to just test array access via subscripting.  Note
  that as specified in the original Kernighan and Wyk test, the second loop
  counts down from the end of the array to the beginning.  I consider this
  an attempt to ensure that we are using a random-access data structure, as
  an <i>array</i> should be, and not just any sequence data structure, as
  such as a <i>list</i>.
<p>
  In this test, we are doing array operations inside a tight loop,
  so the logical question is whether the loop overhead has a
  significant effect on performance.  We try to answer this question
  in the <a href="../ary2/">Array Access II</a> test, where we unroll
  the loops.
<p>
  The correct output (for N = 200000) looks like this:
<pre>
  <!--#include virtual="Output" -->
</pre>


<h4>Observations</h4>
<p>
  The <a href="ary.python">python</a> script is written using the
  xrange() function, while the <a
  href="ary.python2.python">python2</a> uses range().  This test
  illustrates the different performance characteristics of these two
  functions when using them to drive a for-loop where the number of
  iterations is large.  For smaller ranges, range() is usually a bit
  faster, but it uses more memory than xrange(), because range()
  actually creates an array over which the for-loop iterates.
  (xrange() constructs the list, but lazily to save space).

<h4><a href="alt/">Alternates</a></h4>
<p>
  <i>This section is for displaying alternate solutions that are either
  slower than ones above or perhaps don't quite meet my criteria for
  the competition, but are otherwise worthy of comment.</i>
<ul>
<li>
  Here are a couple of alternate Haskell programs from <a
  href="alt/ary.ghc2.ghc">Brian Gregor</a> and <a
  href="alt/ary.ghc3.ghc">Julian Assange</a> that are perhaps written more
  clearly, but I found them to be fractionally slower than the current
  Haskell submission from Brian.
</ul>

<!--#include virtual="../../html/nav.shtml" -->
<!--#include virtual="../../html/footer.shtml" -->
