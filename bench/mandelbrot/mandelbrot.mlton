(*
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * contributed by Christophe TROESTLER
 * Enhanced by Christian Szegedy <szegedy@t-online.de>
 * Ported to MLton/SML by sweeks@sweeks.com.
 *)

val niter = 50
val limit = 2.0
val limit2 = limit * limit

fun addBit0 (ci, cr, byte) =
   let
      val byte = Word8.<< (byte, 0w1)
      fun loop (i, zr, zr2, zi, zi2) =
	 let
	    val zi' = 2.0 * zr * zi + ci
	    val zr = zr2 - zi2 + cr
	    val zi = zi'
	    val zr2 = zr * zr
	    val zi2 = zi * zi
	 in
	    if zr2 + zi2 > limit2
	       then Word8.orb (byte, 0w0)
	    else if i = niter - 1
	       then Word8.orb (byte, 0w1)
	    else loop (i + 1, zr, zr2, zi, zi2)
	 end
   in
      loop (0, 0.0, 0.0, 0.0, 0.0)
   end

val w = valOf (Int.fromString (hd (CommandLine.arguments ())))
val h = w
val fw = real w
val fh = real h

fun outputByte b = TextIO.output1 (TextIO.stdOut, Byte.byteToChar b)

val () = print (concat ["P4\n", Int.toString w, " ", Int.toString h, "\n"])

val cplmt8 = Word.fromInt (8 - w mod 8)

val _ =
   Int.fold
   (0, h, (0, 0w0), fn (y, ac) =>
    let
       val ci = 2.0 * real y / fh - 1.0
       val (bit, byte) =
	  Int.fold
	  (0, w, ac, fn (x, (bit, byte)) =>
	   let
	      val cr = 2.0 * real x / fw - 1.5
	      val byte = addBit0 (ci, cr, byte)
	      val bit = bit + 1
	   in
	      if 8 = bit then (outputByte byte; (0, 0w0))
	      else (bit, byte)
	   end)
    in
       if 0 = bit
	  then (bit, byte)
       else
	  let
	     val () = outputByte (Word8.<< (byte, cplmt8));
	  in
	     (0, 0w0)
	  end
    end)
