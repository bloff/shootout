// The Great Computer Language Shootout
// http://shootout.alioth.debian.org/
// 
// contributed by Diederik van Arkel

module mandelbrot

import StdEnv, LanguageShootout

Start world
	# (console, world)	= stdio world
	# width				= argi
	# console			= console <<< "P4\n" <<< width <<< " " <<< width <<< "\n"
	# chunks			= fractal (points width width)
	# pbm				= map makePBM chunks
	# console			= seq (map fwrites pbm) console
	# (ok,world)		= fclose console world
	= world

mandel_iter :: Int
mandel_iter   = 50

points :: Int Int -> [{!Complex Real}]
points width height
	= [{(2.0*x/w - 1.5, 2.0*y/h - 1.0) \\ x <- [0.0..w-1.0]} \\ y <- [0.0..h-1.0]]
where
	w	= toReal width
	h	= toReal height
	
fractal :: [{!Complex Real}] -> [{#Int}]
fractal []
	= []
fractal [p:ps]
	= [{fractal` (0.0 , 0.0) mandel_iter c \\ c <-: p} : fractal ps]

fractal` :: !(Complex Real) !Int !(Complex Real) -> Int
fractal` z iter c
	| (((r*r) + (i*i)) > limit)	= 0
	| iter == 1			= 1
	| otherwise			= fractal` z` (iter-1) c
where
	(r,i)	= z*z+c
	z`		= (r,i)
	limit	= 4.0

toArray l = {c \\ c <- l}

makePBM :: {#Int} -> .{#Char}
makePBM a
	# x	= a.[0]
	= toArray (makePBM 1 x a)
where
	m = size a

	makePBM :: !Int !Int !{#Int} -> [Char]
	makePBM i acc a
		| i >= m
			= []
		# x	= a.[i]
		# acc = (acc*2+x)
		# i	= i + 1
		| i rem 8 == 0
			= [toChar acc : makePBM i 0 a]
		| i == m
			= [(toChar (acc << (8 - m rem 8)))]
		= makePBM i acc a

// Complex

:: Complex a :== (!a,!a)

instance + (Complex a) | + a
where
	(+) (rl,il) (rr,ir)
		= (rl+rr,il+ir)

instance * (Complex a) | *,+,- a
where
	(*) (rl,il) (rr,ir)
		= (rl*rr - il*ir, rl*ir + rr*il)
