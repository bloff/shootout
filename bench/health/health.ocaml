(* health.ml
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Troestler Christophe
 *)

type patient = {
  mutable remaining_time : int;
  mutable hospital_time : int;
  mutable hospital_visits : int; }

type totals = int * int * int (* patients, hospital time, hospital visits *)

let add_patient (n, t, v) p =
  (n + 1, t + p.hospital_time, v + p.hospital_visits)

let ( ++ ) (n0, t0, v0) (n1, t1, v1) = (n0 + n1, t0 + t1, v0 + v1)

(* Mutable doubly linked lists.  This is not included in the standard
   OCaml library but is available through third party libraries. *)
(* module type Msig =
sig
  type 'a t
  val empty : unit -> 'a t
  val add : 'a -> 'a t -> unit
  val remove : 'a t -> unit
  val fold : ('a -> 'b -> 'a) -> 'a -> 'b t -> 'a
end *)
(* module M =
struct
  type 'a t = 'a list ref
  and 'a list = 'a node option
  and 'a node = { mutable prev : 'a list; mutable next : 'a list; data : 'a }

  let empty() = ref None

  let add e l = match !l with
    | None -> l := Some { prev = None; next = None; data = e }
    | Some n0 as l0 -> match n0.next with
      | None -> n0.next <- Some { prev = l0; next = None; data = e }
      | Some n1 as l1 ->
	  let n' = Some { prev = l0; next = l1; data = e } in
	  n0.next <- n'; n1.prev <- n'

  (* Remove the current element.  It is possible to remove the current
     element during [iter] and [fold]. *)
  let remove l = match !l with
    | None -> ()
    | Some n ->
	match n.prev, n.next with
	| None, None -> l := None
	| Some n0, None -> n0.next <- None
	| None, Some n1 -> n1.prev <- None
	| (Some n0 as l0), (Some n1 as l1) -> n0.next <- l1; n1.prev <- l0

  let rec fold_right f acc = function None -> acc
    | Some n -> fold_right f (f acc n.data) n.next
  let rec fold_left f acc = function None -> acc
    | Some n -> fold_left f (f acc n.data) n.prev
  let fold f acc l = fold_left f (fold_right f acc !l) !l
end *)


module Hospital =
struct
  type t = {
    mutable triage : patient list;
    mutable examination : patient list;
    mutable treatement : patient list;
    mutable discharged : totals;

    mutable available_staff : int;
    mutable seed : int;
    has_no_regional_hospital : bool; (* i.e. "top" one *)
    mutable transfers : patient list;
  }

  (* Shootout random generator, but with hospital seed *)
  let im = 139968 and ia = 3877 and ic = 29573
  let inv_im = 1. /. float im

  let random h max =
    h.seed <- (h.seed * ia + ic) mod im;
    max *. float h.seed *. inv_im

  let make has_no_regional_hospital level seed =
    { triage = [];  examination = [];  treatement = []; discharged = (0,0,0);
      available_staff = 1 lsl (level - 1);
      seed = seed;  has_no_regional_hospital = has_no_regional_hospital;
      transfers = []; }

  let totals h =
    let tot = List.fold_left add_patient (0,0,0) h.triage in
    let tot = List.fold_left add_patient tot h.examination in
    let tot = List.fold_left add_patient tot h.treatement in
    tot ++ h.discharged

  let new_arrival h p =
    p.hospital_visits <- p.hospital_visits + 1;
    if h.available_staff > 0 then (
      h.available_staff <- h.available_staff - 1;
      h.examination <- p :: h.examination;
      p.remaining_time <- 3;
      p.hospital_time <- p.hospital_time + 3;
    )
    else h.triage <- p :: h.triage

  let discharge_patients h =
    let treat p =
      p.remaining_time <- p.remaining_time - 1;
      if p.remaining_time > 0 then true else (
	h.available_staff <- h.available_staff + 1;
	h.discharged <- add_patient h.discharged p;
	false
      ) in
    h.treatement <- List.filter treat h.treatement

  let treat_or_transfer_patients h =
    let examine p =
      p.remaining_time <- p.remaining_time - 1;
      if p.remaining_time > 0 then true else (
	if random h 1.0 > 0.1 || h.has_no_regional_hospital then (
	  (* No transfer *)
	  h.treatement <- p :: h.treatement;
	  p.remaining_time <- 10;
	  p.hospital_time <- p.hospital_time + 10;
	)
	else (
	  (* Transfer *)
	  h.available_staff <- h.available_staff + 1;
	  h.transfers <- p :: h.transfers;
	);
	false
      ) in
    h.examination <- List.filter examine h.examination

  let triage_patients h =
    let triage p =
      if h.available_staff > 0 then (
	h.available_staff <- h.available_staff - 1;
	p.remaining_time <- 3;
	p.hospital_time <- p.hospital_time + 3;
	h.examination <- p :: h.examination;
	false
      )
      else (
	p.hospital_time <- p.hospital_time + 1;  true
      ) in
    h.triage <- List.filter triage h.triage

  let triage_examination_treatment h =
    discharge_patients h;
    treat_or_transfer_patients h;
    triage_patients h;
    if random h 1.0 > 0.7 then new_arrival h {
      remaining_time = 0; hospital_time = 0; hospital_visits = 0 }
end


(* Hierarchical health care: a region consisting of a hospital and
   (possibly) some districts. *)
type health_care = Region of Hospital.t * (health_care array)

let levels = 5
let districts = 4

let rec create_health_care level seed1 seed2 =
  let hospital = Hospital.make (level = levels) level (seed1 * seed2) in
  let create i = create_health_care (level - 1) (4 * seed1 + i + 1) seed2 in
  Region(hospital, Array.init (if level <= 1 then 0 else districts) create)

let rec transfer_patients (Region(h, districts)) =
  let transfer d =
    List.iter (fun p -> Hospital.new_arrival h p) (transfer_patients d) in
  Array.iter transfer districts;
  Hospital.triage_examination_treatment h;
  let patients_to_transfer = h.Hospital.transfers in
  h.Hospital.transfers <- [];
  patients_to_transfer

let rec accumulate_totals (Region(h, districts)) =
  Array.fold_left (fun tot d -> tot ++ accumulate_totals d) (0,0,0) districts
  ++ Hospital.totals h

let () =
  let n = try int_of_string(Array.get Sys.argv 1) with _ -> 100 in
  let hc = create_health_care levels 0 42 in
  for i = 1 to n do ignore(transfer_patients hc) done;
  let (patients, time, visits) = accumulate_totals hc in
  Printf.printf "Patients: %i\nTime:    %i\nVisits:  %i\n" patients time visits
