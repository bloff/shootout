(* health.ml
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Troestler Christophe
 * This is a first implementation to be refined for speed.
 *)

let () = Gc.set { (Gc.get()) with Gc.minor_heap_size = 1024 * 1024 * 6 }


type patient = {
  mutable remaining_time : int;
  mutable hospital_time : int;
  mutable hospital_visits : int; }

type totals = int * int * int (* patients, hospital time, hospital visits *)

let add_patient (n, t, v) p =
  (n + 1, t + p.hospital_time, v + p.hospital_visits)

let ( ++ ) (n0, t0, v0) (n1, t1, v1) = (n0 + n1, t0 + t1, v0 + v1)


module Hospital =
struct
  type t = {
    mutable triage : patient list;
    mutable examination : patient list;
    mutable treatement : patient list;
    mutable discharged : totals;

    mutable available_staff : int;
    mutable seed : int;
    has_no_regional_hospital : bool; (* i.e. "top" one *)
    mutable transfers : patient list;
  }

  (* Shootout random generator, but with hospital seed *)
  let im = 139968 and ia = 3877 and ic = 29573
  let inv_im = 1. /. float im

  let random h max =
    h.seed <- (h.seed * ia + ic) mod im;
    max *. float h.seed *. inv_im

  let make has_no_regional_hospital level seed =
    { triage = [];  examination = [];  treatement = []; discharged = (0,0,0);
      available_staff = 1 lsl (level - 1);
      seed = seed;  has_no_regional_hospital = has_no_regional_hospital;
      transfers = []; }

  let totals h =
    let tot = List.fold_left add_patient (0,0,0) h.triage in
    let tot = List.fold_left add_patient tot h.examination in
    let tot = List.fold_left add_patient tot h.treatement in
    tot ++ h.discharged

  let new_arrival h p =
    p.hospital_visits <- p.hospital_visits + 1;
    if h.available_staff > 0 then (
      h.available_staff <- h.available_staff - 1;
      h.examination <- p :: h.examination;
      p.remaining_time <- 3;
      p.hospital_time <- p.hospital_time + 3;
    )
    else h.triage <- p :: h.triage

  let discharge_patients h =
    let treat p =
      p.remaining_time <- p.remaining_time - 1;
      if p.remaining_time > 0 then true else (
	h.available_staff <- h.available_staff + 1;
	h.discharged <- add_patient h.discharged p;
	false
      ) in
    h.treatement <- List.filter treat h.treatement

  let treat_or_transfer_patients h =
    let examine p =
      p.remaining_time <- p.remaining_time - 1;
      if p.remaining_time > 0 then true else (
	if random h 1.0 > 0.1 || h.has_no_regional_hospital then (
	  (* No transfer *)
	  h.treatement <- p :: h.treatement;
	  p.remaining_time <- 10;
	  p.hospital_time <- p.hospital_time + 10;
	)
	else (
	  (* Transfer to regional hospital *)
	  h.available_staff <- h.available_staff + 1;
	  h.transfers <- p :: h.transfers;
	);
	false
      ) in
    h.examination <- List.filter examine h.examination

  let triage_patients h =
    let triage p =
      if h.available_staff > 0 then (
	h.available_staff <- h.available_staff - 1;
	p.remaining_time <- 3;
	p.hospital_time <- p.hospital_time + 3;
	h.examination <- p :: h.examination;
	false
      )
      else (
	p.hospital_time <- p.hospital_time + 1;  true
      ) in
    h.triage <- List.filter triage h.triage

  let triage_examination_treatment h =
    discharge_patients h;
    treat_or_transfer_patients h;
    triage_patients h;
    if random h 1.0 > 0.7 then new_arrival h {
      remaining_time = 0; hospital_time = 0; hospital_visits = 0 }
end


(* Hierarchical health care: a region consisting of a hospital and
   (possibly) some districts. *)
type health_care = Region of Hospital.t * (health_care array)

let levels = 5
let districts = 4

let rec create_health_care level seed1 seed2 =
  let hospital = Hospital.make (level = levels) level (seed1 * seed2) in
  let create i = create_health_care (level - 1) (4 * seed1 + i + 1) seed2 in
  Region(hospital, Array.init (if level <= 1 then 0 else districts) create)

let rec transfer_patients (Region(h, districts)) =
  let transfer d =
    List.iter (fun p -> Hospital.new_arrival h p) (transfer_patients d) in
  Array.iter transfer districts;
  Hospital.triage_examination_treatment h;
  (* Return the transfer queue -- leaving the one of [h] empty. *)
  let patients_to_transfer = h.Hospital.transfers in
  h.Hospital.transfers <- [];
  patients_to_transfer

let rec accumulate_totals (Region(h, districts)) =
  Array.fold_left (fun tot d -> tot ++ accumulate_totals d) (0,0,0) districts
  ++ Hospital.totals h

let () =
  let n = try int_of_string(Array.get Sys.argv 1) with _ -> 100 in
  let hc = create_health_care levels 0 42 in
  for i = 1 to n do ignore(transfer_patients hc) done;
  let (patients, time, visits) = accumulate_totals hc in
  Printf.printf "Patients: %i\nTime:     %i\nVisits:   %i\n" patients time visits
