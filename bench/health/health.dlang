/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org/

   C# reference implementation contributed by Isaac Gouy

   converted to D by Dave Fladebo
   compile: dmd -O -inline -release health.d
*/

import std.stdio, std.string;

void main(char[][] args)
{
    int n = args.length > 1 ? atoi(args[1]) : 100;

    HealthcareRegion healthcareSystem = HealthcareRegion.Create();

    for(int i = 0; i < n; i++) 
        healthcareSystem.TransferPatients();

    Totals t = healthcareSystem.AccumulateTotals();

    writefln("Patients: ", t.patients ); 
    writefln("Time:     ", t.hospitalTime ); 
    writefln("Visits:   ", t.hospitalVisits ); 
}

class HealthcareRegion 
{
public:
    static HealthcareRegion Create()
    {
        return HealthcareRegion.Create(LEVELS, 0, 42);
    }

    static HealthcareRegion Create(int level, int seed1, int seed2)
    {
        HealthcareRegion r = null;

        if(level > 0)
        {
            r = new HealthcareRegion(level, seed1*seed2);
            for(int i = r.districts.length-1; i >= 0; i--)
                r.districts[i] = Create(level-1, (seed1*4)+i+1, seed2);
        }
        return r;
    }

    this(int level, int s)
    {
        districts = new HealthcareRegion[DISTRICTS];
        localHospital = new Hospital(level == LEVELS, level, s);
    }

private:
    const int LEVELS = 5, DISTRICTS = 4;
    HealthcareRegion[] districts;
    Hospital localHospital;

package:
    Patient[] TransferPatients()
    {
        for(int i = districts.length-1; i >= 0; i--)
            if(districts[i])
                foreach(Patient p; districts[i].TransferPatients())
                    localHospital.NewArrival(p);

        localHospital.TriageExaminationTreatment(); 

        return localHospital.RegionalTransferPatients();
    }

    Totals AccumulateTotals()
    {
        Totals t = new Totals();
        for(int i = districts.length-1; i >= 0; i--)
            if(districts[i])
                t += districts[i].AccumulateTotals();

        localHospital.AccumulateTotals(t);

        return t;
    }
}

class Hospital
{
    public this(bool hasNoRegionalHospital, int level, int seed)
    {
        this.hasNoRegionalHospital = hasNoRegionalHospital;
        availableStaff = 1 << (level - 1);
        discharged = new Totals();
        this.seed = seed;
    }

package:
    void TriageExaminationTreatment()
    {
        DischargePatients();
        TreatOrTransferPatients();
        TriagePatients();

        if(genRandom(1.0) > 0.7)
        {
            NewArrival(Patient());
        }
    }

    Patient[] RegionalTransferPatients()
    {
        return transfers;
    }

    void AccumulateTotals(Totals t)
    {
        foreach(Patient p; triage) t += p;
        foreach(Patient p; examination) t += p;
        foreach(Patient p; treatment) t += p;
        t += discharged;
    }

    void NewArrival(Patient p)
    {
        p.hospitalVisits++;
        if(availableStaff > 0)
        {
            availableStaff--;
            p.remainingTime = 3;
            p.hospitalTime += 3;
            examination ~= p;
        } else {
            triage ~= p;
        }
    }

private:
    Patient[] triage, examination, treatment, transfers;
    Totals discharged;
    int availableStaff;
    bool hasNoRegionalHospital;

    void DischargePatients()
    {
        for(int i = treatment.length-1; i >= 0; i--)
        {
            Patient* p = &treatment[i];
            p.remainingTime -= 1;
            if(!p.remainingTime)
            {
                availableStaff++;
                discharged += *p;
                treatment = treatment[0..i] ~ treatment[i+1..length];
            }
        }
    }

    void TreatOrTransferPatients()
    {
        delete transfers;

        for(int i = examination.length-1; i >= 0; i--)
        {
            Patient* p = &examination[i];
            p.remainingTime -= 1;

            if(!p.remainingTime)
            {
                // no transfer
                if(genRandom(1.0) > 0.1 || hasNoRegionalHospital)
                {
                    p.remainingTime = 10;
                    p.hospitalTime += 10;
                    treatment ~= *p;
                } else {
                // transfer
                    availableStaff++;
                    transfers ~= *p;
                }
                examination = examination[0..i] ~ examination[i+1..length];
            }
        }
    }

    void TriagePatients()
    {	
        for(int i = triage.length-1; i >= 0; i--)
        {
            Patient* p = &triage[i];
            if(availableStaff > 0)
            {
                availableStaff--;
                p.remainingTime = 3;
                p.hospitalTime += 3;
                examination ~= *p;
                triage = triage[0..i] ~ triage[i+1..length];
            } else {
                p.hospitalTime++;
            }
        }
    }

    int seed = 42;
    const int IM = 139968;
    const int IA = 3877;
    const int IC = 29573;
    double genRandom(double max)
    {
        return(max * (seed = (seed * IA + IC) % IM) / IM);
    }
}

struct Patient
{
    static Patient opCall() { Patient p; return p; }
    int remainingTime, hospitalTime, hospitalVisits;
}

class Totals 
{
    private long patients, hospitalTime, hospitalVisits;

package:
    Totals opAddAssign(Totals b)
    {
        patients += b.patients;
        hospitalTime += b.hospitalTime;
        hospitalVisits += b.hospitalVisits;
        return this;
    }

    Totals opAddAssign(Patient p)
    {
        patients++;
        hospitalTime += p.hospitalTime;
        hospitalVisits += p.hospitalVisits;
        return this;
    }
}
