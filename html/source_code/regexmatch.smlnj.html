<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<title>C:\Fulgham\Projects\shootout\bench\regexmatch\regexmatch.smlnj</title>
	<link rel="stylesheet" type="text/css" href="highlight.css">
</head>
<body>
<pre><span class="line">    1 </span><span class="com">(* -*- mode: sml -*-
</span><span class="line">    2 </span><span class="com"> * $Id: regexmatch.smlnj.html,v 1.1 2004-06-14 23:09:28 bfulgham Exp $
</span><span class="line">    3 </span><span class="com"> * http://www.bagley.org/~doug/shootout/
</span><span class="line">    4 </span><span class="com"> * from Stephen Weeks
</span><span class="line">    5 </span><span class="com"> * &quot;ported&quot; to SML/NJ
</span><span class="line">    6 </span><span class="com"> * with help from Daniel Wang
</span><span class="line">    7 </span><span class="com"> *)</span>
<span class="line">    8 </span>
<span class="line">    9 </span><span class="key">structure </span>Test : <span class="key">sig
</span><span class="line">   10 </span><span class="key">    val </span>main : (<span class="typ">string </span>* <span class="typ">string </span>list) -&gt; OS.Process.status
<span class="line">   11 </span><span class="key">end </span>= <span class="key">struct
</span><span class="line">   12 </span><span class="key">
</span><span class="line">   13 </span><span class="key">
</span><span class="line">   14 </span><span class="key">fun </span>++ (r: <span class="typ">int </span>ref): <span class="typ">int </span>=
<span class="line">   15 </span>   <span class="key">let
</span><span class="line">   16 </span><span class="key">      val </span>n = <span class="num">1 </span>+ !r
<span class="line">   17 </span>      <span class="key">val </span>_ = r := n
<span class="line">   18 </span>   <span class="key">in </span>n
<span class="line">   19 </span>   <span class="key">end
</span><span class="line">   20 </span><span class="key">
</span><span class="line">   21 </span><span class="key">structure Int </span>=
<span class="line">   22 </span>   <span class="key">struct
</span><span class="line">   23 </span><span class="key">      open Int
</span><span class="line">   24 </span><span class="key">
</span><span class="line">   25 </span><span class="key">      type </span>t = <span class="typ">int
</span><span class="line">   26 </span><span class="typ">
</span><span class="line">   27 </span><span class="typ">      </span><span class="key">fun </span>exists (start: t, stop: t, f: t -&gt; <span class="typ">bool</span>): <span class="typ">bool </span>=
<span class="line">   28 </span>     <span class="key">let
</span><span class="line">   29 </span><span class="key">        fun </span>loop i = i &lt; stop <span class="key">andalso </span>(f i <span class="key">orelse </span>loop (i + <span class="num">1</span>))
<span class="line">   30 </span>     <span class="key">in
</span><span class="line">   31 </span><span class="key">        </span>loop start
<span class="line">   32 </span>     <span class="key">end
</span><span class="line">   33 </span><span class="key">
</span><span class="line">   34 </span><span class="key">      fun </span>forall (start, stop, f) = not (exists (start, stop, not <span class="key">o </span>f))
<span class="line">   35 </span>
<span class="line">   36 </span>      <span class="key">fun </span>fold (start: t, stop: t, a: 'a, f: t * 'a -&gt; 'a): 'a =
<span class="line">   37 </span>     <span class="key">let
</span><span class="line">   38 </span><span class="key">        fun </span>loop (i: t, a: 'a) =
<span class="line">   39 </span>           <span class="key">if </span>i &gt;= stop
<span class="line">   40 </span>          <span class="key">then </span>a
<span class="line">   41 </span>           <span class="key">else </span>loop (i + <span class="num">1</span>, f (i, a))
<span class="line">   42 </span>     <span class="key">in </span>loop (start, a)
<span class="line">   43 </span>     <span class="key">end
</span><span class="line">   44 </span><span class="key">
</span><span class="line">   45 </span><span class="key">      fun </span>for (start: t, stop: t, f: t -&gt; unit): unit =
<span class="line">   46 </span>     <span class="key">let
</span><span class="line">   47 </span><span class="key">        fun </span>loop i =
<span class="line">   48 </span>           <span class="key">if </span>i &gt;= stop
<span class="line">   49 </span>          <span class="key">then </span>()
<span class="line">   50 </span>           <span class="key">else </span>(f i; loop (i + <span class="num">1</span>))
<span class="line">   51 </span>     <span class="key">in
</span><span class="line">   52 </span><span class="key">        </span>loop start
<span class="line">   53 </span>     <span class="key">end
</span><span class="line">   54 </span><span class="key">   end
</span><span class="line">   55 </span><span class="key">
</span><span class="line">   56 </span><span class="key">structure </span>Array2 =
<span class="line">   57 </span>   <span class="key">struct
</span><span class="line">   58 </span><span class="key">      open </span>Array2
<span class="line">   59 </span>
<span class="line">   60 </span>      <span class="key">type </span>'a t = 'a array
<span class="line">   61 </span>
<span class="line">   62 </span>      <span class="key">val </span>new = array
<span class="line">   63 </span>
<span class="line">   64 </span>      <span class="key">fun </span>tabulate (r, c, f) = Array2.tabulate RowMajor (r, c, f)
<span class="line">   65 </span>
<span class="line">   66 </span>      <span class="key">fun </span>foreachi (a, f) =
<span class="line">   67 </span>     appi RowMajor f {base = a, row = <span class="num">0</span>, col = <span class="num">0</span>,
<span class="line">   68 </span>              nrows = NONE, ncols = NONE}
<span class="line">   69 </span>   <span class="key">end
</span><span class="line">   70 </span><span class="key">
</span><span class="line">   71 </span><span class="key">structure Vector </span>=
<span class="line">   72 </span>   <span class="key">struct
</span><span class="line">   73 </span><span class="key">      open Vector
</span><span class="line">   74 </span><span class="key">
</span><span class="line">   75 </span><span class="key">      fun </span>exists (v, f) =
<span class="line">   76 </span>     <span class="key">Int</span>.exists (<span class="num">0</span>, length v, <span class="key">fn </span>i =&gt; f (sub (v, i)))
<span class="line">   77 </span>      <span class="key">fun </span>foreach (v, f) = app f v
<span class="line">   78 </span>      <span class="key">fun </span>foreachi (v, f) = appi f v
<span class="line">   79 </span>      <span class="key">fun </span>new (n, x) = tabulate (n, <span class="key">fn </span>_ =&gt; x)
<span class="line">   80 </span>      <span class="key">fun </span>new1 x = new (<span class="num">1</span>, x)
<span class="line">   81 </span>   <span class="key">end
</span><span class="line">   82 </span><span class="key">
</span><span class="line">   83 </span><span class="key">structure List </span>=
<span class="line">   84 </span>   <span class="key">struct
</span><span class="line">   85 </span><span class="key">      open List
</span><span class="line">   86 </span><span class="key">
</span><span class="line">   87 </span><span class="key">      fun </span>foreach (l, f) = app f l
<span class="line">   88 </span>
<span class="line">   89 </span>      <span class="key">fun </span>fold (l, b, f) = foldl f b l
<span class="line">   90 </span>
<span class="line">   91 </span>      <span class="key">fun </span>appendRev (l1, l2) = fold (l1, l2, <span class="key">op </span>::)
<span class="line">   92 </span>
<span class="line">   93 </span>      <span class="key">fun </span>push (r, x) = r := x :: !r
<span class="line">   94 </span>
<span class="line">   95 </span>      <span class="key">fun </span>keepAll (l, f) = filter f l
<span class="line">   96 </span>
<span class="line">   97 </span>      <span class="key">fun </span>peek (l, f) = find f l
<span class="line">   98 </span>
<span class="line">   99 </span>      <span class="key">fun </span>insert (l, x, <span class="key">op </span>&lt;=) =
<span class="line">  100 </span>     <span class="key">let
</span><span class="line">  101 </span><span class="key">        fun </span>loop (l, ac) =
<span class="line">  102 </span>           <span class="key">case </span>l <span class="key">of
</span><span class="line">  103 </span><span class="key">          </span>[] =&gt; appendRev (ac, [x])
<span class="line">  104 </span>        | x' :: l' =&gt;
<span class="line">  105 </span>             <span class="key">if </span>x &lt;= x'
<span class="line">  106 </span>            <span class="key">then </span>appendRev (ac, x :: l)
<span class="line">  107 </span>             <span class="key">else </span>loop (l', x' :: ac)
<span class="line">  108 </span>     <span class="key">in </span>loop (l, [])
<span class="line">  109 </span>     <span class="key">end
</span><span class="line">  110 </span><span class="key">   end
</span><span class="line">  111 </span><span class="key">
</span><span class="line">  112 </span><span class="key">structure </span>Array =
<span class="line">  113 </span>   <span class="key">struct
</span><span class="line">  114 </span><span class="key">      open </span>Array
<span class="line">  115 </span>
<span class="line">  116 </span>      <span class="key">val </span>new = array
<span class="line">  117 </span>
<span class="line">  118 </span>      <span class="key">fun </span>modify (a, f) = Array.modify f a
<span class="line">  119 </span>
<span class="line">  120 </span>      <span class="key">fun </span>foreachi (a, f) = appi f a
<span class="line">  121 </span>
<span class="line">  122 </span>      <span class="key">fun </span>indices (a: <span class="typ">bool </span>array): <span class="typ">int </span>vector =
<span class="line">  123 </span>     <span class="key">let
</span><span class="line">  124 </span><span class="key">        val </span>n = Array.length a
<span class="line">  125 </span>        <span class="key">val </span>numTrue =
<span class="line">  126 </span>           <span class="key">let
</span><span class="line">  127 </span><span class="key">          fun </span>loop (i, count) =
<span class="line">  128 </span>             <span class="key">if </span>i = n
<span class="line">  129 </span>            <span class="key">then </span>count
<span class="line">  130 </span>             <span class="key">else </span>loop (i + <span class="num">1</span>,
<span class="line">  131 </span>                <span class="key">if </span>Array.sub (a, i)
<span class="line">  132 </span>                   <span class="key">then </span>count + <span class="num">1
</span><span class="line">  133 </span><span class="num">                </span><span class="key">else </span>count)
<span class="line">  134 </span>           <span class="key">in </span>loop (<span class="num">0</span>, <span class="num">0</span>)
<span class="line">  135 </span>           <span class="key">end
</span><span class="line">  136 </span><span class="key">        val </span>next = ref <span class="num">0
</span><span class="line">  137 </span><span class="num">        </span><span class="key">fun </span>loop i =
<span class="line">  138 </span>           <span class="key">if </span>Array.sub (a, i)
<span class="line">  139 </span>          <span class="key">then </span>(next := i + <span class="num">1</span>; i)
<span class="line">  140 </span>           <span class="key">else </span>loop (i + <span class="num">1</span>)
<span class="line">  141 </span>     <span class="key">in Vector</span>.tabulate (numTrue, <span class="key">fn </span>_ =&gt; loop (!next))
<span class="line">  142 </span>     <span class="key">end
</span><span class="line">  143 </span><span class="key">   end
</span><span class="line">  144 </span><span class="key">
</span><span class="line">  145 </span><span class="key">structure Char </span>=
<span class="line">  146 </span>   <span class="key">struct
</span><span class="line">  147 </span><span class="key">      open Char
</span><span class="line">  148 </span><span class="key">
</span><span class="line">  149 </span><span class="key">      val </span>fromInt = chr
<span class="line">  150 </span>      <span class="key">val </span>toInt = ord
<span class="line">  151 </span>   <span class="key">end
</span><span class="line">  152 </span><span class="key">
</span><span class="line">  153 </span><span class="key">structure String </span>=
<span class="line">  154 </span>   <span class="key">struct
</span><span class="line">  155 </span><span class="key">      open String
</span><span class="line">  156 </span><span class="key">
</span><span class="line">  157 </span><span class="key">      type </span>t = <span class="typ">string
</span><span class="line">  158 </span><span class="typ">
</span><span class="line">  159 </span><span class="typ">      </span><span class="key">fun </span>contains (s: t, c: char): <span class="typ">bool </span>=
<span class="line">  160 </span>     <span class="key">Int</span>.exists (<span class="num">0</span>, size s, <span class="key">fn </span>i =&gt; c = sub (s, i))
<span class="line">  161 </span>   <span class="key">end
</span><span class="line">  162 </span><span class="key">
</span><span class="line">  163 </span><span class="key">val </span>numChars: <span class="typ">int </span>= <span class="num">128
</span><span class="line">  164 </span><span class="num">
</span><span class="line">  165 </span><span class="num"></span><span class="key">structure </span>Regexp =
<span class="line">  166 </span>   <span class="key">struct
</span><span class="line">  167 </span><span class="key">      datatype </span>t =
<span class="line">  168 </span>     AnchorStart
<span class="line">  169 </span>       | CharSet <span class="key">of </span>char -&gt; <span class="typ">bool
</span><span class="line">  170 </span><span class="typ">       </span>| Or <span class="key">of </span>t list
<span class="line">  171 </span>       | Seq <span class="key">of </span>t list
<span class="line">  172 </span>       | Star <span class="key">of </span>t
<span class="line">  173 </span>   <span class="key">end
</span><span class="line">  174 </span><span class="key">
</span><span class="line">  175 </span><span class="key">structure </span>Stack:
<span class="line">  176 </span>   <span class="key">sig
</span><span class="line">  177 </span><span class="key">      type </span>'a t
<span class="line">  178 </span>
<span class="line">  179 </span>      <span class="key">val </span>clear: 'a t -&gt; unit
<span class="line">  180 </span>      <span class="key">val </span>exists: 'a t * ('a -&gt; <span class="typ">bool</span>) -&gt; <span class="typ">bool
</span><span class="line">  181 </span><span class="typ">      </span><span class="key">val </span>foreach: 'a t * ('a -&gt; unit) -&gt; unit
<span class="line">  182 </span>      <span class="key">val </span>new: <span class="typ">int </span>* 'a -&gt; 'a t
<span class="line">  183 </span>      <span class="key">val </span>push: 'a t * 'a -&gt; unit
<span class="line">  184 </span>   <span class="key">end </span>=
<span class="line">  185 </span>   <span class="key">struct
</span><span class="line">  186 </span><span class="key">      datatype </span>'a t = T <span class="key">of </span>{elts: 'a array,
<span class="line">  187 </span>                size: <span class="typ">int </span>ref}
<span class="line">  188 </span>
<span class="line">  189 </span>      <span class="key">fun </span>new (size: <span class="typ">int</span>, dummy: 'a): 'a t =
<span class="line">  190 </span>     T {elts = Array.new (size, dummy),
<span class="line">  191 </span>        size = ref <span class="num">0</span>}
<span class="line">  192 </span>
<span class="line">  193 </span>      <span class="key">fun </span>push (T {elts, size}, x) =
<span class="line">  194 </span>     <span class="key">let
</span><span class="line">  195 </span><span class="key">        val </span>n = !size
<span class="line">  196 </span>        <span class="key">val </span>_ = Array.update (elts, n, x)
<span class="line">  197 </span>        <span class="key">val </span>_ = size := n + <span class="num">1
</span><span class="line">  198 </span><span class="num">     </span><span class="key">in </span>()
<span class="line">  199 </span>     <span class="key">end
</span><span class="line">  200 </span><span class="key">
</span><span class="line">  201 </span><span class="key">      fun </span>exists (T {elts, size, ...}, f) =
<span class="line">  202 </span>     <span class="key">Int</span>.exists (<span class="num">0</span>, !size, <span class="key">fn </span>i =&gt; f (Array.sub (elts, i)))
<span class="line">  203 </span>
<span class="line">  204 </span>      <span class="key">fun </span>foreach (T {elts, size}, f) =
<span class="line">  205 </span>     <span class="key">Int</span>.for (<span class="num">0</span>, !size, <span class="key">fn </span>i =&gt; f (Array.sub (elts, i)))
<span class="line">  206 </span>
<span class="line">  207 </span>      <span class="key">fun </span>clear (T {size, ...}) = size := <span class="num">0
</span><span class="line">  208 </span><span class="num">   </span><span class="key">end
</span><span class="line">  209 </span><span class="key">
</span><span class="line">  210 </span><span class="key"></span><span class="com">(* Non-deterministic Finite Automaton. *)</span>
<span class="line">  211 </span><span class="key">structure </span>NFA:
<span class="line">  212 </span>   <span class="key">sig
</span><span class="line">  213 </span><span class="key">      </span><span class="com">(* The states in an NFA are indexed from 0 to n-1, where n is the
</span><span class="line">  214 </span><span class="com">       number
</span><span class="line">  215 </span><span class="com">       * of states.
</span><span class="line">  216 </span><span class="com">       *)</span>
<span class="line">  217 </span>      <span class="key">type </span>state = <span class="typ">int
</span><span class="line">  218 </span><span class="typ">
</span><span class="line">  219 </span><span class="typ">      </span><span class="com">(* State i is final iff Array.sub (final, i).
</span><span class="line">  220 </span><span class="com">       * The outgoing states from state i on input char c are given by
</span><span class="line">  221 </span><span class="com">       * Array2.sub (next, i, Char.ord c).
</span><span class="line">  222 </span><span class="com">       * anchorStarts is sorted in increasing order of state index.
</span><span class="line">  223 </span><span class="com">       *)</span>
<span class="line">  224 </span>      <span class="key">datatype </span>t = T <span class="key">of </span>{anchorStarts: state list,
<span class="line">  225 </span>             final: <span class="typ">bool </span>array,
<span class="line">  226 </span>             seen: <span class="typ">bool </span>array, <span class="com">(* used for matching. *)</span>
<span class="line">  227 </span>             stack1: <span class="typ">int </span>Stack.t, <span class="com">(* used for matching. *)</span>
<span class="line">  228 </span>             stack2: <span class="typ">int </span>Stack.t, <span class="com">(* used for matching. *)</span>
<span class="line">  229 </span>             start: state,
<span class="line">  230 </span>             next: state vector Array2.t}
<span class="line">  231 </span>
<span class="line">  232 </span>      <span class="key">val </span>fromRegexp: Regexp.t -&gt; t
<span class="line">  233 </span>      <span class="key">val </span>match: {nfa: t,
<span class="line">  234 </span>          <span class="typ">string</span>: <span class="typ">string</span>,
<span class="line">  235 </span>          startPos: <span class="typ">int</span>,
<span class="line">  236 </span>          anchorStart: <span class="typ">bool</span>} -&gt; <span class="typ">int </span>option
<span class="line">  237 </span>      <span class="key">val </span>numStates: t -&gt; <span class="typ">int
</span><span class="line">  238 </span><span class="typ">   </span><span class="key">end </span>=
<span class="line">  239 </span>   <span class="key">struct
</span><span class="line">  240 </span><span class="key">      type </span>state = <span class="typ">int
</span><span class="line">  241 </span><span class="typ">      </span><span class="key">datatype </span>t = T <span class="key">of </span>{anchorStarts: state list,
<span class="line">  242 </span>             final: <span class="typ">bool </span>array,
<span class="line">  243 </span>             seen: <span class="typ">bool </span>array,
<span class="line">  244 </span>             stack1: <span class="typ">int </span>Stack.t,
<span class="line">  245 </span>             stack2: <span class="typ">int </span>Stack.t,
<span class="line">  246 </span>             start: state,
<span class="line">  247 </span>             next: state vector Array2.t}
<span class="line">  248 </span>
<span class="line">  249 </span>      <span class="key">fun </span>numStates (T {next, ...}) = Array2.nRows next
<span class="line">  250 </span>
<span class="line">  251 </span>
<span class="line">  252 </span>      <span class="com">(* Simulating an NFA with two stacks and a bit vector, as in
</span><span class="line">  253 </span><span class="com">       Algorithm 3.4
</span><span class="line">  254 </span><span class="com">       * (page 126) of Compilers: Principles, Techniques, and Tools by Aho,
</span><span class="line">  255 </span><span class="com">       * Sethi, and Ullman.
</span><span class="line">  256 </span><span class="com">       *)</span>
<span class="line">  257 </span>      <span class="key">fun </span>match {anchorStart: <span class="typ">bool</span>,
<span class="line">  258 </span>         nfa <span class="key">as </span>T {anchorStarts, final, seen, stack1, stack2, start,
<span class="line">  259 </span>               next},
<span class="line">  260 </span>         startPos,
<span class="line">  261 </span>         <span class="typ">string </span>= s}: <span class="typ">int </span>option =
<span class="line">  262 </span>     <span class="key">let
</span><span class="line">  263 </span><span class="key">        val </span>numStates = numStates nfa
<span class="line">  264 </span>        <span class="key">val </span>n = <span class="key">String</span>.size s
<span class="line">  265 </span>        <span class="key">val </span>_ = Array.modify (seen, <span class="key">fn </span>_ =&gt; <span class="key">false</span>)
<span class="line">  266 </span>        <span class="key">fun </span>loop (current: state Stack.t,
<span class="line">  267 </span>              nextStates: state Stack.t,
<span class="line">  268 </span>              i: <span class="typ">int</span>,
<span class="line">  269 </span>              last: <span class="typ">int </span>option): <span class="typ">int </span>option =
<span class="line">  270 </span>           <span class="key">let
</span><span class="line">  271 </span><span class="key">          val </span>last =
<span class="line">  272 </span>             <span class="key">if </span>Stack.exists (current, <span class="key">fn </span>s =&gt; Array.sub (final, s))
<span class="line">  273 </span>            <span class="key">then </span>SOME i
<span class="line">  274 </span>             <span class="key">else </span>last
<span class="line">  275 </span>           <span class="key">in
</span><span class="line">  276 </span><span class="key">          if </span>numStates = <span class="num">0 </span><span class="key">orelse </span>i = n
<span class="line">  277 </span>             <span class="key">then </span>(Stack.clear stack1
<span class="line">  278 </span>               ; Stack.clear stack2
<span class="line">  279 </span>               ; last)
<span class="line">  280 </span>          <span class="key">else
</span><span class="line">  281 </span><span class="key">             let
</span><span class="line">  282 </span><span class="key">            val </span>_ = Array.modify (seen, <span class="key">fn </span>_ =&gt; <span class="key">false</span>)
<span class="line">  283 </span>            <span class="key">val </span>c = <span class="key">Char</span>.toInt (<span class="key">String</span>.sub (s, i))
<span class="line">  284 </span>            <span class="key">val </span>_ =
<span class="line">  285 </span>               Stack.foreach (current, <span class="key">fn </span>s =&gt;
<span class="line">  286 </span>                      <span class="key">Vector</span>.foreach
<span class="line">  287 </span>                      (Array2.sub (next, s, c),
<span class="line">  288 </span>                       <span class="key">fn </span>s' =&gt;
<span class="line">  289 </span>                       <span class="key">if </span>Array.sub (seen, s')
<span class="line">  290 </span>                          <span class="key">then </span>()
<span class="line">  291 </span>                       <span class="key">else </span>(Array.update (seen, s', <span class="key">true</span>)
<span class="line">  292 </span>                         ; Stack.push (nextStates, s'))))
<span class="line">  293 </span>            <span class="key">val </span>_ = Stack.clear current
<span class="line">  294 </span>             <span class="key">in </span>loop (nextStates, current, i + <span class="num">1</span>, last)
<span class="line">  295 </span>             <span class="key">end
</span><span class="line">  296 </span><span class="key">           end
</span><span class="line">  297 </span><span class="key">        val </span>_ = Stack.push (stack1, start)
<span class="line">  298 </span>        <span class="key">val </span>_ =
<span class="line">  299 </span>           <span class="key">if </span>anchorStart
<span class="line">  300 </span>          <span class="key">then List</span>.foreach (anchorStarts, <span class="key">fn </span>s =&gt;
<span class="line">  301 </span>                     Stack.push (stack1, s))
<span class="line">  302 </span>           <span class="key">else </span>()
<span class="line">  303 </span>     <span class="key">in
</span><span class="line">  304 </span><span class="key">        </span>loop (stack1, stack2, startPos, NONE)
<span class="line">  305 </span>     <span class="key">end
</span><span class="line">  306 </span><span class="key">
</span><span class="line">  307 </span><span class="key">      </span><span class="com">(* This conversion from a regular expression to an NFA is based on
</span><span class="line">  308 </span><span class="com">       * Section 3.9 (pages 134 -- 140) of Compilers: Principles,
</span><span class="line">  309 </span><span class="com">                      Techniques,
</span><span class="line">  310 </span><span class="com">       * and Tools by Aho, Sethi, and Ullman.
</span><span class="line">  311 </span><span class="com">       *
</span><span class="line">  312 </span><span class="com">       * It creates one NFA state for each CharSet (called a &quot;position&quot;)
</span><span class="line">  313 </span><span class="com">                                                    that is
</span><span class="line">  314 </span><span class="com">       * in the regexp.  There is also one extra state for the start state.
</span><span class="line">  315 </span><span class="com">       * It adds edges as in rules 1 and 2 (page 138) for the followpos
</span><span class="line">  316 </span><span class="com">                                            function.
</span><span class="line">  317 </span><span class="com">       *)</span>
<span class="line">  318 </span>      <span class="key">fun </span>fromRegexp (r: Regexp.t): t =
<span class="line">  319 </span>     <span class="key">let
</span><span class="line">  320 </span><span class="key">        fun </span>loop (r, ac) =
<span class="line">  321 </span>           <span class="key">let open </span>Regexp
<span class="line">  322 </span>           <span class="key">in case </span>r <span class="key">of
</span><span class="line">  323 </span><span class="key">          </span>AnchorStart =&gt; ac + <span class="num">1
</span><span class="line">  324 </span><span class="num">        </span>| CharSet _ =&gt; ac + <span class="num">1
</span><span class="line">  325 </span><span class="num">        </span>| Or rs =&gt; <span class="key">List</span>.fold (rs, ac, loop)
<span class="line">  326 </span>        | Seq rs =&gt; <span class="key">List</span>.fold (rs, ac, loop)
<span class="line">  327 </span>        | Star r =&gt; loop (r, ac)
<span class="line">  328 </span>           <span class="key">end
</span><span class="line">  329 </span><span class="key">        val </span>numPos = loop (r, <span class="num">0</span>)
<span class="line">  330 </span>        <span class="key">val </span>numStates = numPos + <span class="num">1
</span><span class="line">  331 </span><span class="num">        </span><span class="key">val </span>start = numPos
<span class="line">  332 </span>        <span class="key">val </span>posCounter = ref ~<span class="num">1
</span><span class="line">  333 </span><span class="num">        </span><span class="key">val </span>follow = Array2.new (numStates, numStates, <span class="key">false</span>)
<span class="line">  334 </span>        <span class="key">val </span>posChars = Array2.tabulate (numPos, numChars, <span class="key">fn </span>_ =&gt; <span class="key">false</span>)
<span class="line">  335 </span>        <span class="key">local
</span><span class="line">  336 </span><span class="key">           datatype </span>t = T <span class="key">of </span><span class="typ">bool </span>vector <span class="com">(* of length numPos *)</span>
<span class="line">  337 </span>        <span class="key">in
</span><span class="line">  338 </span><span class="key">           fun </span>contains (T v, s) = <span class="key">Vector</span>.sub (v, s)
<span class="line">  339 </span>           <span class="key">val </span>empty: t = T (<span class="key">Vector</span>.new (numPos, <span class="key">false</span>))
<span class="line">  340 </span>           <span class="key">fun </span>union (T v, T v'): t =
<span class="line">  341 </span>          T (<span class="key">Vector</span>.tabulate (numPos, <span class="key">fn </span>i =&gt;
<span class="line">  342 </span>                      <span class="key">Vector</span>.sub (v, i)
<span class="line">  343 </span>                      <span class="key">orelse Vector</span>.sub (v', i)))
<span class="line">  344 </span>           <span class="key">fun </span>singleton (i: <span class="typ">int</span>): t =
<span class="line">  345 </span>          T (<span class="key">Vector</span>.tabulate (numPos, <span class="key">fn </span>j =&gt; i = j))
<span class="line">  346 </span>           <span class="key">fun </span>foreach (T v, f) =
<span class="line">  347 </span>          <span class="key">Vector</span>.foreachi (v, <span class="key">fn </span>(i, b) =&gt; <span class="key">if </span>b <span class="key">then </span>f i <span class="key">else </span>())
<span class="line">  348 </span>        <span class="key">end
</span><span class="line">  349 </span><span class="key">        val </span>anchorStarts = ref []
<span class="line">  350 </span>        <span class="com">(* The following loop fills in follow and posChars. *)</span>
<span class="line">  351 </span>        <span class="key">fun </span>loop r =
<span class="line">  352 </span>           <span class="key">case </span>r <span class="key">of
</span><span class="line">  353 </span><span class="key">          </span>Regexp.AnchorStart =&gt;
<span class="line">  354 </span>             <span class="key">let
</span><span class="line">  355 </span><span class="key">            val </span>i = ++ posCounter
<span class="line">  356 </span>            <span class="key">val </span>_ = <span class="key">List</span>.push (anchorStarts, i)
<span class="line">  357 </span>            <span class="key">val </span>first = singleton i
<span class="line">  358 </span>             <span class="key">in
</span><span class="line">  359 </span><span class="key">            </span>{first = first,
<span class="line">  360 </span>             last = first,
<span class="line">  361 </span>             nullable = <span class="key">false</span>}
<span class="line">  362 </span>             <span class="key">end
</span><span class="line">  363 </span><span class="key">        </span>| Regexp.CharSet f =&gt;
<span class="line">  364 </span>             <span class="key">let
</span><span class="line">  365 </span><span class="key">            val </span>i = ++ posCounter
<span class="line">  366 </span>            <span class="key">val </span>_ =
<span class="line">  367 </span>               <span class="key">Int</span>.for (<span class="num">0</span>, numChars, <span class="key">fn </span>c =&gt;
<span class="line">  368 </span>                    <span class="key">if </span>f (<span class="key">Char</span>.chr c)
<span class="line">  369 </span>                       <span class="key">then </span>Array2.update (posChars, i, c, <span class="key">true</span>)
<span class="line">  370 </span>                    <span class="key">else </span>())
<span class="line">  371 </span>            <span class="key">val </span>first = singleton i
<span class="line">  372 </span>             <span class="key">in </span>{first = first,
<span class="line">  373 </span>             last = first,
<span class="line">  374 </span>             nullable = <span class="key">false</span>}
<span class="line">  375 </span>             <span class="key">end
</span><span class="line">  376 </span><span class="key">        </span>| Regexp.Or rs =&gt;
<span class="line">  377 </span>             <span class="key">List</span>.fold
<span class="line">  378 </span>             (rs, {first = empty,
<span class="line">  379 </span>               last = empty,
<span class="line">  380 </span>               nullable = <span class="key">false</span>},
<span class="line">  381 </span>              <span class="key">fn </span>(r, {first = f, last = l, nullable = n}) =&gt;
<span class="line">  382 </span>              <span class="key">let
</span><span class="line">  383 </span><span class="key">             val </span>{first = f', last = l', nullable = n'} =
<span class="line">  384 </span>                loop r
<span class="line">  385 </span>              <span class="key">in
</span><span class="line">  386 </span><span class="key">             </span>{first = union (f, f'),
<span class="line">  387 </span>              last = union (l, l'),
<span class="line">  388 </span>              nullable = n <span class="key">orelse </span>n'}
<span class="line">  389 </span>              <span class="key">end</span>)
<span class="line">  390 </span>        | Regexp.Seq rs =&gt;
<span class="line">  391 </span>             <span class="key">List</span>.fold
<span class="line">  392 </span>             (rs, {first = empty,
<span class="line">  393 </span>               last = empty,
<span class="line">  394 </span>               nullable = <span class="key">true</span>},
<span class="line">  395 </span>              <span class="key">fn </span>(r, {first = f, last = l, nullable = n}) =&gt;
<span class="line">  396 </span>              <span class="key">let
</span><span class="line">  397 </span><span class="key">             val </span>{first = f', last = l', nullable = n'} =
<span class="line">  398 </span>                loop r
<span class="line">  399 </span>             <span class="key">val </span>_ =
<span class="line">  400 </span>                foreach
<span class="line">  401 </span>                (l, <span class="key">fn </span>s =&gt;
<span class="line">  402 </span>                 foreach
<span class="line">  403 </span>                 (f', <span class="key">fn </span>s' =&gt; Array2.update (follow, s, s', <span class="key">true</span>)))
<span class="line">  404 </span>              <span class="key">in
</span><span class="line">  405 </span><span class="key">             </span>{first = <span class="key">if </span>n <span class="key">then </span>union (f, f') <span class="key">else </span>f,
<span class="line">  406 </span>              last = <span class="key">if </span>n' <span class="key">then </span>union (l, l') <span class="key">else </span>l',
<span class="line">  407 </span>              nullable = n <span class="key">andalso </span>n'}
<span class="line">  408 </span>              <span class="key">end</span>)
<span class="line">  409 </span>        | Regexp.Star r =&gt;
<span class="line">  410 </span>             <span class="key">let
</span><span class="line">  411 </span><span class="key">            val </span>{first = f, last = l, nullable = n} = loop r
<span class="line">  412 </span>            <span class="key">val </span>_ =
<span class="line">  413 </span>               foreach
<span class="line">  414 </span>               (l, <span class="key">fn </span>s =&gt;
<span class="line">  415 </span>                foreach
<span class="line">  416 </span>                (f, <span class="key">fn </span>s' =&gt; Array2.update (follow, s, s', <span class="key">true</span>)))
<span class="line">  417 </span>             <span class="key">in
</span><span class="line">  418 </span><span class="key">            </span>{first = f, last = l, nullable = <span class="key">true</span>}
<span class="line">  419 </span>             <span class="key">end
</span><span class="line">  420 </span><span class="key">        val </span>{first, last, nullable} = loop r
<span class="line">  421 </span>        <span class="com">(* Any anchor starts in first should be anchor starts.
</span><span class="line">  422 </span><span class="com">         * This also reverses anchorStarts so they are in order.
</span><span class="line">  423 </span><span class="com">         *)</span>
<span class="line">  424 </span>        <span class="key">val </span>anchorStarts =
<span class="line">  425 </span>           <span class="key">List</span>.fold (!anchorStarts, [], <span class="key">fn </span>(s, ac) =&gt;
<span class="line">  426 </span>              <span class="key">if </span>contains (first, s) <span class="key">then </span>s :: ac <span class="key">else </span>ac)
<span class="line">  427 </span>        <span class="com">(* The positions in first are all reachable from the start state. *)</span>
<span class="line">  428 </span>        <span class="key">val </span>_ = foreach (first, <span class="key">fn </span>i =&gt;
<span class="line">  429 </span>                 Array2.update (follow, start, i, <span class="key">true</span>))
<span class="line">  430 </span>        <span class="com">(* The positions in last are all final states. *)</span>
<span class="line">  431 </span>        <span class="key">val </span>final = Array.array (numStates, <span class="key">false</span>)
<span class="line">  432 </span>        <span class="key">val </span>_ = foreach (last, <span class="key">fn </span>i =&gt; Array.update (final, i, <span class="key">true</span>))
<span class="line">  433 </span>        <span class="com">(* The start state is final if the whole regexp is nullable. *)</span>
<span class="line">  434 </span>        <span class="key">val </span>_ = <span class="key">if </span>nullable <span class="key">then </span>Array.update (final, start, <span class="key">true</span>) <span class="key">else </span>()
<span class="line">  435 </span>        <span class="com">(* Now c1ompute the transition table. *)</span>
<span class="line">  436 </span>        <span class="key">val </span>a = Array.new (numStates, <span class="key">false</span>)
<span class="line">  437 </span>        <span class="key">val </span>next =
<span class="line">  438 </span>           Array2.tabulate
<span class="line">  439 </span>           (numStates, numChars, <span class="key">fn </span>(i, c) =&gt;
<span class="line">  440 </span>        <span class="key">let
</span><span class="line">  441 </span><span class="key">           val </span>_ =
<span class="line">  442 </span>              <span class="key">Int</span>.for (<span class="num">0</span>, numStates, <span class="key">fn </span>j =&gt; Array.update (a, j, <span class="key">false</span>))
<span class="line">  443 </span>           <span class="key">val </span>_ =
<span class="line">  444 </span>              <span class="key">Int</span>.for
<span class="line">  445 </span>              (<span class="num">0</span>, numPos, <span class="key">fn </span>j =&gt;
<span class="line">  446 </span>               <span class="key">if </span>Array2.sub (follow, i, j)
<span class="line">  447 </span>              <span class="key">andalso </span>Array2.sub (posChars, j, c)
<span class="line">  448 </span>              <span class="key">then </span>Array.update (a, j, <span class="key">true</span>)
<span class="line">  449 </span>               <span class="key">else </span>())
<span class="line">  450 </span>        <span class="key">in </span>Array.indices a
<span class="line">  451 </span>        <span class="key">end</span>)
<span class="line">  452 </span>     <span class="key">in
</span><span class="line">  453 </span><span class="key">        </span>T {anchorStarts = anchorStarts,
<span class="line">  454 </span>           final = final,
<span class="line">  455 </span>           next = next,
<span class="line">  456 </span>           seen = Array.new (numStates, <span class="key">false</span>),
<span class="line">  457 </span>           stack1 = Stack.new (numStates, ~<span class="num">1</span>),
<span class="line">  458 </span>           stack2 = Stack.new (numStates, ~<span class="num">1</span>),
<span class="line">  459 </span>           start = start}
<span class="line">  460 </span>     <span class="key">end
</span><span class="line">  461 </span><span class="key">
</span><span class="line">  462 </span><span class="key">   end
</span><span class="line">  463 </span><span class="key">
</span><span class="line">  464 </span><span class="key">structure </span>DFA:
<span class="line">  465 </span>   <span class="key">sig
</span><span class="line">  466 </span><span class="key">      type </span>t
<span class="line">  467 </span>
<span class="line">  468 </span>      <span class="key">val </span>fromNFA: NFA.t -&gt; t
<span class="line">  469 </span>      <span class="key">val </span>match: {dfa: t,
<span class="line">  470 </span>          <span class="typ">string</span>: <span class="typ">string</span>,
<span class="line">  471 </span>          startPos: <span class="typ">int</span>,
<span class="line">  472 </span>          anchorStart: <span class="typ">bool</span>} -&gt; <span class="typ">int </span>option
<span class="line">  473 </span>      <span class="key">val </span>minimize: t -&gt; t
<span class="line">  474 </span>   <span class="key">end </span>=
<span class="line">  475 </span>   <span class="key">struct
</span><span class="line">  476 </span><span class="key">      </span><span class="com">(* The states in a DFA are indexed from 0 to n-1, where n is the
</span><span class="line">  477 </span><span class="com">       number
</span><span class="line">  478 </span><span class="com">       * of states.
</span><span class="line">  479 </span><span class="com">       *)</span>
<span class="line">  480 </span>      <span class="key">type </span>state = <span class="typ">int
</span><span class="line">  481 </span><span class="typ">
</span><span class="line">  482 </span><span class="typ">      </span><span class="com">(* State i is final iff Array.sub (final, i).
</span><span class="line">  483 </span><span class="com">       * The outgoing state from state i on input char c is
</span><span class="line">  484 </span><span class="com">       * Array2.sub (next, i, Char.ord c).
</span><span class="line">  485 </span><span class="com">       *)</span>
<span class="line">  486 </span>      <span class="key">datatype </span>t = T <span class="key">of </span>{anchorStart: state,
<span class="line">  487 </span>             dead: <span class="typ">bool </span>array,
<span class="line">  488 </span>             final: <span class="typ">bool </span>array,
<span class="line">  489 </span>             next: state Array2.t,
<span class="line">  490 </span>             start: state}
<span class="line">  491 </span>
<span class="line">  492 </span>      <span class="key">fun </span>numStates (T {next, ...}): <span class="typ">int </span>= Array2.nRows next
<span class="line">  493 </span>
<span class="line">  494 </span>
<span class="line">  495 </span>      <span class="key">fun </span>match {dfa <span class="key">as </span>T {anchorStart = ancSt, dead, final, start, next},
<span class="line">  496 </span>         <span class="typ">string </span><span class="key">as </span>s,
<span class="line">  497 </span>         startPos: <span class="typ">int</span>,
<span class="line">  498 </span>         anchorStart: <span class="typ">bool</span>}: <span class="typ">int </span>option =
<span class="line">  499 </span>     <span class="key">let
</span><span class="line">  500 </span><span class="key">        val </span>n = <span class="key">String</span>.size s
<span class="line">  501 </span>        <span class="key">fun </span>loop (i: <span class="typ">int</span>, state: <span class="typ">int</span>, last: <span class="typ">int </span>option): <span class="typ">int </span>option =
<span class="line">  502 </span>           <span class="key">let
</span><span class="line">  503 </span><span class="key">          val </span>last =
<span class="line">  504 </span>             <span class="key">if </span>Array.sub (final, state)
<span class="line">  505 </span>            <span class="key">then </span>SOME i
<span class="line">  506 </span>             <span class="key">else </span>last
<span class="line">  507 </span>           <span class="key">in
</span><span class="line">  508 </span><span class="key">          if </span>Array.sub (dead, state) <span class="key">orelse </span>i = n
<span class="line">  509 </span>             <span class="key">then </span>last
<span class="line">  510 </span>          <span class="key">else </span>loop (i + <span class="num">1</span>,
<span class="line">  511 </span>                 Array2.sub (next, state,
<span class="line">  512 </span>                     <span class="key">Char</span>.toInt (<span class="key">String</span>.sub (s, i))),
<span class="line">  513 </span>                 last)
<span class="line">  514 </span>           <span class="key">end
</span><span class="line">  515 </span><span class="key">     in </span>loop (startPos,
<span class="line">  516 </span>          <span class="key">if </span>anchorStart <span class="key">then </span>ancSt <span class="key">else </span>start,
<span class="line">  517 </span>             NONE)
<span class="line">  518 </span>     <span class="key">end
</span><span class="line">  519 </span><span class="key">
</span><span class="line">  520 </span><span class="key">      fun </span>dead (numStates, final, next) =
<span class="line">  521 </span>     Array.tabulate
<span class="line">  522 </span>     (numStates, <span class="key">fn </span>i =&gt;
<span class="line">  523 </span>      not (Array.sub (final, i))
<span class="line">  524 </span>      <span class="key">andalso Int</span>.forall (<span class="num">0</span>, numChars, <span class="key">fn </span>c =&gt;
<span class="line">  525 </span>                  i = Array2.sub (next, i, c)))
<span class="line">  526 </span>
<span class="line">  527 </span>      <span class="com">(* This DFA minimization algorithm is based on algorithm 3.6 (page
</span><span class="line">  528 </span><span class="com">       142)
</span><span class="line">  529 </span><span class="com">       * of Compilers: Principles, Techniques, and Tools by Aho, Sethi,
</span><span class="line">  530 </span><span class="com">       and
</span><span class="line">  531 </span><span class="com">       * Ullman.
</span><span class="line">  532 </span><span class="com">       *
</span><span class="line">  533 </span><span class="com">       * It maintains an array, r, that stores for each state s the
</span><span class="line">  534 </span><span class="com">       * representative of the class to which s belongs.
</span><span class="line">  535 </span><span class="com">       * It repeatedly refines an equivalence relation, represented by a
</span><span class="line">  536 </span><span class="com">       list
</span><span class="line">  537 </span><span class="com">       * of classes, where each class is a list of states (i.e. ints).
</span><span class="line">  538 </span><span class="com">       *)</span>
<span class="line">  539 </span>      <span class="key">fun </span>minimize (dfa <span class="key">as </span>T {anchorStart, final, start, next, ...}): t =
<span class="line">  540 </span>     <span class="key">let
</span><span class="line">  541 </span><span class="key">        val </span>numStates = numStates dfa
<span class="line">  542 </span>        <span class="key">type </span>class = <span class="typ">int </span>list
<span class="line">  543 </span>        <span class="key">type </span>classes = class list
<span class="line">  544 </span>        <span class="key">val </span>repCounter = ref ~<span class="num">1
</span><span class="line">  545 </span><span class="num">        </span><span class="key">val </span>change = ref <span class="key">false
</span><span class="line">  546 </span><span class="key">        fun </span>newRep () = (change := <span class="key">true</span>; ++ repCounter)
<span class="line">  547 </span>        <span class="key">val </span>finRep = newRep ()
<span class="line">  548 </span>        <span class="key">val </span>nonfinRep = newRep ()
<span class="line">  549 </span>        <span class="key">val </span>r = Array.tabulate (numStates, <span class="key">fn </span>i =&gt;
<span class="line">  550 </span>                    <span class="key">if </span>Array.sub (final, i)
<span class="line">  551 </span>                       <span class="key">then </span>finRep
<span class="line">  552 </span>                    <span class="key">else </span>nonfinRep)
<span class="line">  553 </span>        <span class="key">fun </span>rep s = Array.sub (r, s)
<span class="line">  554 </span>        <span class="key">fun </span>trans (s, c) = rep (Array2.sub (next, s, c))
<span class="line">  555 </span>        <span class="key">fun </span>refine (class: class, ac: classes): classes =
<span class="line">  556 </span>           <span class="key">let
</span><span class="line">  557 </span><span class="key">          val </span>r =
<span class="line">  558 </span>             <span class="key">List</span>.fold
<span class="line">  559 </span>             (class, [], <span class="key">fn </span>(state, classes) =&gt;
<span class="line">  560 </span>              <span class="key">let
</span><span class="line">  561 </span><span class="key">             fun </span>loop (classes, ac) =
<span class="line">  562 </span>                <span class="key">case </span>classes <span class="key">of
</span><span class="line">  563 </span><span class="key">                   </span>[] =&gt;
<span class="line">  564 </span>                  (<span class="key">case </span>ac <span class="key">of
</span><span class="line">  565 </span><span class="key">                      </span>[] =&gt; [{class = [state],
<span class="line">  566 </span>                          old = state}]
<span class="line">  567 </span>                    | _ =&gt;
<span class="line">  568 </span>                     <span class="key">let
</span><span class="line">  569 </span><span class="key">                        val </span>s = newRep ()
<span class="line">  570 </span>                        <span class="key">val </span>_ = Array.update (r, state, s)
<span class="line">  571 </span>                     <span class="key">in </span>{class = [state],
<span class="line">  572 </span>                         old = state} :: ac
<span class="line">  573 </span>                     <span class="key">end</span>)
<span class="line">  574 </span>                 | (z <span class="key">as </span>{class, old}) :: classes =&gt;
<span class="line">  575 </span>                  <span class="key">if Int</span>.forall
<span class="line">  576 </span>                     (<span class="num">0</span>, numChars, <span class="key">fn </span>c =&gt;
<span class="line">  577 </span>                      trans (old, c) = trans (state, c))
<span class="line">  578 </span>                     <span class="key">then
</span><span class="line">  579 </span><span class="key">                    </span>(Array.update (r, state, rep old)
<span class="line">  580 </span>                     ; {class = state :: class,
<span class="line">  581 </span>                        old = old} :: (<span class="key">List</span>.appendRev
<span class="line">  582 </span>                               (classes, ac)))
<span class="line">  583 </span>                  <span class="key">else </span>loop (classes, z :: ac)
<span class="line">  584 </span>              <span class="key">in </span>loop (classes, [])
<span class="line">  585 </span>              <span class="key">end</span>)
<span class="line">  586 </span>           <span class="key">in List</span>.fold (r, ac, <span class="key">fn </span>({class, ...}, ac) =&gt;
<span class="line">  587 </span>                 <span class="key">case </span>class <span class="key">of
</span><span class="line">  588 </span><span class="key">                </span>[_] =&gt; ac
<span class="line">  589 </span>                  | _ =&gt; class :: ac)
<span class="line">  590 </span>           <span class="key">end
</span><span class="line">  591 </span><span class="key">        fun </span>refineAll (classes: classes): unit =
<span class="line">  592 </span>           <span class="key">case </span>classes <span class="key">of
</span><span class="line">  593 </span><span class="key">          </span>[] =&gt; ()
<span class="line">  594 </span>        | _ =&gt;
<span class="line">  595 </span>             <span class="key">let
</span><span class="line">  596 </span><span class="key">            val </span>_ = change := <span class="key">false
</span><span class="line">  597 </span><span class="key">            val </span>classes =
<span class="line">  598 </span>               <span class="key">List</span>.fold (classes, [], <span class="key">fn </span>(class, ac) =&gt;
<span class="line">  599 </span>                      <span class="key">case </span>class <span class="key">of
</span><span class="line">  600 </span><span class="key">                     </span>[_] =&gt; ac
<span class="line">  601 </span>                       | _ =&gt; refine (class, ac))
<span class="line">  602 </span>             <span class="key">in if </span>!change
<span class="line">  603 </span>               <span class="key">then </span>refineAll classes
<span class="line">  604 </span>            <span class="key">else </span>()
<span class="line">  605 </span>             <span class="key">end
</span><span class="line">  606 </span><span class="key">        val </span>(fin, nonfin) =
<span class="line">  607 </span>           <span class="key">Int</span>.fold (<span class="num">0</span>, numStates, ([], []), <span class="key">fn </span>(i, (f, n)) =&gt;
<span class="line">  608 </span>             <span class="key">if </span>Array.sub (final, i)
<span class="line">  609 </span>                <span class="key">then </span>(i :: f, n)
<span class="line">  610 </span>             <span class="key">else </span>(f, i :: n))
<span class="line">  611 </span>        <span class="key">val </span>_ = refineAll [fin, nonfin]
<span class="line">  612 </span>        <span class="key">val </span>numStates' = <span class="num">1 </span>+ !repCounter
<span class="line">  613 </span>        <span class="com">(* Compute reachable states. *)</span>
<span class="line">  614 </span>        <span class="key">val </span>reached = Array.new (numStates', <span class="key">false</span>)
<span class="line">  615 </span>        <span class="key">fun </span>visit (s: <span class="typ">int </span><span class="com">(* an old state *)</span>): unit =
<span class="line">  616 </span>           <span class="key">let
</span><span class="line">  617 </span><span class="key">          val </span>s' = rep s
<span class="line">  618 </span>           <span class="key">in
</span><span class="line">  619 </span><span class="key">          if </span>Array.sub (reached, s')
<span class="line">  620 </span>             <span class="key">then </span>()
<span class="line">  621 </span>          <span class="key">else </span>(Array.update (reached, s', <span class="key">true</span>)
<span class="line">  622 </span>            ; <span class="key">Int</span>.for (<span class="num">0</span>, numChars, <span class="key">fn </span>c =&gt;
<span class="line">  623 </span>                   visit (Array2.sub (next, s, c))))
<span class="line">  624 </span>           <span class="key">end
</span><span class="line">  625 </span><span class="key">        val </span>_ = visit start
<span class="line">  626 </span>        <span class="key">val </span>_ = visit anchorStart
<span class="line">  627 </span>        <span class="com">(* Compute new representatives. *)</span>
<span class="line">  628 </span>        <span class="key">val </span>c = ref ~<span class="num">1
</span><span class="line">  629 </span><span class="num">        </span><span class="key">val </span>newR = Array.tabulate (numStates', <span class="key">fn </span>s =&gt;
<span class="line">  630 </span>                       <span class="key">if </span>Array.sub (reached, s)
<span class="line">  631 </span>                      <span class="key">then </span>++ c
<span class="line">  632 </span>                       <span class="key">else </span>~<span class="num">1</span>)
<span class="line">  633 </span>        <span class="key">val </span>numStates' = <span class="num">1 </span>+ !c
<span class="line">  634 </span>        <span class="key">val </span>_ = Array.modify (r, <span class="key">fn </span>s =&gt; Array.sub (newR, s))
<span class="line">  635 </span>        <span class="key">val </span>next' = Array2.new (numStates', numChars, ~<span class="num">1</span>)
<span class="line">  636 </span>        <span class="key">val </span>_ =
<span class="line">  637 </span>           Array2.foreachi
<span class="line">  638 </span>           (next, <span class="key">fn </span>(s, c, s') =&gt;
<span class="line">  639 </span>        Array2.update (next', rep s, c, rep s'))
<span class="line">  640 </span>        <span class="key">val </span>final' = Array.array (numStates', <span class="key">false</span>)
<span class="line">  641 </span>        <span class="key">val </span>_ =
<span class="line">  642 </span>           Array.foreachi
<span class="line">  643 </span>           (final, <span class="key">fn </span>(i, b) =&gt;
<span class="line">  644 </span>        <span class="key">if </span>b <span class="key">then </span>Array.update (final', rep i, <span class="key">true</span>) <span class="key">else </span>())
<span class="line">  645 </span>     <span class="key">in </span>T {anchorStart = rep anchorStart,
<span class="line">  646 </span>           dead = dead (numStates', final', next'),
<span class="line">  647 </span>           final = final',
<span class="line">  648 </span>           start = rep start,
<span class="line">  649 </span>           next = next'}
<span class="line">  650 </span>     <span class="key">end
</span><span class="line">  651 </span><span class="key">
</span><span class="line">  652 </span><span class="key">      </span><span class="com">(* This is the usual &quot;subset construction&quot;, as in algorithm 3.2 (
</span><span class="line">  653 </span><span class="com">       page 118)
</span><span class="line">  654 </span><span class="com">       * of Compilers: Principles, Techniques, and Tools by Aho, Sethi,
</span><span class="line">  655 </span><span class="com">       and
</span><span class="line">  656 </span><span class="com">       * Ullman.
</span><span class="line">  657 </span><span class="com">       *
</span><span class="line">  658 </span><span class="com">       * It associates each (reachable) set of states in the nfa with a
</span><span class="line">  659 </span><span class="com">                             single
</span><span class="line">  660 </span><span class="com">       * state in the DFA.
</span><span class="line">  661 </span><span class="com">       *)</span>
<span class="line">  662 </span>      <span class="key">fun </span>fromNFA (nfa <span class="key">as </span>NFA.T {anchorStarts, final, start, next, ...}) =
<span class="line">  663 </span>     <span class="key">let
</span><span class="line">  664 </span><span class="key">        </span><span class="com">(* Sets of states are represented as sorted vectors. *)</span>
<span class="line">  665 </span>        <span class="key">type </span>states = state vector
<span class="line">  666 </span>        <span class="key">val </span>counter = ref ~<span class="num">1
</span><span class="line">  667 </span><span class="num">        </span><span class="key">type </span>work = {states: states,
<span class="line">  668 </span>             state: <span class="typ">int</span>,
<span class="line">  669 </span>             out: <span class="typ">int </span>vector option ref}
<span class="line">  670 </span>        <span class="key">val </span>cache: work list ref = ref []
<span class="line">  671 </span>        <span class="key">val </span>todo: work list ref = ref []
<span class="line">  672 </span>        <span class="key">fun </span>statesToState (ss: states): <span class="typ">int </span>=
<span class="line">  673 </span>           <span class="key">case List</span>.peek (!cache, <span class="key">fn </span>{states, ...} =&gt; ss = states) <span class="key">of
</span><span class="line">  674 </span><span class="key">          </span>NONE =&gt;
<span class="line">  675 </span>             <span class="key">let
</span><span class="line">  676 </span><span class="key">            val </span>state = ++ counter
<span class="line">  677 </span>            <span class="key">val </span>work = {out = ref NONE,
<span class="line">  678 </span>                    state = state,
<span class="line">  679 </span>                    states = ss}
<span class="line">  680 </span>            <span class="key">val </span>_ = <span class="key">List</span>.push (cache, work)
<span class="line">  681 </span>            <span class="key">val </span>_ = <span class="key">List</span>.push (todo, work)
<span class="line">  682 </span>             <span class="key">in
</span><span class="line">  683 </span><span class="key">            </span>state
<span class="line">  684 </span>             <span class="key">end
</span><span class="line">  685 </span><span class="key">        </span>| SOME {state, ...} =&gt; state
<span class="line">  686 </span>        <span class="key">local
</span><span class="line">  687 </span><span class="key">           val </span>seen = Array.array (NFA.numStates nfa, <span class="key">false</span>)
<span class="line">  688 </span>        <span class="key">in
</span><span class="line">  689 </span><span class="key">           fun </span>loop () =
<span class="line">  690 </span>          <span class="key">case </span>!todo <span class="key">of
</span><span class="line">  691 </span><span class="key">             </span>[] =&gt; ()
<span class="line">  692 </span>           | {states, out, ...} :: rest =&gt;
<span class="line">  693 </span>            (todo := rest
<span class="line">  694 </span>             ; out := (SOME
<span class="line">  695 </span>                   (<span class="key">Vector</span>.tabulate
<span class="line">  696 </span>                    (numChars, <span class="key">fn </span>c =&gt;
<span class="line">  697 </span>                     <span class="key">let
</span><span class="line">  698 </span><span class="key">                    val </span>_ =
<span class="line">  699 </span>                       Array.modify (seen, <span class="key">fn </span>_ =&gt; <span class="key">false</span>)
<span class="line">  700 </span>                    <span class="key">val </span>_ =
<span class="line">  701 </span>                       <span class="key">Vector</span>.foreach
<span class="line">  702 </span>                       (states, <span class="key">fn </span>s =&gt;
<span class="line">  703 </span>                        <span class="key">Vector</span>.foreach
<span class="line">  704 </span>                        (Array2.sub (next, s, c), <span class="key">fn </span>s' =&gt;
<span class="line">  705 </span>                         Array.update (seen, s', <span class="key">true</span>)))
<span class="line">  706 </span>                     <span class="key">in </span>statesToState (Array.indices seen)
<span class="line">  707 </span>                     <span class="key">end</span>)))
<span class="line">  708 </span>             ; loop ())
<span class="line">  709 </span>        <span class="key">end
</span><span class="line">  710 </span><span class="key">        </span><span class="com">(* This call to statesToState initializes the worklist. *)</span>
<span class="line">  711 </span>        <span class="key">val </span>start' = statesToState (<span class="key">Vector</span>.new1 start)
<span class="line">  712 </span>        <span class="key">val </span>anchorStart' =
<span class="line">  713 </span>           statesToState
<span class="line">  714 </span>           (<span class="key">Vector</span>.fromList (<span class="key">List</span>.insert (anchorStarts, start, <span class="key">op </span>&lt;=)))
<span class="line">  715 </span>        <span class="key">val </span>_ = loop ()
<span class="line">  716 </span>        <span class="key">val </span>numStates = <span class="num">1 </span>+ !counter
<span class="line">  717 </span>        <span class="key">val </span>next' = Array2.new (numStates, numChars, ~<span class="num">1</span>)
<span class="line">  718 </span>        <span class="key">val </span>final' = Array.new (numStates, <span class="key">false</span>)
<span class="line">  719 </span>        <span class="key">val </span>_ =
<span class="line">  720 </span>           <span class="key">List</span>.foreach
<span class="line">  721 </span>           (!cache, <span class="key">fn </span>{states, state = i, out, ...}: work =&gt;
<span class="line">  722 </span>        <span class="key">let
</span><span class="line">  723 </span><span class="key">           val </span>_ =
<span class="line">  724 </span>              <span class="key">Vector</span>.foreachi
<span class="line">  725 </span>              (valOf (! out), <span class="key">fn </span>(c, j) =&gt;
<span class="line">  726 </span>               Array2.update (next', i, c, j))
<span class="line">  727 </span>           <span class="key">val </span>_ =
<span class="line">  728 </span>              <span class="key">if Vector</span>.exists (states, <span class="key">fn </span>s =&gt; Array.sub (final, s))
<span class="line">  729 </span>             <span class="key">then </span>Array.update (final', i, <span class="key">true</span>)
<span class="line">  730 </span>              <span class="key">else </span>()
<span class="line">  731 </span>        <span class="key">in </span>()
<span class="line">  732 </span>        <span class="key">end</span>)
<span class="line">  733 </span>        <span class="key">val </span>dead' = dead (numStates, final', next')
<span class="line">  734 </span>     <span class="key">in </span>T {anchorStart = anchorStart',
<span class="line">  735 </span>           dead = dead',
<span class="line">  736 </span>           final = final',
<span class="line">  737 </span>           start = start',
<span class="line">  738 </span>           next = next'}
<span class="line">  739 </span>     <span class="key">end
</span><span class="line">  740 </span><span class="key">
</span><span class="line">  741 </span><span class="key">   end
</span><span class="line">  742 </span><span class="key">
</span><span class="line">  743 </span><span class="key">structure </span>Regexp:
<span class="line">  744 </span>   <span class="key">sig
</span><span class="line">  745 </span><span class="key">      structure </span>Compiled:
<span class="line">  746 </span>     <span class="key">sig
</span><span class="line">  747 </span><span class="key">        type </span>t
<span class="line">  748 </span>
<span class="line">  749 </span>        <span class="com">(* find returns the longest of the leftmost matches. *)</span>
<span class="line">  750 </span>        <span class="key">val </span>find: t * <span class="typ">string </span>-&gt; {start: <span class="typ">int</span>, length: <span class="typ">int</span>} option
<span class="line">  751 </span>     <span class="key">end
</span><span class="line">  752 </span><span class="key">
</span><span class="line">  753 </span><span class="key">      type </span>t
<span class="line">  754 </span>
<span class="line">  755 </span>      <span class="key">val </span>anchorStart: t
<span class="line">  756 </span>      <span class="key">val </span>any: t
<span class="line">  757 </span>      <span class="key">val </span>char: char -&gt; t
<span class="line">  758 </span>      <span class="key">val </span>compileDFA: t -&gt; Compiled.t
<span class="line">  759 </span>      <span class="key">val </span>compileNFA: t -&gt; Compiled.t
<span class="line">  760 </span>      <span class="key">val </span>digit: t
<span class="line">  761 </span>      <span class="key">val </span>nonDigit: t
<span class="line">  762 </span>      <span class="key">val </span>notOneOf: <span class="typ">string </span>-&gt; t
<span class="line">  763 </span>      <span class="key">val </span>oneOf: <span class="typ">string </span>-&gt; t
<span class="line">  764 </span>      <span class="key">val </span>or: t list -&gt; t
<span class="line">  765 </span>      <span class="key">val </span>seq: t list -&gt; t
<span class="line">  766 </span>      <span class="key">val </span>star: t -&gt; t
<span class="line">  767 </span>   <span class="key">end </span>=
<span class="line">  768 </span>   <span class="key">struct
</span><span class="line">  769 </span><span class="key">      open </span>Regexp
<span class="line">  770 </span>
<span class="line">  771 </span>      <span class="key">val </span>anchorStart = AnchorStart
<span class="line">  772 </span>      <span class="key">val </span>isChar = CharSet
<span class="line">  773 </span>      <span class="key">fun </span>isNotChar f = isChar (not <span class="key">o </span>f)
<span class="line">  774 </span>      <span class="key">fun </span>char c = isChar (<span class="key">fn </span>c' =&gt; c = c')
<span class="line">  775 </span>      <span class="key">val </span>or = Or
<span class="line">  776 </span>      <span class="key">val </span>seq = Seq
<span class="line">  777 </span>      <span class="key">val </span>star = Star
<span class="line">  778 </span>
<span class="line">  779 </span>      <span class="key">val </span>any = isChar (<span class="key">fn </span>_ =&gt; <span class="key">true</span>)
<span class="line">  780 </span>
<span class="line">  781 </span>      <span class="key">fun </span>oneOf s = isChar (<span class="key">fn </span>c =&gt; <span class="key">String</span>.contains (s, c))
<span class="line">  782 </span>      <span class="key">fun </span>notOneOf s = isNotChar (<span class="key">fn </span>c =&gt; <span class="key">String</span>.contains (s, c))
<span class="line">  783 </span>      <span class="key">val </span>digs = <span class="str">&quot;0123456789&quot;</span>
<span class="line">  784 </span>      <span class="key">val </span>digit = oneOf digs
<span class="line">  785 </span>      <span class="key">val </span>nonDigit = notOneOf digs
<span class="line">  786 </span>
<span class="line">  787 </span>      <span class="key">val </span>empty = Or [] <span class="com">(* Empty Language. *)</span>
<span class="line">  788 </span>      <span class="key">val </span>emptyString = Seq [] <span class="com">(* Language containing the empty string
</span><span class="line">  789 </span><span class="com">                        only. *)</span>
<span class="line">  790 </span>
<span class="line">  791 </span>
<span class="line">  792 </span>      <span class="key">structure </span>Compiled =
<span class="line">  793 </span>     <span class="key">struct
</span><span class="line">  794 </span><span class="key">        datatype </span>t =
<span class="line">  795 </span>           DFA <span class="key">of </span>DFA.t
<span class="line">  796 </span>         | NFA <span class="key">of </span>NFA.t
<span class="line">  797 </span>
<span class="line">  798 </span>        <span class="key">fun </span>find (c: t, s: <span class="typ">string</span>) =
<span class="line">  799 </span>           <span class="key">let
</span><span class="line">  800 </span><span class="key">          val </span>n = <span class="key">String</span>.size s
<span class="line">  801 </span>          <span class="key">fun </span>loop (i: <span class="typ">int</span>, anchorStart: <span class="typ">bool</span>) =
<span class="line">  802 </span>             <span class="key">if </span>i = n
<span class="line">  803 </span>            <span class="key">then </span>NONE
<span class="line">  804 </span>             <span class="key">else
</span><span class="line">  805 </span><span class="key">            let
</span><span class="line">  806 </span><span class="key">               val </span>res =
<span class="line">  807 </span>                  <span class="key">case </span>c <span class="key">of
</span><span class="line">  808 </span><span class="key">                 </span>DFA dfa =&gt;
<span class="line">  809 </span>                    DFA.match {dfa = dfa,
<span class="line">  810 </span>                           <span class="typ">string </span>= s,
<span class="line">  811 </span>                           startPos = i,
<span class="line">  812 </span>                           anchorStart = anchorStart}
<span class="line">  813 </span>                   | NFA nfa =&gt;
<span class="line">  814 </span>                    NFA.match {nfa = nfa,
<span class="line">  815 </span>                           <span class="typ">string </span>= s,
<span class="line">  816 </span>                           startPos = i,
<span class="line">  817 </span>                           anchorStart = anchorStart}
<span class="line">  818 </span>            <span class="key">in
</span><span class="line">  819 </span><span class="key">               case </span>res <span class="key">of
</span><span class="line">  820 </span><span class="key">                  </span>NONE =&gt; loop (i + <span class="num">1</span>, <span class="key">false</span>)
<span class="line">  821 </span>                | SOME finish =&gt; SOME {start = i,
<span class="line">  822 </span>                           length = finish - i}
<span class="line">  823 </span>            <span class="key">end
</span><span class="line">  824 </span><span class="key">           in </span>loop (<span class="num">0</span>, <span class="key">true</span>)
<span class="line">  825 </span>           <span class="key">end
</span><span class="line">  826 </span><span class="key">     end
</span><span class="line">  827 </span><span class="key">
</span><span class="line">  828 </span><span class="key">      fun </span>compileDFA r =
<span class="line">  829 </span>     Compiled.DFA (DFA.minimize (DFA.fromNFA (NFA.fromRegexp r)))
<span class="line">  830 </span>      <span class="key">fun </span>compileNFA r =
<span class="line">  831 </span>     Compiled.NFA (NFA.fromRegexp r)
<span class="line">  832 </span>   <span class="key">end
</span><span class="line">  833 </span><span class="key">
</span><span class="line">  834 </span><span class="key">local
</span><span class="line">  835 </span><span class="key">   open </span>Regexp
<span class="line">  836 </span><span class="key">in
</span><span class="line">  837 </span><span class="key">   val </span>d = digit
<span class="line">  838 </span>   <span class="key">val </span>eol = char #<span class="str">&quot;#&quot;</span>
<span class="line">  839 </span>   <span class="key">val </span>space = oneOf <span class="str">&quot; </span><span class="esc">\t</span><span class="str">&quot;</span>
<span class="line">  840 </span>   <span class="key">val </span>r =
<span class="line">  841 </span>      seq [or [anchorStart, notOneOf <span class="str">&quot;0123456789(&quot;</span>],
<span class="line">  842 </span>       or [seq [char #<span class="str">&quot;(&quot;</span>, d, d, d, char #<span class="str">&quot;)&quot;</span>],
<span class="line">  843 </span>           seq [d, d, d]],
<span class="line">  844 </span>       char #<span class="str">&quot; &quot;</span>,
<span class="line">  845 </span>       d, d, d,
<span class="line">  846 </span>       oneOf <span class="str">&quot; -&quot;</span>,
<span class="line">  847 </span>       d, d, d, d,
<span class="line">  848 </span>       or [eol, nonDigit]]
<span class="line">  849 </span><span class="com">(*   val comp = Regexp.compileNFA r *)</span>
<span class="line">  850 </span>   <span class="key">val </span>comp = Regexp.compileDFA r
<span class="line">  851 </span><span class="key">end
</span><span class="line">  852 </span><span class="key">
</span><span class="line">  853 </span><span class="key">fun </span>incr (r: <span class="typ">int </span>ref) = r := !r + <span class="num">1
</span><span class="line">  854 </span><span class="num">
</span><span class="line">  855 </span><span class="num"></span><span class="key">val </span>ins = <span class="key">TextIO</span>.stdIn
<span class="line">  856 </span>
<span class="line">  857 </span>
<span class="line">  858 </span>
<span class="line">  859 </span><span class="key">fun </span>printl [] = print <span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span> | printl(h::t) = ( print h ; printl t )
<span class="line">  860 </span>
<span class="line">  861 </span><span class="com">(* Based on regexmatch.ocaml. *)</span>
<span class="line">  862 </span>
<span class="line">  863 </span><span class="key">local
</span><span class="line">  864 </span><span class="key">   val </span>form = <span class="str">&quot;(...) ...-....&quot;</span>
<span class="line">  865 </span>   <span class="key">val </span>a = CharArray.tabulate (<span class="key">String</span>.size form, <span class="key">fn </span>i =&gt;
<span class="line">  866 </span>                   <span class="key">String</span>.sub (form, i))
<span class="line">  867 </span><span class="key">in
</span><span class="line">  868 </span><span class="key">   fun </span>checkPhone (mustPrint: <span class="typ">bool</span>, cnt: <span class="typ">int </span>ref, line: <span class="typ">string</span>) =
<span class="line">  869 </span>      <span class="key">case </span>Regexp.Compiled.find (comp, line) <span class="key">of
</span><span class="line">  870 </span><span class="key">     </span>NONE =&gt; ()
<span class="line">  871 </span>       | SOME {start = pos, ...} =&gt;
<span class="line">  872 </span>        <span class="key">let
</span><span class="line">  873 </span><span class="key">           fun </span>blit (src, dst, length) =
<span class="line">  874 </span>          <span class="key">let
</span><span class="line">  875 </span><span class="key">             val </span>stop = src + length
<span class="line">  876 </span>             <span class="key">fun </span>loop (src, dst) =
<span class="line">  877 </span>            <span class="key">if </span>src = stop
<span class="line">  878 </span>               <span class="key">then </span>()
<span class="line">  879 </span>            <span class="key">else </span>(CharArray.update (a, dst,
<span class="line">  880 </span>                        <span class="key">String</span>.sub (line, src))
<span class="line">  881 </span>                  ; loop (src + <span class="num">1</span>, dst + <span class="num">1</span>))
<span class="line">  882 </span>          <span class="key">in
</span><span class="line">  883 </span><span class="key">             </span>loop (src, dst)
<span class="line">  884 </span>          <span class="key">end
</span><span class="line">  885 </span><span class="key">           val </span>(o1, o2, o3) =
<span class="line">  886 </span>          <span class="key">if </span>#<span class="str">&quot;(&quot;</span> = <span class="key">String</span>.sub (line, pos)
<span class="line">  887 </span>             <span class="key">then </span>(<span class="num">1</span>, <span class="num">6</span>, <span class="num">10</span>)
<span class="line">  888 </span>          <span class="key">else if </span>#<span class="str">&quot;(&quot;</span> = <span class="key">String</span>.sub (line, pos + <span class="num">1</span>)
<span class="line">  889 </span>              <span class="key">then </span>(<span class="num">2</span>, <span class="num">7</span>, <span class="num">11</span>)
<span class="line">  890 </span>               <span class="key">else if Char</span>.isDigit (<span class="key">String</span>.sub (line, pos))
<span class="line">  891 </span>                   <span class="key">then </span>(<span class="num">0</span>, <span class="num">4</span>, <span class="num">8</span>)
<span class="line">  892 </span>                <span class="key">else </span>(<span class="num">1</span>, <span class="num">5</span>, <span class="num">9</span>)
<span class="line">  893 </span>           <span class="key">val </span>_ = blit (pos + o1, <span class="num">1</span>, <span class="num">3</span>)
<span class="line">  894 </span>           <span class="key">val </span>_ = blit (pos + o2, <span class="num">6</span>, <span class="num">3</span>)
<span class="line">  895 </span>           <span class="key">val </span>_ = blit (pos + o3, <span class="num">10</span>, <span class="num">4</span>)
<span class="line">  896 </span>           <span class="key">val </span>_ =
<span class="line">  897 </span>          <span class="key">if </span>mustPrint
<span class="line">  898 </span>             <span class="key">then </span>printl [<span class="key">Int</span>.toString (!cnt), <span class="str">&quot;: &quot;</span>, CharArray.vector a]
<span class="line">  899 </span>          <span class="key">else </span>()
<span class="line">  900 </span>           <span class="key">val </span>_ = incr cnt
<span class="line">  901 </span>        <span class="key">in
</span><span class="line">  902 </span><span class="key">           </span>()
<span class="line">  903 </span>        <span class="key">end
</span><span class="line">  904 </span><span class="key">end
</span><span class="line">  905 </span><span class="key">
</span><span class="line">  906 </span><span class="key">fun </span>doit (phones,mustPrint: <span class="typ">bool</span>): unit =
<span class="line">  907 </span>   <span class="key">let val </span>cnt = ref <span class="num">1
</span><span class="line">  908 </span><span class="num">   </span><span class="key">in List</span>.foreach (phones, <span class="key">fn </span>line =&gt; checkPhone (mustPrint, cnt, line))
<span class="line">  909 </span>   <span class="key">end
</span><span class="line">  910 </span><span class="key">
</span><span class="line">  911 </span><span class="key">fun </span>atoi s = <span class="key">case Int</span>.fromString s <span class="key">of </span>SOME num =&gt; num | NONE =&gt; <span class="num">0
</span><span class="line">  912 </span><span class="num">
</span><span class="line">  913 </span><span class="num"></span><span class="key">fun </span>main (name, args) =
<span class="line">  914 </span>   <span class="key">let
</span><span class="line">  915 </span><span class="key">      val </span>n = atoi (hd (args &#64; [<span class="str">&quot;1&quot;</span>]))
<span class="line">  916 </span>      <span class="key">val </span>phones =
<span class="line">  917 </span>    <span class="key">let
</span><span class="line">  918 </span><span class="key">      fun </span>loop lines =
<span class="line">  919 </span>        <span class="key">case TextIO</span>.inputLine ins <span class="key">of
</span><span class="line">  920 </span><span class="key">            </span>NONE =&gt; rev lines
<span class="line">  921 </span>          | SOME(str) =&gt;
<span class="line">  922 </span>            (<span class="key">case </span>str <span class="key">of
</span><span class="line">  923 </span><span class="key">             </span><span class="str">&quot;&quot;</span> =&gt; rev lines
<span class="line">  924 </span>               | line =&gt; loop (line :: lines))
<span class="line">  925 </span>    <span class="key">in </span>loop []
<span class="line">  926 </span>    <span class="key">end
</span><span class="line">  927 </span><span class="key">      val </span>_ = <span class="key">Int</span>.for (<span class="num">1</span>, n, <span class="key">fn </span>_ =&gt; doit (phones,<span class="key">false</span>))
<span class="line">  928 </span>      <span class="key">val </span>_ = doit (phones,<span class="key">true</span>)
<span class="line">  929 </span>   <span class="key">in </span>OS.Process.success
<span class="line">  930 </span>   <span class="key">end
</span><span class="line">  931 </span><span class="key">end
</span><span class="line">  932 </span><span class="key">val </span>_ = SMLofNJ.exportFn(<span class="str">&quot;regexmatch&quot;</span>, Test.main);
<span class="line">  933 </span>
</pre>
</body>
</html>
<!--HTML generated by highlight 2.0-24, http://www.andre-simon.de/-->
