<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<title>C:\Fulgham\Projects\shootout\bench\prodcons\prodcons.mlton</title>
	<link rel="stylesheet" type="text/css" href="highlight.css">
</head>
<body>
<pre><span class="line">    1 </span><span class="com">(* -*- mode: sml -*-
</span><span class="line">    2 </span><span class="com"> * $Id: prodcons.mlton.html,v 1.1 2004-06-14 23:09:28 bfulgham Exp $
</span><span class="line">    3 </span><span class="com"> * http://www.bagley.org/~doug/shootout/
</span><span class="line">    4 </span><span class="com"> * from Stephen Weeks
</span><span class="line">    5 </span><span class="com"> *)</span>
<span class="line">    6 </span><span class="com">(* Translated from prodcons.ocaml. *)</span>
<span class="line">    7 </span>
<span class="line">    8 </span><span class="key">fun </span>for (start, stop, f) =
<span class="line">    9 </span>   <span class="key">let
</span><span class="line">   10 </span><span class="key">      fun </span>loop i =
<span class="line">   11 </span>     <span class="key">if </span>i &gt; stop
<span class="line">   12 </span>        <span class="key">then </span>()
<span class="line">   13 </span>     <span class="key">else </span>(f i; loop (i + <span class="num">1</span>))
<span class="line">   14 </span>   <span class="key">in
</span><span class="line">   15 </span><span class="key">      </span>loop start
<span class="line">   16 </span>   <span class="key">end
</span><span class="line">   17 </span><span class="key">
</span><span class="line">   18 </span><span class="key">fun </span>print s = () <span class="com">(* Primitive.Stdio.print s *)</span>
<span class="line">   19 </span>
<span class="line">   20 </span><span class="key">structure </span>Queue:
<span class="line">   21 </span>   <span class="key">sig
</span><span class="line">   22 </span><span class="key">      type </span>'a t
<span class="line">   23 </span>
<span class="line">   24 </span>      <span class="key">val </span>new: unit -&gt; 'a t
<span class="line">   25 </span>      <span class="key">val </span>enque: 'a t * 'a -&gt; unit
<span class="line">   26 </span>      <span class="key">val </span>deque: 'a t -&gt; 'a option
<span class="line">   27 </span>   <span class="key">end </span>=
<span class="line">   28 </span>   <span class="key">struct
</span><span class="line">   29 </span><span class="key">      datatype </span>'a t = T <span class="key">of </span>{front: 'a list ref, back: 'a list ref}
<span class="line">   30 </span>
<span class="line">   31 </span>      <span class="key">fun </span>new () = T {front = ref [], back = ref []}
<span class="line">   32 </span>
<span class="line">   33 </span>      <span class="key">fun </span>enque (T {back, ...}, x) = back := x :: !back
<span class="line">   34 </span>
<span class="line">   35 </span>      <span class="key">fun </span>deque (T {front, back}) =
<span class="line">   36 </span>     <span class="key">case </span>!front <span class="key">of
</span><span class="line">   37 </span><span class="key">        </span>[] =&gt; (<span class="key">case </span>!back <span class="key">of
</span><span class="line">   38 </span><span class="key">              </span>[] =&gt; NONE
<span class="line">   39 </span>            | l =&gt; <span class="key">let val </span>l = rev l
<span class="line">   40 </span>               <span class="key">in case </span>l <span class="key">of
</span><span class="line">   41 </span><span class="key">                  </span>[] =&gt; <span class="key">raise </span>Fail <span class="str">&quot;deque&quot;</span>
<span class="line">   42 </span>                | x :: l =&gt; (back := []; front := l; SOME x)
<span class="line">   43 </span>               <span class="key">end</span>)
<span class="line">   44 </span>      | x :: l =&gt; (front := l; SOME x)
<span class="line">   45 </span>   <span class="key">end
</span><span class="line">   46 </span><span class="key">
</span><span class="line">   47 </span><span class="key">structure </span>Thread:
<span class="line">   48 </span>   <span class="key">sig
</span><span class="line">   49 </span><span class="key">      val </span>exit: unit -&gt; 'a
<span class="line">   50 </span>      <span class="key">val </span>run: unit -&gt; unit
<span class="line">   51 </span>      <span class="key">val </span>spawn: (unit -&gt; unit) -&gt; unit
<span class="line">   52 </span>      <span class="key">val </span>yield: unit -&gt; unit
<span class="line">   53 </span>      <span class="key">structure </span>Mutex:
<span class="line">   54 </span>     <span class="key">sig
</span><span class="line">   55 </span><span class="key">        type </span>t
<span class="line">   56 </span>
<span class="line">   57 </span>        <span class="key">val </span>new: unit -&gt; t
<span class="line">   58 </span>        <span class="key">val </span>lock: t * <span class="typ">string </span>-&gt; unit
<span class="line">   59 </span>        <span class="key">val </span>unlock: t -&gt; unit
<span class="line">   60 </span>     <span class="key">end
</span><span class="line">   61 </span><span class="key">      structure </span>Condition:
<span class="line">   62 </span>           <span class="key">sig
</span><span class="line">   63 </span><span class="key">        type </span>t
<span class="line">   64 </span>
<span class="line">   65 </span>        <span class="key">val </span>new: unit -&gt; t
<span class="line">   66 </span>        <span class="key">val </span>signal: t -&gt; unit
<span class="line">   67 </span>        <span class="key">val </span>wait: t * Mutex.t -&gt; unit
<span class="line">   68 </span>     <span class="key">end
</span><span class="line">   69 </span><span class="key">   end </span>=
<span class="line">   70 </span>   <span class="key">struct
</span><span class="line">   71 </span><span class="key">      open </span>MLton.Itimer
<span class="line">   72 </span>      <span class="key">open </span>MLton.Signal
<span class="line">   73 </span>      <span class="key">open </span>MLton.Thread
<span class="line">   74 </span>
<span class="line">   75 </span>      <span class="key">val </span>topLevel: unit MLton.Thread.t option ref = ref NONE
<span class="line">   76 </span>
<span class="line">   77 </span>      <span class="key">local
</span><span class="line">   78 </span><span class="key">     val </span>threads: unit MLton.Thread.t Queue.t = Queue.new ()
<span class="line">   79 </span>      <span class="key">in
</span><span class="line">   80 </span><span class="key">     fun </span>ready (t): unit = Queue.enque (threads, t)
<span class="line">   81 </span>     <span class="key">fun </span>next () =
<span class="line">   82 </span>        <span class="key">case </span>Queue.deque threads <span class="key">of
</span><span class="line">   83 </span><span class="key">           </span>NONE =&gt; (print <span class="str">&quot;switching to toplevel</span><span class="esc">\n</span><span class="str">&quot;</span>
<span class="line">   84 </span>            ; valOf (!topLevel))
<span class="line">   85 </span>         | SOME t =&gt; t
<span class="line">   86 </span>      <span class="key">end
</span><span class="line">   87 </span><span class="key">
</span><span class="line">   88 </span><span class="key">      fun </span>'a exit (): 'a = switch (<span class="key">fn </span>_ =&gt; (next (), ()))
<span class="line">   89 </span>
<span class="line">   90 </span>      <span class="key">fun </span>new (f: unit -&gt; unit): unit MLton.Thread.t =
<span class="line">   91 </span>     MLton.Thread.new (<span class="key">fn </span>() =&gt; ((f () <span class="key">handle </span>_ =&gt; exit ())
<span class="line">   92 </span>                  ; exit ()))
<span class="line">   93 </span>
<span class="line">   94 </span>      <span class="key">fun </span>schedule t =
<span class="line">   95 </span>     (print <span class="str">&quot;scheduling</span><span class="esc">\n</span><span class="str">&quot;</span>
<span class="line">   96 </span>      ; ready t
<span class="line">   97 </span>      ; next ())
<span class="line">   98 </span>
<span class="line">   99 </span>      <span class="key">fun </span>yield (): unit = switch (<span class="key">fn </span>t =&gt; (schedule t, ()))
<span class="line">  100 </span>
<span class="line">  101 </span>      <span class="key">val </span>spawn = ready <span class="key">o </span>new
<span class="line">  102 </span>
<span class="line">  103 </span>      <span class="key">fun </span>setItimer t =
<span class="line">  104 </span>     MLton.Itimer.set (MLton.Itimer.<span class="key">Real</span>,
<span class="line">  105 </span>             {value = t,
<span class="line">  106 </span>              interval = t})
<span class="line">  107 </span>
<span class="line">  108 </span>      <span class="key">fun </span>run (): unit =
<span class="line">  109 </span>         <span class="key">let
</span><span class="line">  110 </span><span class="key">        val </span>which = MLton.Itimer.<span class="key">Real</span>;
<span class="line">  111 </span>        <span class="key">val </span>signal = MLton.Itimer.signal which;
<span class="line">  112 </span>     <span class="key">in
</span><span class="line">  113 </span><span class="key">     </span>(switch (<span class="key">fn </span>t =&gt;
<span class="line">  114 </span>          (topLevel := SOME t
<span class="line">  115 </span>           ; (new (<span class="key">fn </span>() =&gt; (MLton.Signal.setHandler (signal, Handler.handler (
<span class="line">  116 </span>        <span class="key">fn </span>t =&gt; schedule t))
<span class="line">  117 </span>                     ; setItimer (Time.fromMilliseconds <span class="num">20</span>))),
<span class="line">  118 </span>              ())))
<span class="line">  119 </span>      ; setItimer Time.zeroTime
<span class="line">  120 </span>      ; MLton.Signal.setHandler (signal, MLton.Signal.Handler.ignore)
<span class="line">  121 </span>      ; topLevel := NONE)
<span class="line">  122 </span>      <span class="key">end
</span><span class="line">  123 </span><span class="key">
</span><span class="line">  124 </span><span class="key">      structure </span>Mutex =
<span class="line">  125 </span>     <span class="key">struct
</span><span class="line">  126 </span><span class="key">        datatype </span>t = T <span class="key">of </span>{locked: <span class="typ">bool </span>ref,
<span class="line">  127 </span>                   waiting: unit MLton.Thread.t Queue.t}
<span class="line">  128 </span>
<span class="line">  129 </span>        <span class="key">fun </span>new () =
<span class="line">  130 </span>           T {locked = ref <span class="key">false</span>,
<span class="line">  131 </span>          waiting = Queue.new ()}
<span class="line">  132 </span>
<span class="line">  133 </span>        <span class="key">fun </span>lock (T {locked, waiting, ...}, name) =
<span class="line">  134 </span>           <span class="key">let
</span><span class="line">  135 </span><span class="key">          fun </span>loop () =
<span class="line">  136 </span>             (print (concat [name, <span class="str">&quot; lock looping</span><span class="esc">\n</span><span class="str">&quot;</span>])
<span class="line">  137 </span>              ; MLton.Thread.atomicBegin ()
<span class="line">  138 </span>              ; <span class="key">if </span>!locked
<span class="line">  139 </span>               <span class="key">then </span>(print <span class="str">&quot;mutex is locked</span><span class="esc">\n</span><span class="str">&quot;</span>
<span class="line">  140 </span>                 ; switch (<span class="key">fn </span>t =&gt;
<span class="line">  141 </span>                       (MLton.Thread.atomicEnd ()
<span class="line">  142 </span>                        ; Queue.enque (waiting, t)
<span class="line">  143 </span>                        ; (next (), ())))
<span class="line">  144 </span>                 ; loop ())
<span class="line">  145 </span>            <span class="key">else </span>(print <span class="str">&quot;mutex is not locked</span><span class="esc">\n</span><span class="str">&quot;</span>
<span class="line">  146 </span>                  ; locked := <span class="key">true
</span><span class="line">  147 </span><span class="key">                  </span>; MLton.Thread.atomicEnd ()))
<span class="line">  148 </span>           <span class="key">in </span>loop ()
<span class="line">  149 </span>           <span class="key">end
</span><span class="line">  150 </span><span class="key">
</span><span class="line">  151 </span><span class="key">        fun </span>safeUnlock (T {locked, waiting, ...}) =
<span class="line">  152 </span>           (locked := <span class="key">false
</span><span class="line">  153 </span><span class="key">        </span>; (<span class="key">case </span>Queue.deque waiting <span class="key">of
</span><span class="line">  154 </span><span class="key">              </span>NONE =&gt; ()
<span class="line">  155 </span>            | SOME t =&gt; (print <span class="str">&quot;unlock found waiting thread</span><span class="esc">\n</span><span class="str">&quot;</span>
<span class="line">  156 </span>                 ; ready t)))
<span class="line">  157 </span>
<span class="line">  158 </span>        <span class="key">fun </span>unlock (m: t) =
<span class="line">  159 </span>           (print <span class="str">&quot;unlock atomicBegin</span><span class="esc">\n</span><span class="str">&quot;</span>
<span class="line">  160 </span>        ; MLton.Thread.atomicBegin ()
<span class="line">  161 </span>        ; safeUnlock m
<span class="line">  162 </span>        ; MLton.Thread.atomicEnd ())
<span class="line">  163 </span>     <span class="key">end
</span><span class="line">  164 </span><span class="key">
</span><span class="line">  165 </span><span class="key">      structure </span>Condition =
<span class="line">  166 </span>     <span class="key">struct
</span><span class="line">  167 </span><span class="key">        datatype </span>t = T <span class="key">of </span>{waiting: unit MLton.Thread.t Queue.t}
<span class="line">  168 </span>
<span class="line">  169 </span>        <span class="key">fun </span>new () = T {waiting = Queue.new ()}
<span class="line">  170 </span>
<span class="line">  171 </span>        <span class="key">fun </span>wait (T {waiting, ...}, m) =
<span class="line">  172 </span>           (switch (<span class="key">fn </span>t =&gt;
<span class="line">  173 </span>            (Mutex.safeUnlock m
<span class="line">  174 </span>             ; print <span class="str">&quot;wait unlocked mutex</span><span class="esc">\n</span><span class="str">&quot;</span>
<span class="line">  175 </span>             ; Queue.enque (waiting, t)
<span class="line">  176 </span>             ; (next (), ())))
<span class="line">  177 </span>        ; Mutex.lock (m, <span class="str">&quot;wait&quot;</span>))
<span class="line">  178 </span>
<span class="line">  179 </span>        <span class="key">fun </span>signal (T {waiting, ...}) =
<span class="line">  180 </span>           <span class="key">case </span>Queue.deque waiting <span class="key">of
</span><span class="line">  181 </span><span class="key">          </span>NONE =&gt; ()
<span class="line">  182 </span>        | SOME t =&gt; ready t
<span class="line">  183 </span>     <span class="key">end
</span><span class="line">  184 </span><span class="key">
</span><span class="line">  185 </span><span class="key">   end
</span><span class="line">  186 </span><span class="key">
</span><span class="line">  187 </span><span class="key">structure </span>Mutex = Thread.Mutex
<span class="line">  188 </span><span class="key">structure </span>Condition = Thread.Condition
<span class="line">  189 </span>
<span class="line">  190 </span><span class="key">val </span>count = ref <span class="num">0
</span><span class="line">  191 </span><span class="num"></span><span class="key">val </span>data = ref <span class="num">0
</span><span class="line">  192 </span><span class="num"></span><span class="key">val </span>produced = ref <span class="num">0
</span><span class="line">  193 </span><span class="num"></span><span class="key">val </span>consumed = ref <span class="num">0
</span><span class="line">  194 </span><span class="num"></span><span class="key">val </span>m = Mutex.new ()
<span class="line">  195 </span><span class="key">val </span>c = Condition.new ()
<span class="line">  196 </span>
<span class="line">  197 </span><span class="key">fun </span>producer n =
<span class="line">  198 </span>   for (<span class="num">1</span>, n, <span class="key">fn </span>i =&gt;
<span class="line">  199 </span>    (print (concat [<span class="str">&quot;producer acquiring lock &quot;</span>, <span class="key">Int</span>.toString i, <span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span>])
<span class="line">  200 </span>     ; Mutex.lock (m, <span class="str">&quot;producer&quot;</span>)
<span class="line">  201 </span>     ; print <span class="str">&quot;producer acquired lock</span><span class="esc">\n</span><span class="str">&quot;</span>
<span class="line">  202 </span>     ; <span class="key">while </span>!count = <span class="num">1 </span><span class="key">do </span>Condition.wait (c, m)
<span class="line">  203 </span>     ; print <span class="str">&quot;producer passed condition</span><span class="esc">\n</span><span class="str">&quot;</span>
<span class="line">  204 </span>     ; data := i
<span class="line">  205 </span>     ; count := <span class="num">1
</span><span class="line">  206 </span><span class="num">     </span>; Condition.signal c
<span class="line">  207 </span>     ; print <span class="str">&quot;producer releasing lock</span><span class="esc">\n</span><span class="str">&quot;</span>
<span class="line">  208 </span>     ; Mutex.unlock m
<span class="line">  209 </span>     ; print <span class="str">&quot;producer released lock</span><span class="esc">\n</span><span class="str">&quot;</span>
<span class="line">  210 </span>     ; produced := !produced + <span class="num">1</span>))
<span class="line">  211 </span>
<span class="line">  212 </span><span class="key">fun </span>consumer n =
<span class="line">  213 </span>   <span class="key">let val </span>i = ref <span class="num">0
</span><span class="line">  214 </span><span class="num">   </span><span class="key">in
</span><span class="line">  215 </span><span class="key">      while </span>!i &lt;&gt; n <span class="key">do
</span><span class="line">  216 </span><span class="key">     </span>(print (concat [<span class="str">&quot;consumer acquiring lock &quot;</span>, <span class="key">Int</span>.toString (!i), <span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span>])
<span class="line">  217 </span>      ; Mutex.lock (m, <span class="str">&quot;consumer&quot;</span>)
<span class="line">  218 </span>      ; print <span class="str">&quot;consumer acquired lock</span><span class="esc">\n</span><span class="str">&quot;</span>
<span class="line">  219 </span>      ; <span class="key">while </span>!count = <span class="num">0 </span><span class="key">do </span>Condition.wait (c, m)
<span class="line">  220 </span>      ; i := !data
<span class="line">  221 </span>      ; count := <span class="num">0
</span><span class="line">  222 </span><span class="num">      </span>; Condition.signal c
<span class="line">  223 </span>      ; print <span class="str">&quot;consumer releasing lock</span><span class="esc">\n</span><span class="str">&quot;</span>
<span class="line">  224 </span>      ; Mutex.unlock m
<span class="line">  225 </span>      ; print <span class="str">&quot;consumer released lock</span><span class="esc">\n</span><span class="str">&quot;</span>
<span class="line">  226 </span>      ; consumed := !consumed + <span class="num">1</span>)
<span class="line">  227 </span>   <span class="key">end
</span><span class="line">  228 </span><span class="key">
</span><span class="line">  229 </span><span class="key">fun </span>atoi s = <span class="key">case Int</span>.fromString s <span class="key">of </span>SOME num =&gt; num | NONE =&gt; <span class="num">0
</span><span class="line">  230 </span><span class="num"></span><span class="key">fun </span>printl [] = <span class="key">TextIO</span>.print <span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span> | printl (h::t) = ( <span class="key">TextIO</span>.print h ;
<span class="line">  231 </span>                printl t )
<span class="line">  232 </span>
<span class="line">  233 </span><span class="key">fun </span>main (name, args) =
<span class="line">  234 </span>   <span class="key">let
</span><span class="line">  235 </span><span class="key">      val </span>n = atoi (hd (args &#64; [<span class="str">&quot;1&quot;</span>]))
<span class="line">  236 </span>      <span class="key">val </span>p = Thread.spawn (<span class="key">fn </span>() =&gt; producer n)
<span class="line">  237 </span>      <span class="key">val </span>c = Thread.spawn (<span class="key">fn </span>() =&gt; consumer n)
<span class="line">  238 </span>      <span class="key">val </span>_ = Thread.run ()
<span class="line">  239 </span>      <span class="key">val </span>_ = Posix.Process.sleep (Time.fromSeconds <span class="num">1</span>)
<span class="line">  240 </span>      <span class="key">val </span>_ = printl [<span class="key">Int</span>.toString (!produced),
<span class="line">  241 </span>              <span class="str">&quot; &quot;</span>,
<span class="line">  242 </span>              <span class="key">Int</span>.toString (!consumed)]
<span class="line">  243 </span>   <span class="key">in
</span><span class="line">  244 </span><span class="key">      </span>()
<span class="line">  245 </span>   <span class="key">end
</span><span class="line">  246 </span><span class="key">
</span><span class="line">  247 </span><span class="key">val </span>_ = main ( CommandLine.name (), CommandLine.arguments () )
</pre>
</body>
</html>
<!--HTML generated by highlight 2.0-24, http://www.andre-simon.de/-->
