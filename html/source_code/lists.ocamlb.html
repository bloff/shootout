<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<title>C:\Fulgham\Projects\shootout\bench\lists\lists.ocamlb</title>
	<link rel="stylesheet" type="text/css" href="highlight.css">
</head>
<body>
<pre><span class="line">    1 </span><span class="com">(*
</span><span class="line">    2 </span><span class="com"> * $Id: lists.ocamlb.html,v 1.1 2004-06-14 23:09:27 bfulgham Exp $
</span><span class="line">    3 </span><span class="com"> * http://www.bagley.org/~doug/shootout/
</span><span class="line">    4 </span><span class="com"> * from Benedict Rosenau
</span><span class="line">    5 </span><span class="com"> * improved by Jean-Christophe Filliatre
</span><span class="line">    6 </span><span class="com"> *)</span>
<span class="line">    7 </span>
<span class="line">    8 </span><span class="key">module </span>Deque = <span class="key">struct
</span><span class="line">    9 </span><span class="key">  type </span>t = { size: <span class="typ">int</span>; <span class="key">mutable </span>first: <span class="typ">int</span>; <span class="key">mutable </span>last: <span class="typ">int</span>; fld: <span class="typ">int
</span><span class="line">   10 </span><span class="typ">           </span>array }
<span class="line">   11 </span>
<span class="line">   12 </span>  <span class="key">exception </span>Empty
<span class="line">   13 </span>  <span class="key">exception </span>Full
<span class="line">   14 </span>
<span class="line">   15 </span>  <span class="key">let </span>empty n =
<span class="line">   16 </span>    <span class="key">let </span>n = max (succ n) <span class="num">1 </span><span class="key">in
</span><span class="line">   17 </span><span class="key">    </span>{ size = n; first = <span class="num">0</span>; last = <span class="num">0</span>; fld = Array.make n <span class="num">0 </span>}
<span class="line">   18 </span>
<span class="line">   19 </span>  <span class="key">let </span>iota n =
<span class="line">   20 </span>    <span class="key">let </span>size = succ n <span class="key">in
</span><span class="line">   21 </span><span class="key">    </span>{ size = size; first = <span class="num">0</span>; last = n; fld = Array.init size succ }
<span class="line">   22 </span>
<span class="line">   23 </span>  <span class="key">let </span>up n s = <span class="key">if </span>n &lt; <span class="num">0 </span><span class="key">then </span>n + s <span class="key">else </span>n
<span class="line">   24 </span>  <span class="key">let </span>down n s = <span class="key">if </span>n &gt;= s <span class="key">then </span>n - s <span class="key">else </span>n
<span class="line">   25 </span>  <span class="key">let </span>one_up n s = <span class="key">if </span>n == s <span class="num">- 1 </span><span class="key">then </span><span class="num">0 </span><span class="key">else </span>n + <span class="num">1
</span><span class="line">   26 </span><span class="num">  </span><span class="key">let </span>one_down n s = <span class="key">if </span>n == <span class="num">0 </span><span class="key">then </span>s <span class="num">- 1 </span><span class="key">else </span>n <span class="num">- 1
</span><span class="line">   27 </span><span class="num">
</span><span class="line">   28 </span><span class="num">  </span><span class="key">let </span>length q = up (q.last - q.first) q.size
<span class="line">   29 </span>
<span class="line">   30 </span>  <span class="key">let rec </span>array_eq q1 off1 q2 off2 n =
<span class="line">   31 </span>    n == <span class="num">0 </span>||
<span class="line">   32 </span>      q1.fld.(off1) == q2.fld.(off2) &amp;&amp;
<span class="line">   33 </span>      (array_eq q1 (one_up off1 q1.size) q2 (one_up off2 q2.size) (n <span class="num">- 1</span>))
<span class="line">   34 </span>
<span class="line">   35 </span>  <span class="key">let </span>equal q1 q2 =
<span class="line">   36 </span>    <span class="key">let </span>len1 = length q1 <span class="key">in
</span><span class="line">   37 </span><span class="key">    </span>len1 == length q2 &amp;&amp; array_eq q1 q1.first q2 q2.first len1
<span class="line">   38 </span>
<span class="line">   39 </span>  <span class="key">let </span>nth q n =
<span class="line">   40 </span>    <span class="key">if </span>n &lt; <span class="num">0 </span><span class="key">or </span>n &gt;= length q <span class="key">then </span>failwith <span class="str">&quot;nth&quot;</span>;
<span class="line">   41 </span>    q.fld.(down (q.first + n) q.size)
<span class="line">   42 </span>
<span class="line">   43 </span>  <span class="key">let </span>push_back q elem =
<span class="line">   44 </span>    <span class="key">let </span>last<span class="str">' = one_up q.last q.size in
</span><span class="line">   45 </span><span class="str">    if last'</span> == q.first <span class="key">then </span>raise Full;
<span class="line">   46 </span>    q.fld.(q.last) &lt;- elem;
<span class="line">   47 </span>    q.last &lt;- last<span class="str">'
</span><span class="line">   48 </span><span class="str">
</span><span class="line">   49 </span><span class="str">  let take_front q =
</span><span class="line">   50 </span><span class="str">    if q.first == q.last then raise Empty;
</span><span class="line">   51 </span><span class="str">    let old_first = q.first in
</span><span class="line">   52 </span><span class="str">    q.first &lt;- one_up q.first q.size;
</span><span class="line">   53 </span><span class="str">    q.fld.(old_first)
</span><span class="line">   54 </span><span class="str">
</span><span class="line">   55 </span><span class="str">  let take_back q =
</span><span class="line">   56 </span><span class="str">    if q.first == q.last then raise Empty;
</span><span class="line">   57 </span><span class="str">    let new_last = one_down q.last q.size in
</span><span class="line">   58 </span><span class="str">    q.last &lt;- new_last;
</span><span class="line">   59 </span><span class="str">    q.fld.(new_last)
</span><span class="line">   60 </span><span class="str">
</span><span class="line">   61 </span><span class="str">  let copy q =
</span><span class="line">   62 </span><span class="str">    { size = q.size; first = q.first; last = q.last; fld = Array.copy q.
</span><span class="line">   63 </span><span class="str">      fld }
</span><span class="line">   64 </span><span class="str">
</span><span class="line">   65 </span><span class="str">  let reverse q =
</span><span class="line">   66 </span><span class="str">    let w = length q in
</span><span class="line">   67 </span><span class="str">    for i = 0 to (w lsr 1) - 1 do
</span><span class="line">   68 </span><span class="str">      let i1 = down (q.first + i) q.size and i2 = up (q.last - 1 - i) q.
</span><span class="line">   69 </span><span class="str">               size in
</span><span class="line">   70 </span><span class="str">      let v1 = q.fld.(i1) in
</span><span class="line">   71 </span><span class="str">      q.fld.(i1) &lt;- q.fld.(i2);
</span><span class="line">   72 </span><span class="str">      q.fld.(i2) &lt;- v1
</span><span class="line">   73 </span><span class="str">    done
</span><span class="line">   74 </span><span class="str">end
</span><span class="line">   75 </span><span class="str">
</span><span class="line">   76 </span><span class="str">let test_lists () =
</span><span class="line">   77 </span><span class="str">  let size = 10000 in
</span><span class="line">   78 </span><span class="str">  let d1 = Deque.iota size in
</span><span class="line">   79 </span><span class="str">  let d2 = Deque.copy d1
</span><span class="line">   80 </span><span class="str">  and d3 = Deque.empty size in
</span><span class="line">   81 </span><span class="str">  for i = 1 to Deque.length d2 do Deque.push_back d3 (Deque.take_front d2)
</span><span class="line">   82 </span><span class="str">          done;
</span><span class="line">   83 </span><span class="str">  for i = 1 to Deque.length d3 do Deque.push_back d2 (Deque.take_back d3)
</span><span class="line">   84 </span><span class="str">          done;
</span><span class="line">   85 </span><span class="str">  Deque.reverse d1;
</span><span class="line">   86 </span><span class="str">  if size &lt;&gt; Deque.nth d1 0 then failwith &quot;First test failed&quot;;
</span><span class="line">   87 </span><span class="str">  if Deque.length d1 &lt;&gt; Deque.length d2 then failwith &quot;Second test failed&quot;;
</span><span class="line">   88 </span><span class="str">  if not (Deque.equal d1 d2) then failwith &quot;Third test failed&quot;;
</span><span class="line">   89 </span><span class="str">  Deque.length d1
</span><span class="line">   90 </span><span class="str">
</span><span class="line">   91 </span><span class="str">let n = if Array.length Sys.argv &gt; 1 then int_of_string Sys.argv.(1) else
</span><span class="line">   92 </span><span class="str">        1;;
</span><span class="line">   93 </span><span class="str">for i = 2 to n do ignore (test_lists ()) done;
</span><span class="line">   94 </span><span class="str">Printf.printf &quot;%d</span><span class="esc">\n</span><span class="str">&quot; (test_lists ())</span>
</pre>
</body>
</html>
<!--HTML generated by highlight 2.0-24, http://www.andre-simon.de/-->
