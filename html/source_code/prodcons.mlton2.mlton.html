<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<title>C:\Fulgham\Projects\shootout\bench\prodcons\prodcons.mlton2.mlton</title>
	<link rel="stylesheet" type="text/css" href="highlight.css">
</head>
<body>
<pre><span class="line">    1 </span><span class="com">(* -*- mode: sml -*-
</span><span class="line">    2 </span><span class="com"> * $Id: prodcons.mlton2.mlton.html,v 1.1 2004-06-14 23:09:28 bfulgham Exp $
</span><span class="line">    3 </span><span class="com"> * http://www.bagley.org/~doug/shootout/
</span><span class="line">    4 </span><span class="com"> * from Stephen Weeks
</span><span class="line">    5 </span><span class="com"> * this version uses non-preemptive threads
</span><span class="line">    6 </span><span class="com"> *)</span>
<span class="line">    7 </span><span class="com">(* Translated from prodcons.ocaml. *)</span>
<span class="line">    8 </span>
<span class="line">    9 </span><span class="key">functor </span>Z (S: <span class="key">sig
</span><span class="line">   10 </span><span class="key">         structure </span>Primitive:
<span class="line">   11 </span>            <span class="key">sig
</span><span class="line">   12 </span><span class="key">               structure </span>Thread:
<span class="line">   13 </span>              <span class="key">sig
</span><span class="line">   14 </span><span class="key">                 val </span>atomicBegin: unit -&gt; unit
<span class="line">   15 </span>                 <span class="key">val </span>atomicEnd: unit -&gt; unit
<span class="line">   16 </span>              <span class="key">end
</span><span class="line">   17 </span><span class="key">            end
</span><span class="line">   18 </span><span class="key">         structure </span>MLton:
<span class="line">   19 </span>            <span class="key">sig
</span><span class="line">   20 </span><span class="key">               structure </span>Thread:
<span class="line">   21 </span>              <span class="key">sig
</span><span class="line">   22 </span><span class="key">                 type </span>'a t
<span class="line">   23 </span>                 <span class="key">val </span>new: ('a -&gt; unit) -&gt; 'a t
<span class="line">   24 </span>                 <span class="key">val </span>switch: ('a t -&gt; 'b t * 'b) -&gt; 'a
<span class="line">   25 </span>              <span class="key">end
</span><span class="line">   26 </span><span class="key">            end
</span><span class="line">   27 </span><span class="key">          end</span>) =
<span class="line">   28 </span><span class="key">struct
</span><span class="line">   29 </span><span class="key">
</span><span class="line">   30 </span><span class="key">open </span>S
<span class="line">   31 </span>
<span class="line">   32 </span><span class="key">fun </span>for (start, stop, f) =
<span class="line">   33 </span>   <span class="key">let
</span><span class="line">   34 </span><span class="key">      fun </span>loop i =
<span class="line">   35 </span>     <span class="key">if </span>i &gt; stop
<span class="line">   36 </span>        <span class="key">then </span>()
<span class="line">   37 </span>     <span class="key">else </span>(f i; loop (i + <span class="num">1</span>))
<span class="line">   38 </span>   <span class="key">in
</span><span class="line">   39 </span><span class="key">      </span>loop start
<span class="line">   40 </span>   <span class="key">end
</span><span class="line">   41 </span><span class="key">
</span><span class="line">   42 </span><span class="key">structure </span>Queue:
<span class="line">   43 </span>   <span class="key">sig
</span><span class="line">   44 </span><span class="key">      type </span>'a t
<span class="line">   45 </span>
<span class="line">   46 </span>      <span class="key">val </span>new: unit -&gt; 'a t
<span class="line">   47 </span>      <span class="key">val </span>enque: 'a t * 'a -&gt; unit
<span class="line">   48 </span>      <span class="key">val </span>deque: 'a t -&gt; 'a option
<span class="line">   49 </span>   <span class="key">end </span>=
<span class="line">   50 </span>   <span class="key">struct
</span><span class="line">   51 </span><span class="key">      datatype </span>'a t = T <span class="key">of </span>{front: 'a list ref, back: 'a list ref}
<span class="line">   52 </span>
<span class="line">   53 </span>      <span class="key">fun </span>new () = T {front = ref [], back = ref []}
<span class="line">   54 </span>
<span class="line">   55 </span>      <span class="key">fun </span>enque (T {back, ...}, x) = back := x :: !back
<span class="line">   56 </span>
<span class="line">   57 </span>      <span class="key">fun </span>deque (T {front, back}) =
<span class="line">   58 </span>     <span class="key">case </span>!front <span class="key">of
</span><span class="line">   59 </span><span class="key">        </span>[] =&gt; (<span class="key">case </span>!back <span class="key">of
</span><span class="line">   60 </span><span class="key">              </span>[] =&gt; NONE
<span class="line">   61 </span>            | l =&gt; <span class="key">let val </span>l = rev l
<span class="line">   62 </span>               <span class="key">in case </span>l <span class="key">of
</span><span class="line">   63 </span><span class="key">                  </span>[] =&gt; <span class="key">raise </span>Fail <span class="str">&quot;deque&quot;</span>
<span class="line">   64 </span>                | x :: l =&gt; (back := []; front := l; SOME x)
<span class="line">   65 </span>               <span class="key">end</span>)
<span class="line">   66 </span>      | x :: l =&gt; (front := l; SOME x)
<span class="line">   67 </span>   <span class="key">end
</span><span class="line">   68 </span><span class="key">
</span><span class="line">   69 </span><span class="key">structure </span>Thread:
<span class="line">   70 </span>   <span class="key">sig
</span><span class="line">   71 </span><span class="key">      val </span>exit: unit -&gt; 'a
<span class="line">   72 </span>      <span class="key">val </span>run: unit -&gt; unit
<span class="line">   73 </span>      <span class="key">val </span>spawn: (unit -&gt; unit) -&gt; unit
<span class="line">   74 </span>      <span class="key">val </span>yield: unit -&gt; unit
<span class="line">   75 </span>      <span class="key">structure </span>Mutex:
<span class="line">   76 </span>     <span class="key">sig
</span><span class="line">   77 </span><span class="key">        type </span>t
<span class="line">   78 </span>
<span class="line">   79 </span>        <span class="key">val </span>new: unit -&gt; t
<span class="line">   80 </span>        <span class="key">val </span>lock: t -&gt; unit
<span class="line">   81 </span>        <span class="key">val </span>unlock: t -&gt; unit
<span class="line">   82 </span>     <span class="key">end
</span><span class="line">   83 </span><span class="key">      structure </span>Condition:
<span class="line">   84 </span>           <span class="key">sig
</span><span class="line">   85 </span><span class="key">        type </span>t
<span class="line">   86 </span>
<span class="line">   87 </span>        <span class="key">val </span>new: unit -&gt; t
<span class="line">   88 </span>        <span class="key">val </span>signal: t -&gt; unit
<span class="line">   89 </span>        <span class="key">val </span>wait: t * Mutex.t -&gt; unit
<span class="line">   90 </span>     <span class="key">end
</span><span class="line">   91 </span><span class="key">   end </span>=
<span class="line">   92 </span>   <span class="key">struct
</span><span class="line">   93 </span><span class="key">      open </span>MLton
<span class="line">   94 </span>      <span class="key">open </span>Thread
<span class="line">   95 </span>
<span class="line">   96 </span>      <span class="key">val </span>topLevel: unit Thread.t option ref = ref NONE
<span class="line">   97 </span>
<span class="line">   98 </span>      <span class="key">local
</span><span class="line">   99 </span><span class="key">     val </span>threads: unit Thread.t Queue.t = Queue.new()
<span class="line">  100 </span>      <span class="key">in
</span><span class="line">  101 </span><span class="key">     fun </span>ready t = Queue.enque(threads, t)
<span class="line">  102 </span>     <span class="key">fun </span>next() =
<span class="line">  103 </span>        <span class="key">case </span>Queue.deque threads <span class="key">of
</span><span class="line">  104 </span><span class="key">           </span>NONE =&gt; valOf(!topLevel)
<span class="line">  105 </span>         | SOME t =&gt; t
<span class="line">  106 </span>      <span class="key">end
</span><span class="line">  107 </span><span class="key">
</span><span class="line">  108 </span><span class="key">      fun </span>'a exit(): 'a = switch(fn _ =&gt; (next(), ()))
<span class="line">  109 </span>
<span class="line">  110 </span>      <span class="key">fun </span>new(f: unit -&gt; unit): unit Thread.t =
<span class="line">  111 </span>     Thread.new(fn () =&gt; ((f() <span class="key">handle </span>_ =&gt; exit())
<span class="line">  112 </span>                  ; exit()))
<span class="line">  113 </span>
<span class="line">  114 </span>      <span class="key">fun </span>schedule t = (ready t; next())
<span class="line">  115 </span>
<span class="line">  116 </span>      <span class="key">fun </span>yield(): unit = switch(fn t =&gt; (schedule t, ()))
<span class="line">  117 </span>
<span class="line">  118 </span>      <span class="key">val </span>spawn = ready <span class="key">o </span>new
<span class="line">  119 </span>
<span class="line">  120 </span>      <span class="key">fun </span>run(): unit =
<span class="line">  121 </span>     (switch(fn t =&gt;
<span class="line">  122 </span>         (topLevel := SOME t
<span class="line">  123 </span>          ; (next(), ())))
<span class="line">  124 </span>      ; topLevel := NONE)
<span class="line">  125 </span>
<span class="line">  126 </span>      <span class="key">structure </span>Mutex =
<span class="line">  127 </span>     <span class="key">struct
</span><span class="line">  128 </span><span class="key">        datatype </span>t = T <span class="key">of </span>{locked: <span class="typ">bool </span>ref,
<span class="line">  129 </span>                   waiting: unit Thread.t Queue.t}
<span class="line">  130 </span>
<span class="line">  131 </span>        <span class="key">fun </span>new () =
<span class="line">  132 </span>           T {locked = ref <span class="key">false</span>,
<span class="line">  133 </span>          waiting = Queue.new ()}
<span class="line">  134 </span>
<span class="line">  135 </span>        <span class="key">fun </span>lock (T {locked, waiting, ...}) =
<span class="line">  136 </span>           <span class="key">let
</span><span class="line">  137 </span><span class="key">          fun </span>loop () =
<span class="line">  138 </span>             (Primitive.Thread.atomicBegin ()
<span class="line">  139 </span>              ; <span class="key">if </span>!locked
<span class="line">  140 </span>               <span class="key">then </span>(Primitive.Thread.atomicEnd()
<span class="line">  141 </span>                 ; switch (<span class="key">fn </span>t =&gt;
<span class="line">  142 </span>                       (Queue.enque (waiting, t)
<span class="line">  143 </span>                        ; (next (), ())))
<span class="line">  144 </span>                 ; loop ())
<span class="line">  145 </span>            <span class="key">else </span>(locked := <span class="key">true
</span><span class="line">  146 </span><span class="key">                  </span>; Primitive.Thread.atomicEnd()))
<span class="line">  147 </span>           <span class="key">in </span>loop ()
<span class="line">  148 </span>           <span class="key">end
</span><span class="line">  149 </span><span class="key">
</span><span class="line">  150 </span><span class="key">        fun </span>safeUnlock (T {locked, waiting, ...}) =
<span class="line">  151 </span>           (locked := <span class="key">false
</span><span class="line">  152 </span><span class="key">        </span>; (<span class="key">case </span>Queue.deque waiting <span class="key">of
</span><span class="line">  153 </span><span class="key">              </span>NONE =&gt; ()
<span class="line">  154 </span>            | SOME t =&gt; ready t))
<span class="line">  155 </span>
<span class="line">  156 </span>        <span class="key">fun </span>unlock (m: t) =
<span class="line">  157 </span>           (Primitive.Thread.atomicBegin ()
<span class="line">  158 </span>        ; safeUnlock m
<span class="line">  159 </span>        ; Primitive.Thread.atomicEnd ())
<span class="line">  160 </span>     <span class="key">end
</span><span class="line">  161 </span><span class="key">
</span><span class="line">  162 </span><span class="key">      structure </span>Condition =
<span class="line">  163 </span>     <span class="key">struct
</span><span class="line">  164 </span><span class="key">        datatype </span>t = T <span class="key">of </span>{waiting: unit Thread.t Queue.t}
<span class="line">  165 </span>
<span class="line">  166 </span>        <span class="key">fun </span>new () = T {waiting = Queue.new ()}
<span class="line">  167 </span>
<span class="line">  168 </span>        <span class="key">fun </span>wait (T {waiting, ...}, m) =
<span class="line">  169 </span>           switch (<span class="key">fn </span>t =&gt;
<span class="line">  170 </span>               (Mutex.safeUnlock m
<span class="line">  171 </span>            ; Queue.enque (waiting, t)
<span class="line">  172 </span>            ; (next (), ())))
<span class="line">  173 </span>
<span class="line">  174 </span>        <span class="key">fun </span>signal (T {waiting, ...}) =
<span class="line">  175 </span>           <span class="key">case </span>Queue.deque waiting <span class="key">of
</span><span class="line">  176 </span><span class="key">          </span>NONE =&gt; ()
<span class="line">  177 </span>        | SOME t =&gt; ready t
<span class="line">  178 </span>     <span class="key">end
</span><span class="line">  179 </span><span class="key">
</span><span class="line">  180 </span><span class="key">   end
</span><span class="line">  181 </span><span class="key">
</span><span class="line">  182 </span><span class="key">structure </span>Mutex = Thread.Mutex
<span class="line">  183 </span><span class="key">structure </span>Condition = Thread.Condition
<span class="line">  184 </span>
<span class="line">  185 </span><span class="key">val </span>count = ref <span class="num">0
</span><span class="line">  186 </span><span class="num"></span><span class="key">val </span>data = ref <span class="num">0
</span><span class="line">  187 </span><span class="num"></span><span class="key">val </span>produced = ref <span class="num">0
</span><span class="line">  188 </span><span class="num"></span><span class="key">val </span>consumed = ref <span class="num">0
</span><span class="line">  189 </span><span class="num"></span><span class="key">val </span>m = Mutex.new ()
<span class="line">  190 </span><span class="key">val </span>c = Condition.new ()
<span class="line">  191 </span>
<span class="line">  192 </span><span class="key">fun </span>producer n =
<span class="line">  193 </span>   for (<span class="num">1</span>, n, <span class="key">fn </span>i =&gt;
<span class="line">  194 </span>    (Mutex.lock m
<span class="line">  195 </span>     ; <span class="key">while </span>!count = <span class="num">1 </span><span class="key">do </span>Condition.wait (c, m)
<span class="line">  196 </span>     ; data := i
<span class="line">  197 </span>     ; count := <span class="num">1
</span><span class="line">  198 </span><span class="num">     </span>; Condition.signal c
<span class="line">  199 </span>     ; Mutex.unlock m
<span class="line">  200 </span>     ; produced := !produced + <span class="num">1</span>))
<span class="line">  201 </span>
<span class="line">  202 </span><span class="key">fun </span>consumer n =
<span class="line">  203 </span>   <span class="key">let val </span>i = ref <span class="num">0
</span><span class="line">  204 </span><span class="num">   </span><span class="key">in
</span><span class="line">  205 </span><span class="key">      while </span>!i &lt;&gt; n <span class="key">do
</span><span class="line">  206 </span><span class="key">     </span>(Mutex.lock m
<span class="line">  207 </span>      ; <span class="key">while </span>!count = <span class="num">0 </span><span class="key">do </span>Condition.wait (c, m)
<span class="line">  208 </span>      ; i := !data
<span class="line">  209 </span>      ; count := <span class="num">0
</span><span class="line">  210 </span><span class="num">      </span>; Condition.signal c
<span class="line">  211 </span>      ; Mutex.unlock m
<span class="line">  212 </span>      ; consumed := !consumed + <span class="num">1</span>)
<span class="line">  213 </span>   <span class="key">end
</span><span class="line">  214 </span><span class="key">
</span><span class="line">  215 </span><span class="key">fun </span>atoi s = <span class="key">case Int</span>.fromString s <span class="key">of </span>SOME num =&gt; num | NONE =&gt; <span class="num">0
</span><span class="line">  216 </span><span class="num"></span><span class="key">fun </span>printl [] = print <span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span> | printl(h::t) = ( print h ; printl t )
<span class="line">  217 </span>
<span class="line">  218 </span><span class="key">fun </span>main (name, args) =
<span class="line">  219 </span>   <span class="key">let
</span><span class="line">  220 </span><span class="key">      val </span>n = atoi (hd (args &#64; [<span class="str">&quot;1&quot;</span>]))
<span class="line">  221 </span>      <span class="key">val </span>p = Thread.spawn (<span class="key">fn </span>() =&gt; producer n)
<span class="line">  222 </span>      <span class="key">val </span>c = Thread.spawn (<span class="key">fn </span>() =&gt; consumer n)
<span class="line">  223 </span>      <span class="key">val </span>_ = Thread.run ()
<span class="line">  224 </span>      <span class="key">val </span>_ = printl [<span class="key">Int</span>.toString (!produced),
<span class="line">  225 </span>              <span class="str">&quot; &quot;</span>,
<span class="line">  226 </span>              <span class="key">Int</span>.toString (!consumed)]
<span class="line">  227 </span>   <span class="key">in
</span><span class="line">  228 </span><span class="key">      </span>()
<span class="line">  229 </span>   <span class="key">end
</span><span class="line">  230 </span><span class="key">
</span><span class="line">  231 </span><span class="key">end
</span><span class="line">  232 </span><span class="key">
</span><span class="line">  233 </span><span class="key">structure </span>Z = Z (<span class="key">structure </span>MLton = MLton
<span class="line">  234 </span>         <span class="key">structure </span>Primitive = Primitive)
<span class="line">  235 </span>
<span class="line">  236 </span><span class="key">val </span>_ = Z.main( CommandLine.name(), CommandLine.arguments() )
</pre>
</body>
</html>
<!--HTML generated by highlight 2.0-24, http://www.andre-simon.de/-->
