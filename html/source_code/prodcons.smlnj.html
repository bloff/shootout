<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<title>C:\Fulgham\Projects\shootout\bench\prodcons\prodcons.smlnj</title>
	<link rel="stylesheet" type="text/css" href="highlight.css">
</head>
<body>
<pre><span class="line">    1 </span><span class="com">(* -*- mode: sml -*-
</span><span class="line">    2 </span><span class="com"> * $Id: prodcons.smlnj.html,v 1.1 2004-06-14 23:09:28 bfulgham Exp $
</span><span class="line">    3 </span><span class="com"> * http://www.bagley.org/~doug/shootout/
</span><span class="line">    4 </span><span class="com"> * from Matthias Blume
</span><span class="line">    5 </span><span class="com"> *)</span>
<span class="line">    6 </span>
<span class="line">    7 </span><span class="com">(* producer-consumer threads in SML/NJ
</span><span class="line">    8 </span><span class="com"> * (concurrency primitives re-implemented &quot;by hand&quot; on top of call/cc
</span><span class="line">    9 </span><span class="com"> * using the code in John Reppy's book &quot;Concurrent Programming in ML&quot;)
</span><span class="line">   10 </span><span class="com"> *
</span><span class="line">   11 </span><span class="com"> * (C) 2001 Lucent Technologies, Bell Labs
</span><span class="line">   12 </span><span class="com"> * written by Matthias Blume
</span><span class="line">   13 </span><span class="com"> *)</span>
<span class="line">   14 </span>
<span class="line">   15 </span><span class="key">structure </span>Queue :&gt; <span class="key">sig
</span><span class="line">   16 </span><span class="key">    exception </span>Empty
<span class="line">   17 </span>    <span class="key">type </span>tt = unit SMLofNJ.Cont.cont
<span class="line">   18 </span>    <span class="key">type </span>q
<span class="line">   19 </span>    <span class="key">val </span>new : unit -&gt; q
<span class="line">   20 </span>    <span class="key">val </span>enqueue : q * tt -&gt; unit
<span class="line">   21 </span>    <span class="key">val </span>dequeue : q -&gt; tt
<span class="line">   22 </span>    <span class="key">val </span>empty : q -&gt; <span class="typ">bool
</span><span class="line">   23 </span><span class="typ"></span><span class="key">end </span>= <span class="key">struct
</span><span class="line">   24 </span><span class="key">
</span><span class="line">   25 </span><span class="key">    exception </span>Empty
<span class="line">   26 </span>
<span class="line">   27 </span>    <span class="key">type </span>tt = unit SMLofNJ.Cont.cont
<span class="line">   28 </span>    <span class="key">type </span>q = tt list ref * tt list ref
<span class="line">   29 </span>
<span class="line">   30 </span>    <span class="key">fun </span>new () : q = (ref [], ref [])
<span class="line">   31 </span>
<span class="line">   32 </span>    <span class="key">fun </span>enqueue ((f <span class="key">as </span>ref [], ref []) : q, x) = f := [x]
<span class="line">   33 </span>      | enqueue ((_, b <span class="key">as </span>ref xs), x) = b := x :: xs
<span class="line">   34 </span>
<span class="line">   35 </span>    <span class="key">fun </span>dequeue ((f, b) : q) =
<span class="line">   36 </span>    <span class="key">case </span>!f <span class="key">of
</span><span class="line">   37 </span><span class="key">        </span>[] =&gt; (<span class="key">case </span>rev (!b) <span class="key">of
</span><span class="line">   38 </span><span class="key">               </span>x :: xs =&gt; (f := xs; b := []; x)
<span class="line">   39 </span>             | [] =&gt; <span class="key">raise </span>Empty)
<span class="line">   40 </span>      | x :: xs =&gt; (f := xs; x)
<span class="line">   41 </span>
<span class="line">   42 </span>    <span class="key">fun </span>empty ((ref [], ref []) : q) = <span class="key">true
</span><span class="line">   43 </span><span class="key">      </span>| empty _ = <span class="key">false
</span><span class="line">   44 </span><span class="key">
</span><span class="line">   45 </span><span class="key">end
</span><span class="line">   46 </span><span class="key">
</span><span class="line">   47 </span><span class="key">structure </span>Mutex :&gt; <span class="key">sig
</span><span class="line">   48 </span><span class="key">
</span><span class="line">   49 </span><span class="key">    val </span>yield : unit -&gt; unit
<span class="line">   50 </span>    <span class="key">val </span>fork : (unit -&gt; unit) -&gt; unit
<span class="line">   51 </span>    <span class="key">val </span>exit : unit -&gt; 'a
<span class="line">   52 </span>
<span class="line">   53 </span>    <span class="key">type </span>mutex
<span class="line">   54 </span>    <span class="key">type </span>condition
<span class="line">   55 </span>
<span class="line">   56 </span>    <span class="key">val </span>mutex : unit -&gt; mutex
<span class="line">   57 </span>    <span class="key">val </span>lock : mutex -&gt; unit
<span class="line">   58 </span>    <span class="key">val </span>unlock : mutex -&gt; unit
<span class="line">   59 </span>
<span class="line">   60 </span>    <span class="key">val </span>condition : mutex -&gt; condition
<span class="line">   61 </span>    <span class="key">val </span>wait : condition -&gt; unit
<span class="line">   62 </span>    <span class="key">val </span>signal : condition -&gt; unit
<span class="line">   63 </span>
<span class="line">   64 </span>    <span class="key">val </span>run : (unit -&gt; unit) * Time.time -&gt; unit
<span class="line">   65 </span>
<span class="line">   66 </span><span class="key">end </span>= <span class="key">struct
</span><span class="line">   67 </span><span class="key">
</span><span class="line">   68 </span><span class="key">    local
</span><span class="line">   69 </span><span class="key">    structure </span>C = SMLofNJ.Cont
<span class="line">   70 </span>    <span class="key">structure </span>Q = Queue
<span class="line">   71 </span>    <span class="key">type </span>tt = unit C.cont
<span class="line">   72 </span>
<span class="line">   73 </span>    <span class="com">(* We take the easy way out: Simply drop signals that
</span><span class="line">   74 </span><span class="com">     * arrive during an atomic section on the floor.  This is
</span><span class="line">   75 </span><span class="com">     * enough for our purpose and simplifies the coding... *)</span>
<span class="line">   76 </span>    <span class="key">val </span>atomicState = ref <span class="key">false
</span><span class="line">   77 </span><span class="key">    fun </span>atomicBegin () = atomicState := <span class="key">true
</span><span class="line">   78 </span><span class="key">    fun </span>atomicEnd () = atomicState := <span class="key">false
</span><span class="line">   79 </span><span class="key">    val </span>readyQ : Q.q = Q.new ()
<span class="line">   80 </span>
<span class="line">   81 </span>    <span class="key">fun </span>dispatch () = C.throw (Q.dequeue readyQ) ()
<span class="line">   82 </span>
<span class="line">   83 </span>    <span class="key">fun </span>sigH (_: Signals.signal, _: <span class="typ">int</span>, k: tt) =
<span class="line">   84 </span>        <span class="key">if </span>!atomicState <span class="key">then </span>k
<span class="line">   85 </span>        <span class="key">else </span>(Q.enqueue (readyQ, k); Q.dequeue readyQ)
<span class="line">   86 </span>    <span class="key">in
</span><span class="line">   87 </span><span class="key">        </span><span class="com">(* coroutines *)</span>
<span class="line">   88 </span>        <span class="key">fun </span>yield () =
<span class="line">   89 </span>        (atomicBegin ();
<span class="line">   90 </span>         C.callcc (<span class="key">fn </span>k =&gt; (Q.enqueue (readyQ, k); dispatch ()));
<span class="line">   91 </span>         atomicEnd ())
<span class="line">   92 </span>
<span class="line">   93 </span>    <span class="key">fun </span>exit () = (atomicBegin (); dispatch ())
<span class="line">   94 </span>
<span class="line">   95 </span>    <span class="key">fun </span>fork f = <span class="key">let
</span><span class="line">   96 </span><span class="key">        val </span>k = C.isolate (<span class="key">fn </span>() =&gt; (atomicEnd ();
<span class="line">   97 </span>                     f () <span class="key">handle </span>_ =&gt; ();
<span class="line">   98 </span>                     exit ()))
<span class="line">   99 </span>    <span class="key">in
</span><span class="line">  100 </span><span class="key">        </span>atomicBegin ();
<span class="line">  101 </span>        Q.enqueue (readyQ, k);
<span class="line">  102 </span>        atomicEnd ()
<span class="line">  103 </span>    <span class="key">end
</span><span class="line">  104 </span><span class="key">
</span><span class="line">  105 </span><span class="key">    </span><span class="com">(* mutex locks *)</span>
<span class="line">  106 </span>        <span class="key">datatype </span>mutex = Mutex <span class="key">of </span>{ locked : <span class="typ">bool </span>ref, blocked : Q.q }
<span class="line">  107 </span>
<span class="line">  108 </span>    <span class="key">fun </span>mutex () = Mutex { locked = ref <span class="key">false</span>, blocked = Q.new () }
<span class="line">  109 </span>
<span class="line">  110 </span>    <span class="key">fun </span>lock (Mutex { locked, blocked }) =
<span class="line">  111 </span>        (atomicBegin ();
<span class="line">  112 </span>         <span class="key">if </span>!locked <span class="key">then
</span><span class="line">  113 </span><span class="key">         </span>C.callcc (<span class="key">fn </span>k =&gt; (Q.enqueue (blocked, k);
<span class="line">  114 </span>                    dispatch ()))
<span class="line">  115 </span>         <span class="key">else </span>locked := <span class="key">true</span>;
<span class="line">  116 </span>         atomicEnd ())
<span class="line">  117 </span>
<span class="line">  118 </span>    <span class="key">fun </span>unlock (Mutex { locked, blocked }) =
<span class="line">  119 </span>        (atomicBegin ();
<span class="line">  120 </span>         <span class="key">if </span>Q.empty blocked <span class="key">then </span>locked := <span class="key">false
</span><span class="line">  121 </span><span class="key">         else </span>C.callcc (<span class="key">fn </span>k =&gt; (Q.enqueue (readyQ, k);
<span class="line">  122 </span>                     C.throw (Q.dequeue blocked) ()));
<span class="line">  123 </span>         atomicEnd ())
<span class="line">  124 </span>
<span class="line">  125 </span>
<span class="line">  126 </span>        <span class="com">(* conditions *)</span>
<span class="line">  127 </span>    <span class="key">datatype </span>condition = Cond <span class="key">of </span>{ mutex : mutex, waiting : Q.q }
<span class="line">  128 </span>
<span class="line">  129 </span>    <span class="key">fun </span>condition m = Cond { mutex = m, waiting = Q.new () }
<span class="line">  130 </span>
<span class="line">  131 </span>    <span class="key">fun </span>wait (Cond { mutex = m <span class="key">as </span>Mutex { locked, blocked }, waiting }) =
<span class="line">  132 </span>        (atomicBegin ();
<span class="line">  133 </span>         C.callcc (<span class="key">fn </span>k =&gt;
<span class="line">  134 </span>              (Q.enqueue (waiting, k);
<span class="line">  135 </span>               <span class="key">if </span>Q.empty blocked <span class="key">then </span>(locked := <span class="key">false</span>;
<span class="line">  136 </span>                            dispatch ())
<span class="line">  137 </span>               <span class="key">else </span>C.throw (Q.dequeue blocked) ()));
<span class="line">  138 </span>         <span class="key">if </span>!locked <span class="key">then
</span><span class="line">  139 </span><span class="key">         </span>C.callcc (<span class="key">fn </span>k =&gt; (Q.enqueue (blocked, k);
<span class="line">  140 </span>                    dispatch ()))
<span class="line">  141 </span>         <span class="key">else </span>locked := <span class="key">true</span>;
<span class="line">  142 </span>         atomicEnd ())
<span class="line">  143 </span>
<span class="line">  144 </span>    <span class="key">fun </span>signal (Cond { waiting, ... }) =
<span class="line">  145 </span>        (atomicBegin ();
<span class="line">  146 </span>         <span class="key">if </span>Q.empty waiting <span class="key">then </span>()
<span class="line">  147 </span>         <span class="key">else </span>Q.enqueue (readyQ, Q.dequeue waiting);
<span class="line">  148 </span>         atomicEnd ())
<span class="line">  149 </span>
<span class="line">  150 </span>    <span class="key">fun </span>run (f, t) = <span class="key">let
</span><span class="line">  151 </span><span class="key">        val </span>oh = Signals.setHandler (Signals.sigALRM,
<span class="line">  152 </span>                     Signals.HANDLER sigH)
<span class="line">  153 </span>        <span class="key">val </span>_ = SMLofNJ.IntervalTimer.setIntTimer (SOME t)
<span class="line">  154 </span>        <span class="key">fun </span>reset () =
<span class="line">  155 </span>        (ignore (Signals.setHandler (Signals.sigALRM, oh));
<span class="line">  156 </span>         SMLofNJ.IntervalTimer.setIntTimer NONE)
<span class="line">  157 </span>
<span class="line">  158 </span>    <span class="key">in
</span><span class="line">  159 </span><span class="key">        </span>(f () <span class="key">handle </span>e =&gt; (reset (); <span class="key">raise </span>e))
<span class="line">  160 </span>        <span class="key">before </span>reset ()
<span class="line">  161 </span>    <span class="key">end
</span><span class="line">  162 </span><span class="key">    end
</span><span class="line">  163 </span><span class="key">end
</span><span class="line">  164 </span><span class="key">
</span><span class="line">  165 </span><span class="key">structure </span>ProdCons : <span class="key">sig
</span><span class="line">  166 </span><span class="key">    val </span>main : <span class="typ">string </span>* <span class="typ">string </span>list -&gt; OS.Process.status
<span class="line">  167 </span><span class="key">end </span>= <span class="key">struct
</span><span class="line">  168 </span><span class="key">
</span><span class="line">  169 </span><span class="key">    fun </span>doit n = <span class="key">let
</span><span class="line">  170 </span><span class="key">
</span><span class="line">  171 </span><span class="key">    val </span>c_running = Mutex.mutex ()
<span class="line">  172 </span>    <span class="key">val </span>p_running = Mutex.mutex ()
<span class="line">  173 </span>
<span class="line">  174 </span>    <span class="key">val </span>consumer's_turn = ref <span class="key">false
</span><span class="line">  175 </span><span class="key">    val </span>data = ref <span class="num">0
</span><span class="line">  176 </span><span class="num">    </span><span class="key">val </span>produced = ref <span class="num">0
</span><span class="line">  177 </span><span class="num">    </span><span class="key">val </span>consumed = ref <span class="num">0
</span><span class="line">  178 </span><span class="num">    </span><span class="key">val </span>m = Mutex.mutex ()
<span class="line">  179 </span>    <span class="key">val </span>c = Mutex.condition m
<span class="line">  180 </span>
<span class="line">  181 </span>    <span class="key">fun </span>producer () = <span class="key">let
</span><span class="line">  182 </span><span class="key">        fun </span>wait () = <span class="key">if </span>!consumer's_turn <span class="key">then </span>wait (Mutex.wait c) <span class="key">else </span>()
<span class="line">  183 </span>        <span class="key">fun </span>loop i =
<span class="line">  184 </span>        <span class="key">if </span>i &lt;= n <span class="key">then
</span><span class="line">  185 </span><span class="key">            let val </span>_ = Mutex.lock m
<span class="line">  186 </span>            <span class="key">val </span>_ = wait ()
<span class="line">  187 </span>            <span class="key">in
</span><span class="line">  188 </span><span class="key">            </span>data := i;
<span class="line">  189 </span>            consumer's_turn := <span class="key">true</span>;
<span class="line">  190 </span>            produced := !produced + <span class="num">1</span>;
<span class="line">  191 </span>            Mutex.signal c;
<span class="line">  192 </span>            Mutex.unlock m;
<span class="line">  193 </span>            loop (i + <span class="num">1</span>)
<span class="line">  194 </span>            <span class="key">end
</span><span class="line">  195 </span><span class="key">        else </span>()
<span class="line">  196 </span>    <span class="key">in
</span><span class="line">  197 </span><span class="key">        </span>loop <span class="num">1 </span><span class="key">before </span>Mutex.unlock p_running
<span class="line">  198 </span>    <span class="key">end
</span><span class="line">  199 </span><span class="key">
</span><span class="line">  200 </span><span class="key">    fun </span>consumer () = <span class="key">let
</span><span class="line">  201 </span><span class="key">        fun </span>wait () = <span class="key">if </span>!consumer's_turn <span class="key">then </span>() <span class="key">else </span>wait (Mutex.wait c)
<span class="line">  202 </span>        <span class="key">fun </span>loop () = <span class="key">let
</span><span class="line">  203 </span><span class="key">        val </span>_ = Mutex.lock m
<span class="line">  204 </span>        <span class="key">val </span>_ = wait ()
<span class="line">  205 </span>        <span class="key">val </span>i = !data
<span class="line">  206 </span>        <span class="key">in
</span><span class="line">  207 </span><span class="key">        </span>consumer's_turn := <span class="key">false</span>;
<span class="line">  208 </span>        consumed := !consumed + <span class="num">1</span>;
<span class="line">  209 </span>        Mutex.signal c;
<span class="line">  210 </span>        Mutex.unlock m;
<span class="line">  211 </span>        <span class="key">if </span>i &lt;&gt; n <span class="key">then </span>loop () <span class="key">else </span>()
<span class="line">  212 </span>        <span class="key">end
</span><span class="line">  213 </span><span class="key">    in
</span><span class="line">  214 </span><span class="key">        </span>loop () <span class="key">before </span>Mutex.unlock c_running
<span class="line">  215 </span>    <span class="key">end
</span><span class="line">  216 </span><span class="key">
</span><span class="line">  217 </span><span class="key">    </span><span class="com">(* hack to simulate &quot;join&quot; *)</span>
<span class="line">  218 </span>    <span class="key">val </span>_ = Mutex.lock p_running
<span class="line">  219 </span>    <span class="key">val </span>_ = Mutex.lock c_running
<span class="line">  220 </span>
<span class="line">  221 </span>    <span class="key">val </span>p = Mutex.fork producer
<span class="line">  222 </span>    <span class="key">val </span>c = Mutex.fork consumer
<span class="line">  223 </span>    <span class="key">in
</span><span class="line">  224 </span><span class="key">    </span><span class="com">(* &quot;join&quot; *)</span>
<span class="line">  225 </span>    Mutex.lock p_running;
<span class="line">  226 </span>    Mutex.lock c_running;
<span class="line">  227 </span>
<span class="line">  228 </span>    <span class="key">TextIO</span>.output (<span class="key">TextIO</span>.stdOut,
<span class="line">  229 </span>               concat [<span class="key">Int</span>.toString (!produced), <span class="str">&quot; &quot;</span>,
<span class="line">  230 </span>                   <span class="key">Int</span>.toString (!consumed), <span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span>])
<span class="line">  231 </span>    <span class="key">end
</span><span class="line">  232 </span><span class="key">
</span><span class="line">  233 </span><span class="key">    fun </span>main (_, args) = <span class="key">let
</span><span class="line">  234 </span><span class="key">    val </span>n = <span class="key">case </span>args <span class="key">of </span>[] =&gt; <span class="num">1
</span><span class="line">  235 </span><span class="num">               </span>| (x :: _) =&gt; getOpt (<span class="key">Int</span>.fromString x, <span class="num">1</span>)
<span class="line">  236 </span>    <span class="key">in
</span><span class="line">  237 </span><span class="key">    </span>Mutex.run (<span class="key">fn </span>() =&gt; doit n, Time.fromMilliseconds <span class="num">1</span>);
<span class="line">  238 </span>    OS.Process.success
<span class="line">  239 </span>    <span class="key">end
</span><span class="line">  240 </span><span class="key">end
</span><span class="line">  241 </span><span class="key">
</span><span class="line">  242 </span><span class="key">val </span>_ = SMLofNJ.exportFn(<span class="str">&quot;prodcons&quot;</span>, ProdCons.main);
</pre>
</body>
</html>
<!--HTML generated by highlight 2.0-24, http://www.andre-simon.de/-->
