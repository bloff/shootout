<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<title>C:\Fulgham\Projects\shootout\bench\wordfreq\wordfreq.mlton</title>
	<link rel="stylesheet" type="text/css" href="highlight.css">
</head>
<body>
<pre><span class="line">    1 </span><span class="com">(* -*- mode: sml -*-
</span><span class="line">    2 </span><span class="com"> * $Id: wordfreq.mlton.html,v 1.1 2004-06-14 23:09:29 bfulgham Exp $
</span><span class="line">    3 </span><span class="com"> * http://www.bagley.org/~doug/shootout/
</span><span class="line">    4 </span><span class="com"> * from Stephen Weeks
</span><span class="line">    5 </span><span class="com"> *)</span>
<span class="line">    6 </span>
<span class="line">    7 </span><span class="key">fun </span>for (start, stop, f) =
<span class="line">    8 </span>   <span class="key">let
</span><span class="line">    9 </span><span class="key">      fun </span>loop i =
<span class="line">   10 </span>     <span class="key">if </span>i &gt; stop
<span class="line">   11 </span>        <span class="key">then </span>()
<span class="line">   12 </span>     <span class="key">else </span>(f i; loop (i + <span class="num">1</span>))
<span class="line">   13 </span>   <span class="key">in
</span><span class="line">   14 </span><span class="key">      </span>loop start
<span class="line">   15 </span>   <span class="key">end
</span><span class="line">   16 </span><span class="key">fun </span>incr r = r := <span class="num">1 </span>+ !r
<span class="line">   17 </span><span class="key">val </span>sub = Array.sub
<span class="line">   18 </span><span class="key">val </span>update = Array.update
<span class="line">   19 </span>
<span class="line">   20 </span><span class="key">signature </span>HASH_SET =
<span class="line">   21 </span>   <span class="key">sig
</span><span class="line">   22 </span><span class="key">      type </span>'a t
<span class="line">   23 </span>
<span class="line">   24 </span>      <span class="key">val </span>foreach: 'a t * ('a -&gt; unit) -&gt; unit
<span class="line">   25 </span>      <span class="com">(* lookupOrInsert (s, h, p, f)  looks in the set s for an entry with
</span><span class="line">   26 </span><span class="com">       hash h
</span><span class="line">   27 </span><span class="com">       * satisfying predicate p.  If the entry is there, it is returned.
</span><span class="line">   28 </span><span class="com">       * Otherwise, the function f is called to create a new entry, which
</span><span class="line">   29 </span><span class="com">       is
</span><span class="line">   30 </span><span class="com">       * inserted and returned.
</span><span class="line">   31 </span><span class="com">       *)</span>
<span class="line">   32 </span>      <span class="key">val </span>lookupOrInsert: 'a t * <span class="typ">word </span>* ('a -&gt; <span class="typ">bool</span>) * (unit -&gt; 'a) -&gt; 'a
<span class="line">   33 </span>      <span class="key">val </span>new: {hash: 'a -&gt; <span class="typ">word</span>} -&gt; 'a t
<span class="line">   34 </span>      <span class="key">val </span>size: 'a t -&gt; <span class="typ">int
</span><span class="line">   35 </span><span class="typ">   </span><span class="key">end
</span><span class="line">   36 </span><span class="key">
</span><span class="line">   37 </span><span class="key">structure </span>HashSet: HASH_SET =
<span class="line">   38 </span><span class="key">struct
</span><span class="line">   39 </span><span class="key">
</span><span class="line">   40 </span><span class="key">datatype </span>'a t =
<span class="line">   41 </span>   T <span class="key">of </span>{buckets: 'a list array ref,
<span class="line">   42 </span>     hash: 'a -&gt; <span class="typ">word</span>,
<span class="line">   43 </span>     mask: <span class="typ">word </span>ref,
<span class="line">   44 </span>     numItems: <span class="typ">int </span>ref}
<span class="line">   45 </span>
<span class="line">   46 </span><span class="key">val </span>initialSize: <span class="typ">int </span>= <span class="num">65536
</span><span class="line">   47 </span><span class="num"></span><span class="key">val </span>initialMask: <span class="typ">word </span>= <span class="key">Word</span>.fromInt initialSize <span class="num">- 0w1
</span><span class="line">   48 </span><span class="num">
</span><span class="line">   49 </span><span class="num"></span><span class="key">fun </span>'a new {hash}: 'a t =
<span class="line">   50 </span>   T {buckets = ref (Array.array (initialSize, [])),
<span class="line">   51 </span>      hash = hash,
<span class="line">   52 </span>      numItems = ref <span class="num">0</span>,
<span class="line">   53 </span>      mask = ref initialMask}
<span class="line">   54 </span>
<span class="line">   55 </span><span class="key">fun </span>size (T {numItems, ...}) = !numItems
<span class="line">   56 </span><span class="key">fun </span>numBuckets (T {buckets, ...}) = Array.length (!buckets)
<span class="line">   57 </span>
<span class="line">   58 </span><span class="key">fun </span>index (w: <span class="typ">word</span>, mask: <span class="typ">word</span>): <span class="typ">int </span>=
<span class="line">   59 </span>   <span class="key">Word</span>.toInt (<span class="key">Word</span>.andb (w, mask))
<span class="line">   60 </span>
<span class="line">   61 </span><span class="key">fun </span>resize (T {buckets, hash, mask, ...}, size: <span class="typ">int</span>, newMask: <span class="typ">word</span>): unit
<span class="line">   62 </span>            =
<span class="line">   63 </span>   <span class="key">let
</span><span class="line">   64 </span><span class="key">      val </span>newBuckets = Array.array (size, [])
<span class="line">   65 </span>   <span class="key">in </span>Array.app (<span class="key">fn </span>r =&gt;
<span class="line">   66 </span>         <span class="key">List</span>.app (<span class="key">fn </span>a =&gt;
<span class="line">   67 </span>                   <span class="key">let val </span>j = index (hash a, newMask)
<span class="line">   68 </span>                   <span class="key">in </span>Array.update
<span class="line">   69 </span>                  (newBuckets, j,
<span class="line">   70 </span>                   a :: Array.sub (newBuckets, j))
<span class="line">   71 </span>                   <span class="key">end</span>) r) (!buckets)
<span class="line">   72 </span>      ; buckets := newBuckets
<span class="line">   73 </span>      ; mask := newMask
<span class="line">   74 </span>   <span class="key">end
</span><span class="line">   75 </span><span class="key">
</span><span class="line">   76 </span><span class="key">fun </span>maybeGrow (s <span class="key">as </span>T {buckets, mask, numItems, ...}): unit =
<span class="line">   77 </span>   <span class="key">let
</span><span class="line">   78 </span><span class="key">      val </span>n = Array.length (!buckets)
<span class="line">   79 </span>   <span class="key">in if </span>!numItems * <span class="num">4 </span>&gt; n
<span class="line">   80 </span>     <span class="key">then </span>resize (s,
<span class="line">   81 </span>              n * <span class="num">2</span>,
<span class="line">   82 </span>              <span class="com">(* The new mask depends on growFactor being 2. *)</span>
<span class="line">   83 </span>              <span class="key">Word</span>.orb (<span class="num">0w1</span>, <span class="key">Word</span>.&lt;&lt; (!mask, <span class="num">0w1</span>)))
<span class="line">   84 </span>      <span class="key">else </span>()
<span class="line">   85 </span>   <span class="key">end
</span><span class="line">   86 </span><span class="key">
</span><span class="line">   87 </span><span class="key">fun </span>peekGen (T {buckets = ref buckets, mask, ...}, w, p, no, yes) =
<span class="line">   88 </span>   <span class="key">let
</span><span class="line">   89 </span><span class="key">      val </span>j = index (w, !mask)
<span class="line">   90 </span>      <span class="key">val </span>b = Array.sub (buckets, j)
<span class="line">   91 </span>   <span class="key">in case List</span>.find p b <span class="key">of
</span><span class="line">   92 </span><span class="key">      </span>NONE =&gt; no (j, b)
<span class="line">   93 </span>    | SOME a =&gt; yes a
<span class="line">   94 </span>   <span class="key">end
</span><span class="line">   95 </span><span class="key">
</span><span class="line">   96 </span><span class="key">fun </span>lookupOrInsert (table <span class="key">as </span>T {buckets, numItems, ...}, w, p, f) =
<span class="line">   97 </span>   <span class="key">let
</span><span class="line">   98 </span><span class="key">      fun </span>no (j, b) =
<span class="line">   99 </span>     <span class="key">let val </span>a = f ()
<span class="line">  100 </span>        <span class="key">val </span>_ = incr numItems
<span class="line">  101 </span>        <span class="key">val </span>_ = Array.update (!buckets, j, a :: b)
<span class="line">  102 </span>        <span class="key">val </span>_ = maybeGrow table
<span class="line">  103 </span>     <span class="key">in </span>a
<span class="line">  104 </span>     <span class="key">end
</span><span class="line">  105 </span><span class="key">   in </span>peekGen (table, w, p, no, <span class="key">fn </span>x =&gt; x)
<span class="line">  106 </span>   <span class="key">end
</span><span class="line">  107 </span><span class="key">
</span><span class="line">  108 </span><span class="key">fun </span>foreach (T {buckets, ...}, f) =
<span class="line">  109 </span>   Array.app (<span class="key">fn </span>r =&gt; <span class="key">List</span>.app f r) (!buckets)
<span class="line">  110 </span>
<span class="line">  111 </span><span class="key">end
</span><span class="line">  112 </span><span class="key">
</span><span class="line">  113 </span><span class="key">structure </span>Buffer:
<span class="line">  114 </span>   <span class="key">sig
</span><span class="line">  115 </span><span class="key">      type </span>t
<span class="line">  116 </span>
<span class="line">  117 </span>      <span class="key">val </span>add: t * <span class="key">Word8</span>.<span class="typ">word </span>-&gt; unit
<span class="line">  118 </span>      <span class="key">val </span>clear: t -&gt; unit
<span class="line">  119 </span>      <span class="key">val </span>contents: t -&gt; <span class="typ">string
</span><span class="line">  120 </span><span class="typ">      </span><span class="key">val </span>new: <span class="typ">int </span>-&gt; t
<span class="line">  121 </span>   <span class="key">end </span>=
<span class="line">  122 </span>   <span class="key">struct
</span><span class="line">  123 </span><span class="key">      datatype </span>t = T <span class="key">of </span>{elts: Word8Array.array ref,
<span class="line">  124 </span>             size: <span class="typ">int </span>ref}
<span class="line">  125 </span>
<span class="line">  126 </span>      <span class="key">fun </span>contents (T {elts, size, ...}) =
<span class="line">  127 </span>     Byte.bytesToString
<span class="line">  128 </span>     (Word8ArraySlice.vector
<span class="line">  129 </span>      (Word8ArraySlice.slice (!elts, <span class="num">0</span>, SOME (!size))))
<span class="line">  130 </span>
<span class="line">  131 </span>      <span class="key">fun </span>clear (T {size, ...}) = size := <span class="num">0
</span><span class="line">  132 </span><span class="num">
</span><span class="line">  133 </span><span class="num">      </span><span class="key">fun </span>new (bufSize) =
<span class="line">  134 </span>     T {elts = ref (Word8Array.array (bufSize, <span class="num">0w0</span>)),
<span class="line">  135 </span>        size = ref <span class="num">0</span>}
<span class="line">  136 </span>
<span class="line">  137 </span>      <span class="key">fun </span>add (T {elts, size}, x) =
<span class="line">  138 </span>     <span class="key">let
</span><span class="line">  139 </span><span class="key">        val </span>s = !size
<span class="line">  140 </span>        <span class="key">val </span>_ = size := s + <span class="num">1
</span><span class="line">  141 </span><span class="num">        </span><span class="key">val </span>a = !elts
<span class="line">  142 </span>        <span class="key">val </span>n = Word8Array.length a
<span class="line">  143 </span>     <span class="key">in
</span><span class="line">  144 </span><span class="key">        if </span>s = n
<span class="line">  145 </span>           <span class="key">then
</span><span class="line">  146 </span><span class="key">          let
</span><span class="line">  147 </span><span class="key">             val </span>a' =
<span class="line">  148 </span>            Word8Array.tabulate
<span class="line">  149 </span>            (<span class="num">2 </span>* n, <span class="key">fn </span>i =&gt;
<span class="line">  150 </span>             <span class="key">if </span>i &lt; n <span class="key">then </span>Word8Array.sub (a, i) <span class="key">else </span><span class="num">0w0</span>)
<span class="line">  151 </span>             <span class="key">val </span>_ = elts := a'
<span class="line">  152 </span>             <span class="key">val </span>_ = Word8Array.update (a', s, x)
<span class="line">  153 </span>          <span class="key">in </span>()
<span class="line">  154 </span>          <span class="key">end
</span><span class="line">  155 </span><span class="key">        else </span>Word8Array.update (a, s, x)
<span class="line">  156 </span>     <span class="key">end
</span><span class="line">  157 </span><span class="key">   end
</span><span class="line">  158 </span><span class="key">
</span><span class="line">  159 </span><span class="key">structure </span>Quicksort:
<span class="line">  160 </span>   <span class="key">sig
</span><span class="line">  161 </span><span class="key">      val </span>quicksort: 'a array * ('a * 'a -&gt; <span class="typ">bool</span>) -&gt; unit
<span class="line">  162 </span>   <span class="key">end </span>=
<span class="line">  163 </span>   <span class="key">struct
</span><span class="line">  164 </span><span class="key">      fun </span>assert (s, f: unit -&gt; <span class="typ">bool</span>) =
<span class="line">  165 </span>     <span class="key">if true orelse </span>f ()
<span class="line">  166 </span>        <span class="key">then </span>()
<span class="line">  167 </span>     <span class="key">else raise </span>Fail (concat [<span class="str">&quot;assert: &quot;</span>, s])
<span class="line">  168 </span>
<span class="line">  169 </span>      <span class="key">fun </span>forall (low, high, f) =
<span class="line">  170 </span>     <span class="key">let
</span><span class="line">  171 </span><span class="key">        fun </span>loop i = i &gt; high <span class="key">orelse </span>(f i <span class="key">andalso </span>loop (i + <span class="num">1</span>))
<span class="line">  172 </span>     <span class="key">in
</span><span class="line">  173 </span><span class="key">        </span>loop low
<span class="line">  174 </span>     <span class="key">end
</span><span class="line">  175 </span><span class="key">
</span><span class="line">  176 </span><span class="key">      fun </span>fold (l, u, state, f) =
<span class="line">  177 </span>     <span class="key">let
</span><span class="line">  178 </span><span class="key">        fun </span>loop (i, state) =
<span class="line">  179 </span>           <span class="key">if </span>i &gt; u
<span class="line">  180 </span>          <span class="key">then </span>state
<span class="line">  181 </span>           <span class="key">else </span>loop (i + <span class="num">1</span>, f (i, state))
<span class="line">  182 </span>     <span class="key">in
</span><span class="line">  183 </span><span class="key">        </span>loop (l, state)
<span class="line">  184 </span>     <span class="key">end
</span><span class="line">  185 </span><span class="key">
</span><span class="line">  186 </span><span class="key">      </span><span class="com">(* Check if entries in a[lo ... hi] are sorted. *)</span>
<span class="line">  187 </span>      <span class="key">fun </span>'a isSorted (a: 'a array,
<span class="line">  188 </span>               lo: <span class="typ">int</span>,
<span class="line">  189 </span>               hi: <span class="typ">int</span>,
<span class="line">  190 </span>               <span class="key">op </span>&lt;= : 'a * 'a -&gt; <span class="typ">bool</span>) =
<span class="line">  191 </span>     <span class="key">let
</span><span class="line">  192 </span><span class="key">        fun </span>loop (i, x) =
<span class="line">  193 </span>           i &gt; hi
<span class="line">  194 </span>           <span class="key">orelse let
</span><span class="line">  195 </span><span class="key">             val </span>y = sub (a, i)
<span class="line">  196 </span>              <span class="key">in
</span><span class="line">  197 </span><span class="key">             </span>x &lt;= y <span class="key">andalso </span>loop (i + <span class="num">1</span>, y)
<span class="line">  198 </span>              <span class="key">end
</span><span class="line">  199 </span><span class="key">     in
</span><span class="line">  200 </span><span class="key">        </span>lo &gt;= hi <span class="key">orelse </span>loop (lo + <span class="num">1</span>, sub (a, lo))
<span class="line">  201 </span>     <span class="key">end
</span><span class="line">  202 </span><span class="key">
</span><span class="line">  203 </span><span class="key">      </span><span class="com">(* From page 284 of Numerical Recipes in C. *)</span>
<span class="line">  204 </span>      <span class="key">local
</span><span class="line">  205 </span><span class="key">     open Word
</span><span class="line">  206 </span><span class="key">     val </span>seed = ref <span class="num">0w13
</span><span class="line">  207 </span><span class="num">      </span><span class="key">in
</span><span class="line">  208 </span><span class="key">     fun </span>rand () =
<span class="line">  209 </span>        <span class="key">let
</span><span class="line">  210 </span><span class="key">           val </span>res = <span class="num">0w1664525 </span>* !seed + <span class="num">0w1013904223
</span><span class="line">  211 </span><span class="num">           </span><span class="key">val </span>_ = seed := res
<span class="line">  212 </span>        <span class="key">in
</span><span class="line">  213 </span><span class="key">           </span>toIntX res
<span class="line">  214 </span>        <span class="key">end
</span><span class="line">  215 </span><span class="key">      end
</span><span class="line">  216 </span><span class="key">
</span><span class="line">  217 </span><span class="key">      fun </span>randInt (lo, hi) = lo + <span class="key">Int</span>.mod (rand(), hi - lo + <span class="num">1</span>)
<span class="line">  218 </span>
<span class="line">  219 </span>      <span class="com">(* insertion sort based on page 108 of Programming Pearls, by
</span><span class="line">  220 </span><span class="com">       Bentley. *)</span>
<span class="line">  221 </span>      <span class="key">fun </span>insertionSort (a: 'a array, <span class="key">op </span>&lt;= : 'a * 'a -&gt; <span class="typ">bool</span>): unit =
<span class="line">  222 </span>     <span class="key">let
</span><span class="line">  223 </span><span class="key">        fun </span>x i = sub (a, i)
<span class="line">  224 </span>     <span class="key">in
</span><span class="line">  225 </span><span class="key">        </span>for (<span class="num">1</span>, Array.length a <span class="num">- 1</span>, <span class="key">fn </span>i =&gt;
<span class="line">  226 </span>         <span class="key">let
</span><span class="line">  227 </span><span class="key">            val </span>_ =
<span class="line">  228 </span>               assert (<span class="str">&quot;insertionSort1&quot;</span>, <span class="key">fn </span>() =&gt;
<span class="line">  229 </span>                   isSorted (a, <span class="num">0</span>, i <span class="num">- 1</span>, <span class="key">op </span>&lt;=))
<span class="line">  230 </span>            <span class="key">val </span>t = x i
<span class="line">  231 </span>            <span class="key">fun </span>sift (j: <span class="typ">int</span>) =
<span class="line">  232 </span>               (assert (<span class="str">&quot;insertionSort2&quot;</span>, <span class="key">fn </span>() =&gt;
<span class="line">  233 </span>                isSorted (a, <span class="num">0</span>, j <span class="num">- 1</span>, <span class="key">op </span>&lt;=)
<span class="line">  234 </span>                <span class="key">andalso </span>isSorted (a, j + <span class="num">1</span>, i, <span class="key">op </span>&lt;=)
<span class="line">  235 </span>                <span class="key">andalso </span>forall (j + <span class="num">1</span>, i, <span class="key">fn </span>k =&gt; t &lt;= x k))
<span class="line">  236 </span>            ; <span class="key">if </span>j &gt; <span class="num">0
</span><span class="line">  237 </span><span class="num">                 </span><span class="key">then
</span><span class="line">  238 </span><span class="key">                let
</span><span class="line">  239 </span><span class="key">                   val </span>j' = j <span class="num">- 1
</span><span class="line">  240 </span><span class="num">                   </span><span class="key">val </span>z = x j'
<span class="line">  241 </span>                <span class="key">in if </span>t &lt;= z
<span class="line">  242 </span>                      <span class="key">then </span>(update (a, j, z);
<span class="line">  243 </span>                        sift j')
<span class="line">  244 </span>                   <span class="key">else </span>j
<span class="line">  245 </span>                <span class="key">end
</span><span class="line">  246 </span><span class="key">              else </span>j)
<span class="line">  247 </span>            <span class="key">val </span>_ = update (a, sift i, t)
<span class="line">  248 </span>         <span class="key">in </span>()
<span class="line">  249 </span>         <span class="key">end</span>)
<span class="line">  250 </span>     <span class="key">end
</span><span class="line">  251 </span><span class="key">
</span><span class="line">  252 </span><span class="key">      </span><span class="com">(* quicksort based on page 112 of Programming Pearls, by Bentley. *)</span>
<span class="line">  253 </span>      <span class="key">fun </span>'a quicksort (a: 'a array, <span class="key">op </span>&lt;= : 'a * 'a -&gt; <span class="typ">bool</span>): unit =
<span class="line">  254 </span>     <span class="key">let
</span><span class="line">  255 </span><span class="key">        fun </span>x i = Array.sub (a, i)
<span class="line">  256 </span>        <span class="key">fun </span>swap (i, j) =
<span class="line">  257 </span>           <span class="key">let
</span><span class="line">  258 </span><span class="key">          val </span>t = x i
<span class="line">  259 </span>          <span class="key">val </span>_ = update (a, i, x j)
<span class="line">  260 </span>          <span class="key">val </span>_ = update (a, j, t)
<span class="line">  261 </span>           <span class="key">in </span>()
<span class="line">  262 </span>           <span class="key">end
</span><span class="line">  263 </span><span class="key">        val </span>cutoff = <span class="num">20
</span><span class="line">  264 </span><span class="num">        </span><span class="key">fun </span>qsort (l: <span class="typ">int</span>, u: <span class="typ">int</span>): unit =
<span class="line">  265 </span>           <span class="key">if </span>u - l &gt; cutoff
<span class="line">  266 </span>          <span class="key">then
</span><span class="line">  267 </span><span class="key">             let
</span><span class="line">  268 </span><span class="key">            val </span>_ = swap (l, randInt (l, u))
<span class="line">  269 </span>            <span class="key">val </span>t = x l
<span class="line">  270 </span>            <span class="key">val </span>m =
<span class="line">  271 </span>               fold
<span class="line">  272 </span>               (l + <span class="num">1</span>, u, l, <span class="key">fn </span>(i, m) =&gt;
<span class="line">  273 </span>                (assert
<span class="line">  274 </span>                 (<span class="str">&quot;qsort&quot;</span>, <span class="key">fn </span>() =&gt;
<span class="line">  275 </span>                  forall (l + <span class="num">1</span>, m, <span class="key">fn </span>k =&gt; x k &lt;= t)
<span class="line">  276 </span>                  <span class="key">andalso </span>forall (m + <span class="num">1</span>, i <span class="num">- 1</span>, <span class="key">fn </span>k =&gt; not (x k &lt;= t)))
<span class="line">  277 </span>                 ; <span class="key">if </span>x i &lt;= t
<span class="line">  278 </span>                  <span class="key">then </span>(swap (m + <span class="num">1</span>, i)
<span class="line">  279 </span>                    ; m + <span class="num">1</span>)
<span class="line">  280 </span>                   <span class="key">else </span>m))
<span class="line">  281 </span>            <span class="key">val </span>_ = swap (l, m)
<span class="line">  282 </span>            <span class="key">val </span>_ = qsort (l, m <span class="num">- 1</span>)
<span class="line">  283 </span>            <span class="key">val </span>_ = qsort (m + <span class="num">1</span>, u)
<span class="line">  284 </span>             <span class="key">in </span>()
<span class="line">  285 </span>             <span class="key">end
</span><span class="line">  286 </span><span class="key">           else </span>()
<span class="line">  287 </span>        <span class="key">val </span>max = Array.length a <span class="num">- 1
</span><span class="line">  288 </span><span class="num">        </span><span class="key">val </span>_ = qsort (<span class="num">0</span>, max)
<span class="line">  289 </span>        <span class="key">val </span>_ = insertionSort (a, <span class="key">op </span>&lt;=)
<span class="line">  290 </span>     <span class="key">in
</span><span class="line">  291 </span><span class="key">        </span>()
<span class="line">  292 </span>     <span class="key">end
</span><span class="line">  293 </span><span class="key">   end
</span><span class="line">  294 </span><span class="key">
</span><span class="line">  295 </span><span class="key">structure </span>Test : <span class="key">sig
</span><span class="line">  296 </span><span class="key">    val </span>main : (<span class="typ">string </span>* <span class="typ">string </span>list) -&gt; OS.Process.status
<span class="line">  297 </span><span class="key">end </span>= <span class="key">struct
</span><span class="line">  298 </span><span class="key">
</span><span class="line">  299 </span><span class="key"></span><span class="com">(* This hash function is taken from pages 56-57 of
</span><span class="line">  300 </span><span class="com"> * The Practice of Programming by Kernighan and Pike.
</span><span class="line">  301 </span><span class="com"> *)</span>
<span class="line">  302 </span><span class="key">fun </span>hash (s: <span class="typ">string</span>): <span class="typ">word </span>=
<span class="line">  303 </span>   <span class="key">let
</span><span class="line">  304 </span><span class="key">      val </span>n = <span class="key">String</span>.size s
<span class="line">  305 </span>      <span class="key">fun </span>loop (i, w) =
<span class="line">  306 </span>     <span class="key">if </span>i = n
<span class="line">  307 </span>        <span class="key">then </span>w
<span class="line">  308 </span>     <span class="key">else Word</span>.fromInt (<span class="key">Char</span>.ord (<span class="key">String</span>.sub (s, i))) + <span class="key">Word</span>.* (w, <span class="num">0w31</span>)
<span class="line">  309 </span>   <span class="key">in
</span><span class="line">  310 </span><span class="key">      </span>loop (<span class="num">0</span>, <span class="num">0w0</span>)
<span class="line">  311 </span>   <span class="key">end
</span><span class="line">  312 </span><span class="key">
</span><span class="line">  313 </span><span class="key">fun </span>hash (s: <span class="typ">string</span>): <span class="typ">word </span>=
<span class="line">  314 </span>   <span class="key">let
</span><span class="line">  315 </span><span class="key">      val </span>n = <span class="key">String</span>.size s
<span class="line">  316 </span>      <span class="key">fun </span>loop (i, w) =
<span class="line">  317 </span>     <span class="key">if </span>i = n
<span class="line">  318 </span>        <span class="key">then </span>w
<span class="line">  319 </span>     <span class="key">else </span>loop (i + <span class="num">1</span>,
<span class="line">  320 </span>            <span class="key">Word</span>.fromInt (<span class="key">Char</span>.ord (<span class="key">String</span>.sub (s, i)))
<span class="line">  321 </span>               + <span class="key">Word</span>.* (w, <span class="num">0w31</span>))
<span class="line">  322 </span>   <span class="key">in
</span><span class="line">  323 </span><span class="key">      </span>loop (<span class="num">0</span>, <span class="num">0w0</span>)
<span class="line">  324 </span>   <span class="key">end
</span><span class="line">  325 </span><span class="key">
</span><span class="line">  326 </span><span class="key"></span><span class="com">(* Based on wordfreq.ocaml. *)</span>
<span class="line">  327 </span>
<span class="line">  328 </span><span class="key">val </span>max = <span class="num">4096
</span><span class="line">  329 </span><span class="num"></span><span class="key">val </span>buf = Word8Array.array (max, <span class="num">0w0</span>)
<span class="line">  330 </span><span class="key">val </span>count: {hash: <span class="typ">word</span>,
<span class="line">  331 </span>        <span class="typ">word</span>: <span class="typ">string</span>,
<span class="line">  332 </span>        count: <span class="typ">int </span>ref} HashSet.t = HashSet.new {hash = #hash}
<span class="line">  333 </span><span class="key">val </span>wbuf = Buffer.new <span class="num">64
</span><span class="line">  334 </span><span class="num">
</span><span class="line">  335 </span><span class="num"></span><span class="key">val </span>c2b = Byte.charToByte
<span class="line">  336 </span><span class="key">fun </span>scan_words (i, n, inword) =
<span class="line">  337 </span>  <span class="key">if </span>i &lt; n
<span class="line">  338 </span>     <span class="key">then
</span><span class="line">  339 </span><span class="key">    let
</span><span class="line">  340 </span><span class="key">       val </span>c = Word8Array.sub (buf, i)
<span class="line">  341 </span>    <span class="key">in
</span><span class="line">  342 </span><span class="key">       if </span>c2b #<span class="str">&quot;a&quot;</span> &lt;= c <span class="key">andalso </span>c &lt;= c2b #<span class="str">&quot;z&quot;</span>
<span class="line">  343 </span>          <span class="key">then </span>(Buffer.add (wbuf, c);
<span class="line">  344 </span>            scan_words (i + <span class="num">1</span>, n, <span class="key">true</span>))
<span class="line">  345 </span>       <span class="key">else
</span><span class="line">  346 </span><span class="key">          if </span>c2b #<span class="str">&quot;A&quot;</span> &lt;= c <span class="key">andalso </span>c &lt;= c2b #<span class="str">&quot;Z&quot;</span>
<span class="line">  347 </span>         <span class="key">then
</span><span class="line">  348 </span><span class="key">            </span>(Buffer.add (wbuf, c + <span class="num">0w32</span>);
<span class="line">  349 </span>             scan_words (i + <span class="num">1</span>, n, <span class="key">true</span>))
<span class="line">  350 </span>          <span class="key">else
</span><span class="line">  351 </span><span class="key">         if </span>inword
<span class="line">  352 </span>            <span class="key">then
</span><span class="line">  353 </span><span class="key">               let
</span><span class="line">  354 </span><span class="key">              val </span>w = Buffer.contents wbuf
<span class="line">  355 </span>              <span class="key">val </span>h = hash w
<span class="line">  356 </span>               <span class="key">in
</span><span class="line">  357 </span><span class="key">              </span>incr (#count
<span class="line">  358 </span>                (HashSet.lookupOrInsert
<span class="line">  359 </span>                 (count, h,
<span class="line">  360 </span>                  <span class="key">fn </span>{hash, <span class="typ">word</span>, ...} =&gt;
<span class="line">  361 </span>                  hash = h <span class="key">andalso </span><span class="typ">word </span>= w,
<span class="line">  362 </span>                  <span class="key">fn </span>() =&gt; {hash = h, <span class="typ">word </span>= w, count = ref <span class="num">0</span>})));
<span class="line">  363 </span>              Buffer.clear wbuf;
<span class="line">  364 </span>              scan_words (i + <span class="num">1</span>, n, <span class="key">false</span>)
<span class="line">  365 </span>               <span class="key">end
</span><span class="line">  366 </span><span class="key">         else </span>scan_words (i + <span class="num">1</span>, n, <span class="key">false</span>)
<span class="line">  367 </span>    <span class="key">end
</span><span class="line">  368 </span><span class="key">  else
</span><span class="line">  369 </span><span class="key">     let
</span><span class="line">  370 </span><span class="key">    val </span>nread =
<span class="line">  371 </span>       Posix.IO.readArr (Posix.FileSys.stdin, Word8ArraySlice.full buf)
<span class="line">  372 </span>     <span class="key">in
</span><span class="line">  373 </span><span class="key">    if </span>nread = <span class="num">0
</span><span class="line">  374 </span><span class="num">       </span><span class="key">then </span>()
<span class="line">  375 </span>    <span class="key">else </span>scan_words (<span class="num">0</span>, nread, inword)
<span class="line">  376 </span>     <span class="key">end
</span><span class="line">  377 </span><span class="key">
</span><span class="line">  378 </span><span class="key">fun </span>printl [] = print <span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span> | printl(h::t) = ( print h ; printl t )
<span class="line">  379 </span>
<span class="line">  380 </span><span class="key">fun </span>rightJustify (s: <span class="typ">string</span>, width: <span class="typ">int</span>) =
<span class="line">  381 </span>   <span class="key">let
</span><span class="line">  382 </span><span class="key">      val </span>n = <span class="key">String</span>.size s
<span class="line">  383 </span>   <span class="key">in </span>concat [CharVector.tabulate (width - n, <span class="key">fn </span>_ =&gt; #<span class="str">&quot; &quot;</span>), s]
<span class="line">  384 </span>   <span class="key">end
</span><span class="line">  385 </span><span class="key">
</span><span class="line">  386 </span><span class="key">fun </span>main (name, args) =
<span class="line">  387 </span>   <span class="key">let
</span><span class="line">  388 </span><span class="key">    val </span>_ = scan_words (<span class="num">0</span>, <span class="num">0</span>, <span class="key">false</span>)
<span class="line">  389 </span>    <span class="key">val </span>a = Array.array (HashSet.size count, (<span class="num">0</span>, <span class="str">&quot;&quot;</span>))
<span class="line">  390 </span>    <span class="key">val </span>i = ref <span class="num">0
</span><span class="line">  391 </span><span class="num">    </span><span class="key">val </span>_ = HashSet.foreach (count, <span class="key">fn </span>{<span class="typ">word</span>, count, ...} =&gt;
<span class="line">  392 </span>             (Array.update (a, !i, (!count, <span class="typ">word</span>)); incr i))
<span class="line">  393 </span>    <span class="key">val </span>_ = Quicksort.quicksort (a, <span class="key">fn </span>((c, w), (c', w')) =&gt;
<span class="line">  394 </span>                 c &gt; c' <span class="key">orelse </span>c = c' <span class="key">andalso </span>w &gt;= w')
<span class="line">  395 </span>    <span class="key">val </span>_ = Array.app (<span class="key">fn </span>(c, w) =&gt;
<span class="line">  396 </span>           printl [rightJustify (<span class="key">Int</span>.toString c, <span class="num">7</span>), <span class="str">&quot;</span><span class="esc">\t</span><span class="str">&quot;</span>, w]) a
<span class="line">  397 </span>   <span class="key">in
</span><span class="line">  398 </span><span class="key">      </span>OS.Process.success
<span class="line">  399 </span>   <span class="key">end
</span><span class="line">  400 </span><span class="key">end
</span><span class="line">  401 </span><span class="key">
</span><span class="line">  402 </span><span class="key">val </span>_ = Test.main( CommandLine.name(), CommandLine.arguments() )
</pre>
</body>
</html>
<!--HTML generated by highlight 2.0-24, http://www.andre-simon.de/-->
