#!/usr/bin/python -OO
# The Computer Language Benchmarks Game
# $Id: nanobench,v 1.30 2008-07-31 00:57:34 igouy-guest Exp $

"""
Description: nanobench records a program's cpu
time, and samples resident memory usage and
records cpu load while a program is running. 

nanobench can be used in a limited way standalone
- it is intended for use with the make files and 
directories of The Computer Language Benchmarks Game. 

Usage: nanobench -options

where standalone options include:

   --cmd <commandline string>
      commandline string should be sufficient 
      to run a program from the current directory

   --runs <int>
      how many times to run a program [3]

   --cutoff <int>
      how many seconds to allow before 
      cancelling additional program runs [60]

   --delay <float>
      delay in seconds between sampling 
      memory usage [0.2]

   --maxtime <int>
      how many seconds to allow before 
      stopping a program [600]

   -h --help
      print this help message

where benchmarks game options include:

   --conf <path>
      configuration file [./nanobench.conf]

   --range <test values>
      comma separated int program args

   --data <path>
      test data file

   --ndiff <parameter string>
      ndiff parameters, example "-abserr 1.0e-8"

   --binarycmp
      program output is binary, use cmp

where benchmarks game .ini file options include:

   logfilemax: <int>
      set greater than 0 to create a rotating
      log file [0]

   outputmax: <int>
      how many bytes of a program output to 
      include in each build & run log before 
      truncating program output [10240]


Output: _,0,40.739,6356,100% 0% 0% 0%
   _ 
   0		exit status (-1 error, -2 timeout)
   40.739	user time + system time (seconds)
   6356		sampled resident memory usage (KB)
   100%		cpu load during a program run
"""

from __future__ import with_statement

__author__ =  'Isaac Gouy'


from domain import FileNameParts, LinkNameParts, Record
from nanolib import configureLogger, getLogger, envPath

import sys, os, re, fnmatch, bz2, copy

# need to use ConfigParser not SafeConfigParser
from ConfigParser import ConfigParser, NoSectionError, NoOptionError

from contextlib import nested
from cStringIO import StringIO
from errno import ENOENT, EEXIST, EISDIR
from getopt import getopt, GetoptError
from shutil import copyfile,rmtree
from subprocess import call, STDOUT
from tempfile import TemporaryFile
from time import strftime, localtime, gmtime
from os.path import expanduser, expandvars, getsize, getmtime, isdir, isfile, \
                    join, normpath, realpath, split, splitext   


# globals
logfilemax = 0
logger = None
loggerLine = None


make = frozenset()
commandlines = {}
alias = {}
testvalues = []
data = None
ndiff = None
binarycmp = None

runs = 3
cutoff = 60
delay = 0.2
maxtime = 600

outputmax = 10240

_OUT = '_out'

logdirName = 'log'
datdirName = 'dat'
tmpdirName = 'tmp'
codedirName = 'code'

sitename = None
srcdir = None
testdir = None
makedir = None
logdir = None
datdir = None
tmpdir = None
codedir = None



def initializeFrom(ini):
   global runs, cutoff, delay, maxtime, logfilemax, outputmax, make

   try:
      parser = ConfigParser()
      parser.read(ini)

      make = frozenset( parser.get("build", "make").split() )
      commandlines.update( parser.items("commandlines") )

      for k,v in parser.items("alias"):
         alias[k] = v.split() 

      s = 'measure'
      if parser.has_section(s):
         for o in parser.options(s):
            if o in ('runs'):
               runs = parser.getint(s,o)
            elif o in ('cutoff'):
               cutoff = parser.getint(s,o)
            elif o in ('delay'):
               delay = parser.getfloat(s,o)
            elif o in ('maxtime'):
               maxtime = parser.getint(s,o)  
            elif o in ('logfilemax'):
               logfilemax = parser.getint(s,o)  
            elif o in ('outputmax'):
               outputmax = parser.getint(s,o) 

   except (NoSectionError,NoOptionError), e:
      if logger: logger.debug(e)
      print e, 'in', realpath(ini)
      sys.exit(2)



def createDirectories():
   global srcdir,sitename,testdir,makedir,logdir,datdir,tmpdir,codedir,logger

   def ifNoneMkdir(path,name):
      d = join(path,name)
      if not isdir(d): 
         os.mkdir(d) 
         if logger: logger.debug('mkdir %s' % d)
      return d

   # assume srcdir path ends with a test name
   srcdir = os.getcwd()

   rootdir = envPath('SITE_ROOT')
   if rootdir:
      if not isdir(rootdir): os.mkdir(rootdir) 
      configureLogger(logfilemax,rootdir)
      logger = getLogger()
      testdir = ifNoneMkdir(rootdir,split(srcdir)[1])
   else:
      print 'please set SITE_ROOT in Makefile.site_*'
      sys.exit(0)

   sitename = os.environ.get( 'SITE_NAME', '')
   if not sitename:
      print 'please set SITE_NAME in Makefile.site_*'
      if logger: logger.critical('please set SITE_NAME in Makefile.site_*')
      sys.exit(0)

   makedir = envPath('SITE_MAKEFILES')
   if not isdir(makedir):
      print 'please set NANO_ROOT for MAKE_ROOT in Makefile.site_*'
      if logger: logger.critical('please set NANO_ROOT for MAKE_ROOT in Makefile.site_*')
      sys.exit(0)

   csvsweep = envPath('CSV_SWEEP')
   if csvsweep and not isdir(csvsweep): 
      os.mkdir(csvsweep) 
      if logger: logger.debug('mkdir CSV_SWEEP %s' % csvsweep)

   codesweep = envPath('CODE_SWEEP')
   if codesweep and not isdir(codesweep): 
      os.mkdir(codesweep) 
      if logger: logger.debug('mkdir CODE_SWEEP %s' % codesweep)

   logsweep = envPath('LOG_SWEEP')
   if logsweep and not isdir(logsweep): 
      os.mkdir(logsweep) 
      if logger: logger.debug('mkdir LOG_SWEEP %s' % logsweep)

   logdir = ifNoneMkdir(testdir,logdirName)
   datdir = ifNoneMkdir(testdir,datdirName)
   tmpdir = join(testdir,tmpdirName)
   codedir = ifNoneMkdir(testdir,codedirName)



def targets():
   # include undeleted filenames that might have a file extension
   files = fnmatch.filter( os.listdir(srcdir), '*.*[!~]' )

   # exclude bogus files created by touch
   files = [FileNameParts(f) for f in files if not f.startswith('*')]


   # ALLOW these helper file extensions to be available unchanged 
   # from the working directory - they will never be measured
   a = frozenset( os.environ.get( 'ALLOW', '').split() )
   allowed = []; _files = files; files = []

   for f in _files:
      if f.ext in a:
         allowed.append(f)
      else:
         files.append(f)
      # giving a list of ALLOWed filenames and a list without ALLOWed filenames


   # reverse alias dictionary so we can look up the target for each alias
   revAlias = {}
   for k,vs in alias.iteritems():
      for v in vs:
         revAlias[v] = k

   links = [] 
 
   # ONLY measure files with these extensions 
   o = os.environ.get( 'ONLY', '').split()
   if o:
      _files = files; files = []
      
      for ext in o:
         reva = revAlias.get(ext,None)   
         for f in _files:
            if reva:
               if f.ext == reva:
                  links.append(LinkNameParts(f.filename,ext)) 
            else:
               if f.ext == ext:
                  files.append(f)
      # giving a list of ONLY links and a list of ONLY files

   # measure files with ANY extension, except ...
   else: 
      # create alias filenames
      for f in files:
         for ext in alias.get(f.ext,[]):
            links.append(LinkNameParts(f.filename,ext)) 

      # IGNORE files or links with these extensions
      ignore = frozenset( os.environ.get( 'IGNORE', '').split() )
      if ignore:
         links = [f for f in links if not f.ext in ignore]
         files = [f for f in files if not f.ext in ignore]


   # assume dat file is only written once, when all data is available

   def notUpToDate(s,d):
      try:
         return getmtime(s) > getmtime( join(datdir,d) )
      except OSError, (e,_): 
         return e == ENOENT # No such file or directory

   links = [f for f in links if notUpToDate(f.filename,f.datName)]
   files = [f for f in files if notUpToDate(f.filename,f.datName)]

   return allowed,files,links



def cmdTemplate(p):
   specials = {}
   specials['%X'] = p.runName if hasMake(p.ext) else p.programName
   specials['%T'] = p.name
   specials['%B'] = p.baseName
   specials['%I'] = p.id

   s = commandlines.get(p.ext,None)
   if s:
      for m in re.finditer('\$[\w]+' ,s): 
         k = m.group(0)
         v = os.environ.get( k.lstrip('$'), '' )
         s = re.sub('\\' + k + '(?P<c>[\W])', v + '\g<c>', s) # ate [\W] !

      for m in re.finditer('\%[XTBI]' ,s):
         value = specials.get( m.group(0), '' )
         s = re.sub('\\'+ m.group(0), value, s) 

   else:
      s = join('.',p.runName) + ' %A'

   return s



def cmdWithArg(s,arg):
   _a = '' if data else arg
   for m in re.finditer('\%A' ,s):
      s = re.sub('\\'+ m.group(0), _a, s) 
   return s



# adapt to unavailable libgtop2
try:
   import gtop
except ImportError, (_,err):
   if logger: logger.warn(err)
   from planB import measure # only rusage cpu time
else:
   from planA import measure # cpu load, resident memory and rusage cpu time



def dataName(arg):
   # assume there is a data file
   root,ext = splitext(data)
   return normpath( expandvars( expanduser( root + arg + ext )))



def outName(index):
   return join(_OUT) if index == 0 else '/dev/null'



def logName(p):
   return join(logdir, p.logName)



def diffName():
   return join(tmpdir,'_diff')



def errName():
   return join(tmpdir,'_err')



def makeName():
   return join(tmpdir,'_make')



def hasMake(ext):
   return ext in make



def callMake(p):
   with open( makeName(), 'w') as mf: 
      mf.write('\nMAKE:\n')

   optionFile = join(makedir, sitename + '.programs.Makefile')
   cmd = 'make -f ' + optionFile + ' ' + p.runName
   with open( makeName(), 'a') as mf:
      call(cmd.split(),stdout=mf,stderr=STDOUT)



def symlinkSource(directory,filename,dstDir=None,srcFilename=None):
   # beware - read carefully
   src = join(directory,filename) \
      if srcFilename == None else join(directory,srcFilename)

   # tmpdir is $CWD
   dst = join(filename) if dstDir == None else join(dstDir,filename)

   try:
      os.symlink(src,dst)
   except OSError, (e,_):
      if e == EEXIST: pass # OK the symlink already exists



def standalone(cmd):
   results = StringIO()
   for i in range(0,runs):
      with nested( open( outName(i), 'w'), 
                   TemporaryFile(mode='w+t')) as (of,ef):

         m = measure('_',cmd.split(),delay,maxtime,of,ef)
         print >>results, m
         if ef.tell(): ef.seek(0); print >>results, ef.read()

         if not m.isOkay(): break
         if m.hasExceeded(cutoff): continue

   print results.getvalue()
   results.close()



def checkAndLog(m,outFile,logf):
   if m.isOkay():
      # assume outFile has been closed
      argFile = m.argString + _OUT

      # diff against expected output file
      if isfile(argFile): 
         with open( diffName(), 'w') as df:
            try:
               # compare _OUT not outFile so short name will be shown in logf
               if ndiff:
                  call(["ndiff",'-quiet',ndiff,_OUT,argFile],stdout=df,stderr=STDOUT)
               elif binarycmp:
                  call(["cmp",_OUT,argFile],stdout=df,stderr=STDOUT)
               else:
                  call(["diff",_OUT,argFile],stdout=df,stderr=STDOUT)

            except OSError, (e,err): 
               if e == ENOENT: # No such file or directory 
                  m.setBadOutput()
                  print >>logf, '\nFAIL:', err, '\n'
                  print 'FAIL ', err, 

            if df.tell(): 
               m.setBadOutput()

      else: # create the initial expected output file
         copyfile(outFile, join('..', m.argString + _OUT))
                  
   if not m.isOkay():
      extra = '' if not m.hasTimedout() else ' %s%d%s' % ('after',maxtime,'s')
      print >>logf, '\n%s%s\n' % (m.statusStr(),extra)



def measureCheckAndLog(p,t,ms):
   revisedTestValues = []

   for a in testvalues:
      cmd = cmdWithArg(t,a)
      ofName = outName(0)

      # a logged Empty record will reveal a nanobench failure
      m = Record() 

      try:
         with open(logName(p),'w') as logf:
            with open(ofName,'w') as of:
               # append timestamp to log
               print >>logf, '\n', strftime("%a, %d %b %Y %H:%M:%S GMT", gmtime())

               # append Make output to log
               if hasMake(p.ext):
                  with open( makeName(), 'r') as mf:
                     logf.write( mf.read() ) 

               with open(errName(),'w+') as ef:
                  # append command line showing redirected test data file to log
                  if data:
                     dfName = dataName(a)
                     print >>logf, '\nCOMMAND LINE:\n', cmd, '<', split(dfName)[1]
                     with open(dfName,'r') as df:
                        m = measure(a,cmd.split(),delay,maxtime,of,ef,df,logger=logger)

                  # append command line showing test value argument to log
                  else:
                     print >>logf, '\nCOMMAND LINE:\n', cmd
                     m = measure(a,cmd.split(),delay,maxtime,of,ef,logger=logger)

            # check the program output was as expected
            checkAndLog(m,ofName,logf)

            # add to the measurements
            ms.append(m)

            # if there was a problem finding the program just ignore the program output
            if not m.isMissing():
               with open(ofName,'r+') as of:
                  # append diff or ndiff or cmp output to log
                  if m.hasBadOutput():
                     with open(diffName(), 'r') as df:
                        logf.write( df.read() )               

                  # append program output to log
                  if binarycmp:
                     logf.write( '\n(BINARY) PROGRAM OUTPUT NOT SHOWN\n' )
                  elif getsize(ofName) > outputmax:
                     of.truncate(outputmax)
                     logf.write( '\n(TRUNCATED) PROGRAM OUTPUT:\n' )
                     logf.write( of.read() )
                  else:
                     logf.write( '\nPROGRAM OUTPUT:\n' )
                     logf.write( of.read() )

                  # append program stderr to log
                  if getsize(errName()):
                     with open(errName(), 'r') as ef:
                        logf.write( '\n' )
                        logf.write( ef.read() )               

         if not m.isOkay(): break
         if m.hasExceeded(cutoff): continue
         revisedTestValues.append(a)

      except IOError, err:
         if logger: logger.error(err)

      finally:
         sys.stdout.write('.'); sys.stdout.flush()
         loggerLine.write('.')

   sys.stdout.write( m.statusStr() ); sys.stdout.flush()
   loggerLine.write( m.statusStr() )

   return revisedTestValues



def measureOnly(revisedTestValues,t,ms):
   for i in range(1,runs):
      for a in revisedTestValues:
         cmd = cmdWithArg(t,a)
         with open( outName(i), 'w') as of:

            # pass the test data file to program stdin
            if data:
               dfName = dataName(a)
               with open(dfName,'r') as df:
                  m = measure(a,cmd.split(),delay,maxtime,of,STDOUT,df,logger=logger)

            # pass the test value as a command line argument in cmd
            else:
                  m = measure(a,cmd.split(),delay,maxtime,of,STDOUT,logger=logger)

            # add to the measurements
            ms.append(m)

         sys.stdout.write('.'); sys.stdout.flush()
         loggerLine.write('.')



def cleanTmpdirFor(p,allowed):
   # every time, provide each program with a clean empty tmpdir
   os.chdir(testdir)

   try:
      rmtree(tmpdir)
      os.mkdir(tmpdir)
   except OSError, err:
      if logger: logger.error(err)

   # make sure all build files and crash files are created in tmpdir
   os.chdir(tmpdir)

   # symlink from tmpdir to Include directory
   symlinkSource( normpath( join(srcdir,'..') ) ,'Include')

   # symlink from tmpdir to these allowed helper files 
   for f in allowed:
      symlinkSource(srcdir,f.filename)

   # symlink from tmpdir to expected output files
   for f in [f for f in os.listdir(testdir) if f.endswith(_OUT)]:
      symlinkSource(testdir,f)

   # symlink from tmpdir to the program source code file
   symlinkSource(codedir,p.programName)



def measurePrograms(programs,allowed):
   global loggerLine

   def fillInMissingRecords(ms):
      for a in testvalues[len(ms):]:
         c = copy.deepcopy(ms[-1:])
         if c:
            c[0].argString = a
            ms.append(c[0])

   total = len(programs)

   for p in programs:
      cleanTmpdirFor(p,allowed)

      sys.stdout.write('%s ' % strftime('%a %H:%M:%S', localtime()))
      sys.stdout.flush()

      if hasMake(p.ext):
         callMake(p)   


      loggerLine = StringIO()
      t = cmdTemplate(p)
      ms = []
      revisedTestValues = measureCheckAndLog(p,t,ms)
      fillInMissingRecords(ms)
      measureOnly(revisedTestValues,t,ms)

      # Write compressed dat file once, when all data is available
      try:
         datf = bz2.BZ2File( join(datdir,p.datName) ,'w')
         for m in ms: print >>datf, m
      except IOError, err:
         if logger: logger.error(err)
      finally:
         datf.close()

      loggerLine.write('%s [%d]' % (p.programName,total))
      sys.stdout.write('%s [%d]\n' % (p.programName,total)); sys.stdout.flush()
      total -= 1

      if logger: logger.info( loggerLine.getvalue() )
      loggerLine.close()



def benchmarksGame():
   # assume $CWD is a program source directory
   createDirectories()
   allowed,sources,links = targets()

   programs = set(sources)
   programs.update(links)

   # symlink these programs from codedir so they are available 
   # for conversion to highlight-ed xml files
   for f in programs:
      symlinkSource(directory=srcdir, srcFilename=f.filename,
         dstDir=codedir, filename=f.programName)

      symlinkSource(directory=srcdir, srcFilename=f.filename,
         dstDir=codedir, filename=f.codeName)

   measurePrograms(programs,allowed)



def main():
   global runs, cutoff, delay, maxtime, data, binarycmp

   try:
      options,_ = getopt(sys.argv[1:],'h',['cmd=' ,'runs=' ,'cutoff=' 
         ,'delay=' ,'maxtime=' ,'range=' ,'conf=' ,'ndiff=' ,'data=' 
         ,'binarycmp' ,'help'])

      for o, v in options:
         if o in ('--conf'):
            initializeFrom(v)

      # allow some config file settings to be over-ridden from the command line

      cmd = None
      for o, v in options:
         if o in ('-h', '--help'):
            print __doc__
            sys.exit(0)
         elif o in ('--cmd'):
            cmd = v
         elif o in ('--runs'):
            runs = int(v)
         elif o in ('--cutoff'):
            cutoff = int(v)
         elif o in ('--delay'):
            delay = float(v)
         elif o in ('--maxtime'):
            maxtime = int(v)  
         elif o in ('--range'):
            testvalues.extend( v.split(',') )
         elif o in ('--data'):
            data = v
         elif o in ('--ndiff'):
            ndiff = v
         elif o in ('--binarycmp'):
            binarycmp = True

      if cmd:
         standalone(cmd)
      else:
         benchmarksGame()

   except KeyboardInterrupt:
      if logger: logger.debug('Keyboard Interrupt')
      sys.exit(1)

   except GetoptError, err:
      if logger: logger.debug(err)
      print err
      print 'please try --help'
      sys.exit(2)


           
if __name__ == "__main__":
   main()


