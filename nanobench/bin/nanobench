#!/usr/bin/python
# The Computer Language Benchmarks Game
# $Id: nanobench,v 1.2 2008-07-24 19:27:24 igouy-guest Exp $

"""
Description: nanobench records a program's cpu
time, and samples resident memory usage and
records cpu load while a program is running. 

nanobench can be used in a limited way standalone
- it is intended for use with the make files and 
directories of The Computer Language Benchmarks Game. 

Usage: nanobench -options

where standalone options include:

   --cmd <commandline string>
      commandline string should be sufficient 
      to run a program from the current directory

   --repeat <int>
      how often to run a program [5]

   --cutoff <int>
      how many seconds to allow before 
      cancelling repeat of program run [60]

   --delay <float>
      delay in seconds between sampling 
      memory usage [0.2]

   --maxtime <int>
      how many seconds to allow before 
      stopping a program [600]

   -h --help
      print this help message

where benchmarks game options include:

   --conf <path>
      configuration file [./nanobench.conf]

   --range <test values>
      comma separated int program args

   --data <path>
      test data file

   --ndiff <parameter string>
      ndiff parameters, example "-abserr 1.0e-8"

   --binarycmp
      program output is binary, use cmp


Output: _,0,40.739,6356,100% 0% 0% 0%
   _ 
   0		exit status (-1 error, -2 timeout)
   40.739	user time + system time (seconds)
   6356		sampled resident memory usage (KB)
   100%		cpu load during a program run
"""

from __future__ import with_statement

import sys, os, os.path
from cStringIO import StringIO
from tempfile import TemporaryFile

__author__ =  'Isaac Gouy'



# globals
make = frozenset()
commandlines = {}
testvalues = []
data = None
ndiff = None
binarycmp = None

repeat = 5
cutoff = 60
delay = 0.2
maxtime = 600

maxsize = 10240

_OUT = '_out'

logdirName = 'log'
datdirName = 'dat'
tmpdirName = 'tmp'

sitename = None
sourcedir = None
rootdir = None
makedir = None
logdir = None
datdir = None
tmpdir = None



def initializeFrom(ini):
   global repeat, cutoff, delay, maxtime, make

   # need to use ConfigParser not SafeConfigParser
   from ConfigParser import ConfigParser, NoSectionError, NoOptionError

   try:
      parser = ConfigParser()
      parser.read(ini)

      make = frozenset( parser.get("build", "make").split() )
      commandlines.update( parser.items("commandlines") )

      s = 'measure'
      if parser.has_section(s):
         for o in parser.options(s):
            if o in ('repeat'):
               repeat = parser.getint(s,o)
            elif o in ('cutoff'):
               cutoff = parser.getint(s,o)
            elif o in ('delay'):
               delay = parser.getfloat(s,o)
            elif o in ('maxtime'):
               maxtime = parser.getint(s,o)  

   except (NoSectionError,NoOptionError), e:
      print e, 'in', os.path.realpath(ini)
      sys.exit(2)



def createDirectories():
   global sourcedir,sitename,rootdir,makedir,logdir,datdir,tmpdir
   from os.path import join,split,expanduser,expandvars,normpath,isdir

   sourcedir = os.getcwd()
   os.environ['SOURCE_DIR'] = sourcedir # Make.common uses $SOURCE_DIR

   # assume sourcedir path ends with a test name
   rootdir = normpath( expandvars( expanduser( os.environ.get( 'SITE_ROOT', ''))))
   if isdir(rootdir):
      rootdir = join(rootdir,split(sourcedir)[1])
      if not isdir(rootdir):
         os.mkdir(rootdir) 
   else:
      print 'please set SITE_ROOT in Makefile_local'
      sys.exit(0)
   
   sitename = os.environ.get( 'SITE_NAME', '')
   if not sitename:
      print 'please set SITE_NAME in Makefile_local'
      sys.exit(0)

   makedir = normpath( expandvars( expanduser( os.environ.get( 'SITE_MAKEFILES', ''))))
   if not isdir(makedir):
      print 'please set MAKE_ROOT in Makefile_local'
      sys.exit(0)

   logdir = join(rootdir,logdirName)
   if not isdir(logdir):
      os.mkdir(logdir) 

   datdir = join(rootdir,datdirName)
   if not isdir(datdir):
      os.mkdir(datdir) 

   tmpdir = join(rootdir,tmpdirName)
   if not isdir(tmpdir):
      os.mkdir(tmpdir) 



def targetPrograms():
   # assume dat file is only written once all data is available
   from errno import ENOENT
   from os.path import getmtime,splitext
   from fnmatch import filter

   # include undeleted filenames that might have a file extension
   files = filter( os.listdir(sourcedir), '*.*[!~]' )

   # exclude bogus files created by touch
   files = [f for f in files if not f.startswith('*')]

   # if some file extensions are explicitly selected, exclude those not selected
   selected = os.environ.get( 'SELECT', '')
   if selected:
      imps = [i for i in selected.split() if not i.startswith('*')]
      if imps:
         imps = frozenset(imps)
         files = [f for f in files if splitext(f)[1].lstrip('.') in imps]

   # if some file extensions are explicitly ignored, exclude them
   excluded = os.environ.get( 'IGNORE', '')
   if excluded:
      imps = [i for i in excluded.split() if not i.startswith('*')]
      if imps:
         imps = frozenset(imps)
         files = [f for f in files if not splitext(f)[1].lstrip('.') in imps]

   programs = set()
   for f in files:
      try:
         if getmtime(f) > getmtime( os.path.join(datdir,f) ):
            programs.add(f)
      except OSError, (e,_): 
         if e == ENOENT: # No such file or directory
            programs.add(f)

   return frozenset(programs)



def runName(filename):
   return filename + '_run'



def cmdTemplate(filename,ext):
   vars = {}
   vars['%X'] = runName(filename) if hasMake(ext) else filename

   names = filename.split('.') # We only selected filenames with a .
   vars['%T'] = names[0]
   vars['%B'] = '.'.join( names[0:len(names)-1] )

   p = names[1].split('-')
   vars['%I'] = p[1] if len(p) == 2 and p[1].isdigit() else ''

   vars['%S'] = os.path.join( os.getcwd(),'')

   s = commandlines.get(ext,None)
   if s:
      from re import finditer, sub

      for m in finditer('\$[\w]+' ,s): 
         k = m.group(0)
         v = os.environ.get( k.lstrip('$'), '' )
         s = sub('\\' + k + '(?P<c>[\W])', v + '\g<c>', s) # ate [\W] !

      for m in finditer('\%[XTBIS]' ,s):
         value = vars.get( m.group(0), '' )
         s = sub('\\'+ m.group(0), value, s) 

   else:
      s = os.path.join('.',runName(filename)) + ' %A'

   return s



def cmdWithArg(s,arg):
   from re import finditer, sub
   _a = '' if data else arg
   for m in finditer('\%A' ,s):
      s = sub('\\'+ m.group(0), _a, s) 
   return s



# adapt to unavailable libgtop2
try:
   import gtop
except ImportError:
   from planB import measure # only rusage cpu time
else:
   from planA import measure # cpu load, resident memory and rusage cpu time

import exit



def dataName(arg):
   # assume there is a data file
   root,ext = os.path.splitext(data)
   return root + arg + ext



def outName(directory,index):
   return os.path.join(directory,_OUT) if index == 0 else '/dev/null'



def logName(filename):
   return os.path.join(logdir,
         (os.path.splitext(filename)[0] if filename.find('-') > -1 
            else filename) + '.log')



def diffName():
   return os.path.join(tmpdir,'_diff')



def errName():
   return os.path.join(tmpdir,'_err')



def makeName():
   return os.path.join(tmpdir,'_make')



def hasExceededCutoff(m):
   return m[2] > cutoff



def hasMake(ext):
   return ext in make



def callMake(root,filename):
   from subprocess import call,STDOUT

   # step into tmpdir before the make 
   os.chdir(tmpdir)

   with open( makeName(), 'w') as mf: 
      mf.write('\nMAKE:\n')

   optionFile = os.path.join(root,'Make.common_' + sitename)
   cmd = 'make --no-print-directory -f ' + optionFile + ' ' + runName(filename)
   with open( makeName(), 'a') as mf:
      call(cmd.split(),stdout=mf,stderr=STDOUT)



def standalone(cmd):
   from contextlib import nested

   results = StringIO()
   for i in range(0,repeat):
      with nested( open( outName('./',i), 'w'), 
                   TemporaryFile(mode='w+t')) as (of,ef):
         m = measure('_',cmd.split(),delay,maxtime,of,ef)
         print >>results, '%s,%d,%.3f,%d,%s' % m
         if ef.tell(): ef.seek(0); print >>results, ef.read()
         if not exit.isOk(m) or hasExceededCutoff(m): break

   print results.getvalue()
   results.close()



def checkAndLog(m,outFile,logf):
   # assume outFile has been closed
   # assume $CWD contains the comparison files for different arg values
   from subprocess import call,STDOUT
   from shutil import copyfile
   m_ = m

   if exit.isError(m):
      print >>logf, '\nERROR\n'

   elif exit.isTimeout(m):
      print >>logf, '\nTIMEOUT\n'

   elif exit.isMissing(m):
      print >>logf, '\nMISSING\n'

   else:
      # assume $CWD contains the comparison files for different arg values
      argFile = m[0]+_OUT

      # diff against expected output file
      if os.path.isfile(argFile): 
         with open( diffName(), 'w') as df:
            try:
               # compare _OUT not outFile so short name will be shown in logf
               if ndiff:
                  call(["ndiff",'-quiet',ndiff,_OUT,argFile],
                        stdout=df,stderr=STDOUT)
               elif binarycmp:
                  call(["cmp",_OUT,argFile],stdout=df,stderr=STDOUT)
               else:
                  call(["diff",_OUT,argFile],stdout=df,stderr=STDOUT)

            except OSError, (e,err): 
               if e == ENOENT: # No such file or directory 
                  print >>logf, '\nMISSING:', err, '\n'

            if df.tell(): 
               print >>logf, '\nUNEXPECTED OUTPUT:'

               # mark the measurement tuple as bad output
               m_ = (m[0],exit.BADOUT,m[2],m[3],m[4])

      else: # create the initial expected output file
         copyfile(outFile,argFile)

   return m_



def measureCheckAndLog(t,f,ext,r):
   from time import strftime,gmtime

   revisedTestValues = []

   for a in testvalues:
      cmd = cmdWithArg(t,a)
      ofName = outName(tmpdir,0)
      m = ('_',exit.ERROR,0,0,"%")

      try:
         with open(logName(f),'w') as logf:
            with open(ofName,'w') as of:
               # append timestamp to log
               print >>logf, '\n', strftime("%a, %d %b %Y %H:%M:%S GMT", gmtime())

               # append Make output to log
               if hasMake(ext):
                  with open( makeName(), 'r') as mf:
                     logf.write( mf.read() ) 

               with open(errName(),'w+') as ef:
                  # append command line showing redirected test data file to log
                  if data:
                     dfName = dataName(a)
                     print >>logf, '\nCOMMAND LINE:\n', cmd, '<', os.path.split(dfName)[1]
                     with open(dfName,'r') as df:
                        m = measure(a,cmd.split(),delay,maxtime,of,ef,df)

                  # append command line showing test value argument to log
                  else:
                     print >>logf, '\nCOMMAND LINE:\n', cmd
                     m = measure(a,cmd.split(),delay,maxtime,of,ef)

            # check the program output was as expected
            m = checkAndLog(m,ofName,logf)
            print >>r, '%s,%d,%.3f,%d,%s' % m

            with open(ofName,'r+') as of:
               # append diff or ndiff output to log
               if exit.isBadout(m):
                  with open(diffName(), 'r') as df:
                     logf.write( df.read() )               

               # append program output to log
               if binarycmp:
                  logf.write( '\n(BINARY) PROGRAM OUTPUT NOT SHOWN\n' )
               elif os.path.getsize(ofName) > maxsize:
                  of.truncate(maxsize)
                  logf.write( '\n(TRUNCATED) PROGRAM OUTPUT:\n' )
                  logf.write( of.read() )
               else:
                  logf.write( '\nPROGRAM OUTPUT:\n' )
                  logf.write( of.read() )

               # append program stderr to log
               if os.path.getsize(errName()):
                  with open(errName(), 'r') as ef:
                     logf.write( '\n' )
                     logf.write( ef.read() )               

         if not exit.isOk(m) or hasExceededCutoff(m): break
         revisedTestValues.append(a)

      except IOError, (_,e):
         print 'MISSING', e # need to do something better when there's a missing file

      finally:
         sys.stdout.write('.'); sys.stdout.flush()

   if exit.isOk(m):
      print 'OK ',
   elif exit.isError(m):
      print 'ERROR ',
   elif exit.isTimeout(m):
      print 'TIMEOUT ',
   elif exit.isBadout(m):
      print 'BAD OUTPUT ',
   elif exit.isMissing(m):
      print 'MISSING ',
   sys.stdout.flush()

   return revisedTestValues



def measureOnly(revisedTestValues,t,f,r):
   from subprocess import STDOUT
   for i in range(1,repeat):
      for a in revisedTestValues:
         cmd = cmdWithArg(t,a)
         with open( outName(tmpdir,i), 'w') as of:

            # pass the test data file to program stdin
            if data:
               dfName = dataName(a)
               with open(dfName,'r') as df:
                  m = measure(a,cmd.split(),delay,maxtime,of,STDOUT,df)

            # pass the test value as a command line argument in cmd
            else:
                  m = measure(a,cmd.split(),delay,maxtime,of,STDOUT)

            # record the measurement tuple 
            print >>r, '%s,%d,%.3f,%d,%s' % m

         sys.stdout.write('.'); sys.stdout.flush()



def benchmarksGame():
   # assume $CWD is a program source directory
   from time import strftime,localtime

   createDirectories()
   programs = targetPrograms()
    
   for filename in programs:
      sys.stdout.write('%s ' % strftime('%a %H:%M:%S', localtime())); sys.stdout.flush()
      ext = filename.split('.').pop() # We only selected filenames with a .

      if hasMake(ext):
         # step into tmpdir before the make 
         callMake(makedir,filename)    

      t = cmdTemplate(filename,ext)
      r = StringIO()

      revisedTestValues = measureCheckAndLog(t,filename,ext,r)

      measureOnly(revisedTestValues,t,filename,r)

      # Write dat file once, when all data is available
      with open( os.path.join(datdir,filename),'w') as datf:
         datf.write( r.getvalue() )

      r.close()
      sys.stdout.write('%s\n' % filename); sys.stdout.flush()

      # step into sourcedir (we might have stepped into tmpdir)
      os.chdir(sourcedir)



def main():
   global repeat, cutoff, delay, maxtime, data, binarycmp
   from getopt import getopt, GetoptError

   try:
      options,_ = getopt(sys.argv[1:],'h',['cmd=' ,'repeat=' ,'cutoff=' 
         ,'delay=' ,'maxtime=' ,'range=' ,'conf=' ,'ndiff=' ,'data=' 
         ,'binarycmp' ,'help'])

      for o, v in options:
         if o in ('--conf'):
            initializeFrom(v)

      # allow config file settings to be over-ridden from the command line

      cmd = None
      for o, v in options:
         if o in ('-h', '--help'):
            print __doc__
            exit(0)
         elif o in ('--cmd'):
            cmd = v
         elif o in ('--repeat'):
            repeat = int(v)
         elif o in ('--cutoff'):
            cutoff = int(v)
         elif o in ('--delay'):
            delay = float(v)
         elif o in ('--maxtime'):
            maxtime = int(v)  
         elif o in ('--range'):
            testvalues.extend( v.split(',') )
         elif o in ('--data'):
            data = v
         elif o in ('--ndiff'):
            ndiff = v
         elif o in ('--binarycmp'):
            binarycmp = True

      if cmd:
         standalone(cmd)
      else:
         benchmarksGame()

   except GetoptError, (_,e):
      print e
      print 'please try --help'
      sys.exit(2)

   except KeyboardInterrupt:
      sys.exit(1)

           
if __name__ == "__main__":
   main()


