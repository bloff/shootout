#!/usr/bin/python -OO
# The Computer Language Benchmarks Game
# $Id: nanobench,v 1.4 2008-07-25 01:57:33 igouy-guest Exp $

"""
Description: nanobench records a program's cpu
time, and samples resident memory usage and
records cpu load while a program is running. 

nanobench can be used in a limited way standalone
- it is intended for use with the make files and 
directories of The Computer Language Benchmarks Game. 

Usage: nanobench -options

where standalone options include:

   --cmd <commandline string>
      commandline string should be sufficient 
      to run a program from the current directory

   --repeat <int>
      how often to run a program [3]

   --cutoff <int>
      how many seconds to allow before 
      cancelling repeat of program run [60]

   --delay <float>
      delay in seconds between sampling 
      memory usage [0.2]

   --maxtime <int>
      how many seconds to allow before 
      stopping a program [600]

   -h --help
      print this help message

where benchmarks game options include:

   --conf <path>
      configuration file [./nanobench.conf]

   --range <test values>
      comma separated int program args

   --data <path>
      test data file

   --ndiff <parameter string>
      ndiff parameters, example "-abserr 1.0e-8"

   --binarycmp
      program output is binary, use cmp


Output: _,0,40.739,6356,100% 0% 0% 0%
   _ 
   0		exit status (-1 error, -2 timeout)
   40.739	user time + system time (seconds)
   6356		sampled resident memory usage (KB)
   100%		cpu load during a program run
"""

from __future__ import with_statement

__author__ =  'Isaac Gouy'



import sys, os, re, fnmatch

# need to use ConfigParser not SafeConfigParser
from ConfigParser import ConfigParser, NoSectionError, NoOptionError

from contextlib import nested
from cStringIO import StringIO
from errno import ENOENT
from getopt import getopt, GetoptError
from measurement import Measurement
from shutil import copyfile
from subprocess import call, STDOUT
from tempfile import TemporaryFile
from time import strftime, localtime, gmtime
from os.path import expanduser, expandvars, getsize, getmtime, isdir, isfile, \
                    join, normpath, realpath, split, splitext   
                    


# globals
make = frozenset()
commandlines = {}
alias = {}
testvalues = []
data = None
ndiff = None
binarycmp = None

repeat = 3
cutoff = 60
delay = 0.2
maxtime = 600

maxsize = 10240

_OUT = '_out'

logdirName = 'log'
datdirName = 'dat'
tmpdirName = 'tmp'

sitename = None
sourcedir = None
rootdir = None
makedir = None
logdir = None
datdir = None
tmpdir = None



def initializeFrom(ini):
   global repeat, cutoff, delay, maxtime, make

   try:
      parser = ConfigParser()
      parser.read(ini)

      make = frozenset( parser.get("build", "make").split() )
      commandlines.update( parser.items("commandlines") )

      for k,v in parser.items("alias"):
         alias[k] = v.split() 

      print alias 

      s = 'measure'
      if parser.has_section(s):
         for o in parser.options(s):
            if o in ('repeat'):
               repeat = parser.getint(s,o)
            elif o in ('cutoff'):
               cutoff = parser.getint(s,o)
            elif o in ('delay'):
               delay = parser.getfloat(s,o)
            elif o in ('maxtime'):
               maxtime = parser.getint(s,o)  

   except (NoSectionError,NoOptionError), e:
      print e, 'in', realpath(ini)
      sys.exit(2)



def createDirectories():
   global sourcedir,sitename,rootdir,makedir,logdir,datdir,tmpdir

   def ifNoneMkdir(path,name):
      d = join(path,name)
      if not isdir(d): os.mkdir(d) 
      return d

   sourcedir = os.getcwd()
   os.environ['SOURCE_DIR'] = sourcedir # Make.common uses $SOURCE_DIR

   # assume sourcedir path ends with a test name
   rootdir = normpath( expandvars( expanduser( os.environ.get( 'SITE_ROOT', ''))))
   if isdir(rootdir):
      rootdir = ifNoneMkdir(rootdir,split(sourcedir)[1])
   else:
      print 'please set SITE_ROOT in Makefile_local'
      sys.exit(0)
   
   sitename = os.environ.get( 'SITE_NAME', '')
   if not sitename:
      print 'please set SITE_NAME in Makefile_local'
      sys.exit(0)

   makedir = normpath( expandvars( expanduser( os.environ.get( 'SITE_MAKEFILES', ''))))
   if not isdir(makedir):
      print 'please set MAKE_ROOT in Makefile_local'
      sys.exit(0)

   logdir = ifNoneMkdir(rootdir,logdirName)
   datdir = ifNoneMkdir(rootdir,datdirName)
   tmpdir = ifNoneMkdir(rootdir,tmpdirName)




def targetPrograms():
   # assume dat file is only written once all data is available

   # include undeleted filenames that might have a file extension
   files = fnmatch.filter( os.listdir(sourcedir), '*.*[!~]' )

   # exclude bogus files created by touch
   files = [f for f in files if not f.startswith('*')]

   # if some file extensions are explicitly selected, exclude those not selected
   selected = os.environ.get( 'SELECT', '')
   if selected:
      imps = [i for i in selected.split() if not i.startswith('*')]
      if imps:
         imps = frozenset(imps)
         files = [f for f in files if splitext(f)[1].lstrip('.') in imps]

   # if some file extensions are explicitly ignored, exclude them
   excluded = os.environ.get( 'IGNORE', '')
   if excluded:
      imps = [i for i in excluded.split() if not i.startswith('*')]
      if imps:
         imps = frozenset(imps)
         files = [f for f in files if not splitext(f)[1].lstrip('.') in imps]

   programs = set()
   for f in files:
      try:
         if getmtime(f) > getmtime( join(datdir,f) ):
            programs.add(f)
      except OSError, (e,_): 
         if e == ENOENT: # No such file or directory
            programs.add(f)

   return frozenset(programs)



def runName(filename):
   return filename + '_run'



def cmdTemplate(filename,ext):
   vars = {}
   vars['%X'] = runName(filename) if hasMake(ext) else filename

   names = filename.split('.') # We only selected filenames with a .
   vars['%T'] = names[0]
   vars['%B'] = '.'.join( names[0:len(names)-1] )

   p = names[1].split('-')
   vars['%I'] = p[1] if len(p) == 2 and p[1].isdigit() else ''

   vars['%S'] = join( os.getcwd(),'')

   s = commandlines.get(ext,None)
   if s:
      for m in re.finditer('\$[\w]+' ,s): 
         k = m.group(0)
         v = os.environ.get( k.lstrip('$'), '' )
         s = re.sub('\\' + k + '(?P<c>[\W])', v + '\g<c>', s) # ate [\W] !

      for m in re.finditer('\%[XTBIS]' ,s):
         value = vars.get( m.group(0), '' )
         s = re.sub('\\'+ m.group(0), value, s) 

   else:
      s = join('.',runName(filename)) + ' %A'

   return s



def cmdWithArg(s,arg):
   _a = '' if data else arg
   for m in re.finditer('\%A' ,s):
      s = re.sub('\\'+ m.group(0), _a, s) 
   return s



# adapt to unavailable libgtop2
try:
   import gtop
except ImportError:
   from planB import measure # only rusage cpu time
else:
   from planA import measure # cpu load, resident memory and rusage cpu time



def dataName(arg):
   # assume there is a data file
   root,ext = splitext(data)
   return normpath( expandvars( expanduser( root + arg + ext )))



def outName(directory,index):
   return join(directory,_OUT) if index == 0 else '/dev/null'



def logName(filename):
   return join(logdir,
         (splitext(filename)[0] if filename.find('-') > -1 
            else filename) + '.log')



def diffName():
   return join(tmpdir,'_diff')



def errName():
   return join(tmpdir,'_err')



def makeName():
   return join(tmpdir,'_make')



def hasMake(ext):
   return ext in make



def callMake(root,filename):
   # step into tmpdir before the make 
   os.chdir(tmpdir)

   with open( makeName(), 'w') as mf: 
      mf.write('\nMAKE:\n')

   optionFile = join(root,'Make.common_' + sitename)
   cmd = 'make --no-print-directory -f ' + optionFile + ' ' + runName(filename)
   with open( makeName(), 'a') as mf:
      call(cmd.split(),stdout=mf,stderr=STDOUT)



def standalone(cmd):
   results = StringIO()
   for i in range(0,repeat):
      with nested( open( outName('./',i), 'w'), 
                   TemporaryFile(mode='w+t')) as (of,ef):
         m = measure('_',cmd.split(),delay,maxtime,of,ef)
         print >>results, '%s,%d,%.3f,%d,%s' % m
         if ef.tell(): ef.seek(0); print >>results, ef.read()
         if not m.isOkay() or m.hasExceeded(cutoff): break

   print results.getvalue()
   results.close()



def checkAndLog(m,outFile,logf):
   if m.isOkay():
      print 'OK'
      # assume outFile has been closed
      # assume $CWD contains the comparison files for different arg values
      argFile = m.arg + _OUT

      # diff against expected output file
      if isfile(argFile): 
         with open( diffName(), 'w') as df:
            try:
               # compare _OUT not outFile so short name will be shown in logf
               if ndiff:
                  call(["ndiff",'-quiet',ndiff,_OUT,argFile],stdout=df,stderr=STDOUT)
               elif binarycmp:
                  call(["cmp",_OUT,argFile],stdout=df,stderr=STDOUT)
               else:
                  call(["diff",_OUT,argFile],stdout=df,stderr=STDOUT)

            except OSError, (e,err): 
               if e == ENOENT: # No such file or directory 
                  m.setBadOutput()
                  print >>logf, '\nFAIL:', err, '\n'
                  print 'FAIL ', err, 

            if df.tell(): 
               m.setBadOutput()

      else: # create the initial expected output file
         copyfile(outFile,argFile)

   if not m.isOkay():
      print >>logf, '\n%s\n' % m.statusStr()




def measureCheckAndLog(t,f,ext,r):
   revisedTestValues = []

   for a in testvalues:
      cmd = cmdWithArg(t,a)
      ofName = outName(tmpdir,0)
      m = Measurement()

      try:
         with open(logName(f),'w') as logf:
            with open(ofName,'w') as of:
               # append timestamp to log
               print >>logf, '\n', strftime("%a, %d %b %Y %H:%M:%S GMT", gmtime())

               # append Make output to log
               if hasMake(ext):
                  with open( makeName(), 'r') as mf:
                     logf.write( mf.read() ) 

               with open(errName(),'w+') as ef:
                  # append command line showing redirected test data file to log
                  if data:
                     dfName = dataName(a)
                     print >>logf, '\nCOMMAND LINE:\n', cmd, '<', split(dfName)[1]
                     with open(dfName,'r') as df:
                        m = measure(a,cmd.split(),delay,maxtime,of,ef,df)

                  # append command line showing test value argument to log
                  else:
                     print >>logf, '\nCOMMAND LINE:\n', cmd
                     m = measure(a,cmd.split(),delay,maxtime,of,ef)

            # check the program output was as expected
            checkAndLog(m,ofName,logf)
            print >>r, m

            with open(ofName,'r+') as of:
               # append diff or ndiff output to log
               if m.hasBadOutput():
                  with open(diffName(), 'r') as df:
                     logf.write( df.read() )               

               # append program output to log
               if binarycmp:
                  logf.write( '\n(BINARY) PROGRAM OUTPUT NOT SHOWN\n' )
               elif getsize(ofName) > maxsize:
                  of.truncate(maxsize)
                  logf.write( '\n(TRUNCATED) PROGRAM OUTPUT:\n' )
                  logf.write( of.read() )
               else:
                  logf.write( '\nPROGRAM OUTPUT:\n' )
                  logf.write( of.read() )

               # append program stderr to log
               if getsize(errName()):
                  with open(errName(), 'r') as ef:
                     logf.write( '\n' )
                     logf.write( ef.read() )               

         if not m.isOkay() or m.hasExceeded(cutoff): break
         revisedTestValues.append(a)

      except IOError, (_,e):
         pass # the error will be logged

      finally:
         sys.stdout.write('.'); sys.stdout.flush()

   sys.stdout.write( m.statusStr() ); sys.stdout.flush()

   return revisedTestValues



def measureOnly(revisedTestValues,t,f,r):
   for i in range(1,repeat):
      for a in revisedTestValues:
         cmd = cmdWithArg(t,a)
         with open( outName(tmpdir,i), 'w') as of:

            # pass the test data file to program stdin
            if data:
               dfName = dataName(a)
               with open(dfName,'r') as df:
                  m = measure(a,cmd.split(),delay,maxtime,of,STDOUT,df)

            # pass the test value as a command line argument in cmd
            else:
                  m = measure(a,cmd.split(),delay,maxtime,of,STDOUT)

            # record the measurement tuple 
            print >>r, m

         sys.stdout.write('.'); sys.stdout.flush()



def benchmarksGame():
   # assume $CWD is a program source directory
   createDirectories()
   programs = targetPrograms()
    
   for filename in programs:
      sys.stdout.write('%s ' % strftime('%a %H:%M:%S', localtime()))
      sys.stdout.flush()

      ext = filename.split('.').pop() # We only selected filenames with a .

      if hasMake(ext):
         # step into tmpdir before the make 
         callMake(makedir,filename)    

      t = cmdTemplate(filename,ext)
      r = StringIO()

      revisedTestValues = measureCheckAndLog(t,filename,ext,r)

      measureOnly(revisedTestValues,t,filename,r)

      # Write dat file once, when all data is available
      with open( join(datdir,filename),'w') as datf:
         datf.write( r.getvalue() )

      r.close()
      sys.stdout.write('%s\n' % filename); sys.stdout.flush()

      # step into sourcedir (we might have stepped into tmpdir)
      os.chdir(sourcedir)



def main():
   global repeat, cutoff, delay, maxtime, data, binarycmp

   try:
      options,_ = getopt(sys.argv[1:],'h',['cmd=' ,'repeat=' ,'cutoff=' 
         ,'delay=' ,'maxtime=' ,'range=' ,'conf=' ,'ndiff=' ,'data=' 
         ,'binarycmp' ,'help'])

      for o, v in options:
         if o in ('--conf'):
            initializeFrom(v)

      # allow config file settings to be over-ridden from the command line

      cmd = None
      for o, v in options:
         if o in ('-h', '--help'):
            print __doc__
            sys.exit(0)
         elif o in ('--cmd'):
            cmd = v
         elif o in ('--repeat'):
            repeat = int(v)
         elif o in ('--cutoff'):
            cutoff = int(v)
         elif o in ('--delay'):
            delay = float(v)
         elif o in ('--maxtime'):
            maxtime = int(v)  
         elif o in ('--range'):
            testvalues.extend( v.split(',') )
         elif o in ('--data'):
            data = v
         elif o in ('--ndiff'):
            ndiff = v
         elif o in ('--binarycmp'):
            binarycmp = True

      if cmd:
         standalone(cmd)
      else:
         benchmarksGame()

   except GetoptError, (_,e):
      print e
      print 'please try --help'
      sys.exit(2)

   except KeyboardInterrupt:
      sys.exit(1)

           
if __name__ == "__main__":
   main()


