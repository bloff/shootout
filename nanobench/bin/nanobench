#!/usr/bin/python -OO
# The Computer Language Benchmarks Game
# $Id: nanobench,v 1.16 2008-07-27 03:05:56 igouy-guest Exp $

"""
Description: nanobench records a program's cpu
time, and samples resident memory usage and
records cpu load while a program is running. 

nanobench can be used in a limited way standalone
- it is intended for use with the make files and 
directories of The Computer Language Benchmarks Game. 

Usage: nanobench -options

where standalone options include:

   --cmd <commandline string>
      commandline string should be sufficient 
      to run a program from the current directory

   --runs <int>
      how many times to run a program [3]

   --cutoff <int>
      how many seconds to allow before 
      cancelling additional program runs [60]

   --delay <float>
      delay in seconds between sampling 
      memory usage [0.2]

   --maxtime <int>
      how many seconds to allow before 
      stopping a program [600]

   -h --help
      print this help message

where benchmarks game options include:

   --conf <path>
      configuration file [./nanobench.conf]

   --range <test values>
      comma separated int program args

   --data <path>
      test data file

   --ndiff <parameter string>
      ndiff parameters, example "-abserr 1.0e-8"

   --binarycmp
      program output is binary, use cmp

where benchmarks game .ini file options include:

   logfilemax: <int>
      set greater than 0 to create a rotating
      log file [0]

   outputmax: <int>
      how many bytes of a program output to 
      include in each build & run log before 
      truncating program output [10240]


Output: _,0,40.739,6356,100% 0% 0% 0%
   _ 
   0		exit status (-1 error, -2 timeout)
   40.739	user time + system time (seconds)
   6356		sampled resident memory usage (KB)
   100%		cpu load during a program run
"""

from __future__ import with_statement

__author__ =  'Isaac Gouy'



import sys, os, re, fnmatch, logging, bz2

# need to use ConfigParser not SafeConfigParser
from ConfigParser import ConfigParser, NoSectionError, NoOptionError

from cPickle import Pickler
from logging.handlers import RotatingFileHandler
from contextlib import nested
from cStringIO import StringIO
from errno import ENOENT, EEXIST
from getopt import getopt, GetoptError
from measurement import Measurement
from shutil import copyfile
from subprocess import call, STDOUT
from tempfile import TemporaryFile
from time import strftime, localtime, gmtime
from os.path import expanduser, expandvars, getsize, getmtime, isdir, isfile, \
                    join, normpath, realpath, split, splitext   


# globals
logfilemax = 0
logger = None
loggerLine = None


make = frozenset()
commandlines = {}
alias = {}
testvalues = []
data = None
ndiff = None
binarycmp = None

runs = 3
cutoff = 60
delay = 0.2
maxtime = 600

outputmax = 10240

_OUT = '_out'

logdirName = 'log'
datdirName = 'dat'
tmpdirName = 'tmp'
symdirName = 'sym'

sitename = None
sourcedir = None
makedir = None
logdir = None
datdir = None
tmpdir = None
symdir = None



def initializeFrom(ini):
   global runs, cutoff, delay, maxtime, logfilemax, outputmax, make

   try:
      parser = ConfigParser()
      parser.read(ini)

      make = frozenset( parser.get("build", "make").split() )
      commandlines.update( parser.items("commandlines") )

      for k,v in parser.items("alias"):
         alias[k] = v.split() 

      s = 'measure'
      if parser.has_section(s):
         for o in parser.options(s):
            if o in ('runs'):
               runs = parser.getint(s,o)
            elif o in ('cutoff'):
               cutoff = parser.getint(s,o)
            elif o in ('delay'):
               delay = parser.getfloat(s,o)
            elif o in ('maxtime'):
               maxtime = parser.getint(s,o)  
            elif o in ('logfilemax'):
               logfilemax = parser.getint(s,o)  
            elif o in ('outputmax'):
               outputmax = parser.getint(s,o) 

   except (NoSectionError,NoOptionError), e:
      if logger: logger.debug(e)
      print e, 'in', realpath(ini)
      sys.exit(2)



def configureNanobenchLogger(loggerDir):
   global logger, ifmt, dfmt
   # if a logfilemax size was set, log line-by-line to a rotating log file
   # (as well as logging program-run by program-run to stdout)
   if logfilemax:
      f = join(loggerDir,'nano.log')
      h = RotatingFileHandler(filename=f,maxBytes=logfilemax,backupCount=1)

      fmt = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
      h.setFormatter(fmt)

      logger = logging.getLogger("nanobench")
      logger.addHandler(h)
      logger.setLevel(logging.DEBUG)



def createDirectories():
   global sourcedir,sitename,makedir,logdir,datdir,tmpdir,symdir

   def ifNoneMkdir(path,name):
      d = join(path,name)
      if not isdir(d): os.mkdir(d) 
      return d

   # assume sourcedir path ends with a test name
   sourcedir = os.getcwd()

   rootdir = normpath( expandvars( expanduser( os.environ.get( 'SITE_ROOT', ''))))
   if isdir(rootdir):
      testdir = ifNoneMkdir(rootdir,split(sourcedir)[1])
   else:
      if logger: logger.debug('please set SITE_ROOT in Makefile.site_*')
      print 'please set SITE_ROOT in Makefile.site_*'
      sys.exit(0)

   sitename = os.environ.get( 'SITE_NAME', '')
   if not sitename:
      if logger: logger.debug('please set SITE_NAME in Makefile.site_*')
      print 'please set SITE_NAME in Makefile.site_*'
      sys.exit(0)

   makedir = normpath( expandvars( expanduser( os.environ.get( 'SITE_MAKEFILES', ''))))
   if not isdir(makedir):
      if logger: logger.debug('please set MAKE_ROOT in Makefile.site_*')
      print 'please set MAKE_ROOT in Makefile.site_*'
      sys.exit(0)

   configureNanobenchLogger(rootdir)

   logdir = ifNoneMkdir(testdir,logdirName)
   datdir = ifNoneMkdir(testdir,datdirName)
   tmpdir = ifNoneMkdir(testdir,tmpdirName)
   symdir = ifNoneMkdir(testdir,symdirName)



def targets():
   # assume dat file is only written once all data is available

   # include undeleted filenames that might have a file extension
   files = fnmatch.filter( os.listdir(sourcedir), '*.*[!~]' )

   # exclude bogus files created by touch
   files = [f for f in files if not f.startswith('*')]

   # make the file extension accessible as tuple (f,e)
   files = [(f, splitext(f)[1].lstrip('.') ) for f in files]


   # ALLOW these helper file extensions to be available unchanged 
   # from the working directory - they will never be measured
   a = frozenset( os.environ.get( 'ALLOW', '').split() )
   allowed = []; _files = files; files = []

   for f,e in _files:
      if e in a:
         allowed.append(f)
      else:
         files.append( (f,e) )
      # giving a list of ALLOWed filenames and a list without ALLOWed filenames

   links = [] 

   # reverse alias dictionary so we can look up the target for each alias
   revAlias = {}
   for k,vs in alias.iteritems():
      for v in vs:
         revAlias[v] = k
 
   # ONLY measure files with these extensions 
   o = os.environ.get( 'ONLY', '').split()
   if o:
      _files = files; files = []
      
      for ext in o:
         reva = revAlias.get(ext,None)   
         for f,e in _files:
            if reva:
               if e == reva:
                  links.append( (f,re.sub(e,ext,f)) )
            else:
               if e == ext:
                  files.append( (f,e) )
      # giving a list of ONLY links and a list of ONLY filenames

   # measure files with ANY extension, except ...
   else: 
      # create alias filenames
      for f,e in files:
         for a in alias.get(e,[]):
            links.append( (f,re.sub(e,a,f),a) )

      # IGNORE files or links with these extensions
      ignore = frozenset( os.environ.get( 'IGNORE', '').split() )
      if ignore:
         files = [(f,e) for f,e in files if not e in ignore]
         links = [(src,dst) for src,dst,e in links if not e in ignore]


   def notUptodate(f):
      try:
         return getmtime(f) > getmtime( join(datdir,f) )
      except OSError, (e,_): 
         return e == ENOENT # No such file or directory

   files = [f for f,e in files if notUptodate(f)]
   links = [(src,dst) for src,dst in links if notUptodate(src)]

   return allowed,files,links



def runName(filename):
   return filename + '_run'



def cmdTemplate(filename,ext):
   specials = {}
   specials['%X'] = runName(filename) if hasMake(ext) else filename

   names = filename.split('.') # We only selected filenames with a .
   specials['%T'] = names[0]
   specials['%B'] = '.'.join( names[0:len(names)-1] )

   p = names[1].split('-')
   specials['%I'] = p[1] if len(p) == 2 and p[1].isdigit() else ''

   s = commandlines.get(ext,None)
   if s:
      for m in re.finditer('\$[\w]+' ,s): 
         k = m.group(0)
         v = os.environ.get( k.lstrip('$'), '' )
         s = re.sub('\\' + k + '(?P<c>[\W])', v + '\g<c>', s) # ate [\W] !

      for m in re.finditer('\%[XTBI]' ,s):
         value = specials.get( m.group(0), '' )
         s = re.sub('\\'+ m.group(0), value, s) 

   else:
      s = join('.',runName(filename)) + ' %A'

   return s



def cmdWithArg(s,arg):
   _a = '' if data else arg
   for m in re.finditer('\%A' ,s):
      s = re.sub('\\'+ m.group(0), _a, s) 
   return s



# adapt to unavailable libgtop2
try:
   import gtop
except ImportError, (_,err):
   if logger: logger.warn(err)
   from planB import measure # only rusage cpu time
else:
   from planA import measure # cpu load, resident memory and rusage cpu time



def dataName(arg):
   # assume there is a data file
   root,ext = splitext(data)
   return normpath( expandvars( expanduser( root + arg + ext )))



def outName(directory,index):
   return join(directory,_OUT) if index == 0 else '/dev/null'



def logName(filename):
   return join(logdir,
         (splitext(filename)[0] if filename.find('-') > -1 
            else filename) + '.log')



def diffName():
   return join(tmpdir,'_diff')



def errName():
   return join(tmpdir,'_err')



def makeName():
   return join(tmpdir,'_make')



def hasMake(ext):
   return ext in make



def callMake(root,filename):
   with open( makeName(), 'w') as mf: 
      mf.write('\nMAKE:\n')

   optionFile = join(root,'Make.programs_' + sitename)
   cmd = 'make -f ' + optionFile + ' ' + runName(filename)
   with open( makeName(), 'a') as mf:
      call(cmd.split(),stdout=mf,stderr=STDOUT)



def symlinkSource(srcdir,filename):
   src = join(srcdir,filename)
   dst = join(filename) # tmpdir is $CWD
   try:
      os.symlink(src,dst)
   except OSError, (e,_):
      if e == EEXIST: pass # OK the symlink already exists



def standalone(cmd):
   results = StringIO()
   for i in range(0,runs):
      with nested( open( outName('./',i), 'w'), 
                   TemporaryFile(mode='w+t')) as (of,ef):
         m = measure('_',cmd.split(),delay,maxtime,of,ef)
         print >>results, '%s,%d,%.3f,%d,%s' % m
         if ef.tell(): ef.seek(0); print >>results, ef.read()
         if not m.isOkay() or m.hasExceeded(cutoff): break

   print results.getvalue()
   results.close()



def checkAndLog(m,outFile,logf):
   if m.isOkay():
      # assume outFile has been closed
      argFile = m.arg + _OUT

      # diff against expected output file
      if isfile(argFile): 
         with open( diffName(), 'w') as df:
            try:
               # compare _OUT not outFile so short name will be shown in logf
               if ndiff:
                  call(["ndiff",'-quiet',ndiff,_OUT,argFile],stdout=df,stderr=STDOUT)
               elif binarycmp:
                  call(["cmp",_OUT,argFile],stdout=df,stderr=STDOUT)
               else:
                  call(["diff",_OUT,argFile],stdout=df,stderr=STDOUT)

            except OSError, (e,err): 
               if e == ENOENT: # No such file or directory 
                  m.setBadOutput()
                  print >>logf, '\nFAIL:', err, '\n'
                  print 'FAIL ', err, 

            if df.tell(): 
               m.setBadOutput()

      else: # create the initial expected output file
         copyfile(outFile,argFile)

   if not m.isOkay():
      extra = '' if not m.hasTimedout() else ' %s%d%s' % ('after',maxtime,'s')
      print >>logf, '\n%s%s\n' % (m.statusStr(),extra)



def measureCheckAndLog(t,f,ext,ms):
   revisedTestValues = []

   for a in testvalues:
      cmd = cmdWithArg(t,a)
      ofName = outName(tmpdir,0)
      m = Measurement()

      try:
         with open(logName(f),'w') as logf:
            with open(ofName,'w') as of:
               # append timestamp to log
               print >>logf, '\n', strftime("%a, %d %b %Y %H:%M:%S GMT", gmtime())

               # append Make output to log
               if hasMake(ext):
                  with open( makeName(), 'r') as mf:
                     logf.write( mf.read() ) 

               with open(errName(),'w+') as ef:
                  # append command line showing redirected test data file to log
                  if data:
                     dfName = dataName(a)
                     print >>logf, '\nCOMMAND LINE:\n', cmd, '<', split(dfName)[1]
                     with open(dfName,'r') as df:
                        m = measure(a,cmd.split(),delay,maxtime,of,ef,df,logger=logger)

                  # append command line showing test value argument to log
                  else:
                     print >>logf, '\nCOMMAND LINE:\n', cmd
                     m = measure(a,cmd.split(),delay,maxtime,of,ef,logger=logger)

            # check the program output was as expected
            checkAndLog(m,ofName,logf)

            # add to the measurements
            ms.append(m)
            #print >>r, m

            # if there was a problem finding the program just ignore the program output
            if not m.isMissing():
               with open(ofName,'r+') as of:
                  # append diff or ndiff or cmp output to log
                  if m.hasBadOutput():
                     with open(diffName(), 'r') as df:
                        logf.write( df.read() )               

                  # append program output to log
                  if binarycmp:
                     logf.write( '\n(BINARY) PROGRAM OUTPUT NOT SHOWN\n' )
                  elif getsize(ofName) > outputmax:
                     of.truncate(outputmax)
                     logf.write( '\n(TRUNCATED) PROGRAM OUTPUT:\n' )
                     logf.write( of.read() )
                  else:
                     logf.write( '\nPROGRAM OUTPUT:\n' )
                     logf.write( of.read() )

                  # append program stderr to log
                  if getsize(errName()):
                     with open(errName(), 'r') as ef:
                        logf.write( '\n' )
                        logf.write( ef.read() )               

         if not m.isOkay() or m.hasExceeded(cutoff): break
         revisedTestValues.append(a)

      except IOError, err:
         if logger: logger.error(err)

      finally:
         sys.stdout.write('.'); sys.stdout.flush()
         loggerLine.write('.')

   sys.stdout.write( m.statusStr() ); sys.stdout.flush()
   loggerLine.write( m.statusStr() )

   return revisedTestValues



def measureOnly(revisedTestValues,t,f,ms):
   for i in range(1,runs):
      for a in revisedTestValues:
         cmd = cmdWithArg(t,a)
         with open( outName(tmpdir,i), 'w') as of:

            # pass the test data file to program stdin
            if data:
               dfName = dataName(a)
               with open(dfName,'r') as df:
                  m = measure(a,cmd.split(),delay,maxtime,of,STDOUT,df,logger=logger)

            # pass the test value as a command line argument in cmd
            else:
                  m = measure(a,cmd.split(),delay,maxtime,of,STDOUT,logger=logger)

            # add to the measurements
            ms.append(m)
            #print >>r, m

         sys.stdout.write('.'); sys.stdout.flush()
         loggerLine.write('.')



def measurePrograms(programs,programDir,total):
   global loggerLine

   for filename in programs:
      loggerLine = StringIO()
 
      symlinkSource(programDir,filename)

      sys.stdout.write('%s ' % strftime('%a %H:%M:%S', localtime()))
      sys.stdout.flush()

      ext = filename.split('.').pop() # We only selected filenames with a .

      if hasMake(ext):
         callMake(makedir,filename)   

      t = cmdTemplate(filename,ext)
      ms = []
      revisedTestValues = measureCheckAndLog(t,filename,ext,ms)
      measureOnly(revisedTestValues,t,filename,ms)

      # Write compressed dat file once, when all data is available
      # Write pickles for use with other Python scripts
      try:
         datf = bz2.BZ2File( join(datdir,filename) ,'w')
         p = Pickler(datf)
         for m in ms: p.dump(m)
      except IOError, err:
         if logger: logger.error(err)
      finally:
         datf.close()

      sys.stdout.write('%s [%d]\n' % (filename,total)); sys.stdout.flush()
      loggerLine.write('%s [%d]' % (filename,total))
      total -= 1

      if logger: logger.info( loggerLine.getvalue() )
      loggerLine.close()

   return total



def benchmarksGame():
   # assume $CWD is a program source directory
   createDirectories()
   allowed,sources,symlinks = targets()

   # make sure all build files and crash files are created in tmpdir
   os.chdir(tmpdir)

   # symlink from tmpdir to Include directory
   symlinkSource( normpath( join(sourcedir,'..') ) ,'Include')

   # symlink these allowed helper files from tmpdir
   for filename in allowed:
      symlinkSource(sourcedir,filename)

   # symlink these program aliases from symdir so we 
   # have them later when we measure the source code gzip
   for src,dst in symlinks:
      s = join(sourcedir,src)
      d = join(symdir,dst)
      try:
         os.symlink(s,d)
      except OSError, (e,_):
         if e == EEXIST: pass # OK the symlink already exists

   total = len(sources) + len(symlinks)
   total = measurePrograms(sources, sourcedir, total)
   total = measurePrograms([f for _,f in symlinks], symdir, total)



def main():
   global runs, cutoff, delay, maxtime, data, binarycmp

   try:
      options,_ = getopt(sys.argv[1:],'h',['cmd=' ,'runs=' ,'cutoff=' 
         ,'delay=' ,'maxtime=' ,'range=' ,'conf=' ,'ndiff=' ,'data=' 
         ,'binarycmp' ,'help'])

      for o, v in options:
         if o in ('--conf'):
            initializeFrom(v)

      # allow some config file settings to be over-ridden from the command line

      cmd = None
      for o, v in options:
         if o in ('-h', '--help'):
            print __doc__
            sys.exit(0)
         elif o in ('--cmd'):
            cmd = v
         elif o in ('--runs'):
            runs = int(v)
         elif o in ('--cutoff'):
            cutoff = int(v)
         elif o in ('--delay'):
            delay = float(v)
         elif o in ('--maxtime'):
            maxtime = int(v)  
         elif o in ('--range'):
            testvalues.extend( v.split(',') )
         elif o in ('--data'):
            data = v
         elif o in ('--ndiff'):
            ndiff = v
         elif o in ('--binarycmp'):
            binarycmp = True

      if cmd:
         standalone(cmd)
      else:
         benchmarksGame()

   except KeyboardInterrupt:
      if logger: logger.debug('Keyboard Interrupt')
      sys.exit(1)

   except GetoptError, err:
      if logger: logger.debug(err)
      print err
      print 'please try --help'
      sys.exit(2)


           
if __name__ == "__main__":
   main()


