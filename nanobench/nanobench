#!/usr/bin/python

# $Id: nanobench,v 1.6 2008-07-21 06:15:53 igouy-guest Exp $

"""
Description: nanobench records a program's cpu
time, and samples resident memory usage and
records cpu load while a program is running. 

nanobench can be used in a limited way standalone
- it is intended for use with the make files and 
directories of The Computer Language Benchmarks Game. 

Usage: nanobench -options

where standalone options include:

   --cmd <commandline string>
      commandline string should be sufficient 
      to run a program from the current directory

   --repeat <int>
      how often to run a program [5]

   --cutoff <int>
      how many seconds to allow before 
      cancelling repeat of program run [60]

   --delay <float>
      delay in seconds between sampling 
      memory usage [0.2]

   --maxtime <int>
      how many seconds to allow before 
      stopping a program [600]

   -h --help
      print this help message

where benchmarks game options include:

   --conf <path>
      configuration file [./nanobench.conf]

   --range <test values>
      comma separated int program args


Output: _,0,40.739,6356,100% 0% 0% 0%
   _ 
   0		exit status (-1 error, -2 timeout)
   40.739	user time + system time (seconds)
   6356		sampled resident memory usage (KB)
   100%		cpu load during a program run
"""

from __future__ import with_statement

__author__ =  'Isaac Gouy'



# globals
make = frozenset()
commandlines = {}
testvalues = []

repeat = 5
cutoff = 60
delay = 0.2
maxtime = 600
config_file = 'nanobench.conf'
ndiff = None


def initialize():
   global repeat, cutoff, delay, maxtime, make

   from sys import exit
   from os.path import realpath
   # need to use ConfigParser not SafeConfigParser
   from ConfigParser import ConfigParser, NoSectionError, NoOptionError

   try:
      parser = ConfigParser()
      parser.read(config_file)

      make = frozenset( parser.get("build", "make").split() )
      commandlines.update( parser.items("commandlines") )

      s = 'measure'
      if parser.has_section(s):
         for o in parser.options(s):
            if o in ('repeat'):
               repeat = parser.getint(s,o)
            elif o in ('cutoff'):
               cutoff = parser.getint(s,o)
            elif o in ('delay'):
               delay = parser.getfloat(s,o)
            elif o in ('maxtime'):
               maxtime = parser.getint(s,o)  

   except (NoSectionError,NoOptionError), e:
      print e, 'in', realpath(config_file)
      exit(2)



def targetPrograms(path):
   # Assume dat file is only written once all data is available
   from errno import ENOENT
   from os import listdir, mkdir
   from os.path import join, isdir, getmtime
   from fnmatch import filter

   # undeleted filenames that might have a file extension
   files = filter( listdir(path), '*.*[!~]' )

   programs = set()
   datdir = join(path,'dat')
   if isdir(datdir):
      for f in files:
         try:
            if getmtime(f) > getmtime( join(datdir,f) ):
               programs.add(f)
         except OSError, (e,_): 
            if e == ENOENT: # No such file or directory
               programs.add(f)
            # what if it was a different error?
            
   else:
      mkdir(datdir)      
      programs = frozenset(files)

   return frozenset(programs)



def cmdTemplate(filename,ext):
   vars = {}
   vars['%X'] = filename + '_run' if ext in make else filename
   vars['%T'] = filename.split('.').pop(0) # We only selected filenames with a .

   s = commandlines[ext]

   from os import environ
   from re import finditer, sub

   for m in finditer('\$[\w]+' ,s):
      value = environ.get( m.group(0).lstrip('$'), '' )
      s = sub('\\'+ m.group(0)+'[\W]', value+' ', s) # eaten the trailing space?

   for m in finditer('\%[XT]' ,s):
      value = vars.get( m.group(0), '' )
      s = sub('\\'+ m.group(0), value, s) 

   return s



def cmdWithArg(s,arg):
   from re import finditer, sub
   for m in finditer('\%A' ,s):
      s = sub('\\'+ m.group(0), arg, s) 
   return s



# adapt to unavailable libgtop2
try:
   import gtop
except ImportError:
   from planB import measure # only rusage cpu time
else:
   from planA import measure # cpu load, resident memory and rusage cpu time

import exit



def outFilename(filename,index):
   return '_out' if index == 0 else '/dev/null'



def logFilename(filename):
   from os.path import splitext
   return (splitext(filename)[0] if filename.find('-') > -1 else filename) + '.log'



def hasExceededCutoff(m):
   return m[2] > cutoff



def standalone(cmd):
   from tempfile import TemporaryFile
   from cStringIO import StringIO
   from contextlib import nested

   results = StringIO()
   for i in range(0,repeat):
      with nested( open( outFilename('',i), 'w'), 
                   TemporaryFile(mode='w+t')) as (of,ef):
         m = measure('_',cmd.split(),delay,maxtime,of,ef)
         print >>results, '%s,%d,%.3f,%d,%s' % m
         if ef.tell(): ef.seek(0); print >>results, ef.read()
         if exit.status(m) != exit.OK or hasExceededCutoff(m): break

   print results.getvalue()
   results.close()



def setWorkingDirectory(path):
   from errno import ENOENT
   from os import chdir, mkdir
   from os.path import join

   tmpdir = join(path,'tmp')
   try:
      chdir(tmpdir)
   except OSError, (e,_): 
      if e == ENOENT: # No such file or directory
         mkdir(tmpdir); chdir(tmpdir)
         # what if it was a different error?



def checkAndLog(m,outFile,logf):
   # Lots of side-effects!
   from subprocess import call
   from os.path import isfile
   from shutil import copyfile
   m_ = m

   if (exit.status(m) == exit.ERROR):
      print >>logf,  '\nERROR\n'

   elif (exit.status(m) == exit.TIMEOUT):
      print >>logf,  '\nTIMEOUT\n'

   else:
      argFile = m[0] + '_out'
      if isfile(argFile): 
         if ndiff:
            pass
         else:
            with open('_diff', 'w') as df:
               call(["diff",outFile,argFile],stdout=df)
               if df.tell(): 
                  print >>logf, '\nUNEXPECTED OUTPUT\n'
                  m_ = (m[0],exit.BADOUT,m[2],m[3],m[4])
      else:
         copyfile(outFile,argFile)

   return m_



def measureCheckAndLog(t,f,ext,r):
   from tempfile import TemporaryFile
   from contextlib import nested
   from time import ctime

   revisedTestValues = []

   for a in testvalues:
      cmd = cmdWithArg(t,a)
      ofName = outFilename(f,0)
      m = ('_',exit.ERROR,0,0,"%")

      with open('_err','w+') as ef:
         with open(logFilename(f),'w+') as logf:

            with open(ofName,'w') as of:
               print >>logf, '\n', ctime()
               print >>logf, '\nCommand line:\n', cmd
               m = measure(a,cmd.split(),delay,maxtime,of,ef)
            
            m = checkAndLog(m,ofName,logf)
            print >>r, '%s,%d,%.3f,%d,%s' % m

            with open(ofName,'r') as of:
               if exit.status(m) == exit.BADOUT:
                  with open('_diff', 'r') as df:
                     logf.write( df.read() )               

               logf.write( '\n' )
               logf.write( of.read() )

               logf.write( '\n' )
               ef.seek(0); logf.write( ef.read() )               


      if exit.status(m) != exit.OK or hasExceededCutoff(m): break
      revisedTestValues.append(a)

   return revisedTestValues



def measureOnly(revisedTestValues,t,f,r):
   for i in range(1,repeat):
      for a in revisedTestValues:
         cmd = cmdWithArg(t,a)

         with open( outFilename(f,i), 'w') as of:
            m = measure(a,cmd.split(),delay,maxtime,of)
            print >>r, '%s,%d,%.3f,%d,%s' % m



def benchmarksGame():
   # Assume $CWD is a program source directory
   from os import getcwd
   from os.path import join, splitext
   from cStringIO import StringIO

   initialize()
   path = getcwd()
   programs = targetPrograms(path)
   setWorkingDirectory(path)
    
   for filename in programs:
      ext = filename.split('.').pop() # We only selected filenames with a .
      if ext in make:
         pass     

      t = cmdTemplate(filename,ext)
      r = StringIO()

      revisedTestValues = measureCheckAndLog(t,filename,ext,r)

      measureOnly(revisedTestValues,t,filename,r)

      # Write dat file once, when all data is available
      with open( join(path,'dat',filename),'w') as datf:
         datf.write( r.getvalue() )

      r.close()



def main():
   global repeat, cutoff, delay, maxtime, config_file
   from sys import argv, exit
   from getopt import getopt, GetoptError

   try:
      options,_ = getopt(argv[1:],'h',['cmd=' ,'repeat=' ,'cutoff=' 
         ,'delay=' ,'maxtime=' ,'range=' ,'conf=' ,'ndiff=' ,'help'])

      cmd = None
      for o, v in options:
         if o in ('-h', '--help'):
            print __doc__
            exit(0)
         elif o in ('--cmd'):
            cmd = v
         elif o in ('--repeat'):
            repeat = int(v)
         elif o in ('--cutoff'):
            cutoff = int(v)
         elif o in ('--delay'):
            delay = float(v)
         elif o in ('--maxtime'):
            maxtime = int(v)  

      if cmd:
         standalone(cmd)
      else:
         for o, v in options:
            if o in ('--range'):
               testvalues.extend( v.split(',') )
            elif o in ('--conf'):
               config_file = v
            elif o in ('--ndiff'):
               ndiff = v

         benchmarksGame()

   except GetoptError, (_,e):
      print e
      print 'please try --help'
      exit(2)

           
if __name__ == "__main__":
   main()


