#!/usr/bin/python

# $Id: nanobench,v 1.8 2008-07-21 22:59:19 igouy-guest Exp $

"""
Description: nanobench records a program's cpu
time, and samples resident memory usage and
records cpu load while a program is running. 

nanobench can be used in a limited way standalone
- it is intended for use with the make files and 
directories of The Computer Language Benchmarks Game. 

Usage: nanobench -options

where standalone options include:

   --cmd <commandline string>
      commandline string should be sufficient 
      to run a program from the current directory

   --repeat <int>
      how often to run a program [5]

   --cutoff <int>
      how many seconds to allow before 
      cancelling repeat of program run [60]

   --delay <float>
      delay in seconds between sampling 
      memory usage [0.2]

   --maxtime <int>
      how many seconds to allow before 
      stopping a program [600]

   -h --help
      print this help message

where benchmarks game options include:

   --conf <path>
      configuration file [./nanobench.conf]

   --range <test values>
      comma separated int program args

   --data <path>
      test data file


Output: _,0,40.739,6356,100% 0% 0% 0%
   _ 
   0		exit status (-1 error, -2 timeout)
   40.739	user time + system time (seconds)
   6356		sampled resident memory usage (KB)
   100%		cpu load during a program run
"""

from __future__ import with_statement

__author__ =  'Isaac Gouy'



# globals
make = frozenset()
commandlines = {}
testvalues = []
conf = 'nanobench.conf'
data = None
ndiff = None

repeat = 5
cutoff = 60
delay = 0.2
maxtime = 600

maxsize = 1024

_DIFF = '_diff'
_ERR = '_err'
_MAKE = '_make'
_OUT = '_out'



def initialize():
   global repeat, cutoff, delay, maxtime, make

   from sys import exit
   from os.path import realpath
   # need to use ConfigParser not SafeConfigParser
   from ConfigParser import ConfigParser, NoSectionError, NoOptionError

   try:
      parser = ConfigParser()
      parser.read(conf)

      make = frozenset( parser.get("build", "make").split() )
      commandlines.update( parser.items("commandlines") )

      s = 'measure'
      if parser.has_section(s):
         for o in parser.options(s):
            if o in ('repeat'):
               repeat = parser.getint(s,o)
            elif o in ('cutoff'):
               cutoff = parser.getint(s,o)
            elif o in ('delay'):
               delay = parser.getfloat(s,o)
            elif o in ('maxtime'):
               maxtime = parser.getint(s,o)  

   except (NoSectionError,NoOptionError), e:
      print e, 'in', realpath(conf)
      exit(2)



def targetPrograms(path):
   # Assume dat file is only written once all data is available
   from errno import ENOENT
   from os import listdir, mkdir
   from os.path import join, isdir, getmtime
   from fnmatch import filter

   # undeleted filenames that might have a file extension
   files = filter( listdir(path), '*.*[!~]' )

   programs = set()
   datdir = join(path,'dat')
   if isdir(datdir):
      for f in files:
         try:
            if getmtime(f) > getmtime( join(datdir,f) ):
               programs.add(f)
         except OSError, (e,_): 
            if e == ENOENT: # No such file or directory
               programs.add(f)
            # what if it was a different error?
            
   else:
      mkdir(datdir)      
      programs = frozenset(files)

   return frozenset(programs)



def runName(filename):
   return filename + '_run'



def cmdTemplate(filename,ext):
   vars = {}
   vars['%X'] = runName(filename) if hasMake(ext) else filename
   vars['%T'] = filename.split('.').pop(0) # We only selected filenames with a .

   s = commandlines.get(ext,None)
   if s:
      from os import environ
      from re import finditer, sub

      for m in finditer('\$[\w]+' ,s):
         value = environ.get( m.group(0).lstrip('$'), '' )
         s = sub('\\'+ m.group(0)+'[\W]', value+' ', s) # eaten the trailing space?

      for m in finditer('\%[XT]' ,s):
         value = vars.get( m.group(0), '' )
         s = sub('\\'+ m.group(0), value, s) 

   else:
      from os.path import join
      s = join('.',runName(filename)) + ' %A'

   return s



def cmdWithArg(s,arg):
   from re import finditer, sub
   _a = '' if data else arg
   for m in finditer('\%A' ,s):
      s = sub('\\'+ m.group(0), _a, s) 
   return s



# adapt to unavailable libgtop2
try:
   import gtop
except ImportError:
   from planB import measure # only rusage cpu time
else:
   from planA import measure # cpu load, resident memory and rusage cpu time

import exit



def dataName(arg):
   # assume there is a data file
   from os.path import splitext
   root,ext = splitext(data)
   return root + arg + ext



def outName(filename,index):
   return _OUT if index == 0 else '/dev/null'



def logName(filename):
   from os.path import splitext
   return (splitext(filename)[0] if filename.find('-') > -1 else filename) + '.log'



def hasExceededCutoff(m):
   return m[2] > cutoff



def hasMake(ext):
   return ext in make



def callMake(path,filename):
   from os.path import join
   from subprocess import call,STDOUT

   with open(_MAKE, 'w') as mf: 
      mf.write('\nMAKE:\n')

   makeName = join(path,'..','Makefile.mb')
   cmd = 'make --no-print-directory -f ' + makeName + ' ' + runName(filename)
   with open(_MAKE, 'a') as mf:
      call( cmd.split(),stdout=mf,stderr=STDOUT)



def standalone(cmd):
   from tempfile import TemporaryFile
   from cStringIO import StringIO
   from contextlib import nested

   results = StringIO()
   for i in range(0,repeat):
      with nested( open( outName('',i), 'w'), 
                   TemporaryFile(mode='w+t')) as (of,ef):
         m = measure('_',cmd.split(),delay,maxtime,of,ef)
         print >>results, '%s,%d,%.3f,%d,%s' % m
         if ef.tell(): ef.seek(0); print >>results, ef.read()
         if not exit.isOk(m) or hasExceededCutoff(m): break

   print results.getvalue()
   results.close()



def setWorkingDirectory(path):
   from errno import ENOENT
   from os import chdir, mkdir
   from os.path import join

   tmpdir = join(path,'tmp')
   try:
      chdir(tmpdir)
   except OSError, (e,_): 
      if e == ENOENT: # No such file or directory
         mkdir(tmpdir); chdir(tmpdir)
         # what if it was a different error?



def checkAndLog(m,outFile,logf):
   # assume outFile has been closed
   # Lots of side-effects!
   from subprocess import call,STDOUT
   from os.path import isfile
   from shutil import copyfile
   m_ = m

   if exit.isError(m):
      print >>logf, '\nERROR\n'

   elif exit.isTimeout(m):
      print >>logf, '\nTIMEOUT\n'

   else:
      argFile = m[0] + _OUT
      if isfile(argFile): 
         with open(_DIFF, 'w') as df:
            try:
               if ndiff:
                  call(["ndiff",'-quiet',ndiff,outFile,argFile],
                        stdout=df,stderr=STDOUT)
               else:
                  call(["diff",outFile,argFile],stdout=df,stderr=STDOUT)

            except OSError, (e,err): 
               if e == ENOENT: # No such file or directory 
                  print >>logf, '\nFAIL:', err, '\n'

            if df.tell(): 
               print >>logf, '\nUNEXPECTED OUTPUT:'
               m_ = (m[0],exit.BADOUT,m[2],m[3],m[4])

      else:
         copyfile(outFile,argFile)

   return m_



def measureCheckAndLog(t,f,ext,r):
   from tempfile import TemporaryFile
   from time import strftime,gmtime
   from os.path import getsize, split

   revisedTestValues = []

   for a in testvalues:
      cmd = cmdWithArg(t,a)
      ofName = outName(f,0)
      m = ('_',exit.ERROR,0,0,"%")

      try:
         with open(_ERR,'w+') as ef:
            with open(logName(f),'w') as logf:

               with open(ofName,'w') as of:
                  print >>logf, '\n', strftime("%a, %d %b %Y %H:%M:%S GMT", gmtime())

                  if hasMake(ext):
                     with open(_MAKE, 'r') as mf:
                        logf.write( mf.read() )    


                  if data:
                     dfName = dataName(a)
                     print >>logf, '\nCOMMAND LINE:\n', cmd, '<', split(dfName)[1]
                     with open(dfName,'r') as df:
                        m = measure(a,cmd.split(),delay,maxtime,of,ef,df)
                  else:
                     print >>logf, '\nCOMMAND LINE:\n', cmd
                     m = measure(a,cmd.split(),delay,maxtime,of,ef)

            
               m = checkAndLog(m,ofName,logf)
               print >>r, '%s,%d,%.3f,%d,%s' % m

               with open(ofName,'r+') as of:
                  if exit.isBadout(m):
                     with open(_DIFF, 'r') as df:
                        logf.write( df.read() )               

                  if getsize(ofName) > maxsize:
                     of.truncate(maxsize)
                     logf.write( '\nTRUNCATED PROGRAM OUTPUT:\n' )
                  else:
                     logf.write( '\nPROGRAM OUTPUT:\n' )
                  logf.write( of.read() )

                  logf.write( '\n' )
                  ef.seek(0); logf.write( ef.read() )               


         if not exit.isOk(m) or hasExceededCutoff(m): break
         revisedTestValues.append(a)

      except IOError, (_,e):
         print e # need to do something better when there's a missing file

   return revisedTestValues



def measureOnly(revisedTestValues,t,f,r):
   from subprocess import STDOUT
   for i in range(1,repeat):
      for a in revisedTestValues:
         cmd = cmdWithArg(t,a)

         with open( outName(f,i), 'w') as of:
            if data:
               dfName = dataName(a)
               with open(dfName,'r') as df:
                  m = measure(a,cmd.split(),delay,maxtime,of,STDOUT,df)
            else:
                  m = measure(a,cmd.split(),delay,maxtime,of,STDOUT)

            print >>r, '%s,%d,%.3f,%d,%s' % m



def benchmarksGame():
   # Assume $CWD is a program source directory
   from os import getcwd
   from os import environ
   from os.path import join, splitext
   from cStringIO import StringIO

   initialize()
   path = getcwd()
   environ['MB_SRCDIR'] = path # make files use $MB_SRCDIR
   programs = targetPrograms(path)
   setWorkingDirectory(path)
    
   for filename in programs:
      ext = filename.split('.').pop() # We only selected filenames with a .

      if hasMake(ext):
         callMake(path,filename)    

      t = cmdTemplate(filename,ext)
      r = StringIO()

      revisedTestValues = measureCheckAndLog(t,filename,ext,r)

      measureOnly(revisedTestValues,t,filename,r)

      # Write dat file once, when all data is available
      with open( join(path,'dat',filename),'w') as datf:
         datf.write( r.getvalue() )

      r.close()



def main():
   global repeat, cutoff, delay, maxtime, conf, data
   from sys import argv, exit
   from getopt import getopt, GetoptError

   try:
      options,_ = getopt(argv[1:],'h',['cmd=' ,'repeat=' ,'cutoff=' 
         ,'delay=' ,'maxtime=' ,'range=' ,'conf=' ,'ndiff=' ,'data=' ,'help'])

      cmd = None
      for o, v in options:
         if o in ('-h', '--help'):
            print __doc__
            exit(0)
         elif o in ('--cmd'):
            cmd = v
         elif o in ('--repeat'):
            repeat = int(v)
         elif o in ('--cutoff'):
            cutoff = int(v)
         elif o in ('--delay'):
            delay = float(v)
         elif o in ('--maxtime'):
            maxtime = int(v)  

      if cmd:
         standalone(cmd)
      else:
         for o, v in options:
            if o in ('--range'):
               testvalues.extend( v.split(',') )
            elif o in ('--conf'):
               conf = v
            elif o in ('--data'):
               data = v
            elif o in ('--ndiff'):
               ndiff = v

         benchmarksGame()

   except GetoptError, (_,e):
      print e
      print 'please try --help'
      exit(2)

           
if __name__ == "__main__":
   main()


