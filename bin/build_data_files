#!/usr/bin/perl
# to be run in top directory

# Extracts the data from each test and build the global data file
# used to display the graphs on the benchmark pages.
use strict;
use File::Basename;

my $use_flags;

BEGIN {
    # Load our hash of languages
    foreach my $d qw(. .. ../.. ../../..) {
        my $file = "$d/langs.pl";
	if (-f $file) {
	    require $file;
	    last;
	}
    }
}

#
#  Print an output [n]data file
#
sub print_datafile($$$%) {
    my ($benchmark, $dest, $mdref, %startup_cost) = @_;
    my $ref = $main::use_flags{$benchmark};
    my %use_flags = %$ref;
    my %masterdata = %$mdref;
    my $locsource = "bench/$benchmark/data/loc.tab";
    my (%loc);

    # Process LOC data
    unless ( open(LOC, "<$locsource") ) {
        print "Can't open $locsource for input!: $!\n";
	return;
    }
    while(<LOC>) {
        chomp;
        my($impl, $lines) = split;
	$loc{$impl} = $lines;
    }
    close LOC;
    print "    Read $locsource input data...\n";

    # Process each language in turn...
    open(DEST, ">>$dest") or die "Can't open $dest for output!";
    foreach my $impl (sort keys %masterdata) {
         my %data = %{$masterdata{$impl}};

	 foreach my $run (sort keys %data) {
	     my $ref = $data{$run};
	     my %rundata = %$ref;

	     my $cpu = $rundata{'cpu'};
	     my $mem = $rundata{'mem'};

	     $impl =~ /(.*)\-(\d+)/;
	     my $lang = $1;
	     my $id = $2;

	     unless (defined($lang)) {
	         $lang = $impl;
             }

             unless (defined($id)) {
                 $id = " ";
             }

             print DEST "$use_flags{$lang},$benchmark,$lang,$id,$run,";
	     print DEST $cpu - $startup_cost{$lang};
	     print DEST ",$cpu,$mem,";
             print DEST $loc{$impl};
	     print DEST ", 09/30/2004\n";
         }
    }
    close DEST;

    return;
}

#
#   Read in existing use flag from data file.
#
sub read_use_flags ($@) {
    my ($source, @allfiles) = @_;

    print "    Saving prior run settings from $source\n";
    
    # Build a default map, assuming 'true' for all combinations.
    foreach my $bench (@allfiles) {
        next unless -d "bench/$bench";	    
        next if ($bench =~ /\.\./);
        next if ($bench =~ /\./);
        next if ($bench =~ /Include/);
        next if ($bench =~ /CVS/);

        my %bench_use_flags;
        foreach my $lang (keys %::LANG) {
	    $bench_use_flags{$lang} = "+";
	}
	$main::use_flags{$bench} = \%bench_use_flags;
    }

    unless ( open (SOURCE, "<$source") ) {
        print "    Using default settings...\n";
	return;
    }

    # Otherwise, read file and update map appropriately
    my $cubmrk = "ackermann";
    my $use_flag_ref;
    while (<SOURCE>) {
        chomp;
	next if /#/;
	next if /use/;
	my($flag, $bmrk, $impl, @rest) = split /,/;

	if ($bmrk ne $cubmrk) {
	    $main::use_flags{$cubmrk} = $use_flag_ref;
	    $cubmrk = $bmrk;
	    $use_flag_ref = $main::use_flags{$bmrk};
        }

	
	$use_flag_ref->{$impl} = $flag;
    }

    print "    Finished reading data.\n";
    return;
}

#
#   Overall "Summary" Data File
#
sub gen_master_file ($$%) {
    my ($benchmark, $dest, %startup_cost) = @_;
    my $source = "bench/$benchmark/data/max.mbtab";
    my (%data);

    return unless -s $source;

    open(SOURCE, "<$source") or die "Can't open $source for input!: $!\n";
    while(<SOURCE>) {
        chomp;
	next if /#/;
        my($lang, $cpu, $mem) = split;

	# This extra indirection is to allow us to use the same printing
	# function for both types of files
	my %rundata;
	$rundata{' '} ={ cpu => $cpu, mem => $mem};
	$data{$lang} = \%rundata;
    }
    close SOURCE;
    print "    Read $source input data...\n";
    print "    Generating summary data.csv...\n";

    print_datafile($benchmark, $dest, \%data, %startup_cost);

    return;
}

#
#  Global "All Run" Data File
#
sub gen_ndata_files ($$%) {
    my ($benchmark, $dest, %startup_cost) = @_;
    my (%masterdata);

    print "    >>> Reading individual run data <<<\n";
    print "        ";
    my $langcount = 0;
    foreach my $lang (keys %::LANG) {

	# Note:  Each language may provide a few implementations.  These
	# are stored as, e.g., "ackermann.perl", "ackermann.perl2.perl",
	# "ackermann.perl3.perl", etc.
	my @choices = ("", "$lang-2.", "$lang-3.", "$lang-4.");
	foreach my $try (@choices) {
            my $source = "bench/$benchmark/tmp/$benchmark." . $try . "$lang.mbdat";
            my (%filedata);

            next unless -s $source;

            open(SOURCE, "<$source") or die "Can't open $source for input!: $!\n";
            while(<SOURCE>) {
                chomp;
                next if /#/;
                my($run, $user, $sys, $mem) = split;

                if (($user eq -1) || ($user eq -2)) {
                    $filedata{$run} = [ 1, $user, $user];
                    next;
                }
		
                my $cpu = $user;

                my $ref = $filedata{$run};
                my @data;
                if (defined $ref) {
                    @data = @$ref;
                } else {
                    @data = (0, 0, 0);
                }

                $filedata{$run} = [ $data[0] + 1, $data[1] + $cpu, $data[2] + $mem];
            }
            close SOURCE;

            # Now get averages and add to the master hash
            my %rundata;
            foreach my $iter (keys %filedata) {
                my $ref = $filedata{$iter};
                my @tempdata;
                if (defined $ref) {
	            @tempdata = @$ref;
                } else {
	            @tempdata = (0, 0, 0);
                }
                my $count = shift @tempdata;
                my $agcpu = shift @tempdata;
                my $agmem = shift @tempdata;

                if (($agcpu eq -1) || ($agcpu eq -2)) {
                    $rundata{$iter} = { cpu => $agcpu, mem => $agcpu };
                } else {
                    my $avgcpu = sprintf("%0.4f", $agcpu/$count);
                    my $avgmem = sprintf("%.0f", $agmem/$count);

                   $rundata{$iter} = { cpu => $avgcpu, mem => $avgmem };
                }
            }

	    if ($try eq "") {
                $masterdata{$lang} = \%rundata;
            } else {
	        my $slot = $try;
		$slot =~ s/\.//;
                $masterdata{$slot} = \%rundata;
            }
        }
        print "$lang ";
        $langcount++;
        if ($langcount % 10 eq 0) {
            print "\n        ";
        }
    }
    print "\n";
    print "    Processed individual data files.  Generating master ndata.csv...\n";

    print_datafile($benchmark, $dest, \%masterdata, %startup_cost);

    return;
}


#
#  Main
#
sub main {

    print "Generating ndata.csv and data.csv...\n";

    my $startup = "bench/hello/data/startup.tab";
    my %startup_cost;
    my $dest = "website/data/data.csv";
    my $ndest = "website/data/ndata.csv";

    # Read in the startup costs
    open(STARTUP, "<$startup") or die "Can't open $startup for input!";

    while(<STARTUP>) {
        chomp;
        my($lang, $startup) = split;
	$startup_cost{$lang} = $startup;
    }
    print "    Read startup cost data...\n";
	
    # Mine the data from the benchmarks
    opendir BENCHDIR, "bench" or die "Couldn't open benchmark directory: $!\n";
    my @allfiles = sort readdir BENCHDIR;
    shift @allfiles;	# Drop the . directory
    shift @allfiles;	# Drop the .. directory
    closedir BENCHDIR;

    # Read the existing 'use' flags, if available
    my %use_flags = read_use_flags($dest, @allfiles);

    print "    Read list of benchmarks...\n";
    if (-s $dest) {
        unlink $dest or die "Couldn't delete old $dest file: $!\n";
    }
    open(DEST, ">$dest") or die "Couldn't create new $dest file: $!\n";
    print DEST "use,test,lang,id,iter,secs-startup,secs,kb,lines,date\n";
    close DEST;
    
    if (-s $ndest) {
        unlink $ndest or die "Couldn't delete old $ndest file: $!\n";
    }
    open(NDEST, ">$ndest") or die "Couldn't create new $ndest file: $!\n";
    print NDEST "use,test,lang,id,iter,secs-startup,secs,kb,lines,date\n";
    close NDEST;
    print "\n\n";

    #
    #  For each directory in the bench directory, read the
    #  associated '[test].[lang].mbdat' data file.  Build a hash of
    #  these entries and then write the corresponding 'ndata.csv'
    #  file in the website directory.
    #
    print "    [[[ Processing data ]]]\n";
    foreach my $benchmark (@allfiles) {

        my $benchdir = $benchmark;

        next unless -d "bench/$benchdir";	    
        next if ($benchdir =~ /\.\./);
        next if ($benchdir =~ /\./);
        next if ($benchdir =~ /Include/);
        next if ($benchdir =~ /CVS/);

	print "  [$benchdir]\n";

	gen_ndata_files($benchdir, $ndest, %startup_cost, $use_flags{$benchdir});

	gen_master_file($benchdir, $dest, %startup_cost, $use_flags{$benchdir});
    }
    
    print "Finished.\n";
}

main();
