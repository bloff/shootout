#!/usr/bin/perl
# $Id: make_craps,v 1.3 2004-06-22 08:08:32 bfulgham Exp $

use strict;

BEGIN {
    foreach my $d qw(. .. ../.. ../../..) {
	my $file = "$d/langs.pl";
	if (-f $file) {
	    require $file;
	    last;
	}
    }
}

sub listfiles ($$) {
    my($dir, $pat) = @_;
    my @files = ();
    my $re = qr{$pat};
    if (opendir(DH, $dir)) {
	@files = grep(/$re/, readdir(DH));
	closedir(DH);
    }
    return(@files);
}

sub weighting {
    my($SCALE) = 1.0;
    my($n) = shift;
    my($goal) = shift;
    if (! defined $n) {
        return 0;
    }
    if ($n == 0) {
        return 0;
    }
    if ($goal == 0) {
        return 0;
    }

    return 1 / (1 + $SCALE * log($n/$goal)/log(2));
}

sub score {
    my $test = shift;
    local *S;
    my $datafile = "$test/data/max.mbtab";
    open(S, "<$datafile") ||
	die "Error opening $datafile for input ($!)";
    my %score = ();
    my($cpumin, $cpumax, $memmin, $memmax);
    while (<S>) {
	next if (/^\#/);
	if (/^([a-z]\S+)\s+(\d+\.\d+)\s+(\d+)$/) {
	    my($lang, $cpu, $mem) = ($1, $2, $3);
	    if ($cpu != 0) {
                $cpumin = $cpu if ((not defined $cpumin) or ($cpu < $cpumin));
	        $cpumax = $cpu if ((not defined $cpumax) or ($cpu > $cpumax));
	    }
	    if ($mem != 0) {
	        $memmin = $mem if ((not defined $memmin) or ($mem < $memmin));
	        $memmax = $mem if ((not defined $memmax) or ($mem > $memmax));
	    }
	    $score{$lang}->{CPU} = $cpu;
	    $score{$lang}->{MEM} = $mem;
	} else {
	    warn "Bad data in $datafile: $_";
	}
    }
    close(S);


    my($locmin, $locmax);
    $datafile = "$test/data/loc.tab";
    open(S, "<$datafile") ||
	die "Error opening $datafile for input ($!)";
    while (<S>) {
	next if (/^\#/);
	if (/^([a-z]\S+)\s+(\d+)$/) {
	    my($lang, $loc) = ($1, $2);
	    $locmin = $loc if ((not defined $locmin) or (($loc != 0) && ($loc < $locmin)));
	    $locmax = $loc if ((not defined $locmax) or ($loc > $locmax));
	    $score{$lang}->{LOC} = $loc;
	    #print "score for $lang is $loc\n";
	} else {
	    warn "Bad data in $datafile: $_";
	}
    }
    close(S);

    my $topcpu = ($cpumax + $cpumin);
    my $topmem = ($memmax + $memmin);
    my $toploc = ($locmax + $locmin);
    foreach my $key (%score) {
	$score{$key}->{CPU} = weighting($score{$key}->{CPU}, $cpumin);
	#print "MEM weighting: $key -> $score{$key}->{MEM}, $memmin\n";
	$score{$key}->{MEM} = weighting($score{$key}->{MEM}, $memmin);
	#print "LOC weighting: $key -> $score{$key}->{LOC}, $locmin\n";
	$score{$key}->{LOC} = weighting($score{$key}->{LOC}, $locmin);
    }
    return(\%score);
}

sub title {
    my $test = shift;
    local *S;
    my $makefile = "$test/Makefile";
    open(S, "<$makefile") ||
	die "Error opening $makefile for input ($!)";
    my $title = '';
    while (<S>) {
	if (/TITLE\s*:?=\s*(.*)/) {
	    $title = $1;
	    last;
	}
    }
    close(S);
    return($title);
}

sub main {
    my %title = ();
    my %implemented = ();
    foreach my $test (sort @ARGV) {
	my $score = score($test);
	$title{$test} = title($test);
	foreach my $source (listfiles($test, '^'.$test."\\.[^.]+[^~]\$")) {
	    my($testname, $lang) = split(/\./, $source);
	    die "null lang($lang) for test $testname($test)" if $lang =~ /^$/;
	    my $cpu = sprintf "%.2f", $score->{$lang}->{CPU};
	    my $mem = sprintf "%.2f", $score->{$lang}->{MEM};
	    my $loc = sprintf "%d", $score->{$lang}->{LOC};
	    print qq{SCORE,$testname,$lang,$cpu,$mem,$loc\n};
	    ++$implemented{$lang};
	}
    }
    my $max = 0;
    foreach my $lang (keys %implemented) {
	$max = $implemented{$lang} if $implemented{$lang} > $max;
    }
    my %missing = ();
    foreach my $lang (keys %implemented) {
	$missing{$lang} = $max - $implemented{$lang};
    }
    foreach my $test (sort keys %title) {
	print qq{TITLE,$test,$title{$test}\n};
    }
    foreach my $lang (keys %missing) {
	print qq{LANG,$::LANG{$lang}->{Lang},$lang,$missing{$lang}\n};
    }
}

&main();
