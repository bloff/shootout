#!/usr/bin/perl
# $Id: make_craps,v 1.1 2004-05-19 18:14:26 bfulgham Exp $

use strict;

BEGIN {
    foreach my $d qw(. .. ../.. ../../..) {
	my $file = "$d/langs.pl";
	if (-f $file) {
	    require $file;
	    last;
	}
    }
}

sub listfiles ($$) {
    my($dir, $pat) = @_;
    my @files = ();
    my $re = qr{$pat};
    if (opendir(DH, $dir)) {
	@files = grep(/$re/, readdir(DH));
	closedir(DH);
    }
    return(@files);
}

sub score {
    my $test = shift;
    local *S;
    my $datafile = "$test/data/max.mbtab";
    open(S, "<$datafile") ||
	die "Error opening $datafile for input ($!)";
    my %score = ();
    my($cpumin, $cpumax, $memmin, $memmax);
    while (<S>) {
	next if (/^\#/);
	if (/^([a-z]\S+)\s+(\d+\.\d+)\s+(\d+)$/) {
	    my($lang, $cpu, $mem) = ($1, $2, $3);
	    $cpumin = $cpu if ((not defined $cpumin) or ($cpu < $cpumin));
	    $cpumax = $cpu if ((not defined $cpumax) or ($cpu > $cpumax));
	    $memmin = $mem if ((not defined $memmin) or ($mem < $memmin));
	    $memmax = $mem if ((not defined $memmax) or ($mem > $memmax));
	    $score{$lang}->{CPU} = $cpu;
	    $score{$lang}->{MEM} = $mem;
	} else {
	    warn "Bad data in $datafile: $_";
	}
    }
    close(S);


    my($locmin, $locmax);
    $datafile = "$test/data/loc.tab";
    open(S, "<$datafile") ||
	die "Error opening $datafile for input ($!)";
    while (<S>) {
	next if (/^\#/);
	if (/^([a-z]\S+)\s+(\d+)$/) {
	    my($lang, $loc) = ($1, $2);
	    $locmin = $loc if ((not defined $locmin) or ($loc < $locmin));
	    $locmax = $loc if ((not defined $locmax) or ($loc > $locmax));
	    $score{$lang}->{LOC} = $loc;
	} else {
	    warn "Bad data in $datafile: $_";
	}
    }
    close(S);

    my $topcpu = ($cpumax + $cpumin);
    my $topmem = ($memmax + $memmin);
    my $toploc = ($locmax + $locmin);
    foreach my $key (%score) {
	$score{$key}->{CPU} = (defined $score{$key}->{CPU}) ?
	    10 * ($topcpu - $score{$key}->{CPU})/$topcpu : 0;
	$score{$key}->{MEM} = (defined $score{$key}->{MEM}) ?
	    10 * ($topmem - $score{$key}->{MEM})/$topmem : 0;
	$score{$key}->{LOC} = (defined $score{$key}->{LOC}) ?
	    10 * ($toploc - $score{$key}->{LOC})/$toploc : 0;
    }
    return(\%score);
}

sub title {
    my $test = shift;
    local *S;
    my $makefile = "$test/Makefile";
    open(S, "<$makefile") ||
	die "Error opening $makefile for input ($!)";
    my $title = '';
    while (<S>) {
	if (/TITLE\s*:?=\s*(.*)/) {
	    $title = $1;
	    last;
	}
    }
    close(S);
    return($title);
}

sub main {
    my %title = ();
    my %implemented = ();
    foreach my $test (sort @ARGV) {
	my $score = score($test);
	$title{$test} = title($test);
	foreach my $source (listfiles($test, '^'.$test."\\.[^.]+[^~]\$")) {
	    my($testname, $lang) = split(/\./, $source);
	    die "null lang($lang) for test $testname($test)" if $lang =~ /^$/;
	    my $cpu = sprintf "%.2f", $score->{$lang}->{CPU};
	    my $mem = sprintf "%.2f", $score->{$lang}->{MEM};
	    my $loc = sprintf "%d", $score->{$lang}->{LOC};
	    print qq{SCORE,$testname,$lang,$cpu,$mem,$loc\n};
	    ++$implemented{$lang};
	}
    }
    my $max = 0;
    foreach my $lang (keys %implemented) {
	$max = $implemented{$lang} if $implemented{$lang} > $max;
    }
    my %missing = ();
    foreach my $lang (keys %implemented) {
	$missing{$lang} = $max - $implemented{$lang};
    }
    foreach my $test (sort keys %title) {
	print qq{TITLE,$test,$title{$test}\n};
    }
    foreach my $lang (keys %missing) {
	print qq{LANG,$::LANG{$lang}->{Lang},$lang,$missing{$lang}\n};
    }
}

&main();
