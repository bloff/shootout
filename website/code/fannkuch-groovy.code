<span class="dir">#!/bin/env groovy
</span><span class="com">/*
	$Id: fannkuch-groovy.code,v 1.1 2005-09-21 05:17:34 bfulgham Exp $

	The Great Computer Language Shootout
	http://shootout.alioth.debian.org/

	contributed by Jochen Hinrichsen
	modified by

	Each program should

	    * &quot;Take a permutation of {1,...,n}, for example: {4,2,1,5,3}.
	    * Take the first element, here 4, and reverse the order of the first 4 elements: {5,1,2,4,3}.
	    * Repeat this until the first element is a 1, so flipping won't change anything more: {3,4,2,1,5}, {2,4,3,1,5}, {4,2,3,1,5}, {1,3,2,4,5}.
	    * Count the number of flips, here 5.
	    * Do this for all n! permutations, and record the maximum number of flips needed for any permutation.

	The conjecture is that this maximum count is approximated by n*log(n) when n goes to infinity.

	FANNKUCH is an abbreviation for the German word Pfannkuchen, or pancakes, in analogy to flipping pancakes.&quot;

	Each program should generate the same sequence of n! permutations - the sequence generated by the incremental change algorithm implemented in
	the C# and Oberon-2 programs. For N=4 the sequence of permutations is:

	   {1,2,3,4}
	   {2,1,3,4}
	   {2,3,1,4}
	   {3,2,1,4}
	   {3,1,2,4}
	   {1,3,2,4}
	   {2,3,4,1}
	   {3,2,4,1}
	   {3,4,2,1}
	   {4,3,2,1}
	   {4,2,3,1}
	   {2,4,3,1}
	   {3,4,1,2}
	   {4,3,1,2}
	   {4,1,3,2}
	   {1,4,3,2}
	   {1,3,4,2}
	   {3,1,4,2}
	   {4,1,2,3}
	   {1,4,2,3}
	   {1,2,4,3}
	   {2,1,4,3}
	   {2,4,1,3}
	   {4,2,1,3}


	Correct output N = 7 is:

	Pfannkuchen(7) = 16


	Correct output N = 8 is:

	Pfannkuchen(8) = 22


	The fannkuch benchmark is defined in Performing Lisp Analysis of the FANNKUCH Benchmark, Kenneth R. Anderson and Duane Rettig (26KB postscript)
*/</span>

<span class="slc">// This algorithm taken from the ruby sample does not produce the exact order as defined above
</span>def permute<span class="sym">(</span>head<span class="sym">,</span> tail<span class="sym">,</span> permute<span class="sym">) {
</span>	<span class="kwa">for</span> <span class="sym">(</span>i in <span class="num">0</span><span class="sym">..&lt;</span>tail<span class="sym">.</span>size<span class="sym">()) {
</span>		head<span class="sym">.</span>add<span class="sym">(</span>tail<span class="sym">.</span>remove<span class="sym">(</span>i<span class="sym">))
</span>		tail<span class="sym">.</span>isEmpty<span class="sym">()</span> ? permute<span class="sym">(</span>head<span class="sym">.</span>clone<span class="sym">()) :</span> permute<span class="sym">(</span>head<span class="sym">,</span> tail<span class="sym">,</span> permute<span class="sym">)
</span>		tail<span class="sym">.</span>add<span class="sym">(</span>i<span class="sym">,</span> head<span class="sym">.</span>pop<span class="sym">())
	}
}

</span>def permute<span class="sym">(</span>size<span class="sym">,</span> closure<span class="sym">) {
</span>	permute<span class="sym">([], (</span><span class="num">1</span><span class="sym">..</span>size<span class="sym">).</span>step<span class="sym">(</span><span class="num">1</span><span class="sym">),</span> closure<span class="sym">)
}

</span>def N <span class="sym">= (</span>args<span class="sym">.</span>length <span class="sym">==</span> <span class="num">0</span><span class="sym">)</span> ? <span class="num">7</span> <span class="sym">:</span> args<span class="sym">[</span><span class="num">0</span><span class="sym">].</span>toInteger<span class="sym">()
</span>def maxflips <span class="sym">=</span> <span class="num">0

</span>permute<span class="sym">(</span>N<span class="sym">) { |</span>list<span class="sym">|
</span>	def flips <span class="sym">=</span> <span class="num">0
</span>	<span class="kwa">while</span> <span class="sym">((</span>count <span class="sym">=</span> list<span class="sym">[</span><span class="num">0</span><span class="sym">]) !=</span> <span class="num">1</span><span class="sym">) {
</span>		<span class="slc">// Inconsistent groovy syntax, lvalue list[0..&lt;count] does not work
</span>		<span class="slc">// Option #1
</span>		<span class="slc">// list[0, count-1] = list[0..&lt;count].reverse()
</span>
		<span class="slc">// Option #2: more Java like alternative, little bit faster
</span>		Collections<span class="sym">.</span>copy<span class="sym">(</span>list<span class="sym">,</span> list<span class="sym">[</span><span class="num">0</span><span class="sym">..&lt;</span>count<span class="sym">].</span>reverse<span class="sym">())

</span>		flips<span class="sym">++
	}
</span>	maxflips <span class="sym">= [</span>maxflips<span class="sym">,</span> flips<span class="sym">].</span>max<span class="sym">()
}

</span>println <span class="str">&quot;Pfannkuchen(${N}) = ${maxflips}&quot;</span>

<span class="slc">// EOF
</span>
