<span class="slc">-- The Computer Language Shootout</span>
<span class="slc">-- http://shootout.alioth.debian.org/</span>
<span class="slc">-- contributed by Jeff Newbern</span>

<span class="slc">-- Uses random generation code derived from Simon Marlow and Einar Karttunen's</span>
<span class="slc">-- &quot;random&quot; test entry.</span>

<span class="slc">-- Note: This code has not been optimized *at all*.  It is written to be clear</span>
<span class="slc">-- and to follow standard Haskell idioms as much as possible (but we have to match</span>
<span class="slc">-- the stateful PRNG idiom in the test definition, which is oriented toward an</span>
<span class="slc">-- imperative language).  Performance is decent with ghc -O2, but if it can be</span>
<span class="slc">-- improved without sacrificing the clarity of the code, by all means go for it!</span>

<span class="kwa">import</span> System<span class="sym">(</span>getArgs<span class="sym">)</span>

<span class="kwa">type</span> Base <span class="sym">=</span> <span class="kwb">Char</span>
<span class="kwa">type</span> Sequence <span class="sym">= [</span>Base<span class="sym">]</span>

alu <span class="sym">::</span> Sequence  <span class="slc">-- predefined sequence</span>
alu <span class="sym">=</span> <span class="str">&quot;GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG&quot;</span> <span class="sym">++</span>
      <span class="str">&quot;GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA&quot;</span> <span class="sym">++</span>
      <span class="str">&quot;CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT&quot;</span> <span class="sym">++</span>
      <span class="str">&quot;ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA&quot;</span> <span class="sym">++</span>
      <span class="str">&quot;GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG&quot;</span> <span class="sym">++</span>
      <span class="str">&quot;AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC&quot;</span> <span class="sym">++</span>
      <span class="str">&quot;AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA&quot;</span>

<span class="kwa">type</span> BaseFrequency <span class="sym">= (</span>Base<span class="sym">,</span><span class="kwb">Double</span><span class="sym">)</span>

iub <span class="sym">:: [</span>BaseFrequency<span class="sym">]</span>
iub <span class="sym">= [ (</span><span class="str">'a'</span><span class="sym">,</span> <span class="num">0.27</span><span class="sym">), (</span><span class="str">'c'</span><span class="sym">,</span> <span class="num">0.12</span><span class="sym">), (</span><span class="str">'g'</span><span class="sym">,</span> <span class="num">0.12</span><span class="sym">), (</span><span class="str">'t'</span><span class="sym">,</span> <span class="num">0.27</span><span class="sym">),</span>
        <span class="sym">(</span><span class="str">'B'</span><span class="sym">,</span> <span class="num">0.02</span><span class="sym">), (</span><span class="str">'D'</span><span class="sym">,</span> <span class="num">0.02</span><span class="sym">), (</span><span class="str">'H'</span><span class="sym">,</span> <span class="num">0.02</span><span class="sym">), (</span><span class="str">'K'</span><span class="sym">,</span> <span class="num">0.02</span><span class="sym">), (</span><span class="str">'M'</span><span class="sym">,</span> <span class="num">0.02</span><span class="sym">), (</span><span class="str">'N'</span><span class="sym">,</span> <span class="num">0.02</span><span class="sym">),</span>
        <span class="sym">(</span><span class="str">'R'</span><span class="sym">,</span> <span class="num">0.02</span><span class="sym">), (</span><span class="str">'S'</span><span class="sym">,</span> <span class="num">0.02</span><span class="sym">), (</span><span class="str">'V'</span><span class="sym">,</span> <span class="num">0.02</span><span class="sym">), (</span><span class="str">'W'</span><span class="sym">,</span> <span class="num">0.02</span><span class="sym">), (</span><span class="str">'Y'</span><span class="sym">,</span> <span class="num">0.02</span><span class="sym">) ]</span>

homosapiens <span class="sym">:: [</span>BaseFrequency<span class="sym">]</span>
homosapiens <span class="sym">= [ (</span><span class="str">'a'</span><span class="sym">,</span> <span class="num">0.3029549426680</span><span class="sym">), (</span><span class="str">'c'</span><span class="sym">,</span> <span class="num">0.1979883004921</span><span class="sym">),</span>
                <span class="sym">(</span><span class="str">'g'</span><span class="sym">,</span> <span class="num">0.1975473066391</span><span class="sym">), (</span><span class="str">'t'</span><span class="sym">,</span> <span class="num">0.3015094502008</span><span class="sym">) ]</span>

<span class="slc">-- select a base whose interval covers the given double</span>
chooseBase <span class="sym">:: [</span>BaseFrequency<span class="sym">] -&gt;</span> <span class="kwb">Double</span> <span class="sym">-&gt;</span> Base
chooseBase <span class="sym">[(</span>b<span class="sym">,</span>_<span class="sym">)]</span>    _ <span class="sym">=</span> b
chooseBase <span class="sym">((</span>b<span class="sym">,</span>f<span class="sym">):</span>xs<span class="sym">)</span> p <span class="sym">|</span> p <span class="sym">&lt;</span> f     <span class="sym">=</span> b
                        <span class="sym">|</span> otherwise <span class="sym">=</span> chooseBase xs <span class="sym">(</span>p<span class="sym">-</span>f<span class="sym">)</span>

<span class="slc">-- write a sequence in Fasta format</span>
writeFasta <span class="sym">::</span> String <span class="sym">-&gt;</span> String <span class="sym">-&gt;</span> Sequence <span class="sym">-&gt;</span> IO <span class="sym">()</span>
writeFasta label title sequence <span class="sym">=</span>
  <span class="kwa">do</span> putStrLn $ <span class="str">&quot;&gt;&quot;</span> <span class="sym">++ (</span>label <span class="sym">++ (</span><span class="str">&quot; &quot;</span> <span class="sym">++</span> title<span class="sym">))</span>
     writeWrapped <span class="num">60</span> sequence
  <span class="kwa">where</span> writeWrapped _   <span class="sym">[]  =</span> <span class="kwa">do</span> return <span class="sym">()</span>
        writeWrapped len str <span class="sym">=</span> <span class="kwa">do let</span> <span class="sym">(</span>s1<span class="sym">,</span>s2<span class="sym">) =</span> splitAt len str
                                  putStrLn s1
                                  writeWrapped len s2

<span class="slc">-- generate an infinite sequence of random doubles using the</span>
<span class="slc">-- prng from the &quot;random&quot; test</span>
probs <span class="sym">::</span> <span class="kwb">Int</span> <span class="sym">-&gt; [</span><span class="kwb">Double</span><span class="sym">]</span>
probs seed <span class="sym">=</span> tail $ map normalize <span class="sym">(</span>iterate nextSeed seed<span class="sym">)</span>
  <span class="kwa">where</span> nextSeed s <span class="sym">= (</span>s <span class="sym">*</span> ia <span class="sym">+</span> ic<span class="sym">)</span> `mod` im
        im <span class="sym">=</span> <span class="num">139968</span>
        ia <span class="sym">=</span> <span class="num">3877</span>
        ic <span class="sym">=</span> <span class="num">29573</span>
        normalize n <span class="sym">= (</span>fromIntegral n<span class="sym">) * (</span><span class="num">1.0</span> <span class="sym">/</span> fromIntegral im<span class="sym">)</span>

main <span class="sym">=</span> <span class="kwa">do</span> args <span class="sym">&lt;-</span> getArgs
          <span class="kwa">let</span> n <span class="sym">=</span> if <span class="sym">(</span>null args<span class="sym">)</span> <span class="kwa">then</span> <span class="num">1000</span> <span class="kwa">else</span> read <span class="sym">(</span>head args<span class="sym">)</span>
          writeFasta <span class="str">&quot;ONE&quot;</span> <span class="str">&quot;Homo sapiens alu&quot;</span> <span class="sym">(</span>take <span class="sym">(</span><span class="num">2</span><span class="sym">*</span>n<span class="sym">) (</span>cycle alu<span class="sym">))</span>
          <span class="kwa">let</span> <span class="sym">(</span>seq1<span class="sym">,</span>seq2<span class="sym">) =</span> splitAt <span class="sym">(</span><span class="num">3</span><span class="sym">*</span>n<span class="sym">) (</span>probs <span class="num">42</span><span class="sym">)</span> <span class="slc">-- we have to match the imperative version</span>
          <span class="kwa">let</span> seq2<span class="str">' = take (5*n) seq2                -- instead of using the Haskell idiom</span>
<span class="str">          writeFasta &quot;TWO&quot; &quot;IUB ambiguity codes&quot; (map (chooseBase iub) seq1)</span>
<span class="str">          writeFasta &quot;THREE&quot; &quot;Homo sapiens frequency&quot; (map (chooseBase homosapiens) seq2'</span><span class="sym">)</span>
