<span class="com">{ The Computer Language Benchmarks Game</span>
<span class="com">  http://shootout.alioth.debian.org</span>
<span class="com"></span>
<span class="com">  contributed by Steve Fisher</span>
<span class="com">  modified by Peter Vreman</span>
<span class="com">  modified by Steve Fisher</span>
<span class="com">}</span>

<span class="slc">// This version allows * search.</span>


<span class="kwa">const</span>
  patterns <span class="sym">:</span> <span class="kwa">array</span><span class="sym">[</span><span class="num">1</span>.<span class="num">.9</span><span class="sym">]</span> <span class="kwa">of string</span><span class="sym">[</span><span class="num">255</span><span class="sym">] =</span>
    <span class="sym">(</span>
      <span class="str">'agggtaaa|tttaccct'</span><span class="sym">,</span>
      <span class="str">'[cgt]gggtaaa|tttaccc[acg]'</span><span class="sym">,</span>
      <span class="str">'a[act]ggtaaa|tttacc[agt]t'</span><span class="sym">,</span>
      <span class="str">'ag[act]gtaaa|tttac[agt]ct'</span><span class="sym">,</span>
      <span class="str">'agg[act]taaa|ttta[agt]cct'</span><span class="sym">,</span>
      <span class="str">'aggg[acg]aaa|ttt[cgt]ccct'</span><span class="sym">,</span>
      <span class="str">'agggt[cgt]aa|tt[acg]accct'</span><span class="sym">,</span>
      <span class="str">'agggta[cgt]a|t[acg]taccct'</span><span class="sym">,</span>
      <span class="str">'agggtaa[cgt]|[acg]ttaccct'</span>
    <span class="sym">);</span>
  replacements <span class="sym">:</span> <span class="kwa">array</span><span class="sym">[</span><span class="num">0</span>.<span class="num">.10</span><span class="sym">,</span><span class="num">0</span>.<span class="num">.1</span><span class="sym">]</span> <span class="kwa">of string</span><span class="sym">[</span><span class="num">15</span><span class="sym">] =</span>
  <span class="sym">(</span>
    <span class="sym">(</span><span class="str">'B'</span><span class="sym">,</span> <span class="str">'(c|g|t)'</span><span class="sym">), (</span><span class="str">'D'</span><span class="sym">,</span> <span class="str">'(a|g|t)'</span><span class="sym">), (</span><span class="str">'H'</span><span class="sym">,</span> <span class="str">'(a|c|t)'</span><span class="sym">), (</span><span class="str">'K'</span><span class="sym">,</span> <span class="str">'(g|t)'</span><span class="sym">),</span>
    <span class="sym">(</span><span class="str">'M'</span><span class="sym">,</span> <span class="str">'(a|c)'</span><span class="sym">), (</span><span class="str">'N'</span><span class="sym">,</span> <span class="str">'(a|c|g|t)'</span><span class="sym">), (</span><span class="str">'R'</span><span class="sym">,</span> <span class="str">'(a|g)'</span><span class="sym">), (</span><span class="str">'S'</span><span class="sym">,</span> <span class="str">'(c|t)'</span><span class="sym">),</span>
    <span class="sym">(</span><span class="str">'V'</span><span class="sym">,</span> <span class="str">'(a|c|g)'</span><span class="sym">), (</span><span class="str">'W'</span><span class="sym">,</span> <span class="str">'(a|t)'</span><span class="sym">), (</span><span class="str">'Y'</span><span class="sym">,</span> <span class="str">'(c|t)'</span><span class="sym">)</span>
  <span class="sym">);</span>


<span class="kwa">type</span>
  skip_type <span class="sym">=</span> <span class="kwa">array</span><span class="sym">[</span><span class="kwd">low</span><span class="sym">(</span><span class="kwb">char</span><span class="sym">)</span> .. <span class="kwd">high</span><span class="sym">(</span><span class="kwb">char</span><span class="sym">)]</span> <span class="kwa">of</span> <span class="kwb">integer</span><span class="sym">;</span>
  TRegexEngine <span class="sym">=</span> <span class="kwa">record</span>
    left<span class="sym">,</span> right<span class="sym">,</span> starred<span class="sym">:</span> <span class="kwa">string</span><span class="sym">[</span><span class="num">255</span><span class="sym">];</span>
    size<span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;</span>
    cclass<span class="sym">:</span> <span class="kwa">set of</span> <span class="kwb">char</span><span class="sym">;</span>
    skip<span class="sym">:</span> skip_type<span class="sym">;</span>
    simple<span class="sym">:</span> <span class="kwb">boolean</span><span class="sym">;</span>
  <span class="kwa">end</span><span class="sym">;</span>
  t_escaped <span class="sym">=</span> <span class="kwa">array</span><span class="sym">[</span><span class="num">1</span>.<span class="num">.255</span><span class="sym">]</span> <span class="kwa">of</span> <span class="kwb">boolean</span><span class="sym">;</span>

<span class="kwa">procedure</span> <span class="kwd">rx_mark_escapes</span><span class="sym">(</span> <span class="kwa">const</span> str<span class="sym">:</span><span class="kwa">string</span><span class="sym">[</span><span class="num">255</span><span class="sym">];</span> <span class="kwa">var</span> dest<span class="sym">:</span> <span class="kwa">string</span><span class="sym">[</span><span class="num">255</span><span class="sym">];</span>
                  <span class="kwa">var</span> escaped<span class="sym">:</span> t_escaped<span class="sym">);</span>
<span class="kwa">var</span>
  i<span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;</span>
  flag<span class="sym">:</span> <span class="kwb">boolean</span><span class="sym">;</span>
<span class="kwa">begin</span>
  dest <span class="sym">:=</span> <span class="str">''</span><span class="sym">;</span>   flag <span class="sym">:=</span> <span class="kwb">false</span><span class="sym">;</span>   i <span class="sym">:=</span> <span class="num">1</span><span class="sym">;</span>
  <span class="kwa">while</span> i <span class="sym">&lt;=</span> <span class="kwd">length</span><span class="sym">(</span>str<span class="sym">)</span> <span class="kwa">do</span>
  <span class="kwa">begin</span>
    <span class="kwa">if</span>  <span class="sym">(</span><span class="str">'\'</span> <span class="sym">=</span> str<span class="sym">[</span>i<span class="sym">])</span> <span class="kwa">and</span> <span class="sym">(</span>i <span class="sym">&lt;</span> <span class="kwd">length</span><span class="sym">(</span>str<span class="sym">))</span> <span class="kwa">then</span>
      <span class="kwa">begin</span>   <span class="kwd">inc</span><span class="sym">(</span>i<span class="sym">);</span>   flag <span class="sym">:=</span> <span class="kwb">true</span>   <span class="kwa">end</span><span class="sym">;</span>
    dest <span class="sym">+=</span> str<span class="sym">[</span>i<span class="sym">];</span>
    escaped<span class="sym">[</span> <span class="kwd">length</span><span class="sym">(</span>dest<span class="sym">) ] :=</span> flag<span class="sym">;</span>
    flag <span class="sym">:=</span> <span class="kwb">false</span><span class="sym">;</span>
    <span class="kwd">inc</span><span class="sym">(</span>i<span class="sym">)</span>
  <span class="kwa">end</span><span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">procedure</span> <span class="kwd">rx_parse_pat</span><span class="sym">(</span> <span class="kwa">const</span> str<span class="sym">:</span> <span class="kwa">string</span><span class="sym">[</span><span class="num">255</span><span class="sym">];</span>
                        <span class="kwa">var</span> left<span class="sym">,</span> middle<span class="sym">,</span> right<span class="sym">:</span> <span class="kwa">string</span><span class="sym">[</span><span class="num">255</span><span class="sym">]);</span>
<span class="kwa">var</span>
  temp<span class="sym">:</span> <span class="kwa">string</span><span class="sym">[</span><span class="num">255</span><span class="sym">];</span>
  escaped<span class="sym">:</span> t_escaped<span class="sym">;</span>
  i<span class="sym">,</span>j<span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;</span>
<span class="kwa">begin</span>
  <span class="kwd">rx_mark_escapes</span><span class="sym">(</span> str<span class="sym">,</span> temp<span class="sym">,</span> escaped <span class="sym">);</span>
  left <span class="sym">:=</span> temp<span class="sym">;</span>   middle <span class="sym">:=</span> <span class="str">''</span><span class="sym">;</span>   right <span class="sym">:=</span> <span class="str">''</span><span class="sym">;</span>
  <span class="kwa">for</span> i <span class="sym">:=</span> <span class="num">1</span> <span class="kwa">to</span> <span class="kwd">length</span><span class="sym">(</span>temp<span class="sym">)</span> <span class="kwa">do</span>
    <span class="kwa">if not</span> escaped<span class="sym">[</span>i<span class="sym">]</span> <span class="kwa">then</span>
      <span class="kwa">if</span> <span class="str">'['</span> <span class="sym">=</span> temp<span class="sym">[</span>i<span class="sym">]</span> <span class="kwa">then</span>
      <span class="kwa">begin</span>
        j <span class="sym">:=</span> i<span class="sym">+</span><span class="num">1</span><span class="sym">;</span>
        <span class="kwa">while not</span> <span class="sym">((</span>temp<span class="sym">[</span>j<span class="sym">]=</span><span class="str">']'</span><span class="sym">)</span> <span class="kwa">and not</span> escaped<span class="sym">[</span>j<span class="sym">])</span> <span class="kwa">do</span>
          <span class="kwd">inc</span><span class="sym">(</span>j<span class="sym">);</span>
        left <span class="sym">:=</span> <span class="kwd">copy</span><span class="sym">(</span>temp<span class="sym">,</span> <span class="num">1</span><span class="sym">,</span> i<span class="sym">-</span><span class="num">1</span><span class="sym">);</span>
        right <span class="sym">:=</span> <span class="kwd">copy</span><span class="sym">(</span>temp<span class="sym">,</span> j<span class="sym">+</span><span class="num">1</span><span class="sym">,</span> <span class="kwd">length</span><span class="sym">(</span>temp<span class="sym">) -</span> j<span class="sym">);</span>
        middle <span class="sym">:=</span> <span class="kwd">copy</span><span class="sym">(</span>temp<span class="sym">,</span> i<span class="sym">,</span> j <span class="sym">-</span> i <span class="sym">+</span> <span class="num">1</span><span class="sym">);</span>
        break<span class="sym">;</span>
      <span class="kwa">end</span>
      <span class="kwa">else if</span> <span class="sym">(</span><span class="str">'*'</span> <span class="sym">=</span> temp<span class="sym">[</span>i<span class="sym">])</span> <span class="kwa">and</span> <span class="sym">(</span>i<span class="sym">&gt;</span><span class="num">1</span><span class="sym">)</span> <span class="kwa">then</span>
      <span class="kwa">begin</span>
        left <span class="sym">:=</span> <span class="kwd">copy</span><span class="sym">(</span>temp<span class="sym">,</span><span class="num">1</span><span class="sym">,</span> i<span class="sym">-</span><span class="num">2</span><span class="sym">);</span>
        right <span class="sym">:=</span> <span class="kwd">copy</span><span class="sym">(</span>temp<span class="sym">,</span> i<span class="sym">+</span><span class="num">1</span><span class="sym">,</span> <span class="kwd">length</span><span class="sym">(</span>temp<span class="sym">) -</span> i<span class="sym">);</span>
        <span class="kwa">if</span> escaped<span class="sym">[</span>i<span class="sym">-</span><span class="num">1</span><span class="sym">]</span> <span class="kwa">then</span>  middle <span class="sym">:=</span> <span class="str">'\'</span><span class="sym">;</span>
        middle <span class="sym">+=</span> temp<span class="sym">[</span>i<span class="sym">-</span><span class="num">1</span><span class="sym">];</span>
        break<span class="sym">;</span>
      <span class="kwa">end</span><span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>


<span class="kwa">function</span> <span class="kwd">RegexCreate</span><span class="sym">(</span> pat<span class="sym">:</span> pchar <span class="sym">):</span> TRegexEngine<span class="sym">;</span>
<span class="kwa">var</span>
  i<span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;</span>
  str<span class="sym">,</span> middle <span class="sym">:</span> <span class="kwa">string</span><span class="sym">[</span><span class="num">255</span><span class="sym">];</span>
  ch<span class="sym">:</span> <span class="kwb">char</span><span class="sym">;</span>
<span class="kwa">begin</span>
  <span class="kwa">with</span> RegexCreate <span class="kwa">do</span>
  <span class="kwa">begin</span>
    cclass <span class="sym">:= [];</span>
    str <span class="sym">:=</span> pat<span class="sym">;</span>
    <span class="kwd">rx_parse_pat</span><span class="sym">(</span> str<span class="sym">,</span> left<span class="sym">,</span> middle<span class="sym">,</span> right <span class="sym">);</span>
    <span class="kwa">if</span> <span class="sym">(</span><span class="str">'['</span> <span class="sym">=</span> middle<span class="sym">[</span><span class="num">1</span><span class="sym">])</span> <span class="kwa">and</span> <span class="sym">(</span><span class="str">']'</span> <span class="sym">=</span> middle<span class="sym">[</span><span class="kwd">length</span><span class="sym">(</span>middle<span class="sym">)])</span> <span class="kwa">then</span>
    <span class="kwa">begin</span>
      <span class="kwa">for</span> i <span class="sym">:=</span> <span class="num">2</span> <span class="kwa">to</span> <span class="kwd">length</span><span class="sym">(</span>middle<span class="sym">) -</span> <span class="num">1</span> <span class="kwa">do</span>
        cclass <span class="sym">:=</span> cclass <span class="sym">+ [</span> middle<span class="sym">[</span>i<span class="sym">] ];</span>
      size <span class="sym">:=</span> <span class="kwd">length</span><span class="sym">(</span>left<span class="sym">) +</span> <span class="num">1</span> <span class="sym">+</span> <span class="kwd">length</span><span class="sym">(</span>right<span class="sym">);</span>
      simple <span class="sym">:=</span> <span class="kwb">false</span><span class="sym">;</span>
    <span class="kwa">end</span>
    <span class="kwa">else if</span> middle <span class="sym">&lt;&gt;</span> <span class="str">''</span> <span class="kwa">then</span>
    <span class="kwa">begin</span>
      simple <span class="sym">:=</span> <span class="kwb">false</span><span class="sym">;</span>
      size <span class="sym">:=</span> <span class="kwd">length</span><span class="sym">(</span>left<span class="sym">) +</span> <span class="kwd">length</span><span class="sym">(</span>right<span class="sym">);</span>
      <span class="kwa">if</span> <span class="str">'\'</span> <span class="sym">=</span> middle<span class="sym">[</span><span class="num">1</span><span class="sym">]</span> <span class="kwa">then</span>
        starred <span class="sym">:=</span> middle<span class="sym">[</span><span class="num">2</span><span class="sym">]</span>
      <span class="kwa">else if</span> <span class="str">'.'</span> <span class="sym">=</span> middle <span class="kwa">then</span>
        starred <span class="sym">:=</span> <span class="str">''</span>
      <span class="kwa">else</span>
        starred <span class="sym">:=</span> middle
    <span class="kwa">end</span>
    <span class="kwa">else</span>
    <span class="kwa">begin</span>
      simple <span class="sym">:=</span> <span class="kwb">true</span><span class="sym">;</span>
      size <span class="sym">:=</span> <span class="kwd">length</span><span class="sym">(</span> left <span class="sym">);</span>
    <span class="kwa">end</span><span class="sym">;</span>
    str <span class="sym">:=</span> left<span class="sym">;</span>
    <span class="kwa">if</span> simple <span class="kwa">or</span> <span class="sym">(</span>cclass <span class="sym">&lt;&gt; [])</span> <span class="kwa">then</span>
      <span class="kwa">if</span> <span class="kwd">length</span><span class="sym">(</span>str<span class="sym">) &lt;</span> <span class="kwd">length</span><span class="sym">(</span>right<span class="sym">)</span> <span class="kwa">then</span>   str <span class="sym">:=</span> right<span class="sym">;</span>
    <span class="kwa">if</span> str <span class="sym">&lt;&gt;</span> <span class="str">''</span> <span class="kwa">then</span>
    <span class="kwa">begin</span>
      <span class="slc">// Set up Boyer-Moore table for longer string.</span>
      <span class="kwa">for</span> ch <span class="sym">:=</span> <span class="kwd">low</span><span class="sym">(</span><span class="kwb">char</span><span class="sym">)</span> <span class="kwa">to</span> <span class="kwd">high</span><span class="sym">(</span><span class="kwb">char</span><span class="sym">)</span> <span class="kwa">do</span>
        skip<span class="sym">[</span>ch<span class="sym">] :=</span> <span class="kwd">length</span><span class="sym">(</span>str<span class="sym">);</span>
      <span class="kwa">for</span> i <span class="sym">:=</span> <span class="num">1</span> <span class="kwa">to</span> <span class="kwd">length</span><span class="sym">(</span>str<span class="sym">) -</span> <span class="num">1</span> <span class="kwa">do</span>
        skip<span class="sym">[</span> str<span class="sym">[</span>i<span class="sym">] ] :=</span> <span class="kwd">length</span><span class="sym">(</span>str<span class="sym">) -</span> i<span class="sym">;</span>
    <span class="kwa">end</span><span class="sym">;</span>
  <span class="kwa">end</span><span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">function</span> <span class="kwd">bm_search</span><span class="sym">(</span> <span class="kwa">const</span> pat<span class="sym">:</span> <span class="kwa">string</span><span class="sym">;</span> <span class="kwa">const</span> skip<span class="sym">:</span> skip_type<span class="sym">;</span>
                    str<span class="sym">:</span> pchar<span class="sym">;</span> len<span class="sym">:</span> <span class="kwb">longint</span> <span class="sym">):</span> pchar<span class="sym">;</span>
<span class="kwa">var</span>
  i<span class="sym">,</span> size<span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;</span>
  where<span class="sym">,</span> top<span class="sym">,</span> p<span class="sym">:</span> pchar<span class="sym">;</span>
<span class="kwa">begin</span>
  size <span class="sym">:=</span> <span class="kwd">length</span><span class="sym">(</span>pat<span class="sym">);</span>
  <span class="kwa">if</span> size <span class="sym">=</span> <span class="num">0</span> <span class="kwa">then</span>
    <span class="kwd">exit</span><span class="sym">(</span> str <span class="sym">);</span>

  where <span class="sym">:=</span> str <span class="sym">+</span> size <span class="sym">-</span> <span class="num">1</span><span class="sym">;</span>
  top <span class="sym">:=</span> str <span class="sym">+</span> len <span class="sym">-</span> <span class="num">1</span><span class="sym">;</span>
  <span class="kwa">while</span> where <span class="sym">&lt;=</span> top <span class="kwa">do</span>
  <span class="kwa">begin</span>
    p <span class="sym">:=</span> where<span class="sym">;</span>
    i <span class="sym">:=</span> size<span class="sym">;</span>
    <span class="kwa">while</span> i <span class="sym">&gt;</span> <span class="num">0</span> <span class="kwa">do</span>
      <span class="kwa">if</span> p^ <span class="sym">=</span> pat<span class="sym">[</span>i<span class="sym">]</span> <span class="kwa">then</span>
      <span class="kwa">begin</span>
        <span class="kwd">dec</span><span class="sym">(</span>i<span class="sym">);</span>
        <span class="kwd">dec</span><span class="sym">(</span>p<span class="sym">);</span>
      <span class="kwa">end</span>
      <span class="kwa">else</span>
        break<span class="sym">;</span>
    <span class="kwa">if</span> i <span class="sym">=</span> <span class="num">0</span> <span class="kwa">then</span>
      <span class="kwd">exit</span><span class="sym">(</span> p<span class="sym">+</span><span class="num">1</span> <span class="sym">);</span>
    where <span class="sym">+=</span> skip<span class="sym">[</span> where^ <span class="sym">];</span>
  <span class="kwa">end</span><span class="sym">;</span> <span class="slc">// while</span>
  <span class="kwd">exit</span><span class="sym">(</span> <span class="kwa">nil</span> <span class="sym">)</span>
<span class="kwa">end</span><span class="sym">;</span>


<span class="kwa">function</span> <span class="kwd">str_eq</span><span class="sym">(</span> <span class="kwa">const</span> str<span class="sym">:</span> <span class="kwa">string</span><span class="sym">;</span> p<span class="sym">:</span> pchar<span class="sym">):</span> <span class="kwb">boolean</span><span class="sym">;</span> <span class="kwa">inline</span><span class="sym">;</span>
<span class="kwa">var</span> i<span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;</span>
<span class="kwa">begin</span>
  <span class="kwa">for</span> i <span class="sym">:=</span> <span class="num">1</span> <span class="kwa">to</span> <span class="kwd">length</span><span class="sym">(</span>str<span class="sym">)</span> <span class="kwa">do</span>
  <span class="kwa">begin</span>
    <span class="kwa">if</span> str<span class="sym">[</span>i<span class="sym">] &lt;&gt;</span> p^ <span class="kwa">then</span>
      <span class="kwd">exit</span><span class="sym">(</span> <span class="kwb">false</span> <span class="sym">);</span>
    <span class="kwd">inc</span><span class="sym">(</span> p <span class="sym">)</span>
  <span class="kwa">end</span><span class="sym">;</span>
  <span class="kwd">exit</span><span class="sym">(</span> <span class="kwb">true</span> <span class="sym">)</span>
<span class="kwa">end</span><span class="sym">;</span>


<span class="slc">// Non-greedy.</span>
<span class="kwa">function</span> <span class="kwd">rx_wild_match</span><span class="sym">(</span> <span class="kwa">const</span> skip_this<span class="sym">,</span> stop_at<span class="sym">:</span> <span class="kwa">string</span><span class="sym">[</span><span class="num">255</span><span class="sym">];</span> p<span class="sym">:</span> pchar <span class="sym">):</span> pchar<span class="sym">;</span>
<span class="kwa">var</span> i<span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;</span>
<span class="kwa">begin</span>
  <span class="kwa">while</span> <span class="sym">(</span>p <span class="sym">&lt;&gt;</span> <span class="kwa">nil</span><span class="sym">)</span> <span class="kwa">and</span> <span class="sym">(</span> p^ <span class="sym">&lt;&gt;</span> <span class="esc">#0</span> <span class="sym">)</span> <span class="kwa">do</span>
  <span class="kwa">begin</span>
    <span class="kwa">if</span> <span class="kwd">str_eq</span><span class="sym">(</span> stop_at<span class="sym">,</span> p <span class="sym">)</span> <span class="kwa">then</span>
      <span class="kwd">exit</span><span class="sym">(</span> p <span class="sym">+</span> <span class="kwd">length</span><span class="sym">(</span>stop_at<span class="sym">) )</span>
    <span class="kwa">else if</span> <span class="str">''</span> <span class="sym">=</span> skip_this <span class="kwa">then</span>
      <span class="kwd">inc</span><span class="sym">(</span> p <span class="sym">)</span>
    <span class="kwa">else if</span> <span class="kwd">str_eq</span><span class="sym">(</span> skip_this<span class="sym">,</span> p <span class="sym">)</span> <span class="kwa">then</span>
      <span class="kwa">for</span> i <span class="sym">:=</span> <span class="num">1</span> <span class="kwa">to</span> <span class="kwd">length</span><span class="sym">(</span> skip_this<span class="sym">)</span> <span class="kwa">do</span>
      <span class="kwa">begin</span>
        <span class="kwd">inc</span><span class="sym">(</span>p<span class="sym">);</span>
        <span class="kwa">if</span> p^ <span class="sym">=</span> <span class="esc">#0</span> <span class="kwa">then</span>
          <span class="kwd">exit</span><span class="sym">(</span> <span class="kwa">nil</span> <span class="sym">);</span>
      <span class="kwa">end</span>
    <span class="kwa">else</span>
      <span class="kwd">exit</span><span class="sym">(</span> <span class="kwa">nil</span> <span class="sym">);</span>
  <span class="kwa">end</span><span class="sym">;</span>
  <span class="kwa">if</span> stop_at <span class="sym">=</span> <span class="str">''</span> <span class="kwa">then</span>  <span class="kwd">exit</span><span class="sym">(</span> p <span class="sym">);</span>
  <span class="kwd">exit</span><span class="sym">(</span> <span class="kwa">nil</span> <span class="sym">)</span>
<span class="kwa">end</span><span class="sym">;</span>



<span class="kwa">function</span> <span class="kwd">Regex_search</span><span class="sym">(</span> <span class="kwa">const</span> rx<span class="sym">:</span> TRegexEngine<span class="sym">;</span> <span class="kwa">const</span> str<span class="sym">:</span> ansistring<span class="sym">;</span>
                       start<span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;</span>  <span class="kwa">var</span> index<span class="sym">,</span> len<span class="sym">:</span> <span class="kwb">longint</span><span class="sym">):</span> <span class="kwb">boolean</span><span class="sym">;</span>
<span class="kwa">var</span>
  p<span class="sym">,</span> last_p<span class="sym">,</span> ceiling<span class="sym">,</span> found_at<span class="sym">,</span> just_past<span class="sym">:</span> pchar<span class="sym">;</span>
  remainder<span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;</span>
<span class="kwa">begin</span>
  p <span class="sym">:= &#64;</span>str<span class="sym">[</span>start<span class="sym">];</span>
  last_p <span class="sym">:= &#64;</span>str<span class="sym">[</span><span class="kwd">length</span><span class="sym">(</span>str<span class="sym">)];</span>

  <span class="kwa">if</span> rx.simple <span class="kwa">then</span>
  <span class="kwa">begin</span>
    found_at <span class="sym">:=</span> <span class="kwd">bm_search</span><span class="sym">(</span> rx.left<span class="sym">,</span> rx.skip<span class="sym">,</span> p<span class="sym">,</span> last_p <span class="sym">-</span> p <span class="sym">+</span> <span class="num">1</span> <span class="sym">);</span>
    <span class="kwa">if</span> found_at <span class="sym">&lt;&gt;</span> <span class="kwa">nil then</span>
    <span class="kwa">begin</span>
      index <span class="sym">:=</span> found_at <span class="sym">- &#64;</span>str<span class="sym">[</span><span class="num">1</span><span class="sym">] +</span> <span class="num">1</span><span class="sym">;</span>
      len <span class="sym">:=</span> rx.size<span class="sym">;</span>
      <span class="kwd">exit</span><span class="sym">(</span> <span class="kwb">true</span> <span class="sym">);</span>
    <span class="kwa">end</span>
    <span class="kwa">else</span>
      <span class="kwd">exit</span><span class="sym">(</span><span class="kwb">false</span><span class="sym">);</span>
  <span class="kwa">end</span><span class="sym">;</span>

  ceiling <span class="sym">:=</span> last_p <span class="sym">-</span> rx.size <span class="sym">+</span> <span class="num">2</span><span class="sym">;</span>

  <span class="slc">// Do a * search?</span>
  <span class="kwa">if</span> rx.cclass <span class="sym">= []</span> <span class="kwa">then</span>
  <span class="kwa">begin</span>
    <span class="kwa">while</span> p <span class="sym">&lt;</span> ceiling <span class="kwa">do</span>
    <span class="kwa">begin</span>
      found_at <span class="sym">:=</span> <span class="kwd">bm_search</span><span class="sym">(</span> rx.left<span class="sym">,</span> rx.skip<span class="sym">,</span> p<span class="sym">,</span> last_p <span class="sym">-</span> p <span class="sym">+</span> <span class="num">1</span> <span class="sym">);</span>
      <span class="kwa">if</span> found_at <span class="sym">=</span> <span class="kwa">nil then</span>
        <span class="kwd">exit</span><span class="sym">(</span> <span class="kwb">false</span> <span class="sym">);</span>
      just_past <span class="sym">:=</span> <span class="kwd">rx_wild_match</span><span class="sym">(</span>
        rx.starred<span class="sym">,</span> rx.right<span class="sym">,</span> found_at <span class="sym">+</span> <span class="kwd">length</span><span class="sym">(</span>rx.left<span class="sym">) );</span>
      <span class="kwa">if</span> just_past <span class="sym">=</span> <span class="kwa">nil then</span>
        p <span class="sym">:=</span> found_at <span class="sym">+</span> <span class="num">1</span>
      <span class="kwa">else</span>
      <span class="kwa">begin</span>
        index <span class="sym">:=</span> found_at <span class="sym">-</span> <span class="kwd">pchar</span><span class="sym">(</span>str<span class="sym">) +</span> <span class="num">1</span><span class="sym">;</span>
        len <span class="sym">:=</span> just_past <span class="sym">-</span> found_at<span class="sym">;</span>
        <span class="kwd">exit</span><span class="sym">(</span> <span class="kwb">true</span> <span class="sym">)</span>
      <span class="kwa">end</span><span class="sym">;</span>
    <span class="kwa">end</span><span class="sym">;</span> <span class="slc">// while</span>
    <span class="kwd">exit</span><span class="sym">(</span> <span class="kwb">false</span> <span class="sym">);</span>
  <span class="kwa">end</span><span class="sym">;</span>

  <span class="slc">// Do a character-class search.</span>
  <span class="slc">// If right string is longer than left, look for it.</span>
  <span class="kwa">if</span> <span class="kwd">length</span><span class="sym">(</span>rx.left<span class="sym">) &lt;</span> <span class="kwd">length</span><span class="sym">(</span>rx.right<span class="sym">)</span> <span class="kwa">then</span>
  <span class="kwa">begin</span>
    remainder <span class="sym">:=</span> rx.size <span class="sym">-</span> <span class="kwd">length</span><span class="sym">(</span>rx.right<span class="sym">);</span>
    <span class="kwd">inc</span><span class="sym">(</span> p<span class="sym">,</span> remainder <span class="sym">);</span>
    <span class="kwd">inc</span><span class="sym">(</span> ceiling<span class="sym">,</span> remainder <span class="sym">);</span>
    <span class="kwa">while</span> p <span class="sym">&lt;</span> ceiling <span class="kwa">do</span>
    <span class="kwa">begin</span>
      found_at <span class="sym">:=</span> <span class="kwd">bm_search</span><span class="sym">(</span> rx.right<span class="sym">,</span> rx.skip<span class="sym">,</span> p<span class="sym">,</span> last_p <span class="sym">-</span> p <span class="sym">+</span> <span class="num">1</span><span class="sym">);</span>
      <span class="kwa">if</span> found_at <span class="sym">&lt;&gt;</span> <span class="kwa">nil then</span>
        <span class="kwa">if</span> <span class="sym">((</span>found_at <span class="sym">-</span> <span class="num">1</span><span class="sym">)</span>^ <span class="kwa">in</span> rx.cclass<span class="sym">)</span> <span class="kwa">and</span>
          <span class="kwd">str_eq</span><span class="sym">(</span>rx.left<span class="sym">,</span> found_at <span class="sym">-</span> remainder<span class="sym">)</span> <span class="kwa">then</span>
        <span class="kwa">begin</span>
          index <span class="sym">:=</span> found_at <span class="sym">-</span> remainder <span class="sym">- &#64;</span>str<span class="sym">[</span><span class="num">1</span><span class="sym">];</span>
          len <span class="sym">:=</span> rx.size<span class="sym">;</span>
          <span class="kwd">exit</span><span class="sym">(</span> <span class="kwb">true</span> <span class="sym">);</span>
        <span class="kwa">end</span>
        <span class="kwa">else</span>
          p <span class="sym">:=</span> found_at <span class="sym">+</span> <span class="num">1</span>
      <span class="kwa">else</span>
        <span class="kwd">exit</span><span class="sym">(</span> <span class="kwb">false</span> <span class="sym">);</span>
    <span class="kwa">end</span><span class="sym">;</span> <span class="slc">// while</span>
    <span class="kwd">exit</span><span class="sym">(</span> <span class="kwb">false</span> <span class="sym">)</span>
  <span class="kwa">end</span><span class="sym">;</span>

  <span class="kwa">while</span> p <span class="sym">&lt;</span> ceiling <span class="kwa">do</span>
  <span class="kwa">begin</span>
    found_at <span class="sym">:=</span> <span class="kwd">bm_search</span><span class="sym">(</span> rx.left<span class="sym">,</span> rx.skip<span class="sym">,</span> p<span class="sym">,</span> last_p <span class="sym">-</span> p <span class="sym">+</span> <span class="num">1</span><span class="sym">);</span>
    <span class="kwa">if</span> found_at <span class="sym">&lt;&gt;</span> <span class="kwa">nil then</span>
    <span class="kwa">begin</span>
      p <span class="sym">:=</span> found_at <span class="sym">+</span> <span class="kwd">length</span><span class="sym">(</span>rx.left<span class="sym">);</span>
      <span class="kwa">if</span> <span class="sym">(</span>p^ <span class="kwa">in</span> rx.cclass<span class="sym">)</span> <span class="kwa">and</span> <span class="kwd">str_eq</span><span class="sym">(</span> rx.right<span class="sym">,</span> p<span class="sym">+</span><span class="num">1</span> <span class="sym">)</span> <span class="kwa">then</span>
      <span class="kwa">begin</span>
        index <span class="sym">:=</span> found_at <span class="sym">- &#64;</span>str<span class="sym">[</span><span class="num">1</span><span class="sym">] +</span> <span class="num">1</span><span class="sym">;</span>
        <span class="kwd">exit</span><span class="sym">(</span> <span class="kwb">true</span> <span class="sym">);</span>
      <span class="kwa">end</span>
      <span class="kwa">else</span>
        p <span class="sym">:=</span> found_at <span class="sym">+</span> <span class="num">1</span><span class="sym">;</span>
    <span class="kwa">end</span>
    <span class="kwa">else</span>
      <span class="kwd">exit</span><span class="sym">(</span> <span class="kwb">false</span> <span class="sym">);</span>
  <span class="kwa">end</span><span class="sym">;</span>

  <span class="kwd">exit</span><span class="sym">(</span> <span class="kwb">false</span> <span class="sym">)</span>
<span class="kwa">end</span><span class="sym">;</span>



<span class="slc">// Append 2 strings to an ansistring rapidly.  Note: the ansistring's</span>
<span class="slc">// length will be increased by a more than sufficient amount.</span>
<span class="kwa">function</span> <span class="kwd">append2</span><span class="sym">(</span> <span class="kwa">var</span> dest<span class="sym">:</span> ansistring<span class="sym">;</span> len0<span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;</span>
                  s1<span class="sym">:</span> pchar<span class="sym">;</span> len1<span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;</span>
                  s2<span class="sym">:</span> pchar<span class="sym">;</span> len2<span class="sym">:</span> <span class="kwb">longint</span><span class="sym">):</span> <span class="kwb">longint</span><span class="sym">;</span> <span class="kwa">inline</span><span class="sym">;</span>
<span class="kwa">const</span>  quantum <span class="sym">=</span> <span class="num">599000</span><span class="sym">;</span>
<span class="kwa">var</span>  newlength<span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;</span>
<span class="kwa">begin</span>
  newlength <span class="sym">:=</span> len0 <span class="sym">+</span> len1 <span class="sym">+</span> len2<span class="sym">;</span>
  <span class="slc">// Since setlength() is somewhat costly, we'll do it less</span>
  <span class="slc">// often than you would think.</span>
  <span class="kwa">if</span> <span class="kwd">length</span><span class="sym">(</span> dest <span class="sym">) &lt;</span> newlength <span class="kwa">then</span>
    <span class="kwd">setlength</span><span class="sym">(</span> dest<span class="sym">,</span> newlength <span class="sym">+</span> quantum <span class="sym">);</span>
  <span class="kwd">move</span><span class="sym">(</span> s1^<span class="sym">,</span> dest<span class="sym">[</span>len0 <span class="sym">+</span> <span class="num">1</span><span class="sym">],</span> len1 <span class="sym">);</span>
  <span class="kwd">move</span><span class="sym">(</span> s2^<span class="sym">,</span> dest<span class="sym">[</span>len0 <span class="sym">+</span> <span class="num">1</span> <span class="sym">+</span> len1<span class="sym">],</span> len2 <span class="sym">);</span>
  <span class="kwd">exit</span><span class="sym">(</span> newlength <span class="sym">);</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">procedure</span> <span class="kwd">rx_gsub</span><span class="sym">(</span><span class="kwa">const</span> this<span class="sym">,</span> that<span class="sym">:</span> <span class="kwa">string</span><span class="sym">[</span><span class="num">255</span><span class="sym">];</span>
                  <span class="kwa">const</span> str<span class="sym">:</span> ansistring<span class="sym">;</span>  <span class="kwa">var</span> dest<span class="sym">:</span> ansistring <span class="sym">);</span>
<span class="kwa">var</span>
  engine <span class="sym">:</span> TRegexEngine<span class="sym">;</span>
  starti<span class="sym">,</span> index<span class="sym">,</span> foundsize<span class="sym">,</span> truelength<span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;</span>
  temp<span class="sym">:</span> <span class="kwa">string</span><span class="sym">[</span><span class="num">255</span><span class="sym">];</span>
<span class="kwa">begin</span>
  temp <span class="sym">:=</span> this <span class="sym">+</span> <span class="esc">#0</span><span class="sym">;</span>
  engine <span class="sym">:=</span> <span class="kwd">RegexCreate</span><span class="sym">( &#64;</span>temp<span class="sym">[</span><span class="num">1</span><span class="sym">] );</span>
  dest <span class="sym">:=</span> <span class="str">''</span><span class="sym">;</span>   truelength <span class="sym">:=</span> <span class="num">0</span><span class="sym">;</span>
  starti <span class="sym">:=</span> <span class="num">1</span><span class="sym">;</span>
  <span class="kwa">while</span> starti <span class="sym">&lt;=</span> <span class="kwd">length</span><span class="sym">(</span>str<span class="sym">)</span> <span class="kwa">do</span>
    <span class="kwa">if</span> <span class="kwd">Regex_search</span><span class="sym">(</span>engine<span class="sym">,</span> str<span class="sym">,</span> starti<span class="sym">,</span> index<span class="sym">,</span> foundsize<span class="sym">)</span> <span class="kwa">then</span>
    <span class="kwa">begin</span>
      truelength <span class="sym">:=</span> <span class="kwd">append2</span><span class="sym">(</span>
        dest<span class="sym">,</span> truelength<span class="sym">,  &#64;</span>str<span class="sym">[</span>starti<span class="sym">],</span> index<span class="sym">-</span>starti<span class="sym">,  &#64;</span>that<span class="sym">[</span><span class="num">1</span><span class="sym">],</span> <span class="kwd">length</span><span class="sym">(</span>that<span class="sym">) );</span>
      starti <span class="sym">:=</span> index <span class="sym">+</span> foundsize<span class="sym">;</span>
    <span class="kwa">end</span>
    <span class="kwa">else</span>
      break<span class="sym">;</span>
  <span class="kwd">setlength</span><span class="sym">(</span> dest<span class="sym">,</span> truelength <span class="sym">);</span>
  dest <span class="sym">:=</span> dest <span class="sym">+</span> <span class="kwd">Copy</span><span class="sym">(</span> str<span class="sym">,</span> starti<span class="sym">,</span> <span class="kwd">length</span><span class="sym">(</span>str<span class="sym">)-</span>starti<span class="sym">+</span><span class="num">1</span><span class="sym">);</span>
<span class="kwa">end</span><span class="sym">;</span>


<span class="kwa">procedure</span> <span class="kwd">replace_matches</span><span class="sym">(</span> <span class="kwa">const</span> str<span class="sym">:</span> ansistring<span class="sym">;</span>  <span class="kwa">var</span> dest<span class="sym">:</span> ansistring <span class="sym">);</span>
<span class="kwa">var</span>
  engine <span class="sym">:</span> TRegexEngine<span class="sym">;</span>
  starti<span class="sym">,</span> index<span class="sym">,</span> foundsize<span class="sym">,</span> truelength<span class="sym">,</span> i <span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;</span>
  target<span class="sym">,</span> repl<span class="sym">:</span> <span class="kwa">string</span><span class="sym">[</span><span class="num">255</span><span class="sym">];</span>
<span class="kwa">begin</span>
  <span class="slc">// Instead of looking for one letter at a time, lump them all</span>
  <span class="slc">// together in a character-class.</span>
  target <span class="sym">:=</span> <span class="str">'['</span><span class="sym">;</span>
  <span class="kwa">for</span> i <span class="sym">:=</span> <span class="num">0</span> <span class="kwa">to</span> <span class="kwd">high</span><span class="sym">(</span>replacements<span class="sym">)</span> <span class="kwa">do</span>
    target <span class="sym">+=</span> replacements<span class="sym">[</span>i<span class="sym">,</span><span class="num">0</span><span class="sym">];</span>
  target <span class="sym">+=</span> <span class="str">']'</span> <span class="sym">+</span> <span class="kwb">char</span><span class="sym">(</span><span class="num">0</span><span class="sym">);</span>
  engine <span class="sym">:=</span> <span class="kwd">RegexCreate</span><span class="sym">( &#64;</span>target<span class="sym">[</span><span class="num">1</span><span class="sym">] );</span>

  dest <span class="sym">:=</span> <span class="str">''</span><span class="sym">;</span>   truelength <span class="sym">:=</span> <span class="num">0</span><span class="sym">;</span>
  starti <span class="sym">:=</span> <span class="num">1</span><span class="sym">;</span>
  <span class="kwa">while</span> starti <span class="sym">&lt;=</span> <span class="kwd">length</span><span class="sym">(</span>str<span class="sym">)</span> <span class="kwa">do</span>
    <span class="kwa">if</span> <span class="kwd">Regex_search</span><span class="sym">(</span>engine<span class="sym">,</span> str<span class="sym">,</span> starti<span class="sym">,</span> index<span class="sym">,</span> foundsize<span class="sym">)</span> <span class="kwa">then</span>
    <span class="kwa">begin</span>
      repl <span class="sym">:=</span> replacements<span class="sym">[</span> <span class="kwd">pos</span><span class="sym">(</span> str<span class="sym">[</span>index<span class="sym">],</span> target<span class="sym">) -</span> <span class="num">2</span><span class="sym">,</span> <span class="num">1</span> <span class="sym">];</span>
      truelength <span class="sym">:=</span> <span class="kwd">append2</span><span class="sym">(</span>
        dest<span class="sym">,</span> truelength<span class="sym">,  &#64;</span>str<span class="sym">[</span>starti<span class="sym">],</span> index<span class="sym">-</span>starti<span class="sym">,  &#64;</span>repl<span class="sym">[</span><span class="num">1</span><span class="sym">],</span> <span class="kwd">length</span><span class="sym">(</span>repl<span class="sym">) );</span>
      starti <span class="sym">:=</span> index <span class="sym">+</span> engine.size<span class="sym">;</span>
    <span class="kwa">end</span>
    <span class="kwa">else</span>
      break<span class="sym">;</span>
  <span class="kwd">setlength</span><span class="sym">(</span> dest<span class="sym">,</span> truelength <span class="sym">);</span>
  dest <span class="sym">:=</span> dest <span class="sym">+</span> <span class="kwd">Copy</span><span class="sym">(</span> str<span class="sym">,</span> starti<span class="sym">,</span> <span class="kwd">length</span><span class="sym">(</span>str<span class="sym">)-</span>starti<span class="sym">+</span><span class="num">1</span><span class="sym">);</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">type</span> t_cc <span class="sym">=</span> <span class="kwa">set of</span> <span class="kwb">char</span><span class="sym">;</span>
<span class="kwa">function</span> <span class="kwd">cclass2str</span><span class="sym">(</span> cc<span class="sym">:</span> t_cc<span class="sym">):</span> <span class="kwa">string</span><span class="sym">;</span>
<span class="kwa">var</span>
  s<span class="sym">:</span> <span class="kwa">string</span><span class="sym">;</span>
  ch<span class="sym">:</span> <span class="kwb">char</span><span class="sym">;</span>
<span class="kwa">begin</span>
  s <span class="sym">:=</span> <span class="str">''</span><span class="sym">;</span>
  <span class="kwa">for</span> ch <span class="sym">:=</span> <span class="kwb">char</span><span class="sym">(</span><span class="num">32</span><span class="sym">)</span> <span class="kwa">to</span> <span class="kwb">char</span><span class="sym">(</span><span class="num">127</span><span class="sym">)</span> <span class="kwa">do</span>
    <span class="kwa">if</span> ch <span class="kwa">in</span> cc <span class="kwa">then</span>
      s <span class="sym">+=</span> ch<span class="sym">;</span>
  <span class="kwd">exit</span><span class="sym">(</span>s<span class="sym">)</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">function</span> <span class="kwd">count_matches_simple</span><span class="sym">(</span> pattern<span class="sym">:</span> pchar<span class="sym">;</span> <span class="kwa">const</span> str<span class="sym">:</span> ansistring <span class="sym">):</span> <span class="kwb">longint</span><span class="sym">;</span>
<span class="kwa">var</span>
  engine <span class="sym">:</span> TRegexEngine<span class="sym">;</span>
  start<span class="sym">,</span> ceiling<span class="sym">,</span> count<span class="sym">,</span> index<span class="sym">,</span> foundsize <span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;</span>
<span class="kwa">begin</span>
  engine <span class="sym">:=</span> <span class="kwd">RegexCreate</span><span class="sym">(</span> pattern <span class="sym">);</span>

  <span class="com">{</span>
<span class="com">  with engine do</span>
<span class="com">  begin</span>
<span class="com">    if pos('[', pattern) &gt; 0 then</span>
<span class="com">    begin</span>
<span class="com">      writeln('Pattern: ', pattern );</span>
<span class="com">      writeln('Left: ', left , '&lt;&lt;');</span>
<span class="com">      writeln('cclass: ', cclass2str( cclass ), '&lt;&lt;');</span>
<span class="com">      writeln('Right: ', right, '&lt;&lt;' );</span>
<span class="com">      writeln('Starred: ', starred, '&lt;&lt;' );</span>
<span class="com">      halt;</span>
<span class="com">    end;</span>
<span class="com">  end;</span>
<span class="com">  }</span>

  ceiling <span class="sym">:=</span> <span class="kwd">length</span><span class="sym">(</span>str<span class="sym">) -</span> engine.size <span class="sym">+</span> <span class="num">2</span><span class="sym">;</span>
  count <span class="sym">:=</span> <span class="num">0</span><span class="sym">;</span>
  start <span class="sym">:=</span> <span class="num">1</span><span class="sym">;</span>
  <span class="kwa">while</span> start <span class="sym">&lt;</span> ceiling <span class="kwa">do</span>
    <span class="kwa">if</span> <span class="kwd">Regex_search</span><span class="sym">(</span>engine<span class="sym">,</span> str<span class="sym">,</span> start<span class="sym">,</span> index<span class="sym">,</span> foundsize <span class="sym">)</span> <span class="kwa">then</span>
    <span class="kwa">begin</span>
      <span class="kwd">inc</span><span class="sym">(</span>count<span class="sym">);</span>
      <span class="slc">// start := index + engine.size;</span>
      start <span class="sym">:=</span> index <span class="sym">+</span> foundsize<span class="sym">;</span>
    <span class="kwa">end</span>
    <span class="kwa">else</span>
      break<span class="sym">;</span>

  <span class="kwd">exit</span><span class="sym">(</span>count<span class="sym">)</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">function</span> <span class="kwd">count_matches</span><span class="sym">(</span> pattern<span class="sym">:</span> <span class="kwa">string</span><span class="sym">[</span><span class="num">255</span><span class="sym">];</span> <span class="kwa">const</span> str<span class="sym">:</span> ansistring <span class="sym">):</span> <span class="kwb">longint</span><span class="sym">;</span>
<span class="kwa">var</span>
  count<span class="sym">,</span> p<span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;</span>
<span class="kwa">begin</span>
  pattern <span class="sym">+=</span> <span class="kwb">char</span><span class="sym">(</span><span class="num">0</span><span class="sym">);</span>
  p <span class="sym">:=</span> <span class="kwd">pos</span><span class="sym">(</span> <span class="str">'|'</span><span class="sym">,</span> pattern <span class="sym">);</span>
  pattern<span class="sym">[</span>p<span class="sym">] :=</span> <span class="kwb">char</span><span class="sym">(</span><span class="num">0</span><span class="sym">);</span>
  count <span class="sym">:=</span> <span class="kwd">count_matches_simple</span><span class="sym">( &#64;</span>pattern<span class="sym">[</span><span class="num">1</span><span class="sym">],</span> str <span class="sym">);</span>
  count <span class="sym">+=</span> <span class="kwd">count_matches_simple</span><span class="sym">( &#64;</span>pattern<span class="sym">[</span>p<span class="sym">+</span><span class="num">1</span><span class="sym">],</span> str <span class="sym">);</span>
  <span class="kwd">exit</span><span class="sym">(</span> count <span class="sym">)</span>
<span class="kwa">end</span><span class="sym">;</span>


<span class="kwa">var</span>
  dirty_sequence<span class="sym">,</span> sequence<span class="sym">,</span> new_seq<span class="sym">,</span> temp <span class="sym">:</span> ansiString<span class="sym">;</span>
  line<span class="sym">,</span> linefeed<span class="sym">:</span> <span class="kwa">string</span><span class="sym">[</span><span class="num">255</span><span class="sym">];</span>
  truelength<span class="sym">,</span> i<span class="sym">,</span> count<span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;</span>
  inbuf <span class="sym">:</span> <span class="kwa">array</span><span class="sym">[</span><span class="num">1</span>.<span class="num">.64</span><span class="sym">*</span><span class="num">1024</span><span class="sym">]</span> <span class="kwa">of</span> <span class="kwb">char</span><span class="sym">;</span>

<span class="kwa">begin</span>
  <span class="kwd">settextbuf</span><span class="sym">(</span>input<span class="sym">,</span> inbuf<span class="sym">);</span>
  linefeed <span class="sym">:=</span> <span class="esc">#1</span>0<span class="sym">;</span>
  dirty_sequence <span class="sym">:=</span> <span class="str">''</span><span class="sym">;</span>
  truelength <span class="sym">:=</span> <span class="num">0</span><span class="sym">;</span>
  <span class="kwa">while not</span> eof <span class="kwa">do</span>
  <span class="kwa">begin</span>
    <span class="kwd">readln</span><span class="sym">(</span> line <span class="sym">);</span>
    truelength <span class="sym">:=</span> <span class="kwd">append2</span><span class="sym">(</span>dirty_sequence<span class="sym">,</span>truelength<span class="sym">,</span>
        <span class="sym">&#64;</span>line<span class="sym">[</span><span class="num">1</span><span class="sym">],</span><span class="kwd">length</span><span class="sym">(</span>line<span class="sym">), &#64;</span>linefeed<span class="sym">[</span><span class="num">1</span><span class="sym">],</span><span class="num">1</span><span class="sym">);</span>
  <span class="kwa">end</span><span class="sym">;</span>
  <span class="kwd">setlength</span><span class="sym">(</span> dirty_sequence<span class="sym">,</span> truelength <span class="sym">);</span>

  <span class="kwd">rx_gsub</span><span class="sym">(</span> <span class="str">'&gt;.*'</span> <span class="sym">+</span> linefeed<span class="sym">,</span> <span class="str">''</span><span class="sym">,</span> dirty_sequence<span class="sym">,</span> temp <span class="sym">);</span>
  <span class="kwd">rx_gsub</span><span class="sym">(</span> linefeed<span class="sym">,</span> <span class="str">''</span><span class="sym">,</span> temp<span class="sym">,</span> sequence <span class="sym">);</span>


  <span class="slc">// Count pattern-matches.</span>
  temp <span class="sym">:=</span> <span class="kwd">lowercase</span><span class="sym">(</span> sequence <span class="sym">);</span>
  <span class="kwa">for</span> i <span class="sym">:=</span> <span class="kwd">low</span><span class="sym">(</span>patterns<span class="sym">)</span> <span class="kwa">to</span> <span class="kwd">high</span><span class="sym">(</span>patterns<span class="sym">)</span> <span class="kwa">do</span>
  <span class="kwa">begin</span>
    count <span class="sym">:=</span> <span class="kwd">count_matches</span><span class="sym">(</span> patterns<span class="sym">[</span>i<span class="sym">],</span> temp <span class="sym">);</span>
    <span class="kwd">writeln</span><span class="sym">(</span> patterns<span class="sym">[</span>i<span class="sym">],</span> <span class="str">' '</span><span class="sym">,</span> count<span class="sym">);</span>
  <span class="kwa">end</span><span class="sym">;</span>


  <span class="slc">//  Replace.</span>
  <span class="kwd">replace_matches</span><span class="sym">(</span>sequence<span class="sym">,</span> new_seq<span class="sym">);</span>


  writeln<span class="sym">;</span>
  <span class="kwd">writeln</span><span class="sym">(</span> <span class="kwd">length</span><span class="sym">(</span> dirty_sequence <span class="sym">) );</span>
  <span class="kwd">writeln</span><span class="sym">(</span> <span class="kwd">length</span><span class="sym">(</span> sequence <span class="sym">) );</span>
  <span class="kwd">writeln</span><span class="sym">(</span> <span class="kwd">length</span><span class="sym">(</span>new_seq<span class="sym">) );</span>
<span class="kwa">end</span>.
