<span class="slc">;;; -*- mode: lisp -*-
</span><span class="slc">;;; $Id: echo-poplisp.code,v 1.6 2005-05-12 02:35:49 bfulgham Exp $
</span><span class="slc">;;; http://shootout.alioth.debian.org/
</span><span class="slc">;;; from Bulent Murtezaogl
</span>
<span class="slc">;(in-package &quot;UNIX&quot;)
</span><span class="sym">(</span><span class="kwa">defun</span> unix<span class="sym">-</span>wait <span class="sym">()
</span>  <span class="str">&quot;Wait for a child to die. We don't care about the status&quot;</span>
  <span class="sym">(</span>int<span class="sym">-</span>syscall <span class="sym">(</span><span class="str">&quot;wait&quot;</span> <span class="sym">(*</span> int<span class="sym">))</span> nil<span class="sym">))</span> <span class="slc">;;  is lisp nil == C NULL ?? Dunno.
</span><span class="sym">(</span>in<span class="sym">-</span>package <span class="str">&quot;USER&quot;</span><span class="sym">)


(</span>define<span class="sym">-</span>condition sigpipe<span class="sym">)

(</span><span class="kwa">defun</span> ih<span class="sym">-</span>sigpipe <span class="sym">(</span>signal code scp<span class="sym">)
  (</span>declare <span class="sym">(</span>ignore signal code scp<span class="sym">))
  (</span>signal <span class="str">'sigpipe))

(defun error-return (str)
  (format *standard-output* &quot;Error: ~s ~%&quot; str)
  (quit))

(defun echo-client (port iter)
  (declare (fixnum iter))
  (let* ((stream (sys:make-fd-stream
		  (ext:connect-to-inet-socket &quot;127.0.0.1&quot; port)
		  :output t :input t :buffering :line))
	 (estr &quot;Hello there sailor
&quot;)
	   (len (length estr))
	   (buffer (make-string len)))
    (dotimes (i iter)
      (declare (fixnum i len) (simple-base-string buffer)
	       (inline write-sequence sys:read-n-bytes string=))
      (write-sequence estr stream :start 0 :end len )
      (sys:read-n-bytes stream buffer 0 len nil)
      (unless (string= estr buffer)
	(format t &quot;client did not receive what it sent ~%&quot;)))))

  (let ((lsock (ext:create-inet-listener 0))
	(n (parse-integer (or (car pop11::poparglist) &quot;1&quot;))))
    (multiple-value-bind (host port) (get-socket-host-and-port lsock)
      (declare (ignore host))
      (let ((fork-res (unix:unix-fork)))
	(if fork-res
	    (if (zerop fork-res)
		(echo-client port n)
	      (let ((stream (sys:make-fd-stream
			     (ext:accept-tcp-connection lsock)
			     :output t :input t :buffering :line))
		    (buffer (make-string 64))
		    (insize 0)
		    (sum 0))
		(declare (fixnum insize sum))
		(sys:enable-interrupt UNIX:sigpipe #'</span>ih<span class="sym">-</span>sigpipe<span class="sym">)
		(</span>handler<span class="sym">-</span>case
		    <span class="sym">(</span><span class="kwa">progn
</span>		      <span class="sym">(</span>loop <span class="slc">;; loop seems to chew up my declarations!?
</span>			<span class="kwa">while</span> <span class="sym">(</span><span class="kwa">not</span> <span class="sym">(</span><span class="kwa">zerop</span> <span class="sym">(</span>setf <span class="sym">(</span>the fixnum insize<span class="sym">)
						(</span>the fixnum <span class="sym">(</span>sys<span class="sym">:</span><span class="kwa">read</span><span class="sym">-</span>n<span class="sym">-</span>bytes stream buffer <span class="num">0 64</span> nil<span class="sym">)))))
</span>			do <span class="sym">(</span>write<span class="sym">-</span>sequence buffer stream <span class="sym">:</span>start <span class="num">0</span> <span class="sym">:</span>end insize<span class="sym">)
			(</span>incf sum insize<span class="sym">))
		      (</span>unix<span class="sym">::</span>unix<span class="sym">-</span>wait<span class="sym">)
		      (</span>format t <span class="str">&quot;server processed ~D bytes~%&quot;</span> sum<span class="sym">))
		  (</span>sigpipe <span class="sym">(</span>foo<span class="sym">) (</span>declare <span class="sym">(</span>ignore foo<span class="sym">)) (</span>error<span class="sym">-</span>return <span class="str">&quot;Kid died prematurely&quot;</span><span class="sym">))</span> <span class="slc">;; as good as catching sigchild for this app
</span>		  <span class="sym">(</span>end<span class="sym">-</span>of<span class="sym">-</span>file <span class="sym">(</span>foo<span class="sym">) (</span>declare <span class="sym">(</span>ignore foo<span class="sym">))(</span>error<span class="sym">-</span>return <span class="str">&quot;EOF signalled.  Huh???&quot;</span><span class="sym">)))))))))</span>
