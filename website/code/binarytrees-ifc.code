<span class="slc">! -*- mode: f90 -*-
</span><span class="slc">!
</span><span class="slc">! $Id: binarytrees-ifc.code,v 1.1 2005-06-12 23:15:12 bfulgham Exp $ ; $Name:  $
</span><span class="slc">!
</span><span class="slc">! The Great Computer Language Shootout
</span><span class="slc">! http://shootout.alioth.debian.org/
</span><span class="slc">!
</span><span class="slc">! contributed by Simon Geard, 2005; translated from binarytrees.python by Kevin Carson
</span><span class="slc">!
</span><span class="slc">! Compile: ifort -O3 -u -static-libcxa -o binarytrees binarytrees.f90
</span><span class="slc">!
</span>module binaryTree
  <span class="slc">!
</span>  <span class="slc">! Tree data structure
</span>  type Tree
     integer             <span class="sym">::</span> data
     type<span class="sym">(</span>Tree<span class="sym">),</span> pointer <span class="sym">::</span> left <span class="sym">=&gt;</span> null<span class="sym">()
</span>     type<span class="sym">(</span>Tree<span class="sym">),</span> pointer <span class="sym">::</span> right <span class="sym">=&gt;</span> null<span class="sym">()
</span>  end type Tree

  interface assignment<span class="sym">(=)
</span>     module procedure equals_t_t
  end interface
contains

  recursive subroutine equals_t_t<span class="sym">(</span>t2<span class="sym">,</span> t1<span class="sym">)
</span>    type<span class="sym">(</span>Tree<span class="sym">),</span> intent<span class="sym">(</span>out<span class="sym">) ::</span> t2
    type<span class="sym">(</span>Tree<span class="sym">),</span> intent<span class="sym">(</span>in<span class="sym">)  ::</span> t1
    <span class="slc">!print *,'equals_t_t'
</span>    t2<span class="sym">%</span>data <span class="sym">=</span> t1<span class="sym">%</span>data
    if <span class="sym">(</span>.not. associated<span class="sym">(</span>t2<span class="sym">%</span>left<span class="sym">))</span> then
       allocate<span class="sym">(</span>t2<span class="sym">%</span>left<span class="sym">)
</span>    end if
    t2<span class="sym">%</span>left <span class="sym">=&gt;</span> t1<span class="sym">%</span>left

    if <span class="sym">(</span>associated<span class="sym">(</span>t2<span class="sym">%</span>right<span class="sym">))</span> then
       allocate<span class="sym">(</span>t2<span class="sym">%</span>right<span class="sym">)
</span>    end if
    t2<span class="sym">%</span>right <span class="sym">=&gt;</span> t1<span class="sym">%</span>right

  end subroutine equals_t_t

  <span class="slc">! Initialize tree nodes
</span>  type<span class="sym">(</span>Tree<span class="sym">)</span> function init<span class="sym">(</span>left<span class="sym">,</span> right<span class="sym">,</span> item<span class="sym">)</span> result<span class="sym">(</span>t<span class="sym">)
</span>    type<span class="sym">(</span>Tree<span class="sym">),</span> intent<span class="sym">(</span>in<span class="sym">)    ::</span> left<span class="sym">,</span> right
    integer<span class="sym">,</span> intent<span class="sym">(</span>in<span class="sym">)       ::</span> item
    t<span class="sym">%</span>data <span class="sym">=</span> item
    allocate<span class="sym">(</span>t<span class="sym">%</span>left<span class="sym">)
</span>    t<span class="sym">%</span>left <span class="sym">=</span> left
    allocate<span class="sym">(</span>t<span class="sym">%</span>right<span class="sym">)
</span>    t<span class="sym">%</span>right <span class="sym">=</span> right
  end function init

  recursive function BottomUpTree<span class="sym">(</span>item<span class="sym">,</span> depth<span class="sym">)</span> result<span class="sym">(</span>bu<span class="sym">)
</span>    type<span class="sym">(</span>Tree<span class="sym">)          ::</span> bu
    integer<span class="sym">,</span> intent<span class="sym">(</span>in<span class="sym">) ::</span> item
    integer<span class="sym">,</span> intent<span class="sym">(</span>in<span class="sym">) ::</span> depth
    integer <span class="sym">::</span> item_item
    <span class="slc">!print *,depth
</span>    if <span class="sym">(</span>depth <span class="sym">&gt;</span> <span class="num">0</span><span class="sym">)</span> then
       item_item <span class="sym">=</span> <span class="num">2</span><span class="sym">*</span>item
       bu <span class="sym">=</span> init<span class="sym">(</span>BottomUpTree<span class="sym">(</span>item_item <span class="num">- 1</span><span class="sym">,</span> depth<span class="num">-1</span><span class="sym">), &amp;
</span>            BottomUpTree<span class="sym">(</span>item_item<span class="sym">,</span> depth<span class="num">-1</span><span class="sym">), &amp;
</span>            item<span class="sym">)

</span>    else
       bu <span class="sym">=</span> init<span class="sym">(</span>null<span class="sym">(),</span>null<span class="sym">(),</span>item<span class="sym">)
</span>    end if
  end function BottomUpTree

  recursive function ItemCheck<span class="sym">(</span>t<span class="sym">)</span> result<span class="sym">(</span>ic<span class="sym">)
</span>    integer ic
    type<span class="sym">(</span>Tree<span class="sym">),</span> intent<span class="sym">(</span>in<span class="sym">) ::</span> t

    if <span class="sym">(</span>.not. associated<span class="sym">(</span>t<span class="sym">%</span>left<span class="sym">))</span> then
       ic <span class="sym">=</span> t<span class="sym">%</span>data
    else
       ic <span class="sym">=</span> t<span class="sym">%</span>data <span class="sym">+</span> ItemCheck<span class="sym">(</span>t<span class="sym">%</span>left<span class="sym">) -</span> ItemCheck<span class="sym">(</span>t<span class="sym">%</span>right<span class="sym">)
</span>    end if
  end function ItemCheck

  <span class="slc">! Free all allocated memory
</span>  recursive subroutine tidy<span class="sym">(</span>t<span class="sym">)
</span>    type<span class="sym">(</span>Tree<span class="sym">),</span> intent<span class="sym">(</span>inout<span class="sym">) ::</span> t

    if <span class="sym">(</span>associated<span class="sym">(</span>t<span class="sym">%</span>left<span class="sym">))</span> then
       call tidy<span class="sym">(</span>t<span class="sym">%</span>left<span class="sym">)
</span>    end if
    deallocate<span class="sym">(</span>t<span class="sym">%</span>left<span class="sym">)
</span>    if <span class="sym">(</span>associated<span class="sym">(</span>t<span class="sym">%</span>right<span class="sym">))</span> then
       call tidy<span class="sym">(</span>t<span class="sym">%</span>right<span class="sym">)
</span>    end if
    deallocate<span class="sym">(</span>t<span class="sym">%</span>right<span class="sym">)
</span>  end subroutine tidy

<span class="slc">!!$  recursive subroutine print(level, x, t)
</span><span class="slc">!!$    ! Debugging code to examine the scene tree
</span><span class="slc">!!$    integer, intent(in)    :: level
</span><span class="slc">!!$    integer, intent(in)    :: x
</span><span class="slc">!!$    type(Tree), intent(in) :: t
</span><span class="slc">!!$    integer:: i
</span><span class="slc">!!$    write(*,'(i0,a,i0,a,4f10.4)') level,' - ',x,': ',t%data%radius,(t%data%centre(i),i=1,3)
</span><span class="slc">!!$    if (.not. associated(t%children)) then
</span><span class="slc">!!$       return
</span><span class="slc">!!$    end if
</span><span class="slc">!!$    do i=1,t%num_children
</span><span class="slc">!!$       call print(level+1,i,t%children(i))
</span><span class="slc">!!$    end do
</span><span class="slc">!!$  end subroutine print
</span>
end module binaryTree

<span class="slc">! The program itself
</span>program bTrees
  use binaryTree

  integer    <span class="sym">::</span> N<span class="sym">,</span> minDepth<span class="sym">,</span> maxDepth<span class="sym">,</span> stretchDepth<span class="sym">,</span> depth<span class="sym">,</span> iterations<span class="sym">,</span> i<span class="sym">,</span> check
  type<span class="sym">(</span>Tree<span class="sym">) ::</span> stretchTree<span class="sym">,</span> longLivedTree<span class="sym">,</span> tempTree
  character<span class="sym">(</span>len<span class="sym">=</span><span class="num">3</span><span class="sym">)</span> argv

  call getarg<span class="sym">(</span><span class="num">1</span><span class="sym">,</span>argv<span class="sym">)
</span>  read<span class="sym">(</span>argv<span class="sym">,*)</span> N

  minDepth <span class="sym">=</span> <span class="num">4

</span>  if <span class="sym">(</span>minDepth <span class="sym">+</span> <span class="num">2</span><span class="sym">&gt;</span> N<span class="sym">)</span> then
     maxDepth <span class="sym">=</span> minDepth <span class="sym">+</span> <span class="num">2
</span>  else
     maxDepth <span class="sym">=</span> N
  end if

  stretchDepth <span class="sym">=</span> maxDepth <span class="sym">+</span> <span class="num">1
</span>  stretchTree <span class="sym">=</span> BottomUpTree<span class="sym">(</span><span class="num">0</span><span class="sym">,</span> stretchDepth<span class="sym">)
</span>  write<span class="sym">(*,</span><span class="str">'(a,i0,a,i0)'</span><span class="sym">)</span> <span class="str">'stretch tree of depth '</span><span class="sym">,</span>stretchDepth<span class="sym">,</span>achar<span class="sym">(</span><span class="num">9</span><span class="sym">)//</span><span class="str">' check: '</span><span class="sym">,</span>ItemCheck<span class="sym">(</span>stretchTree<span class="sym">)

</span>  longLivedTree <span class="sym">=</span> BottomUpTree<span class="sym">(</span><span class="num">0</span><span class="sym">,</span> maxDepth<span class="sym">)

</span>  do depth <span class="sym">=</span> minDepth<span class="sym">,</span> maxDepth <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> <span class="num">2
</span>     iterations <span class="sym">=</span> <span class="num">2</span><span class="sym">**(</span>maxDepth <span class="sym">-</span> depth <span class="sym">+</span> minDepth<span class="sym">)
</span>     check <span class="sym">=</span> <span class="num">0

</span>     do i<span class="sym">=</span><span class="num">1</span><span class="sym">,</span> iterations
        tempTree <span class="sym">=</span> BottomUpTree<span class="sym">(</span>i<span class="sym">,</span> depth<span class="sym">)
</span>        check <span class="sym">=</span> check <span class="sym">+</span> ItemCheck<span class="sym">(</span>tempTree<span class="sym">)

</span>        tempTree <span class="sym">=</span> BottomUpTree<span class="sym">(-</span>i<span class="sym">,</span> depth<span class="sym">)
</span>        check <span class="sym">=</span> check <span class="sym">+</span> ItemCheck<span class="sym">(</span>tempTree<span class="sym">)

</span>     end do
     write<span class="sym">(*,</span><span class="str">'(i0,a,i0,a,i0)'</span><span class="sym">)</span> iterations <span class="sym">*</span> <span class="num">2</span><span class="sym">,</span>achar<span class="sym">(</span><span class="num">9</span><span class="sym">)//</span><span class="str">' trees of depth '</span><span class="sym">,</span>depth<span class="sym">,</span>achar<span class="sym">(</span><span class="num">9</span><span class="sym">)//</span><span class="str">' check: '</span><span class="sym">,</span>check
  end do
  write<span class="sym">(*,</span><span class="str">'(a,i0,a,i0)'</span><span class="sym">)</span> <span class="str">'long lived tree of depth '</span><span class="sym">,</span>maxDepth<span class="sym">,</span>achar<span class="sym">(</span><span class="num">9</span><span class="sym">)//</span><span class="str">' check: '</span><span class="sym">,</span>ItemCheck<span class="sym">(</span>longLivedTree<span class="sym">)

</span>end program bTrees
