\ <span class="sym">-*-</span> mode<span class="sym">:</span> forth <span class="sym">-*-
</span>\ $Id<span class="sym">:</span> regexmatch<span class="sym">-</span>gforth<span class="sym">.</span>code<span class="sym">,</span>v <span class="num">1.2 2004</span><span class="sym">/</span><span class="num">11</span><span class="sym">/</span><span class="num">08 08</span><span class="sym">:</span><span class="num">15</span><span class="sym">:</span><span class="num">19</span> bfulgham Exp $
\ http<span class="sym">:</span><span class="slc">//www.bagley.org/~doug/shootout/
</span>
\ from Anton Ertl<span class="sym">,</span> fixes by Ian Osgood<span class="sym">:
</span>\ <span class="kwa">this</span> uses the Gray parser generator<span class="sym">,</span> which is probably too big a
\ cannon <span class="kwa">for this</span> problem <span class="sym">(</span>it also needs a lot of setup code<span class="sym">).
</span>\ Writing a recursive descent parser by hand is probably both smaller
\ <span class="kwa">and</span> faster in <span class="kwa">this case</span><span class="sym">.


</span><span class="num">0</span><span class="sym">.</span> argc &#64; <span class="num">1</span><span class="sym">-</span> arg <span class="sym">&gt;</span>number <span class="num">2d</span>rop drop constant NUM

warnings off \ Gray is a little wordy

require gray<span class="sym">.</span>fs

<span class="sym">:</span> bit<span class="sym">-</span>equiv <span class="sym">(</span> w1 w2 <span class="sym">--</span> w3 <span class="sym">)
</span>    \ w3<span class="sym">=~</span>w1^w2
    invert <span class="kwa">xor</span> <span class="sym">;

:</span> set<span class="sym">-</span>complement <span class="sym">(</span> set1 <span class="sym">--</span> set2 <span class="sym">)
</span>    empty <span class="sym">[</span><span class="str">'] bit-equiv binary-set-operation ;

variable input</span> <span class="esc">\ </span><span class="str">pointer to next character to be scanned
variable end-input</span> <span class="esc">\ </span><span class="str">pointer to end of input
-1 constant eof-char

: start ( -- addr )
    input &#64; ;

: end ( addr -- addr u )
    input &#64; over - ;

: get-input ( -- c )
    start end-input &#64; = if
        eof-char
    else
        start c&#64;
    endif ;

256 max-member
s&quot; scan failed&quot; exception constant scanfail

: ?nextchar ( f -- )
    0= scanfail and throw
    1 chars input +! ;

: testchar? ( set -- f )
    get-input member? ;
'</span> testchar? test<span class="sym">-</span>vector <span class="sym">!

: .. (</span> c1 c2 <span class="sym">--</span> set <span class="sym">)
 (</span> creates a set that includes the characters c<span class="sym">,</span> c1<span class="sym">&lt;=</span>c<span class="sym">&lt;=</span>c2 <span class="sym">)
</span> empty copy<span class="sym">-</span>set
 swap <span class="num">1</span><span class="sym">+</span> rot <span class="kwa">do
</span>  i over add<span class="sym">-</span>member
 loop <span class="sym">;

:</span> ` <span class="sym">(</span> <span class="str">&quot;c&quot;</span> <span class="sym">--</span> terminal <span class="sym">)
</span>    \ creates anonymous terminal <span class="kwa">for</span> the character c <span class="sym">)
</span>    <span class="kwb">char</span> singleton <span class="sym">[</span><span class="str">'] ?nextchar make-terminal ;

char 0 char 9 .. dup  '</span> ?nextchar  terminal digit
set<span class="sym">-</span>complement        <span class="str">' ?nextchar  terminal nondigit
bl singleton          '</span> ?nextchar  terminal lspace

<span class="num">2</span>variable areacode
<span class="num">2</span>variable exchange
<span class="num">2</span>variable last4

<span class="sym">(( {{</span> start <span class="sym">}}</span> digit digit digit <span class="sym">{{</span> end areacode <span class="num">2</span><span class="sym">! }} ))
&lt;-</span> area<span class="sym">-</span>code

<span class="sym">(( ((</span> ` <span class="sym">(</span> area<span class="sym">-</span>code ` <span class="sym">) ||</span> area<span class="sym">-</span>code <span class="sym">))
</span>   lspace <span class="sym">{{</span> start <span class="sym">}}</span> digit digit digit <span class="sym">{{</span> end exchange <span class="num">2</span><span class="sym">! }}
   ((</span> lspace <span class="sym">||</span> ` <span class="sym">- ))
   {{</span> start <span class="sym">}}</span> digit digit digit digit <span class="sym">{{</span> end last4 <span class="num">2</span><span class="sym">! }}
</span>   nondigit
<span class="sym">)) &lt;-</span> telnum <span class="sym">( -- )

</span>telnum parser scan<span class="sym">-</span>telnum <span class="sym">( -- )

:</span> scan<span class="sym">-</span><span class="kwa">for</span><span class="sym">-</span>nondigit <span class="sym">(</span> addr1 <span class="sym">--</span> addr2 <span class="sym">)
</span>    begin
        count <span class="sym">(</span> c&#64;<span class="sym">+ ) &gt;</span>r
        r&#64; <span class="str">'0 &lt; r&#64; '</span><span class="num">9</span> <span class="sym">&gt;</span> <span class="kwa">or</span>  r<span class="sym">&gt;</span> <span class="str">'( &lt;&gt;  and
        over end-input &#64; u&gt;= or
    until ;

variable count  0 count !

defer on-match  '</span> noop is on<span class="sym">-</span>match

<span class="sym">:</span> output<span class="sym">-</span>match <span class="sym">( -- )
</span>    <span class="num">1</span> count <span class="sym">+!</span> count &#64; <span class="num">1</span> u<span class="sym">.</span>r <span class="sym">.</span><span class="str">&quot; : &quot;</span>
    <span class="sym">.</span><span class="str">&quot; (&quot;</span> areacode <span class="num">2</span>&#64; type <span class="sym">.</span><span class="str">&quot; ) &quot;</span> exchange <span class="num">2</span>&#64; type <span class="sym">.</span><span class="str">&quot; -&quot;</span> last4 <span class="num">2</span>&#64; type cr <span class="sym">;

:</span> scanfile <span class="sym">(</span> addr u <span class="sym">-- )
</span>    over <span class="sym">+</span> end<span class="sym">-</span>input <span class="sym">!
</span>    begin <span class="sym">(</span> addr1 <span class="sym">)
</span>        dup input <span class="sym">!
        [</span><span class="str">'] scan-telnum catch
        dup dup scanfail &lt;&gt; and throw
        if ( addr1 )
            scan-for-nondigit
        else
            on-match
            end-input &#64; over - #lf scan drop</span> <span class="esc">\ </span><span class="str">skip rest of line
        endif
        dup end-input &#64; u&gt;=
    until
    drop ;

: mainloop ( addr u -- )
    NUM 1 +do
        2dup scanfile
    loop
    ['</span><span class="sym">]</span> output<span class="sym">-</span>match <span class="sym">[</span>is<span class="sym">]</span> on<span class="sym">-</span>match
    scanfile <span class="sym">;

</span>stdin slurp<span class="sym">-</span>fid mainloop bye

