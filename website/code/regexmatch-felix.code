<table width="100%" border="0" cellpadding="5" cellspacing="0"><tr><td bgcolor="#FFFFFF"><pre>
<I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Contributed by John Skaller
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I>include <B><FONT COLOR="#BC8F8F">&quot;std&quot;</FONT></B>;
n := atoi(System::argv 1);

open Lexer;

regexp digit = [<B><FONT COLOR="#BC8F8F">&quot;0123456789&quot;</FONT></B>];
regexp digits3 = digit digit digit;
regexp digits4 =  digits3 digit;

regexp area_code = digits3 | <B><FONT COLOR="#BC8F8F">&quot;(&quot;</FONT></B> digits3 <B><FONT COLOR="#BC8F8F">&quot;)&quot;</FONT></B>;
regexp exchange = digits3;

regexp phone = area_code <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> exchange (<B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> | <B><FONT COLOR="#BC8F8F">&quot;-&quot;</FONT></B>) digits4;

<I><FONT COLOR="#B22222">// Felix, like Python, provides no literals of char type
</FONT></I>zero := ord(<B><FONT COLOR="#BC8F8F">&quot;0&quot;</FONT></B>.[0]);
nine := ord(<B><FONT COLOR="#BC8F8F">&quot;9&quot;</FONT></B>.[0]);

<I><FONT COLOR="#B22222">// Felix regular matching currently only supports
</FONT></I><I><FONT COLOR="#B22222">// actual regular sets of strings -- it does not support
</FONT></I><I><FONT COLOR="#B22222">// lookback or lookahead because they're not regular
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// So we have to hand code the context check.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I>fun <B><FONT COLOR="#0000FF">check_context</FONT></B>(start: iterator, finish: iterator): string =
{
  prior :=  ord(deref(start-1));
  next := ord(deref(finish));
  <B><FONT COLOR="#A020F0">return</FONT></B>
    <B><FONT COLOR="#A020F0">if</FONT></B> zero &lt;= prior &amp;&lt;= nine
    or zero &lt;= next &amp;&lt;= nine
    then <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>
    <B><FONT COLOR="#A020F0">else</FONT></B> string_between(start, finish)
    endif
  ;
}

<I><FONT COLOR="#B22222">// this is the actual lexer function
</FONT></I>fun <B><FONT COLOR="#0000FF">lexit</FONT></B> (start:iterator, finish:iterator): iterator * string =&gt;
  reglex start to finish with
  | phone =&gt; check_context (lexeme_start, lexeme_end)
  | _ =&gt; <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>
  endmatch
;

<I><FONT COLOR="#B22222">// hack so context_check won't crash (pre- and append space)
</FONT></I><I><FONT COLOR="#B22222">//val data = &quot; &quot; + Text_file::load(Text_file::stdin)+&quot; &quot;;
</FONT></I>val data = <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> + Text_file::load(<B><FONT COLOR="#BC8F8F">&quot;bagley/data/phone_numbers.data&quot;</FONT></B>)+<B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
first := Lexer::start_iterator data;
finish := Lexer::end_iterator data;


var i=n;
var current: iterator;
var s: string;
whilst i&gt;1 <B><FONT COLOR="#A020F0">do</FONT></B>
  current = first;
  until current == finish <B><FONT COLOR="#A020F0">do</FONT></B>
    def current, s = lexit(current, finish);
  done;
  --i;
done;

proc <B><FONT COLOR="#0000FF">print_phone</FONT></B>(x:string, j:<B><FONT COLOR="#228B22">int</FONT></B>) {
  n := len x;
  var s = <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>;
  var i = 0;
  whilst i&lt;n <B><FONT COLOR="#A020F0">do</FONT></B>
    <B><FONT COLOR="#A020F0">if</FONT></B> zero &lt;= ord(x.[i]) &amp;&lt;= nine <B><FONT COLOR="#A020F0">do</FONT></B>
      s = s + ord(x.[i]);
    done;
    ++i;
  done;
  print j; print <B><FONT COLOR="#BC8F8F">&quot;: &quot;</FONT></B>;
  print (<B><FONT COLOR="#BC8F8F">&quot;(&quot;</FONT></B>+s.[0 to 3]+<B><FONT COLOR="#BC8F8F">&quot;) &quot;</FONT></B>+s.[3 to 6]+<B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>+s.[6 to 10]); endl;
}

current = first;
var j = 0;
until current == finish <B><FONT COLOR="#A020F0">do</FONT></B>
 def current, s = lexit(current, finish);
 <B><FONT COLOR="#A020F0">if</FONT></B> s != <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B> <B><FONT COLOR="#A020F0">do</FONT></B>  ++j; print_phone (s,j); done;
done;
</pre></td></tr></table>
