<span class="com">(* -*- mode: sml -*-</span>
<span class="com"> * $Id: regexmatch-mlton.code,v 1.11 2006-09-20 05:52:30 bfulgham Exp $</span>
<span class="com"> * http://www.bagley.org/~doug/shootout/</span>
<span class="com"> * from Stephen Weeks</span>
<span class="com"> *)</span>

<span class="kwa">fun</span> <span class="sym">++ (</span>r<span class="sym">:</span> <span class="kwb">int</span> ref<span class="sym">):</span> <span class="kwb">int</span> <span class="sym">=</span>
   <span class="kwa">let</span>
      <span class="kwa">val</span> n <span class="sym">=</span> <span class="num">1</span> <span class="sym">+ !</span>r
      <span class="kwa">val</span> _ <span class="sym">=</span> r <span class="sym">:=</span> n
   <span class="kwa">in</span> n
   <span class="kwa">end</span>

<span class="kwa">structure Int</span> <span class="sym">=</span>
   <span class="kwa">struct</span>
      <span class="kwa">open Int</span>

      <span class="kwa">type</span> t <span class="sym">=</span> <span class="kwb">int</span>


   <span class="kwa">end</span>

<span class="kwa">structure</span> Array2 <span class="sym">=</span>
   <span class="kwa">struct</span>
      <span class="kwa">open</span> Array2

      <span class="kwa">type</span> 'a t <span class="sym">=</span> 'a array

      <span class="kwa">val</span> new <span class="sym">=</span> array

      <span class="kwa">fun</span> tabulate <span class="sym">(</span>r<span class="sym">,</span> c<span class="sym">,</span> f<span class="sym">) =</span> Array2.tabulate RowMajor <span class="sym">(</span>r<span class="sym">,</span> c<span class="sym">,</span> f<span class="sym">)</span>

      <span class="kwa">fun</span> foreachi <span class="sym">(</span>a<span class="sym">,</span> f<span class="sym">) =</span>
	 appi RowMajor f <span class="sym">{</span>base <span class="sym">=</span> a<span class="sym">,</span> row <span class="sym">=</span> <span class="num">0</span><span class="sym">,</span> col <span class="sym">=</span> <span class="num">0</span><span class="sym">,</span>
			  nrows <span class="sym">=</span> NONE<span class="sym">,</span> ncols <span class="sym">=</span> NONE<span class="sym">}</span>
   <span class="kwa">end</span>

<span class="kwa">structure Vector</span> <span class="sym">=</span>
   <span class="kwa">struct</span>
      <span class="kwa">open Vector</span>

      <span class="kwa">fun</span> exists <span class="sym">(</span>v<span class="sym">,</span> f<span class="sym">) =</span>
	 <span class="kwa">Int</span>.exists <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> length v<span class="sym">,</span> <span class="kwa">fn</span> i <span class="sym">=&gt;</span> f <span class="sym">(</span>sub <span class="sym">(</span>v<span class="sym">,</span> i<span class="sym">)))</span>
      <span class="kwa">fun</span> foreach <span class="sym">(</span>v<span class="sym">,</span> f<span class="sym">) =</span> app f v
      <span class="kwa">fun</span> foreachi <span class="sym">(</span>v<span class="sym">,</span> f<span class="sym">) =</span> appi f v
      <span class="kwa">fun</span> new <span class="sym">(</span>n<span class="sym">,</span> x<span class="sym">) =</span> tabulate <span class="sym">(</span>n<span class="sym">,</span> <span class="kwa">fn</span> _ <span class="sym">=&gt;</span> x<span class="sym">)</span>
      <span class="kwa">fun</span> new1 x <span class="sym">=</span> new <span class="sym">(</span><span class="num">1</span><span class="sym">,</span> x<span class="sym">)</span>
   <span class="kwa">end</span>

<span class="kwa">structure List</span> <span class="sym">=</span>
   <span class="kwa">struct</span>
      <span class="kwa">open List</span>

      <span class="kwa">fun</span> foreach <span class="sym">(</span>l<span class="sym">,</span> f<span class="sym">) =</span> app f l

      <span class="kwa">fun</span> fold <span class="sym">(</span>l<span class="sym">,</span> b<span class="sym">,</span> f<span class="sym">) =</span> foldl f b l

      <span class="kwa">fun</span> appendRev <span class="sym">(</span>l1<span class="sym">,</span> l2<span class="sym">) =</span> fold <span class="sym">(</span>l1<span class="sym">,</span> l2<span class="sym">,</span> <span class="kwa">op</span> <span class="sym">::)</span>

      <span class="kwa">fun</span> push <span class="sym">(</span>r<span class="sym">,</span> x<span class="sym">) =</span> r <span class="sym">:=</span> x <span class="sym">:: !</span>r

      <span class="kwa">fun</span> keepAll <span class="sym">(</span>l<span class="sym">,</span> f<span class="sym">) =</span> filter f l

      <span class="kwa">fun</span> peek <span class="sym">(</span>l<span class="sym">,</span> f<span class="sym">) =</span> find f l

      <span class="kwa">fun</span> insert <span class="sym">(</span>l<span class="sym">,</span> x<span class="sym">,</span> <span class="kwa">op</span> <span class="sym">&lt;=) =</span>
	 <span class="kwa">let</span>
	    <span class="kwa">fun</span> loop <span class="sym">(</span>l<span class="sym">,</span> ac<span class="sym">) =</span>
	       <span class="kwa">case</span> l <span class="kwa">of</span>
		  <span class="sym">[] =&gt;</span> appendRev <span class="sym">(</span>ac<span class="sym">, [</span>x<span class="sym">])</span>
		<span class="sym">|</span> x' <span class="sym">::</span> l' <span class="sym">=&gt;</span>
		     <span class="kwa">if</span> x <span class="sym">&lt;=</span> x'
			<span class="kwa">then</span> appendRev <span class="sym">(</span>ac<span class="sym">,</span> x <span class="sym">::</span> l<span class="sym">)</span>
		     <span class="kwa">else</span> loop <span class="sym">(</span>l'<span class="sym">,</span> x' <span class="sym">::</span> ac<span class="sym">)</span>
	 <span class="kwa">in</span> loop <span class="sym">(</span>l<span class="sym">, [])</span>
	 <span class="kwa">end</span>
   <span class="kwa">end</span>

<span class="kwa">structure</span> Array <span class="sym">=</span>
   <span class="kwa">struct</span>
      <span class="kwa">open</span> Array

      <span class="kwa">fun</span> indices <span class="sym">(</span>a<span class="sym">:</span> <span class="kwb">bool</span> array<span class="sym">):</span> <span class="kwb">int</span> vector <span class="sym">=</span>
	 <span class="kwa">let</span>
	    <span class="kwa">val</span> n <span class="sym">=</span> Array.length a
	    <span class="kwa">val</span> numTrue <span class="sym">=</span>
	       <span class="kwa">let</span>
		  <span class="kwa">fun</span> loop <span class="sym">(</span>i<span class="sym">,</span> count<span class="sym">) =</span>
		     <span class="kwa">if</span> i <span class="sym">=</span> n
			<span class="kwa">then</span> count
		     <span class="kwa">else</span> loop <span class="sym">(</span>i <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span>
				<span class="kwa">if</span> Array.sub <span class="sym">(</span>a<span class="sym">,</span> i<span class="sym">)</span>
				   <span class="kwa">then</span> count <span class="sym">+</span> <span class="num">1</span>
				<span class="kwa">else</span> count<span class="sym">)</span>
	       <span class="kwa">in</span> loop <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> <span class="num">0</span><span class="sym">)</span>
	       <span class="kwa">end</span>
	    <span class="kwa">val</span> next <span class="sym">=</span> ref <span class="num">0</span>
	    <span class="kwa">fun</span> loop i <span class="sym">=</span>
	       <span class="kwa">if</span> Array.sub <span class="sym">(</span>a<span class="sym">,</span> i<span class="sym">)</span>
		  <span class="kwa">then</span> <span class="sym">(</span>next <span class="sym">:=</span> i <span class="sym">+</span> <span class="num">1</span><span class="sym">;</span> i<span class="sym">)</span>
	       <span class="kwa">else</span> loop <span class="sym">(</span>i <span class="sym">+</span> <span class="num">1</span><span class="sym">)</span>
	 <span class="kwa">in Vector</span>.tabulate <span class="sym">(</span>numTrue<span class="sym">,</span> <span class="kwa">fn</span> _ <span class="sym">=&gt;</span> loop <span class="sym">(!</span>next<span class="sym">))</span>
	 <span class="kwa">end</span>
   <span class="kwa">end</span>

<span class="kwa">structure Char</span> <span class="sym">=</span>
   <span class="kwa">struct</span>
      <span class="kwa">open Char</span>

      <span class="kwa">val</span> fromInt <span class="sym">=</span> chr
      <span class="kwa">val</span> toInt <span class="sym">=</span> ord
   <span class="kwa">end</span>

<span class="kwa">structure String</span> <span class="sym">=</span>
   <span class="kwa">struct</span>
      <span class="kwa">open String</span>

      <span class="kwa">type</span> t <span class="sym">=</span> <span class="kwb">string</span>

      <span class="kwa">fun</span> contains <span class="sym">(</span>s<span class="sym">:</span> t<span class="sym">,</span> c<span class="sym">:</span> char<span class="sym">):</span> <span class="kwb">bool</span> <span class="sym">=</span>
	 <span class="kwa">Int</span>.exists <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> size s<span class="sym">,</span> <span class="kwa">fn</span> i <span class="sym">=&gt;</span> c <span class="sym">=</span> sub <span class="sym">(</span>s<span class="sym">,</span> i<span class="sym">))</span>
   <span class="kwa">end</span>

<span class="kwa">val</span> numChars<span class="sym">:</span> <span class="kwb">int</span> <span class="sym">=</span> <span class="num">128</span>

<span class="kwa">structure</span> Regexp <span class="sym">=</span>
   <span class="kwa">struct</span>
      <span class="kwa">datatype</span> t <span class="sym">=</span>
	 AnchorStart
       <span class="sym">|</span> CharSet <span class="kwa">of</span> char <span class="sym">-&gt;</span> <span class="kwb">bool</span>
       <span class="sym">|</span> Or <span class="kwa">of</span> t list
       <span class="sym">|</span> Seq <span class="kwa">of</span> t list
       <span class="sym">|</span> Star <span class="kwa">of</span> t
   <span class="kwa">end</span>

<span class="kwa">structure</span> Stack<span class="sym">:</span>
   <span class="kwa">sig</span>
      <span class="kwa">type</span> 'a t

      <span class="kwa">val</span> clear<span class="sym">:</span> 'a t <span class="sym">-&gt;</span> unit
      <span class="kwa">val</span> exists<span class="sym">:</span> 'a t <span class="sym">* (</span>'a <span class="sym">-&gt;</span> <span class="kwb">bool</span><span class="sym">) -&gt;</span> <span class="kwb">bool</span>
      <span class="kwa">val</span> foreach<span class="sym">:</span> 'a t <span class="sym">* (</span>'a <span class="sym">-&gt;</span> unit<span class="sym">) -&gt;</span> unit
      <span class="kwa">val</span> new<span class="sym">:</span> <span class="kwb">int</span> <span class="sym">*</span> 'a <span class="sym">-&gt;</span> 'a t
      <span class="kwa">val</span> push<span class="sym">:</span> 'a t <span class="sym">*</span> 'a <span class="sym">-&gt;</span> unit
   <span class="kwa">end</span> <span class="sym">=</span>
   <span class="kwa">struct</span>
      <span class="kwa">datatype</span> 'a t <span class="sym">=</span> T <span class="kwa">of</span> <span class="sym">{</span>elts<span class="sym">:</span> 'a array<span class="sym">,</span>
			    size<span class="sym">:</span> <span class="kwb">int</span> ref<span class="sym">}</span>

      <span class="kwa">fun</span> new <span class="sym">(</span>size<span class="sym">:</span> <span class="kwb">int</span><span class="sym">,</span> dummy<span class="sym">:</span> 'a<span class="sym">):</span> 'a t <span class="sym">=</span>
	 T <span class="sym">{</span>elts <span class="sym">=</span> Array.new <span class="sym">(</span>size<span class="sym">,</span> dummy<span class="sym">),</span>
	    size <span class="sym">=</span> ref <span class="num">0</span><span class="sym">}</span>

      <span class="kwa">fun</span> push <span class="sym">(</span>T <span class="sym">{</span>elts<span class="sym">,</span> size<span class="sym">},</span> x<span class="sym">) =</span>
	 <span class="kwa">let</span>
	    <span class="kwa">val</span> n <span class="sym">= !</span>size
	    <span class="kwa">val</span> _ <span class="sym">=</span> Array.update <span class="sym">(</span>elts<span class="sym">,</span> n<span class="sym">,</span> x<span class="sym">)</span>
	    <span class="kwa">val</span> _ <span class="sym">=</span> size <span class="sym">:=</span> n <span class="sym">+</span> <span class="num">1</span>
	 <span class="kwa">in</span> <span class="sym">()</span>
	 <span class="kwa">end</span>

      <span class="kwa">fun</span> exists <span class="sym">(</span>T <span class="sym">{</span>elts<span class="sym">,</span> size<span class="sym">,</span> ...<span class="sym">},</span> f<span class="sym">) =</span>
	 <span class="kwa">Int</span>.exists <span class="sym">(</span><span class="num">0</span><span class="sym">, !</span>size<span class="sym">,</span> <span class="kwa">fn</span> i <span class="sym">=&gt;</span> f <span class="sym">(</span>Array.sub <span class="sym">(</span>elts<span class="sym">,</span> i<span class="sym">)))</span>

      <span class="kwa">fun</span> foreach <span class="sym">(</span>T <span class="sym">{</span>elts<span class="sym">,</span> size<span class="sym">},</span> f<span class="sym">) =</span>
	 <span class="kwa">Int</span>.for <span class="sym">(</span><span class="num">0</span><span class="sym">, !</span>size<span class="sym">,</span> <span class="kwa">fn</span> i <span class="sym">=&gt;</span> f <span class="sym">(</span>Array.sub <span class="sym">(</span>elts<span class="sym">,</span> i<span class="sym">)))</span>

      <span class="kwa">fun</span> clear <span class="sym">(</span>T <span class="sym">{</span>size<span class="sym">,</span> ...<span class="sym">}) =</span> size <span class="sym">:=</span> <span class="num">0</span>
   <span class="kwa">end</span>

<span class="com">(* Non-deterministic Finite Automaton. *)</span>
<span class="kwa">structure</span> NFA<span class="sym">:</span>
   <span class="kwa">sig</span>
      <span class="com">(* The states in an NFA are indexed from 0 to n-1, where n is the number</span>
<span class="com">       * of states.</span>
<span class="com">       *)</span>
      <span class="kwa">type</span> state <span class="sym">=</span> <span class="kwb">int</span>

      <span class="com">(* State i is final iff Array.sub (final, i).</span>
<span class="com">       * The outgoing states from state i on input char c are given by</span>
<span class="com">       * Array2.sub (next, i, Char.ord c).</span>
<span class="com">       * anchorStarts is sorted in increasing order of state index.</span>
<span class="com">       *)</span>
      <span class="kwa">datatype</span> t <span class="sym">=</span> T <span class="kwa">of</span> <span class="sym">{</span>anchorStarts<span class="sym">:</span> state list<span class="sym">,</span>
			 final<span class="sym">:</span> <span class="kwb">bool</span> array<span class="sym">,</span>
			 seen<span class="sym">:</span> <span class="kwb">bool</span> array<span class="sym">,</span> <span class="com">(* used for matching. *)</span>
			 stack1<span class="sym">:</span> <span class="kwb">int</span> Stack.t<span class="sym">,</span> <span class="com">(* used for matching. *)</span>
			 stack2<span class="sym">:</span> <span class="kwb">int</span> Stack.t<span class="sym">,</span> <span class="com">(* used for matching. *)</span>
			 start<span class="sym">:</span> state<span class="sym">,</span>
			 next<span class="sym">:</span> state vector Array2.t<span class="sym">}</span>

      <span class="kwa">val</span> fromRegexp<span class="sym">:</span> Regexp.t <span class="sym">-&gt;</span> t
      <span class="kwa">val</span> match<span class="sym">: {</span>nfa<span class="sym">:</span> t<span class="sym">,</span>
		  <span class="kwb">string</span><span class="sym">:</span> <span class="kwb">string</span><span class="sym">,</span>
		  startPos<span class="sym">:</span> <span class="kwb">int</span><span class="sym">,</span>
		  anchorStart<span class="sym">:</span> <span class="kwb">bool</span><span class="sym">} -&gt;</span> <span class="kwb">int</span> option
      <span class="kwa">val</span> numStates<span class="sym">:</span> t <span class="sym">-&gt;</span> <span class="kwb">int</span>
   <span class="kwa">end</span> <span class="sym">=</span>
   <span class="kwa">struct</span>
      <span class="kwa">type</span> state <span class="sym">=</span> <span class="kwb">int</span>
      <span class="kwa">datatype</span> t <span class="sym">=</span> T <span class="kwa">of</span> <span class="sym">{</span>anchorStarts<span class="sym">:</span> state list<span class="sym">,</span>
			 final<span class="sym">:</span> <span class="kwb">bool</span> array<span class="sym">,</span>
			 seen<span class="sym">:</span> <span class="kwb">bool</span> array<span class="sym">,</span>
			 stack1<span class="sym">:</span> <span class="kwb">int</span> Stack.t<span class="sym">,</span>
			 stack2<span class="sym">:</span> <span class="kwb">int</span> Stack.t<span class="sym">,</span>
			 start<span class="sym">:</span> state<span class="sym">,</span>
			 next<span class="sym">:</span> state vector Array2.t<span class="sym">}</span>

      <span class="kwa">fun</span> numStates <span class="sym">(</span>T <span class="sym">{</span>next<span class="sym">,</span> ...<span class="sym">}) =</span> Array2.nRows next


      <span class="com">(* Simulating an NFA with two stacks and a bit vector, as in Algorithm 3.4</span>
<span class="com">       * (page 126) of Compilers: Principles, Techniques, and Tools by Aho,</span>
<span class="com">       * Sethi, and Ullman.</span>
<span class="com">       *)</span>
      <span class="kwa">fun</span> match <span class="sym">{</span>anchorStart<span class="sym">:</span> <span class="kwb">bool</span><span class="sym">,</span>
		 nfa <span class="kwa">as</span> T <span class="sym">{</span>anchorStarts<span class="sym">,</span> final<span class="sym">,</span> seen<span class="sym">,</span> stack1<span class="sym">,</span> stack2<span class="sym">,</span> start<span class="sym">,</span>
			   next<span class="sym">},</span>
		 startPos<span class="sym">,</span>
		 <span class="kwb">string</span> <span class="sym">=</span> s<span class="sym">}:</span> <span class="kwb">int</span> option <span class="sym">=</span>
	 <span class="kwa">let</span>
	    <span class="kwa">val</span> numStates <span class="sym">=</span> numStates nfa
	    <span class="kwa">val</span> n <span class="sym">=</span> <span class="kwa">String</span>.size s
	    <span class="kwa">val</span> _ <span class="sym">=</span> Array.modify <span class="sym">(</span>seen<span class="sym">,</span> <span class="kwa">fn</span> _ <span class="sym">=&gt;</span> <span class="kwa">false</span><span class="sym">)</span>
	    <span class="kwa">fun</span> loop <span class="sym">(</span>current<span class="sym">:</span> state Stack.t<span class="sym">,</span>
		      nextStates<span class="sym">:</span> state Stack.t<span class="sym">,</span>
		      i<span class="sym">:</span> <span class="kwb">int</span><span class="sym">,</span>
		      last<span class="sym">:</span> <span class="kwb">int</span> option<span class="sym">):</span> <span class="kwb">int</span> option <span class="sym">=</span>
	       <span class="kwa">let</span>
		  <span class="kwa">val</span> last <span class="sym">=</span>
		     <span class="kwa">if</span> Stack.exists <span class="sym">(</span>current<span class="sym">,</span> <span class="kwa">fn</span> s <span class="sym">=&gt;</span> Array.sub <span class="sym">(</span>final<span class="sym">,</span> s<span class="sym">))</span>
			<span class="kwa">then</span> SOME i
		     <span class="kwa">else</span> last
	       <span class="kwa">in</span>
		  <span class="kwa">if</span> numStates <span class="sym">=</span> <span class="num">0</span> <span class="kwa">orelse</span> i <span class="sym">=</span> n
		     <span class="kwa">then</span> <span class="sym">(</span>Stack.clear stack1
			   <span class="sym">;</span> Stack.clear stack2
			   <span class="sym">;</span> last<span class="sym">)</span>
		  <span class="kwa">else</span>
		     <span class="kwa">let</span>
			<span class="kwa">val</span> _ <span class="sym">=</span> Array.modify <span class="sym">(</span>seen<span class="sym">,</span> <span class="kwa">fn</span> _ <span class="sym">=&gt;</span> <span class="kwa">false</span><span class="sym">)</span>
			<span class="kwa">val</span> c <span class="sym">=</span> <span class="kwa">Char</span>.toInt <span class="sym">(</span><span class="kwa">String</span>.sub <span class="sym">(</span>s<span class="sym">,</span> i<span class="sym">))</span>
			<span class="kwa">val</span> _ <span class="sym">=</span>
			   Stack.foreach <span class="sym">(</span>current<span class="sym">,</span> <span class="kwa">fn</span> s <span class="sym">=&gt;</span>
					  <span class="kwa">Vector</span>.foreach
					  <span class="sym">(</span>Array2.sub <span class="sym">(</span>next<span class="sym">,</span> s<span class="sym">,</span> c<span class="sym">),</span>
					   <span class="kwa">fn</span> s' <span class="sym">=&gt;</span>
					   <span class="kwa">if</span> Array.sub <span class="sym">(</span>seen<span class="sym">,</span> s'<span class="sym">)</span>
					      <span class="kwa">then</span> <span class="sym">()</span>
					   <span class="kwa">else</span> <span class="sym">(</span>Array.update <span class="sym">(</span>seen<span class="sym">,</span> s'<span class="sym">,</span> <span class="kwa">true</span><span class="sym">)</span>
						 <span class="sym">;</span> Stack.push <span class="sym">(</span>nextStates<span class="sym">,</span> s'<span class="sym">))))</span>
			<span class="kwa">val</span> _ <span class="sym">=</span> Stack.clear current
		     <span class="kwa">in</span> loop <span class="sym">(</span>nextStates<span class="sym">,</span> current<span class="sym">,</span> i <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> last<span class="sym">)</span>
		     <span class="kwa">end</span>
	       <span class="kwa">end</span>
	    <span class="kwa">val</span> _ <span class="sym">=</span> Stack.push <span class="sym">(</span>stack1<span class="sym">,</span> start<span class="sym">)</span>
	    <span class="kwa">val</span> _ <span class="sym">=</span>
	       <span class="kwa">if</span> anchorStart
		  <span class="kwa">then List</span>.foreach <span class="sym">(</span>anchorStarts<span class="sym">,</span> <span class="kwa">fn</span> s <span class="sym">=&gt;</span>
				     Stack.push <span class="sym">(</span>stack1<span class="sym">,</span> s<span class="sym">))</span>
	       <span class="kwa">else</span> <span class="sym">()</span>
	 <span class="kwa">in</span>
	    loop <span class="sym">(</span>stack1<span class="sym">,</span> stack2<span class="sym">,</span> startPos<span class="sym">,</span> NONE<span class="sym">)</span>
	 <span class="kwa">end</span>

      <span class="com">(* This conversion from a regular expression to an NFA is based on</span>
<span class="com">       * Section 3.9 (pages 134 -- 140) of Compilers: Principles, Techniques,</span>
<span class="com">       * and Tools by Aho, Sethi, and Ullman.</span>
<span class="com">       *</span>
<span class="com">       * It creates one NFA state for each CharSet (called a &quot;position&quot;) that is</span>
<span class="com">       * in the regexp.  There is also one extra state for the start state.</span>
<span class="com">       * It adds edges as in rules 1 and 2 (page 138) for the followpos function.</span>
<span class="com">       *)</span>
      <span class="kwa">fun</span> fromRegexp <span class="sym">(</span>r<span class="sym">:</span> Regexp.t<span class="sym">):</span> t <span class="sym">=</span>
	 <span class="kwa">let</span>
	    <span class="kwa">fun</span> loop <span class="sym">(</span>r<span class="sym">,</span> ac<span class="sym">) =</span>
	       <span class="kwa">let open</span> Regexp
	       <span class="kwa">in case</span> r <span class="kwa">of</span>
		  AnchorStart <span class="sym">=&gt;</span> ac <span class="sym">+</span> <span class="num">1</span>
		<span class="sym">|</span> CharSet _ <span class="sym">=&gt;</span> ac <span class="sym">+</span> <span class="num">1</span>
		<span class="sym">|</span> Or rs <span class="sym">=&gt;</span> <span class="kwa">List</span>.fold <span class="sym">(</span>rs<span class="sym">,</span> ac<span class="sym">,</span> loop<span class="sym">)</span>
		<span class="sym">|</span> Seq rs <span class="sym">=&gt;</span> <span class="kwa">List</span>.fold <span class="sym">(</span>rs<span class="sym">,</span> ac<span class="sym">,</span> loop<span class="sym">)</span>
		<span class="sym">|</span> Star r <span class="sym">=&gt;</span> loop <span class="sym">(</span>r<span class="sym">,</span> ac<span class="sym">)</span>
	       <span class="kwa">end</span>
	    <span class="kwa">val</span> numPos <span class="sym">=</span> loop <span class="sym">(</span>r<span class="sym">,</span> <span class="num">0</span><span class="sym">)</span>
	    <span class="kwa">val</span> numStates <span class="sym">=</span> numPos <span class="sym">+</span> <span class="num">1</span>
	    <span class="kwa">val</span> start <span class="sym">=</span> numPos
	    <span class="kwa">val</span> posCounter <span class="sym">=</span> ref ~<span class="num">1</span>
	    <span class="kwa">val</span> follow <span class="sym">=</span> Array2.new <span class="sym">(</span>numStates<span class="sym">,</span> numStates<span class="sym">,</span> <span class="kwa">false</span><span class="sym">)</span>
	    <span class="kwa">val</span> posChars <span class="sym">=</span> Array2.tabulate <span class="sym">(</span>numPos<span class="sym">,</span> numChars<span class="sym">,</span> <span class="kwa">fn</span> _ <span class="sym">=&gt;</span> <span class="kwa">false</span><span class="sym">)</span>
	    <span class="kwa">local</span>
	       <span class="kwa">datatype</span> t <span class="sym">=</span> T <span class="kwa">of</span> <span class="kwb">bool</span> vector <span class="com">(* of length numPos *)</span>
	    <span class="kwa">in</span>
	       <span class="kwa">fun</span> contains <span class="sym">(</span>T v<span class="sym">,</span> s<span class="sym">) =</span> <span class="kwa">Vector</span>.sub <span class="sym">(</span>v<span class="sym">,</span> s<span class="sym">)</span>
	       <span class="kwa">val</span> empty<span class="sym">:</span> t <span class="sym">=</span> T <span class="sym">(</span><span class="kwa">Vector</span>.new <span class="sym">(</span>numPos<span class="sym">,</span> <span class="kwa">false</span><span class="sym">))</span>
	       <span class="kwa">fun</span> union <span class="sym">(</span>T v<span class="sym">,</span> T v'<span class="sym">):</span> t <span class="sym">=</span>
		  T <span class="sym">(</span><span class="kwa">Vector</span>.tabulate <span class="sym">(</span>numPos<span class="sym">,</span> <span class="kwa">fn</span> i <span class="sym">=&gt;</span>
				      <span class="kwa">Vector</span>.sub <span class="sym">(</span>v<span class="sym">,</span> i<span class="sym">)</span>
				      <span class="kwa">orelse Vector</span>.sub <span class="sym">(</span>v'<span class="sym">,</span> i<span class="sym">)))</span>
	       <span class="kwa">fun</span> singleton <span class="sym">(</span>i<span class="sym">:</span> <span class="kwb">int</span><span class="sym">):</span> t <span class="sym">=</span>
		  T <span class="sym">(</span><span class="kwa">Vector</span>.tabulate <span class="sym">(</span>numPos<span class="sym">,</span> <span class="kwa">fn</span> j <span class="sym">=&gt;</span> i <span class="sym">=</span> j<span class="sym">))</span>
	       <span class="kwa">fun</span> foreach <span class="sym">(</span>T v<span class="sym">,</span> f<span class="sym">) =</span>
		  <span class="kwa">Vector</span>.foreachi <span class="sym">(</span>v<span class="sym">,</span> <span class="kwa">fn</span> <span class="sym">(</span>i<span class="sym">,</span> b<span class="sym">) =&gt;</span> <span class="kwa">if</span> b <span class="kwa">then</span> f i <span class="kwa">else</span> <span class="sym">())</span>
	    <span class="kwa">end</span>
	    <span class="kwa">val</span> anchorStarts <span class="sym">=</span> ref <span class="sym">[]</span>
	    <span class="com">(* The following loop fills in follow and posChars. *)</span>
	    <span class="kwa">fun</span> loop r <span class="sym">=</span>
	       <span class="kwa">case</span> r <span class="kwa">of</span>
		  Regexp.AnchorStart <span class="sym">=&gt;</span>
		     <span class="kwa">let</span>
			<span class="kwa">val</span> i <span class="sym">= ++</span> posCounter
			<span class="kwa">val</span> _ <span class="sym">=</span> <span class="kwa">List</span>.push <span class="sym">(</span>anchorStarts<span class="sym">,</span> i<span class="sym">)</span>
			<span class="kwa">val</span> first <span class="sym">=</span> singleton i
		     <span class="kwa">in</span>
			<span class="sym">{</span>first <span class="sym">=</span> first<span class="sym">,</span>
			 last <span class="sym">=</span> first<span class="sym">,</span>
			 nullable <span class="sym">=</span> <span class="kwa">false</span><span class="sym">}</span>
		     <span class="kwa">end</span>
		<span class="sym">|</span> Regexp.CharSet f <span class="sym">=&gt;</span>
		     <span class="kwa">let</span>
			<span class="kwa">val</span> i <span class="sym">= ++</span> posCounter
			<span class="kwa">val</span> _ <span class="sym">=</span>
			   <span class="kwa">Int</span>.for <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> numChars<span class="sym">,</span> <span class="kwa">fn</span> c <span class="sym">=&gt;</span>
				    <span class="kwa">if</span> f <span class="sym">(</span><span class="kwa">Char</span>.chr c<span class="sym">)</span>
				       <span class="kwa">then</span> Array2.update <span class="sym">(</span>posChars<span class="sym">,</span> i<span class="sym">,</span> c<span class="sym">,</span> <span class="kwa">true</span><span class="sym">)</span>
				    <span class="kwa">else</span> <span class="sym">())</span>
			<span class="kwa">val</span> first <span class="sym">=</span> singleton i
		     <span class="kwa">in</span> <span class="sym">{</span>first <span class="sym">=</span> first<span class="sym">,</span>
			 last <span class="sym">=</span> first<span class="sym">,</span>
			 nullable <span class="sym">=</span> <span class="kwa">false</span><span class="sym">}</span>
		     <span class="kwa">end</span>
		<span class="sym">|</span> Regexp.Or rs <span class="sym">=&gt;</span>
		     <span class="kwa">List</span>.fold
		     <span class="sym">(</span>rs<span class="sym">, {</span>first <span class="sym">=</span> empty<span class="sym">,</span>
			   last <span class="sym">=</span> empty<span class="sym">,</span>
			   nullable <span class="sym">=</span> <span class="kwa">false</span><span class="sym">},</span>
		      <span class="kwa">fn</span> <span class="sym">(</span>r<span class="sym">, {</span>first <span class="sym">=</span> f<span class="sym">,</span> last <span class="sym">=</span> l<span class="sym">,</span> nullable <span class="sym">=</span> n<span class="sym">}) =&gt;</span>
		      <span class="kwa">let</span>
			 <span class="kwa">val</span> <span class="sym">{</span>first <span class="sym">=</span> f'<span class="sym">,</span> last <span class="sym">=</span> l'<span class="sym">,</span> nullable <span class="sym">=</span> n'<span class="sym">} =</span>
			    loop r
		      <span class="kwa">in</span>
			 <span class="sym">{</span>first <span class="sym">=</span> union <span class="sym">(</span>f<span class="sym">,</span> f'<span class="sym">),</span>
			  last <span class="sym">=</span> union <span class="sym">(</span>l<span class="sym">,</span> l'<span class="sym">),</span>
			  nullable <span class="sym">=</span> n <span class="kwa">orelse</span> n'<span class="sym">}</span>
		      <span class="kwa">end</span><span class="sym">)</span>
		<span class="sym">|</span> Regexp.Seq rs <span class="sym">=&gt;</span>
		     <span class="kwa">List</span>.fold
		     <span class="sym">(</span>rs<span class="sym">, {</span>first <span class="sym">=</span> empty<span class="sym">,</span>
			   last <span class="sym">=</span> empty<span class="sym">,</span>
			   nullable <span class="sym">=</span> <span class="kwa">true</span><span class="sym">},</span>
		      <span class="kwa">fn</span> <span class="sym">(</span>r<span class="sym">, {</span>first <span class="sym">=</span> f<span class="sym">,</span> last <span class="sym">=</span> l<span class="sym">,</span> nullable <span class="sym">=</span> n<span class="sym">}) =&gt;</span>
		      <span class="kwa">let</span>
			 <span class="kwa">val</span> <span class="sym">{</span>first <span class="sym">=</span> f'<span class="sym">,</span> last <span class="sym">=</span> l'<span class="sym">,</span> nullable <span class="sym">=</span> n'<span class="sym">} =</span>
			    loop r
			 <span class="kwa">val</span> _ <span class="sym">=</span>
			    foreach
			    <span class="sym">(</span>l<span class="sym">,</span> <span class="kwa">fn</span> s <span class="sym">=&gt;</span>
			     foreach
			     <span class="sym">(</span>f'<span class="sym">,</span> <span class="kwa">fn</span> s' <span class="sym">=&gt;</span> Array2.update <span class="sym">(</span>follow<span class="sym">,</span> s<span class="sym">,</span> s'<span class="sym">,</span> <span class="kwa">true</span><span class="sym">)))</span>
		      <span class="kwa">in</span>
			 <span class="sym">{</span>first <span class="sym">=</span> <span class="kwa">if</span> n <span class="kwa">then</span> union <span class="sym">(</span>f<span class="sym">,</span> f'<span class="sym">)</span> <span class="kwa">else</span> f<span class="sym">,</span>
			  last <span class="sym">=</span> <span class="kwa">if</span> n' <span class="kwa">then</span> union <span class="sym">(</span>l<span class="sym">,</span> l'<span class="sym">)</span> <span class="kwa">else</span> l'<span class="sym">,</span>
			  nullable <span class="sym">=</span> n <span class="kwa">andalso</span> n'<span class="sym">}</span>
		      <span class="kwa">end</span><span class="sym">)</span>
		<span class="sym">|</span> Regexp.Star r <span class="sym">=&gt;</span>
		     <span class="kwa">let</span>
			<span class="kwa">val</span> <span class="sym">{</span>first <span class="sym">=</span> f<span class="sym">,</span> last <span class="sym">=</span> l<span class="sym">,</span> nullable <span class="sym">=</span> n<span class="sym">} =</span> loop r
			<span class="kwa">val</span> _ <span class="sym">=</span>
			   foreach
			   <span class="sym">(</span>l<span class="sym">,</span> <span class="kwa">fn</span> s <span class="sym">=&gt;</span>
			    foreach
			    <span class="sym">(</span>f<span class="sym">,</span> <span class="kwa">fn</span> s' <span class="sym">=&gt;</span> Array2.update <span class="sym">(</span>follow<span class="sym">,</span> s<span class="sym">,</span> s'<span class="sym">,</span> <span class="kwa">true</span><span class="sym">)))</span>
		     <span class="kwa">in</span>
			<span class="sym">{</span>first <span class="sym">=</span> f<span class="sym">,</span> last <span class="sym">=</span> l<span class="sym">,</span> nullable <span class="sym">=</span> <span class="kwa">true</span><span class="sym">}</span>
		     <span class="kwa">end</span>
	    <span class="kwa">val</span> <span class="sym">{</span>first<span class="sym">,</span> last<span class="sym">,</span> nullable<span class="sym">} =</span> loop r
	    <span class="com">(* Any anchor starts in first should be anchor starts.</span>
<span class="com">	     * This also reverses anchorStarts so they are in order.</span>
<span class="com">	     *)</span>
	    <span class="kwa">val</span> anchorStarts <span class="sym">=</span>
	       <span class="kwa">List</span>.fold <span class="sym">(!</span>anchorStarts<span class="sym">, [],</span> <span class="kwa">fn</span> <span class="sym">(</span>s<span class="sym">,</span> ac<span class="sym">) =&gt;</span>
			  <span class="kwa">if</span> contains <span class="sym">(</span>first<span class="sym">,</span> s<span class="sym">)</span> <span class="kwa">then</span> s <span class="sym">::</span> ac <span class="kwa">else</span> ac<span class="sym">)</span>
	    <span class="com">(* The positions in first are all reachable from the start state. *)</span>
	    <span class="kwa">val</span> _ <span class="sym">=</span> foreach <span class="sym">(</span>first<span class="sym">,</span> <span class="kwa">fn</span> i <span class="sym">=&gt;</span>
			     Array2.update <span class="sym">(</span>follow<span class="sym">,</span> start<span class="sym">,</span> i<span class="sym">,</span> <span class="kwa">true</span><span class="sym">))</span>
	    <span class="com">(* The positions in last are all final states. *)</span>
	    <span class="kwa">val</span> final <span class="sym">=</span> Array.array <span class="sym">(</span>numStates<span class="sym">,</span> <span class="kwa">false</span><span class="sym">)</span>
	    <span class="kwa">val</span> _ <span class="sym">=</span> foreach <span class="sym">(</span>last<span class="sym">,</span> <span class="kwa">fn</span> i <span class="sym">=&gt;</span> Array.update <span class="sym">(</span>final<span class="sym">,</span> i<span class="sym">,</span> <span class="kwa">true</span><span class="sym">))</span>
	    <span class="com">(* The start state is final if the whole regexp is nullable. *)</span>
	    <span class="kwa">val</span> _ <span class="sym">=</span> <span class="kwa">if</span> nullable <span class="kwa">then</span> Array.update <span class="sym">(</span>final<span class="sym">,</span> start<span class="sym">,</span> <span class="kwa">true</span><span class="sym">)</span> <span class="kwa">else</span> <span class="sym">()</span>
	    <span class="com">(* Now c1ompute the transition table. *)</span>
	    <span class="kwa">val</span> a <span class="sym">=</span> Array.new <span class="sym">(</span>numStates<span class="sym">,</span> <span class="kwa">false</span><span class="sym">)</span>
	    <span class="kwa">val</span> next <span class="sym">=</span>
	       Array2.tabulate
	       <span class="sym">(</span>numStates<span class="sym">,</span> numChars<span class="sym">,</span> <span class="kwa">fn</span> <span class="sym">(</span>i<span class="sym">,</span> c<span class="sym">) =&gt;</span>
		<span class="kwa">let</span>
		   <span class="kwa">val</span> _ <span class="sym">=</span>
		      <span class="kwa">Int</span>.for <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> numStates<span class="sym">,</span> <span class="kwa">fn</span> j <span class="sym">=&gt;</span> Array.update <span class="sym">(</span>a<span class="sym">,</span> j<span class="sym">,</span> <span class="kwa">false</span><span class="sym">))</span>
		   <span class="kwa">val</span> _ <span class="sym">=</span>
		      <span class="kwa">Int</span>.for
		      <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> numPos<span class="sym">,</span> <span class="kwa">fn</span> j <span class="sym">=&gt;</span>
		       <span class="kwa">if</span> Array2.sub <span class="sym">(</span>follow<span class="sym">,</span> i<span class="sym">,</span> j<span class="sym">)</span>
			  <span class="kwa">andalso</span> Array2.sub <span class="sym">(</span>posChars<span class="sym">,</span> j<span class="sym">,</span> c<span class="sym">)</span>
			  <span class="kwa">then</span> Array.update <span class="sym">(</span>a<span class="sym">,</span> j<span class="sym">,</span> <span class="kwa">true</span><span class="sym">)</span>
		       <span class="kwa">else</span> <span class="sym">())</span>
		<span class="kwa">in</span> Array.indices a
		<span class="kwa">end</span><span class="sym">)</span>
	 <span class="kwa">in</span>
	    T <span class="sym">{</span>anchorStarts <span class="sym">=</span> anchorStarts<span class="sym">,</span>
	       final <span class="sym">=</span> final<span class="sym">,</span>
	       next <span class="sym">=</span> next<span class="sym">,</span>
	       seen <span class="sym">=</span> Array.new <span class="sym">(</span>numStates<span class="sym">,</span> <span class="kwa">false</span><span class="sym">),</span>
	       stack1 <span class="sym">=</span> Stack.new <span class="sym">(</span>numStates<span class="sym">,</span> ~<span class="num">1</span><span class="sym">),</span>
	       stack2 <span class="sym">=</span> Stack.new <span class="sym">(</span>numStates<span class="sym">,</span> ~<span class="num">1</span><span class="sym">),</span>
	       start <span class="sym">=</span> start<span class="sym">}</span>
	 <span class="kwa">end</span>

   <span class="kwa">end</span>

<span class="kwa">structure</span> DFA<span class="sym">:</span>
   <span class="kwa">sig</span>
      <span class="kwa">type</span> t

      <span class="kwa">val</span> fromNFA<span class="sym">:</span> NFA.t <span class="sym">-&gt;</span> t
      <span class="kwa">val</span> match<span class="sym">: {</span>dfa<span class="sym">:</span> t<span class="sym">,</span>
		  <span class="kwb">string</span><span class="sym">:</span> <span class="kwb">string</span><span class="sym">,</span>
		  startPos<span class="sym">:</span> <span class="kwb">int</span><span class="sym">,</span>
		  anchorStart<span class="sym">:</span> <span class="kwb">bool</span><span class="sym">} -&gt;</span> <span class="kwb">int</span> option
      <span class="kwa">val</span> minimize<span class="sym">:</span> t <span class="sym">-&gt;</span> t
   <span class="kwa">end</span> <span class="sym">=</span>
   <span class="kwa">struct</span>
      <span class="com">(* The states in a DFA are indexed from 0 to n-1, where n is the number</span>
<span class="com">       * of states.</span>
<span class="com">       *)</span>
      <span class="kwa">type</span> state <span class="sym">=</span> <span class="kwb">int</span>

      <span class="com">(* State i is final iff Array.sub (final, i).</span>
<span class="com">       * The outgoing state from state i on input char c is</span>
<span class="com">       * Array2.sub (next, i, Char.ord c).</span>
<span class="com">       *)</span>
      <span class="kwa">datatype</span> t <span class="sym">=</span> T <span class="kwa">of</span> <span class="sym">{</span>anchorStart<span class="sym">:</span> state<span class="sym">,</span>
			 dead<span class="sym">:</span> <span class="kwb">bool</span> array<span class="sym">,</span>
			 final<span class="sym">:</span> <span class="kwb">bool</span> array<span class="sym">,</span>
			 next<span class="sym">:</span> state Array2.t<span class="sym">,</span>
			 start<span class="sym">:</span> state<span class="sym">}</span>

      <span class="kwa">fun</span> numStates <span class="sym">(</span>T <span class="sym">{</span>next<span class="sym">,</span> ...<span class="sym">}):</span> <span class="kwb">int</span> <span class="sym">=</span> Array2.nRows next


      <span class="kwa">fun</span> match <span class="sym">{</span>dfa <span class="kwa">as</span> T <span class="sym">{</span>anchorStart <span class="sym">=</span> ancSt<span class="sym">,</span> dead<span class="sym">,</span> final<span class="sym">,</span> start<span class="sym">,</span> next<span class="sym">},</span>
		 <span class="kwb">string</span> <span class="kwa">as</span> s<span class="sym">,</span>
		 startPos<span class="sym">:</span> <span class="kwb">int</span><span class="sym">,</span>
		 anchorStart<span class="sym">:</span> <span class="kwb">bool</span><span class="sym">}:</span> <span class="kwb">int</span> option <span class="sym">=</span>
	 <span class="kwa">let</span>
	    <span class="kwa">val</span> n <span class="sym">=</span> <span class="kwa">String</span>.size s
	    <span class="kwa">fun</span> loop <span class="sym">(</span>i<span class="sym">:</span> <span class="kwb">int</span><span class="sym">,</span> state<span class="sym">:</span> <span class="kwb">int</span><span class="sym">,</span> last<span class="sym">:</span> <span class="kwb">int</span> option<span class="sym">):</span> <span class="kwb">int</span> option <span class="sym">=</span>
	       <span class="kwa">let</span>
		  <span class="kwa">val</span> last <span class="sym">=</span>
		     <span class="kwa">if</span> Array.sub <span class="sym">(</span>final<span class="sym">,</span> state<span class="sym">)</span>
			<span class="kwa">then</span> SOME i
		     <span class="kwa">else</span> last
	       <span class="kwa">in</span>
		  <span class="kwa">if</span> Array.sub <span class="sym">(</span>dead<span class="sym">,</span> state<span class="sym">)</span> <span class="kwa">orelse</span> i <span class="sym">=</span> n
		     <span class="kwa">then</span> last
		  <span class="kwa">else</span> loop <span class="sym">(</span>i <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span>
			     Array2.sub <span class="sym">(</span>next<span class="sym">,</span> state<span class="sym">,</span>
					 <span class="kwa">Char</span>.toInt <span class="sym">(</span><span class="kwa">String</span>.sub <span class="sym">(</span>s<span class="sym">,</span> i<span class="sym">))),</span>
			     last<span class="sym">)</span>
	       <span class="kwa">end</span>
	 <span class="kwa">in</span> loop <span class="sym">(</span>startPos<span class="sym">,</span>
		  <span class="kwa">if</span> anchorStart <span class="kwa">then</span> ancSt <span class="kwa">else</span> start<span class="sym">,</span>
		     NONE<span class="sym">)</span>
	 <span class="kwa">end</span>

      <span class="kwa">fun</span> dead <span class="sym">(</span>numStates<span class="sym">,</span> final<span class="sym">,</span> next<span class="sym">) =</span>
	 Array.tabulate
	 <span class="sym">(</span>numStates<span class="sym">,</span> <span class="kwa">fn</span> i <span class="sym">=&gt;</span>
	  not <span class="sym">(</span>Array.sub <span class="sym">(</span>final<span class="sym">,</span> i<span class="sym">))</span>
	  <span class="kwa">andalso Int</span>.forall <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> numChars<span class="sym">,</span> <span class="kwa">fn</span> c <span class="sym">=&gt;</span>
			      i <span class="sym">=</span> Array2.sub <span class="sym">(</span>next<span class="sym">,</span> i<span class="sym">,</span> c<span class="sym">)))</span>

      <span class="com">(* This DFA minimization algorithm is based on algorithm 3.6 (page 142)</span>
<span class="com">       * of Compilers: Principles, Techniques, and Tools by Aho, Sethi, and</span>
<span class="com">       * Ullman.</span>
<span class="com">       *</span>
<span class="com">       * It maintains an array, r, that stores for each state s the</span>
<span class="com">       * representative of the class to which s belongs.</span>
<span class="com">       * It repeatedly refines an equivalence relation, represented by a list</span>
<span class="com">       * of classes, where each class is a list of states (i.e. ints).</span>
<span class="com">       *)</span>
      <span class="kwa">fun</span> minimize <span class="sym">(</span>dfa <span class="kwa">as</span> T <span class="sym">{</span>anchorStart<span class="sym">,</span> final<span class="sym">,</span> start<span class="sym">,</span> next<span class="sym">,</span> ...<span class="sym">}):</span> t <span class="sym">=</span>
	 <span class="kwa">let</span>
	    <span class="kwa">val</span> numStates <span class="sym">=</span> numStates dfa
	    <span class="kwa">type</span> class <span class="sym">=</span> <span class="kwb">int</span> list
	    <span class="kwa">type</span> classes <span class="sym">=</span> class list
	    <span class="kwa">val</span> repCounter <span class="sym">=</span> ref ~<span class="num">1</span>
	    <span class="kwa">val</span> change <span class="sym">=</span> ref <span class="kwa">false</span>
	    <span class="kwa">fun</span> newRep <span class="sym">() = (</span>change <span class="sym">:=</span> <span class="kwa">true</span><span class="sym">; ++</span> repCounter<span class="sym">)</span>
	    <span class="kwa">val</span> finRep <span class="sym">=</span> newRep <span class="sym">()</span>
	    <span class="kwa">val</span> nonfinRep <span class="sym">=</span> newRep <span class="sym">()</span>
	    <span class="kwa">val</span> r <span class="sym">=</span> Array.tabulate <span class="sym">(</span>numStates<span class="sym">,</span> <span class="kwa">fn</span> i <span class="sym">=&gt;</span>
				    <span class="kwa">if</span> Array.sub <span class="sym">(</span>final<span class="sym">,</span> i<span class="sym">)</span>
				       <span class="kwa">then</span> finRep
				    <span class="kwa">else</span> nonfinRep<span class="sym">)</span>
	    <span class="kwa">fun</span> rep s <span class="sym">=</span> Array.sub <span class="sym">(</span>r<span class="sym">,</span> s<span class="sym">)</span>
	    <span class="kwa">fun</span> trans <span class="sym">(</span>s<span class="sym">,</span> c<span class="sym">) =</span> rep <span class="sym">(</span>Array2.sub <span class="sym">(</span>next<span class="sym">,</span> s<span class="sym">,</span> c<span class="sym">))</span>
	    <span class="kwa">fun</span> refine <span class="sym">(</span>class<span class="sym">:</span> class<span class="sym">,</span> ac<span class="sym">:</span> classes<span class="sym">):</span> classes <span class="sym">=</span>
	       <span class="kwa">let</span>
		  <span class="kwa">val</span> r <span class="sym">=</span>
		     <span class="kwa">List</span>.fold
		     <span class="sym">(</span>class<span class="sym">, [],</span> <span class="kwa">fn</span> <span class="sym">(</span>state<span class="sym">,</span> classes<span class="sym">) =&gt;</span>
		      <span class="kwa">let</span>
			 <span class="kwa">fun</span> loop <span class="sym">(</span>classes<span class="sym">,</span> ac<span class="sym">) =</span>
			    <span class="kwa">case</span> classes <span class="kwa">of</span>
			       <span class="sym">[] =&gt;</span>
				  <span class="sym">(</span><span class="kwa">case</span> ac <span class="kwa">of</span>
				      <span class="sym">[] =&gt; [{</span>class <span class="sym">= [</span>state<span class="sym">],</span>
					      old <span class="sym">=</span> state<span class="sym">}]</span>
				    <span class="sym">|</span> _ <span class="sym">=&gt;</span>
					 <span class="kwa">let</span>
					    <span class="kwa">val</span> s <span class="sym">=</span> newRep <span class="sym">()</span>
					    <span class="kwa">val</span> _ <span class="sym">=</span> Array.update <span class="sym">(</span>r<span class="sym">,</span> state<span class="sym">,</span> s<span class="sym">)</span>
					 <span class="kwa">in</span> <span class="sym">{</span>class <span class="sym">= [</span>state<span class="sym">],</span>
					     old <span class="sym">=</span> state<span class="sym">} ::</span> ac
					 <span class="kwa">end</span><span class="sym">)</span>
			     <span class="sym">| (</span>z <span class="kwa">as</span> <span class="sym">{</span>class<span class="sym">,</span> old<span class="sym">}) ::</span> classes <span class="sym">=&gt;</span>
				  <span class="kwa">if Int</span>.forall
				     <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> numChars<span class="sym">,</span> <span class="kwa">fn</span> c <span class="sym">=&gt;</span>
				      trans <span class="sym">(</span>old<span class="sym">,</span> c<span class="sym">) =</span> trans <span class="sym">(</span>state<span class="sym">,</span> c<span class="sym">))</span>
				     <span class="kwa">then</span>
					<span class="sym">(</span>Array.update <span class="sym">(</span>r<span class="sym">,</span> state<span class="sym">,</span> rep old<span class="sym">)</span>
					 <span class="sym">; {</span>class <span class="sym">=</span> state <span class="sym">::</span> class<span class="sym">,</span>
					    old <span class="sym">=</span> old<span class="sym">} :: (</span><span class="kwa">List</span>.appendRev
							   <span class="sym">(</span>classes<span class="sym">,</span> ac<span class="sym">)))</span>
				  <span class="kwa">else</span> loop <span class="sym">(</span>classes<span class="sym">,</span> z <span class="sym">::</span> ac<span class="sym">)</span>
		      <span class="kwa">in</span> loop <span class="sym">(</span>classes<span class="sym">, [])</span>
		      <span class="kwa">end</span><span class="sym">)</span>
	       <span class="kwa">in List</span>.fold <span class="sym">(</span>r<span class="sym">,</span> ac<span class="sym">,</span> <span class="kwa">fn</span> <span class="sym">({</span>class<span class="sym">,</span> ...<span class="sym">},</span> ac<span class="sym">) =&gt;</span>
			     <span class="kwa">case</span> class <span class="kwa">of</span>
				<span class="sym">[</span>_<span class="sym">] =&gt;</span> ac
			      <span class="sym">|</span> _ <span class="sym">=&gt;</span> class <span class="sym">::</span> ac<span class="sym">)</span>
	       <span class="kwa">end</span>
	    <span class="kwa">fun</span> refineAll <span class="sym">(</span>classes<span class="sym">:</span> classes<span class="sym">):</span> unit <span class="sym">=</span>
	       <span class="kwa">case</span> classes <span class="kwa">of</span>
		  <span class="sym">[] =&gt; ()</span>
		<span class="sym">|</span> _ <span class="sym">=&gt;</span>
		     <span class="kwa">let</span>
			<span class="kwa">val</span> _ <span class="sym">=</span> change <span class="sym">:=</span> <span class="kwa">false</span>
			<span class="kwa">val</span> classes <span class="sym">=</span>
			   <span class="kwa">List</span>.fold <span class="sym">(</span>classes<span class="sym">, [],</span> <span class="kwa">fn</span> <span class="sym">(</span>class<span class="sym">,</span> ac<span class="sym">) =&gt;</span>
				      <span class="kwa">case</span> class <span class="kwa">of</span>
					 <span class="sym">[</span>_<span class="sym">] =&gt;</span> ac
				       <span class="sym">|</span> _ <span class="sym">=&gt;</span> refine <span class="sym">(</span>class<span class="sym">,</span> ac<span class="sym">))</span>
		     <span class="kwa">in if</span> <span class="sym">!</span>change
			   <span class="kwa">then</span> refineAll classes
			<span class="kwa">else</span> <span class="sym">()</span>
		     <span class="kwa">end</span>
	    <span class="kwa">val</span> <span class="sym">(</span>fin<span class="sym">,</span> nonfin<span class="sym">) =</span>
	       <span class="kwa">Int</span>.fold <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> numStates<span class="sym">, ([], []),</span> <span class="kwa">fn</span> <span class="sym">(</span>i<span class="sym">, (</span>f<span class="sym">,</span> n<span class="sym">)) =&gt;</span>
			 <span class="kwa">if</span> Array.sub <span class="sym">(</span>final<span class="sym">,</span> i<span class="sym">)</span>
			    <span class="kwa">then</span> <span class="sym">(</span>i <span class="sym">::</span> f<span class="sym">,</span> n<span class="sym">)</span>
			 <span class="kwa">else</span> <span class="sym">(</span>f<span class="sym">,</span> i <span class="sym">::</span> n<span class="sym">))</span>
	    <span class="kwa">val</span> _ <span class="sym">=</span> refineAll <span class="sym">[</span>fin<span class="sym">,</span> nonfin<span class="sym">]</span>
	    <span class="kwa">val</span> numStates' <span class="sym">=</span> <span class="num">1</span> <span class="sym">+ !</span>repCounter
	    <span class="com">(* Compute reachable states. *)</span>
	    <span class="kwa">val</span> reached <span class="sym">=</span> Array.new <span class="sym">(</span>numStates'<span class="sym">,</span> <span class="kwa">false</span><span class="sym">)</span>
	    <span class="kwa">fun</span> visit <span class="sym">(</span>s<span class="sym">:</span> <span class="kwb">int</span> <span class="com">(* an old state *)</span><span class="sym">):</span> unit <span class="sym">=</span>
	       <span class="kwa">let</span>
		  <span class="kwa">val</span> s' <span class="sym">=</span> rep s
	       <span class="kwa">in</span>
		  <span class="kwa">if</span> Array.sub <span class="sym">(</span>reached<span class="sym">,</span> s'<span class="sym">)</span>
		     <span class="kwa">then</span> <span class="sym">()</span>
		  <span class="kwa">else</span> <span class="sym">(</span>Array.update <span class="sym">(</span>reached<span class="sym">,</span> s'<span class="sym">,</span> <span class="kwa">true</span><span class="sym">)</span>
			<span class="sym">;</span> <span class="kwa">Int</span>.for <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> numChars<span class="sym">,</span> <span class="kwa">fn</span> c <span class="sym">=&gt;</span>
				   visit <span class="sym">(</span>Array2.sub <span class="sym">(</span>next<span class="sym">,</span> s<span class="sym">,</span> c<span class="sym">))))</span>
	       <span class="kwa">end</span>
	    <span class="kwa">val</span> _ <span class="sym">=</span> visit start
	    <span class="kwa">val</span> _ <span class="sym">=</span> visit anchorStart
	    <span class="com">(* Compute new representatives. *)</span>
	    <span class="kwa">val</span> c <span class="sym">=</span> ref ~<span class="num">1</span>
	    <span class="kwa">val</span> newR <span class="sym">=</span> Array.tabulate <span class="sym">(</span>numStates'<span class="sym">,</span> <span class="kwa">fn</span> s <span class="sym">=&gt;</span>
				       <span class="kwa">if</span> Array.sub <span class="sym">(</span>reached<span class="sym">,</span> s<span class="sym">)</span>
					  <span class="kwa">then</span> <span class="sym">++</span> c
				       <span class="kwa">else</span> ~<span class="num">1</span><span class="sym">)</span>
	    <span class="kwa">val</span> numStates' <span class="sym">=</span> <span class="num">1</span> <span class="sym">+ !</span>c
	    <span class="kwa">val</span> _ <span class="sym">=</span> Array.modify <span class="sym">(</span>r<span class="sym">,</span> <span class="kwa">fn</span> s <span class="sym">=&gt;</span> Array.sub <span class="sym">(</span>newR<span class="sym">,</span> s<span class="sym">))</span>
	    <span class="kwa">val</span> next' <span class="sym">=</span> Array2.new <span class="sym">(</span>numStates'<span class="sym">,</span> numChars<span class="sym">,</span> ~<span class="num">1</span><span class="sym">)</span>
	    <span class="kwa">val</span> _ <span class="sym">=</span>
	       Array2.foreachi
	       <span class="sym">(</span>next<span class="sym">,</span> <span class="kwa">fn</span> <span class="sym">(</span>s<span class="sym">,</span> c<span class="sym">,</span> s'<span class="sym">) =&gt;</span>
		Array2.update <span class="sym">(</span>next'<span class="sym">,</span> rep s<span class="sym">,</span> c<span class="sym">,</span> rep s'<span class="sym">))</span>
	    <span class="kwa">val</span> final' <span class="sym">=</span> Array.array <span class="sym">(</span>numStates'<span class="sym">,</span> <span class="kwa">false</span><span class="sym">)</span>
	    <span class="kwa">val</span> _ <span class="sym">=</span>
	       Array.foreachi
	       <span class="sym">(</span>final<span class="sym">,</span> <span class="kwa">fn</span> <span class="sym">(</span>i<span class="sym">,</span> b<span class="sym">) =&gt;</span>
		<span class="kwa">if</span> b <span class="kwa">then</span> Array.update <span class="sym">(</span>final'<span class="sym">,</span> rep i<span class="sym">,</span> <span class="kwa">true</span><span class="sym">)</span> <span class="kwa">else</span> <span class="sym">())</span>
	 <span class="kwa">in</span> T <span class="sym">{</span>anchorStart <span class="sym">=</span> rep anchorStart<span class="sym">,</span>
	       dead <span class="sym">=</span> dead <span class="sym">(</span>numStates'<span class="sym">,</span> final'<span class="sym">,</span> next'<span class="sym">),</span>
	       final <span class="sym">=</span> final'<span class="sym">,</span>
	       start <span class="sym">=</span> rep start<span class="sym">,</span>
	       next <span class="sym">=</span> next'<span class="sym">}</span>
	 <span class="kwa">end</span>

      <span class="com">(* This is the usual &quot;subset construction&quot;, as in algorithm 3.2 (page 118)</span>
<span class="com">       * of Compilers: Principles, Techniques, and Tools by Aho, Sethi, and</span>
<span class="com">       * Ullman.</span>
<span class="com">       *</span>
<span class="com">       * It associates each (reachable) set of states in the nfa with a single</span>
<span class="com">       * state in the DFA.</span>
<span class="com">       *)</span>
      <span class="kwa">fun</span> fromNFA <span class="sym">(</span>nfa <span class="kwa">as</span> NFA.T <span class="sym">{</span>anchorStarts<span class="sym">,</span> final<span class="sym">,</span> start<span class="sym">,</span> next<span class="sym">,</span> ...<span class="sym">}) =</span>
	 <span class="kwa">let</span>
	    <span class="com">(* Sets of states are represented as sorted vectors. *)</span>
	    <span class="kwa">type</span> states <span class="sym">=</span> state vector
	    <span class="kwa">val</span> counter <span class="sym">=</span> ref ~<span class="num">1</span>
	    <span class="kwa">type</span> work <span class="sym">= {</span>states<span class="sym">:</span> states<span class="sym">,</span>
			 state<span class="sym">:</span> <span class="kwb">int</span><span class="sym">,</span>
			 out<span class="sym">:</span> <span class="kwb">int</span> vector option ref<span class="sym">}</span>
	    <span class="kwa">val</span> cache<span class="sym">:</span> work list ref <span class="sym">=</span> ref <span class="sym">[]</span>
	    <span class="kwa">val</span> todo<span class="sym">:</span> work list ref <span class="sym">=</span> ref <span class="sym">[]</span>
	    <span class="kwa">fun</span> statesToState <span class="sym">(</span>ss<span class="sym">:</span> states<span class="sym">):</span> <span class="kwb">int</span> <span class="sym">=</span>
	       <span class="kwa">case List</span>.peek <span class="sym">(!</span>cache<span class="sym">,</span> <span class="kwa">fn</span> <span class="sym">{</span>states<span class="sym">,</span> ...<span class="sym">} =&gt;</span> ss <span class="sym">=</span> states<span class="sym">)</span> <span class="kwa">of</span>
		  NONE <span class="sym">=&gt;</span>
		     <span class="kwa">let</span>
			<span class="kwa">val</span> state <span class="sym">= ++</span> counter
			<span class="kwa">val</span> work <span class="sym">= {</span>out <span class="sym">=</span> ref NONE<span class="sym">,</span>
				    state <span class="sym">=</span> state<span class="sym">,</span>
				    states <span class="sym">=</span> ss<span class="sym">}</span>
			<span class="kwa">val</span> _ <span class="sym">=</span> <span class="kwa">List</span>.push <span class="sym">(</span>cache<span class="sym">,</span> work<span class="sym">)</span>
			<span class="kwa">val</span> _ <span class="sym">=</span> <span class="kwa">List</span>.push <span class="sym">(</span>todo<span class="sym">,</span> work<span class="sym">)</span>
		     <span class="kwa">in</span>
			state
		     <span class="kwa">end</span>
		<span class="sym">|</span> SOME <span class="sym">{</span>state<span class="sym">,</span> ...<span class="sym">} =&gt;</span> state
	    <span class="kwa">local</span>
	       <span class="kwa">val</span> seen <span class="sym">=</span> Array.array <span class="sym">(</span>NFA.numStates nfa<span class="sym">,</span> <span class="kwa">false</span><span class="sym">)</span>
	    <span class="kwa">in</span>
	       <span class="kwa">fun</span> loop <span class="sym">() =</span>
		  <span class="kwa">case</span> <span class="sym">!</span>todo <span class="kwa">of</span>
		     <span class="sym">[] =&gt; ()</span>
		   <span class="sym">| {</span>states<span class="sym">,</span> out<span class="sym">,</span> ...<span class="sym">} ::</span> rest <span class="sym">=&gt;</span>
			<span class="sym">(</span>todo <span class="sym">:=</span> rest
			 <span class="sym">;</span> out <span class="sym">:= (</span>SOME
				   <span class="sym">(</span><span class="kwa">Vector</span>.tabulate
				    <span class="sym">(</span>numChars<span class="sym">,</span> <span class="kwa">fn</span> c <span class="sym">=&gt;</span>
				     <span class="kwa">let</span>
					<span class="kwa">val</span> _ <span class="sym">=</span>
					   Array.modify <span class="sym">(</span>seen<span class="sym">,</span> <span class="kwa">fn</span> _ <span class="sym">=&gt;</span> <span class="kwa">false</span><span class="sym">)</span>
					<span class="kwa">val</span> _ <span class="sym">=</span>
					   <span class="kwa">Vector</span>.foreach
					   <span class="sym">(</span>states<span class="sym">,</span> <span class="kwa">fn</span> s <span class="sym">=&gt;</span>
					    <span class="kwa">Vector</span>.foreach
					    <span class="sym">(</span>Array2.sub <span class="sym">(</span>next<span class="sym">,</span> s<span class="sym">,</span> c<span class="sym">),</span> <span class="kwa">fn</span> s' <span class="sym">=&gt;</span>
					     Array.update <span class="sym">(</span>seen<span class="sym">,</span> s'<span class="sym">,</span> <span class="kwa">true</span><span class="sym">)))</span>
				     <span class="kwa">in</span> statesToState <span class="sym">(</span>Array.indices seen<span class="sym">)</span>
				     <span class="kwa">end</span><span class="sym">)))</span>
			 <span class="sym">;</span> loop <span class="sym">())</span>
	    <span class="kwa">end</span>
	    <span class="com">(* This call to statesToState initializes the worklist. *)</span>
	    <span class="kwa">val</span> start' <span class="sym">=</span> statesToState <span class="sym">(</span><span class="kwa">Vector</span>.new1 start<span class="sym">)</span>
	    <span class="kwa">val</span> anchorStart' <span class="sym">=</span>
	       statesToState
	       <span class="sym">(</span><span class="kwa">Vector</span>.fromList <span class="sym">(</span><span class="kwa">List</span>.insert <span class="sym">(</span>anchorStarts<span class="sym">,</span> start<span class="sym">,</span> <span class="kwa">op</span> <span class="sym">&lt;=)))</span>
	    <span class="kwa">val</span> _ <span class="sym">=</span> loop <span class="sym">()</span>
	    <span class="kwa">val</span> numStates <span class="sym">=</span> <span class="num">1</span> <span class="sym">+ !</span>counter
	    <span class="kwa">val</span> next' <span class="sym">=</span> Array2.new <span class="sym">(</span>numStates<span class="sym">,</span> numChars<span class="sym">,</span> ~<span class="num">1</span><span class="sym">)</span>
	    <span class="kwa">val</span> final' <span class="sym">=</span> Array.new <span class="sym">(</span>numStates<span class="sym">,</span> <span class="kwa">false</span><span class="sym">)</span>
	    <span class="kwa">val</span> _ <span class="sym">=</span>
	       <span class="kwa">List</span>.foreach
	       <span class="sym">(!</span>cache<span class="sym">,</span> <span class="kwa">fn</span> <span class="sym">{</span>states<span class="sym">,</span> state <span class="sym">=</span> i<span class="sym">,</span> out<span class="sym">,</span> ...<span class="sym">}:</span> work <span class="sym">=&gt;</span>
		<span class="kwa">let</span>
		   <span class="kwa">val</span> _ <span class="sym">=</span>
		      <span class="kwa">Vector</span>.foreachi
		      <span class="sym">(</span>valOf <span class="sym">(!</span> out<span class="sym">),</span> <span class="kwa">fn</span> <span class="sym">(</span>c<span class="sym">,</span> j<span class="sym">) =&gt;</span>
		       Array2.update <span class="sym">(</span>next'<span class="sym">,</span> i<span class="sym">,</span> c<span class="sym">,</span> j<span class="sym">))</span>
		   <span class="kwa">val</span> _ <span class="sym">=</span>
		      <span class="kwa">if Vector</span>.exists <span class="sym">(</span>states<span class="sym">,</span> <span class="kwa">fn</span> s <span class="sym">=&gt;</span> Array.sub <span class="sym">(</span>final<span class="sym">,</span> s<span class="sym">))</span>
			 <span class="kwa">then</span> Array.update <span class="sym">(</span>final'<span class="sym">,</span> i<span class="sym">,</span> <span class="kwa">true</span><span class="sym">)</span>
		      <span class="kwa">else</span> <span class="sym">()</span>
		<span class="kwa">in</span> <span class="sym">()</span>
		<span class="kwa">end</span><span class="sym">)</span>
	    <span class="kwa">val</span> dead' <span class="sym">=</span> dead <span class="sym">(</span>numStates<span class="sym">,</span> final'<span class="sym">,</span> next'<span class="sym">)</span>
	 <span class="kwa">in</span> T <span class="sym">{</span>anchorStart <span class="sym">=</span> anchorStart'<span class="sym">,</span>
	       dead <span class="sym">=</span> dead'<span class="sym">,</span>
	       final <span class="sym">=</span> final'<span class="sym">,</span>
	       start <span class="sym">=</span> start'<span class="sym">,</span>
	       next <span class="sym">=</span> next'<span class="sym">}</span>
	 <span class="kwa">end</span>

   <span class="kwa">end</span>

<span class="kwa">structure</span> Regexp<span class="sym">:</span>
   <span class="kwa">sig</span>
      <span class="kwa">structure</span> Compiled<span class="sym">:</span>
	 <span class="kwa">sig</span>
	    <span class="kwa">type</span> t

	    <span class="com">(* find returns the longest of the leftmost matches. *)</span>
	    <span class="kwa">val</span> find<span class="sym">:</span> t <span class="sym">*</span> <span class="kwb">string</span> <span class="sym">-&gt; {</span>start<span class="sym">:</span> <span class="kwb">int</span><span class="sym">,</span> length<span class="sym">:</span> <span class="kwb">int</span><span class="sym">}</span> option
	 <span class="kwa">end</span>

      <span class="kwa">type</span> t

      <span class="kwa">val</span> anchorStart<span class="sym">:</span> t
      <span class="kwa">val</span> any<span class="sym">:</span> t
      <span class="kwa">val</span> char<span class="sym">:</span> char <span class="sym">-&gt;</span> t
      <span class="kwa">val</span> compileDFA<span class="sym">:</span> t <span class="sym">-&gt;</span> Compiled.t
      <span class="kwa">val</span> compileNFA<span class="sym">:</span> t <span class="sym">-&gt;</span> Compiled.t
      <span class="kwa">val</span> digit<span class="sym">:</span> t
      <span class="kwa">val</span> nonDigit<span class="sym">:</span> t
      <span class="kwa">val</span> notOneOf<span class="sym">:</span> <span class="kwb">string</span> <span class="sym">-&gt;</span> t
      <span class="kwa">val</span> oneOf<span class="sym">:</span> <span class="kwb">string</span> <span class="sym">-&gt;</span> t
      <span class="kwa">val</span> or<span class="sym">:</span> t list <span class="sym">-&gt;</span> t
      <span class="kwa">val</span> seq<span class="sym">:</span> t list <span class="sym">-&gt;</span> t
      <span class="kwa">val</span> star<span class="sym">:</span> t <span class="sym">-&gt;</span> t
   <span class="kwa">end</span> <span class="sym">=</span>
   <span class="kwa">struct</span>
      <span class="kwa">open</span> Regexp

      <span class="kwa">val</span> anchorStart <span class="sym">=</span> AnchorStart
      <span class="kwa">val</span> isChar <span class="sym">=</span> CharSet
      <span class="kwa">fun</span> isNotChar f <span class="sym">=</span> isChar <span class="sym">(</span>not <span class="kwa">o</span> f<span class="sym">)</span>
      <span class="kwa">fun</span> char c <span class="sym">=</span> isChar <span class="sym">(</span><span class="kwa">fn</span> c' <span class="sym">=&gt;</span> c <span class="sym">=</span> c'<span class="sym">)</span>
      <span class="kwa">val</span> or <span class="sym">=</span> Or
      <span class="kwa">val</span> seq <span class="sym">=</span> Seq
      <span class="kwa">val</span> star <span class="sym">=</span> Star

      <span class="kwa">val</span> any <span class="sym">=</span> isChar <span class="sym">(</span><span class="kwa">fn</span> _ <span class="sym">=&gt;</span> <span class="kwa">true</span><span class="sym">)</span>

      <span class="kwa">fun</span> oneOf s <span class="sym">=</span> isChar <span class="sym">(</span><span class="kwa">fn</span> c <span class="sym">=&gt;</span> <span class="kwa">String</span>.contains <span class="sym">(</span>s<span class="sym">,</span> c<span class="sym">))</span>
      <span class="kwa">fun</span> notOneOf s <span class="sym">=</span> isNotChar <span class="sym">(</span><span class="kwa">fn</span> c <span class="sym">=&gt;</span> <span class="kwa">String</span>.contains <span class="sym">(</span>s<span class="sym">,</span> c<span class="sym">))</span>
      <span class="kwa">val</span> digs <span class="sym">=</span> <span class="str">&quot;0123456789&quot;</span>
      <span class="kwa">val</span> digit <span class="sym">=</span> oneOf digs
      <span class="kwa">val</span> nonDigit <span class="sym">=</span> notOneOf digs

      <span class="kwa">val</span> empty <span class="sym">=</span> Or <span class="sym">[]</span> <span class="com">(* Empty Language. *)</span>
      <span class="kwa">val</span> emptyString <span class="sym">=</span> Seq <span class="sym">[]</span> <span class="com">(* Language containing the empty string only. *)</span>


      <span class="kwa">structure</span> Compiled <span class="sym">=</span>
	 <span class="kwa">struct</span>
	    <span class="kwa">datatype</span> t <span class="sym">=</span>
	       DFA <span class="kwa">of</span> DFA.t
	     <span class="sym">|</span> NFA <span class="kwa">of</span> NFA.t

	    <span class="kwa">fun</span> find <span class="sym">(</span>c<span class="sym">:</span> t<span class="sym">,</span> s<span class="sym">:</span> <span class="kwb">string</span><span class="sym">) =</span>
	       <span class="kwa">let</span>
		  <span class="kwa">val</span> n <span class="sym">=</span> <span class="kwa">String</span>.size s
		  <span class="kwa">fun</span> loop <span class="sym">(</span>i<span class="sym">:</span> <span class="kwb">int</span><span class="sym">,</span> anchorStart<span class="sym">:</span> <span class="kwb">bool</span><span class="sym">) =</span>
		     <span class="kwa">if</span> i <span class="sym">=</span> n
			<span class="kwa">then</span> NONE
		     <span class="kwa">else</span>
			<span class="kwa">let</span>
			   <span class="kwa">val</span> res <span class="sym">=</span>
			      <span class="kwa">case</span> c <span class="kwa">of</span>
				 DFA dfa <span class="sym">=&gt;</span>
				    DFA.match <span class="sym">{</span>dfa <span class="sym">=</span> dfa<span class="sym">,</span>
					       <span class="kwb">string</span> <span class="sym">=</span> s<span class="sym">,</span>
					       startPos <span class="sym">=</span> i<span class="sym">,</span>
					       anchorStart <span class="sym">=</span> anchorStart<span class="sym">}</span>
			       <span class="sym">|</span> NFA nfa <span class="sym">=&gt;</span>
				    NFA.match <span class="sym">{</span>nfa <span class="sym">=</span> nfa<span class="sym">,</span>
					       <span class="kwb">string</span> <span class="sym">=</span> s<span class="sym">,</span>
					       startPos <span class="sym">=</span> i<span class="sym">,</span>
					       anchorStart <span class="sym">=</span> anchorStart<span class="sym">}</span>
			<span class="kwa">in</span>
			   <span class="kwa">case</span> res <span class="kwa">of</span>
			      NONE <span class="sym">=&gt;</span> loop <span class="sym">(</span>i <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> <span class="kwa">false</span><span class="sym">)</span>
			    <span class="sym">|</span> SOME finish <span class="sym">=&gt;</span> SOME <span class="sym">{</span>start <span class="sym">=</span> i<span class="sym">,</span>
						   length <span class="sym">=</span> finish <span class="sym">-</span> i<span class="sym">}</span>
			<span class="kwa">end</span>
	       <span class="kwa">in</span> loop <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> <span class="kwa">true</span><span class="sym">)</span>
	       <span class="kwa">end</span>
	 <span class="kwa">end</span>

      <span class="kwa">fun</span> compileDFA r <span class="sym">=</span>
	 Compiled.DFA <span class="sym">(</span>DFA.minimize <span class="sym">(</span>DFA.fromNFA <span class="sym">(</span>NFA.fromRegexp r<span class="sym">)))</span>
      <span class="kwa">fun</span> compileNFA r <span class="sym">=</span>
	 Compiled.NFA <span class="sym">(</span>NFA.fromRegexp r<span class="sym">)</span>
   <span class="kwa">end</span>

<span class="kwa">local</span>
   <span class="kwa">open</span> Regexp
<span class="kwa">in</span>
   <span class="kwa">val</span> d <span class="sym">=</span> digit
   <span class="kwa">val</span> eol <span class="sym">=</span> char #<span class="str">&quot;#&quot;</span>
   <span class="kwa">val</span> space <span class="sym">=</span> oneOf <span class="str">&quot;</span> <span class="esc">\t</span><span class="str">&quot;</span>
   <span class="kwa">val</span> r <span class="sym">=</span>
      seq <span class="sym">[</span>or <span class="sym">[</span>anchorStart<span class="sym">,</span> notOneOf <span class="str">&quot;0123456789(&quot;</span><span class="sym">],</span>
	   or <span class="sym">[</span>seq <span class="sym">[</span>char #<span class="str">&quot;(&quot;</span><span class="sym">,</span> d<span class="sym">,</span> d<span class="sym">,</span> d<span class="sym">,</span> char #<span class="str">&quot;)&quot;</span><span class="sym">],</span>
	       seq <span class="sym">[</span>d<span class="sym">,</span> d<span class="sym">,</span> d<span class="sym">]],</span>
	   char #<span class="str">&quot; &quot;</span><span class="sym">,</span>
	   d<span class="sym">,</span> d<span class="sym">,</span> d<span class="sym">,</span>
	   oneOf <span class="str">&quot; -&quot;</span><span class="sym">,</span>
	   d<span class="sym">,</span> d<span class="sym">,</span> d<span class="sym">,</span> d<span class="sym">,</span>
	   or <span class="sym">[</span>eol<span class="sym">,</span> nonDigit<span class="sym">]]</span>
<span class="com">(*   val comp = Regexp.compileNFA r *)</span>
   <span class="kwa">val</span> comp <span class="sym">=</span> Regexp.compileDFA r
<span class="kwa">end</span>

<span class="kwa">fun</span> incr <span class="sym">(</span>r<span class="sym">:</span> <span class="kwb">int</span> ref<span class="sym">) =</span> r <span class="sym">:= !</span>r <span class="sym">+</span> <span class="num">1</span>

<span class="kwa">val</span> ins <span class="sym">=</span> <span class="kwa">TextIO</span>.stdIn

<span class="kwa">val</span> phones <span class="sym">=</span>
   <span class="kwa">let</span>
      <span class="kwa">fun</span> loop lines <span class="sym">=</span>
	 <span class="kwa">case TextIO</span>.inputLine ins <span class="kwa">of</span>
	    NONE <span class="sym">=&gt;</span> rev lines
	  <span class="sym">|</span> SOME<span class="sym">(</span>str<span class="sym">) =&gt;</span>
	    <span class="sym">(</span><span class="kwa">case</span> str <span class="kwa">of</span>
	        <span class="str">&quot;&quot;</span> <span class="sym">=&gt;</span> rev lines
	      <span class="sym">|</span> line <span class="sym">=&gt;</span> loop <span class="sym">(</span>line <span class="sym">::</span> lines<span class="sym">))</span>
   <span class="kwa">in</span> loop <span class="sym">[]</span>
   <span class="kwa">end</span>

<span class="kwa">fun</span> printl <span class="sym">[] =</span> print <span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span> <span class="sym">|</span> printl<span class="sym">(</span>h<span class="sym">::</span>t<span class="sym">) = (</span> print h <span class="sym">;</span> printl t <span class="sym">)</span>

<span class="com">(* Based on regexmatch.ocaml. *)</span>

<span class="kwa">local</span>
   <span class="kwa">val</span> form <span class="sym">=</span> <span class="str">&quot;(...) ...-....&quot;</span>
   <span class="kwa">val</span> a <span class="sym">=</span> CharArray.tabulate <span class="sym">(</span><span class="kwa">String</span>.size form<span class="sym">,</span> <span class="kwa">fn</span> i <span class="sym">=&gt;</span>
			       <span class="kwa">String</span>.sub <span class="sym">(</span>form<span class="sym">,</span> i<span class="sym">))</span>
<span class="kwa">in</span>
   <span class="kwa">fun</span> checkPhone <span class="sym">(</span>mustPrint<span class="sym">:</span> <span class="kwb">bool</span><span class="sym">,</span> cnt<span class="sym">:</span> <span class="kwb">int</span> ref<span class="sym">,</span> line<span class="sym">:</span> <span class="kwb">string</span><span class="sym">) =</span>
      <span class="kwa">case</span> Regexp.Compiled.find <span class="sym">(</span>comp<span class="sym">,</span> line<span class="sym">)</span> <span class="kwa">of</span>
	 NONE <span class="sym">=&gt; ()</span>
       <span class="sym">|</span> SOME <span class="sym">{</span>start <span class="sym">=</span> pos<span class="sym">,</span> ...<span class="sym">} =&gt;</span>
	    <span class="kwa">let</span>
	       <span class="kwa">fun</span> blit <span class="sym">(</span>src<span class="sym">,</span> dst<span class="sym">,</span> length<span class="sym">) =</span>
		  <span class="kwa">let</span>
		     <span class="kwa">val</span> stop <span class="sym">=</span> src <span class="sym">+</span> length
		     <span class="kwa">fun</span> loop <span class="sym">(</span>src<span class="sym">,</span> dst<span class="sym">) =</span>
			<span class="kwa">if</span> src <span class="sym">=</span> stop
			   <span class="kwa">then</span> <span class="sym">()</span>
			<span class="kwa">else</span> <span class="sym">(</span>CharArray.update <span class="sym">(</span>a<span class="sym">,</span> dst<span class="sym">,</span>
						<span class="kwa">String</span>.sub <span class="sym">(</span>line<span class="sym">,</span> src<span class="sym">))</span>
			      <span class="sym">;</span> loop <span class="sym">(</span>src <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> dst <span class="sym">+</span> <span class="num">1</span><span class="sym">))</span>
		  <span class="kwa">in</span>
		     loop <span class="sym">(</span>src<span class="sym">,</span> dst<span class="sym">)</span>
		  <span class="kwa">end</span>
	       <span class="kwa">val</span> <span class="sym">(</span>o1<span class="sym">,</span> o2<span class="sym">,</span> o3<span class="sym">) =</span>
		  <span class="kwa">if</span> #<span class="str">&quot;(&quot;</span> <span class="sym">=</span> <span class="kwa">String</span>.sub <span class="sym">(</span>line<span class="sym">,</span> pos<span class="sym">)</span>
		     <span class="kwa">then</span> <span class="sym">(</span><span class="num">1</span><span class="sym">,</span> <span class="num">6</span><span class="sym">,</span> <span class="num">10</span><span class="sym">)</span>
		  <span class="kwa">else if</span> #<span class="str">&quot;(&quot;</span> <span class="sym">=</span> <span class="kwa">String</span>.sub <span class="sym">(</span>line<span class="sym">,</span> pos <span class="sym">+</span> <span class="num">1</span><span class="sym">)</span>
			  <span class="kwa">then</span> <span class="sym">(</span><span class="num">2</span><span class="sym">,</span> <span class="num">7</span><span class="sym">,</span> <span class="num">11</span><span class="sym">)</span>
		       <span class="kwa">else if Char</span>.isDigit <span class="sym">(</span><span class="kwa">String</span>.sub <span class="sym">(</span>line<span class="sym">,</span> pos<span class="sym">))</span>
			       <span class="kwa">then</span> <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> <span class="num">4</span><span class="sym">,</span> <span class="num">8</span><span class="sym">)</span>
			    <span class="kwa">else</span> <span class="sym">(</span><span class="num">1</span><span class="sym">,</span> <span class="num">5</span><span class="sym">,</span> <span class="num">9</span><span class="sym">)</span>
	       <span class="kwa">val</span> _ <span class="sym">=</span> blit <span class="sym">(</span>pos <span class="sym">+</span> o1<span class="sym">,</span> <span class="num">1</span><span class="sym">,</span> <span class="num">3</span><span class="sym">)</span>
	       <span class="kwa">val</span> _ <span class="sym">=</span> blit <span class="sym">(</span>pos <span class="sym">+</span> o2<span class="sym">,</span> <span class="num">6</span><span class="sym">,</span> <span class="num">3</span><span class="sym">)</span>
	       <span class="kwa">val</span> _ <span class="sym">=</span> blit <span class="sym">(</span>pos <span class="sym">+</span> o3<span class="sym">,</span> <span class="num">10</span><span class="sym">,</span> <span class="num">4</span><span class="sym">)</span>
	       <span class="kwa">val</span> _ <span class="sym">=</span>
		  <span class="kwa">if</span> mustPrint
		     <span class="kwa">then</span> printl <span class="sym">[</span><span class="kwa">Int</span>.toString <span class="sym">(!</span>cnt<span class="sym">),</span> <span class="str">&quot;: &quot;</span><span class="sym">,</span> CharArray.vector a<span class="sym">]</span>
		  <span class="kwa">else</span> <span class="sym">()</span>
	       <span class="kwa">val</span> _ <span class="sym">=</span> incr cnt
	    <span class="kwa">in</span>
	       <span class="sym">()</span>
	    <span class="kwa">end</span>
<span class="kwa">end</span>

<span class="kwa">fun</span> doit <span class="sym">(</span>mustPrint<span class="sym">:</span> <span class="kwb">bool</span><span class="sym">):</span> unit <span class="sym">=</span>
   <span class="kwa">let</span>
      <span class="kwa">val</span> cnt <span class="sym">=</span> ref <span class="num">1</span>
   <span class="kwa">in</span>
      <span class="kwa">List</span>.foreach <span class="sym">(</span>phones<span class="sym">,</span> <span class="kwa">fn</span> line <span class="sym">=&gt;</span> checkPhone <span class="sym">(</span>mustPrint<span class="sym">,</span> cnt<span class="sym">,</span> line<span class="sym">))</span>
   <span class="kwa">end</span>

<span class="kwa">fun</span> atoi s <span class="sym">=</span> <span class="kwa">case Int</span>.fromString s <span class="kwa">of</span> SOME num <span class="sym">=&gt;</span> num <span class="sym">|</span> NONE <span class="sym">=&gt;</span> <span class="num">0</span>

<span class="kwa">fun</span> main <span class="sym">(</span>name<span class="sym">,</span> args<span class="sym">) =</span>
   <span class="kwa">let</span>
      <span class="kwa">val</span> n <span class="sym">=</span> atoi <span class="sym">(</span>hd <span class="sym">(</span>args &#64; <span class="sym">[</span><span class="str">&quot;1&quot;</span><span class="sym">]))</span>
      <span class="kwa">val</span> _ <span class="sym">=</span> <span class="kwa">Int</span>.for <span class="sym">(</span><span class="num">1</span><span class="sym">,</span> n<span class="sym">,</span> <span class="kwa">fn</span> _ <span class="sym">=&gt;</span> doit <span class="kwa">false</span><span class="sym">)</span>
      <span class="kwa">val</span> _ <span class="sym">=</span> doit <span class="kwa">true</span>
   <span class="kwa">in</span> <span class="sym">()</span>
   <span class="kwa">end</span>

<span class="kwa">val</span> _ <span class="sym">=</span> main<span class="sym">(</span> CommandLine.name<span class="sym">(),</span> CommandLine.arguments<span class="sym">() )</span>
