<span class="com">(*
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Fast version. Contributed by Jon Harrop, 2005
 * Compile: ocamlopt -ffast-math -inline 100 raytracer.ocaml -o raytracer
 *)</span>

<span class="kwa">let</span> delta <span class="sym">=</span> sqrt epsilon_float
<span class="kwa">type</span> vec <span class="sym">= {</span>x<span class="sym">:</span><span class="kwb">float</span><span class="sym">;</span> y<span class="sym">:</span><span class="kwb">float</span><span class="sym">;</span> z<span class="sym">:</span><span class="kwb">float</span><span class="sym">}
</span><span class="kwa">let</span> <span class="sym">( *| )</span> s r <span class="sym">= {</span>x <span class="sym">=</span> s <span class="sym">*</span>. r.x<span class="sym">;</span> y <span class="sym">=</span> s <span class="sym">*</span>. r.y<span class="sym">;</span> z <span class="sym">=</span> s <span class="sym">*</span>. r.z<span class="sym">}
</span><span class="kwa">let</span> <span class="sym">( +| )</span> a b <span class="sym">= {</span>x <span class="sym">=</span> a.x <span class="sym">+</span>. b.x<span class="sym">;</span> y <span class="sym">=</span> a.y <span class="sym">+</span>. b.y<span class="sym">;</span> z <span class="sym">=</span> a.z <span class="sym">+</span>. b.z<span class="sym">}
</span><span class="kwa">let</span> <span class="sym">( -| )</span> a b <span class="sym">= {</span>x <span class="sym">=</span> a.x <span class="sym">-</span>. b.x<span class="sym">;</span> y <span class="sym">=</span> a.y <span class="sym">-</span>. b.y<span class="sym">;</span> z <span class="sym">=</span> a.z <span class="sym">-</span>. b.z<span class="sym">}
</span><span class="kwa">let</span> dot a b <span class="sym">=</span> a.x <span class="sym">*</span>. b.x <span class="sym">+</span>. a.y <span class="sym">*</span>. b.y <span class="sym">+</span>. a.z <span class="sym">*</span>. b.z
<span class="kwa">let</span> unitise r <span class="sym">= (</span><span class="num">1</span>. <span class="sym">/</span>. sqrt <span class="sym">(</span>dot r r<span class="sym">)) *|</span> r <span class="kwa">and</span> length r <span class="sym">=</span> sqrt<span class="sym">(</span>dot r r<span class="sym">)
</span><span class="kwa">type</span> scene <span class="sym">=</span> Sphere <span class="kwa">of</span> vec <span class="sym">*</span> <span class="kwb">float</span> <span class="sym">|</span> Group <span class="kwa">of</span> vec <span class="sym">*</span> <span class="kwb">float</span> <span class="sym">*</span> scene list
<span class="kwa">let</span> ray_sphere orig dir center radius <span class="sym">=
</span>  <span class="kwa">let</span> v <span class="sym">=</span> center <span class="sym">-|</span> orig <span class="kwa">in
  let</span> b <span class="sym">=</span> dot v dir <span class="kwa">in
  let</span> disc <span class="sym">=</span> b <span class="sym">*</span>. b <span class="sym">-</span>. dot v v <span class="sym">+</span>. radius <span class="sym">*</span>. radius <span class="kwa">in
  if</span> disc <span class="sym">&lt;</span> <span class="num">0</span>. <span class="kwa">then</span> infinity <span class="kwa">else
    let</span> disc <span class="sym">=</span> sqrt disc <span class="kwa">in
</span>    <span class="sym">(</span><span class="kwa">fun</span> t2 <span class="sym">-&gt;</span> <span class="kwa">if</span> t2 <span class="sym">&lt;</span> <span class="num">0</span>. <span class="kwa">then</span> infinity <span class="kwa">else
</span>       <span class="sym">((</span><span class="kwa">fun</span> t1 <span class="sym">-&gt;</span> <span class="kwa">if</span> t1 <span class="sym">&gt;</span> <span class="num">0</span>. <span class="kwa">then</span> t1 <span class="kwa">else</span> t2<span class="sym">) (</span>b <span class="sym">-</span>. disc<span class="sym">))) (</span>b <span class="sym">+</span>. disc<span class="sym">)
</span><span class="kwa">let</span> ray_sphere<span class="str">' orig dir center radius =
  let v = center -| orig in
  let b = dot v dir in
  let disc = b *. b -. dot v v +. radius *. radius in
  if disc &lt; 0. then false else b +. sqrt disc &gt;= 0.
let intersect orig dir =
  let rec aux ((l, _) as first) = function
      Sphere (center, radius) -&gt;
	let l'</span> <span class="sym">=</span> ray_sphere orig dir center radius <span class="kwa">in
	if</span> l<span class="str">' &gt;= l then first else l'</span><span class="sym">,</span> unitise <span class="sym">(</span>orig <span class="sym">+|</span> l<span class="str">' *| dir -| center)
    | Group (center, radius, scenes) -&gt;
	let l'</span> <span class="sym">=</span> ray_sphere orig dir center radius <span class="kwa">in
	if</span> l<span class="str">' &gt;= l then first else List.fold_left aux first scenes in
  aux (infinity, {x=0.; y=0.; z=0.})
let intersect'</span> orig dir <span class="sym">=
</span>  <span class="kwa">let rec</span> aux <span class="sym">=</span> <span class="kwa">function
</span>      Sphere <span class="sym">(</span>center<span class="sym">,</span> radius<span class="sym">) -&gt;</span> ray_sphere<span class="str">' orig dir center radius
    | Group (center, radius, scenes) -&gt;
	ray_sphere'</span> orig dir center radius <span class="sym">&amp;&amp;</span> List.exists aux scenes <span class="kwa">in
</span>  aux
<span class="kwa">let rec</span> ray_trace light orig dir scene <span class="sym">=
</span>  <span class="kwa">let</span> lambda<span class="sym">,</span> normal <span class="sym">=</span> intersect orig dir scene <span class="kwa">in
  if</span> lambda <span class="sym">=</span> infinity <span class="kwa">then</span> <span class="num">0</span>. <span class="kwa">else
    let</span> g <span class="sym">=</span> dot normal light <span class="kwa">in
    if</span> g <span class="sym">&gt;=</span> <span class="num">0</span>. <span class="kwa">then</span> <span class="num">0</span>. <span class="kwa">else
      let</span> p <span class="sym">=</span> orig <span class="sym">+|</span> lambda <span class="sym">*|</span> dir <span class="sym">+|</span> delta <span class="sym">*|</span> normal <span class="kwa">in
      if</span> intersect<span class="str">' p (-1. *| light) scene then 0. else -. g
let rec create level c r =
  let obj = Sphere (c, r) in
  if level = 1 then obj else
    let a = 3. *. r /. sqrt 12. in
    let rec bound (c, r) = function
	Sphere (c'</span><span class="sym">,</span> r<span class="str">') -&gt; (c, max r (length (c -| c'</span><span class="sym">) +</span>. r<span class="str">'))
      | Group (_, _, l) -&gt; List.fold_left bound (c, r) l in
    let aux x'</span> z<span class="str">' = create (level - 1) (c +| {x=x'</span><span class="sym">;</span> y<span class="sym">=</span>a<span class="sym">;</span> z<span class="sym">=</span>z<span class="str">'}) (0.5 *. r) in
    let l = [obj; aux (-.a) (-.a); aux a (-.a); aux (-.a) a; aux a a] in
    let c, r = List.fold_left bound (c +| {x=0.; y=r; z=0.}, 0.) l in
    Group (c, r, l)
let () =
  let level = 6 and n = int_of_string Sys.argv.(1) in
  let scene = create level { x = 0.; y = -1.; z = 0. } 1. in
  let light = unitise {x= -1.; y= -3.; z=2.} and ss = 4 in
  Printf.printf &quot;P5</span><span class="esc">\n</span><span class="str">%d %d</span><span class="esc">\n</span><span class="str">255</span><span class="esc">\n</span><span class="str">&quot; n n;
  for y = n - 1 downto 0 do
    for x = 0 to n - 1 do
      let g = ref 0. in
      for dx = 0 to ss - 1 do
	for dy = 0 to ss - 1 do
	  let aux x d = float x -. float n /. 2. +. float d /. float ss in
	  let dir = unitise {x = aux x dx; y = aux y dy; z = float n } in
	  g := !g +. ray_trace light {x=0.; y=0.; z= -4.} dir scene
	done
      done;
      let g = 0.5 +. 255. *. !g /. float (ss*ss) in
      Printf.printf &quot;%c&quot; (char_of_int (int_of_float g))
    done
  done</span>
