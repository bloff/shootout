<span class="slc">;;; The Great Computer Language Shootout
</span><span class="slc">;;; http://shootout.alioth.debian.org/
</span><span class="slc">;;; contributed by Dima Dorfman, 2005
</span>
<span class="sym">(</span><span class="kwa">defun</span> swap<span class="sym">! (</span>a i j<span class="sym">)
  (</span>let <span class="sym">((</span>temp <span class="sym">(</span>aref a i<span class="sym">)))
    (</span>setf <span class="sym">(</span>aref a i<span class="sym">) (</span>aref a j<span class="sym">))
    (</span>setf <span class="sym">(</span>aref a j<span class="sym">)</span> temp<span class="sym">)))

(</span><span class="kwa">defun reverse</span><span class="sym">-</span>slice<span class="sym">! (</span>a i j<span class="sym">)
  (</span>declare
   <span class="sym">(</span><span class="kwa">type</span> <span class="sym">(</span>simple<span class="sym">-</span>array <span class="sym">(</span>unsigned<span class="sym">-</span>byte <span class="num">8</span><span class="sym">))</span> a<span class="sym">)
   (</span><span class="kwa">type</span> fixnum i j<span class="sym">))
  (</span>when <span class="sym">(&lt;</span> i j<span class="sym">)
    (</span>swap<span class="sym">!</span> a i <span class="sym">(</span><span class="num">1</span><span class="sym">-</span> j<span class="sym">))
    (</span><span class="kwa">reverse</span><span class="sym">-</span>slice<span class="sym">!</span> a <span class="sym">(</span><span class="num">1</span><span class="sym">+</span> i<span class="sym">) (</span><span class="num">1</span><span class="sym">-</span> j<span class="sym">))))

(</span><span class="kwa">defun</span> count<span class="sym">-</span>flips <span class="sym">(</span>p<span class="sym">)
  (</span>let <span class="sym">((</span>p <span class="sym">(</span>copy<span class="sym">-</span>seq p<span class="sym">)))
    (</span>loop until <span class="sym">(= (</span>aref p <span class="num">0</span><span class="sym">)</span> <span class="num">1</span><span class="sym">)
</span>	  do <span class="sym">(</span><span class="kwa">reverse</span><span class="sym">-</span>slice<span class="sym">!</span> p <span class="num">0</span> <span class="sym">(</span>aref p <span class="num">0</span><span class="sym">))
</span>	  count t<span class="sym">)))

(</span><span class="kwa">defun</span> folding<span class="sym">-</span>flips <span class="sym">(</span>z p<span class="sym">)
  (</span>declare <span class="sym">(</span><span class="kwa">type</span> fixnum z<span class="sym">))
  (</span><span class="kwa">max</span> <span class="sym">(</span>count<span class="sym">-</span>flips p<span class="sym">)</span> z<span class="sym">))

(</span><span class="kwa">defun</span> fold<span class="sym">-</span>permutations <span class="sym">(</span>f z n<span class="sym">)
  (</span>declare <span class="sym">(</span><span class="kwa">type</span> <span class="sym">(</span>unsigned<span class="sym">-</span>byte <span class="num">8</span><span class="sym">)</span> n<span class="sym">))
  (</span>let <span class="sym">((</span>p <span class="sym">(</span>make<span class="sym">-</span>array <span class="sym">(</span><span class="kwa">list</span> n<span class="sym">) :</span>element<span class="sym">-</span><span class="kwa">type</span> <span class="str">'(unsigned-byte 8)
		       :initial-contents (loop for i from 1 to n collect i))))
    (labels ((another (z)
	       (let ((i (loop for i from (- n 2) downto 0
			      when (&gt; (aref p (1+ i)) (aref p i)) return i)))
		 (if (null i)
		     z
		   (let ((j (loop for j from (1- n) downto 0
				  when (&gt; (aref p j) (aref p i)) return j)))
		     (swap! p i j)
		     (reverse-slice! p (1+ i) n)
		     (another (funcall f z p)))))))
      (another z))))

(defun fannkuch (n)
  (fold-permutations #'</span>folding<span class="sym">-</span>flips <span class="num">0</span> n<span class="sym">))

(</span><span class="kwa">defun</span> main <span class="sym">()
  (</span>let<span class="sym">* ((</span>args #<span class="sym">+</span>sbcl sb<span class="sym">-</span>ext<span class="sym">:*</span>posix<span class="sym">-</span>argv<span class="sym">*
</span>	       #<span class="sym">+</span>cmu extensions<span class="sym">:*</span><span class="kwa">command</span><span class="sym">-</span><span class="kwa">line</span><span class="sym">-</span>strings<span class="sym">*
</span>	       #<span class="sym">+</span>gcl si<span class="sym">::*</span><span class="kwa">command</span><span class="sym">-</span>args<span class="sym">*)
	 (</span>n <span class="sym">(</span>parse<span class="sym">-</span>integer <span class="sym">(</span><span class="kwa">car</span> <span class="sym">(</span><span class="kwa">last</span> args<span class="sym">)))))
    (</span>format t <span class="str">&quot;fannkuck(~d) = ~d~%&quot;</span> n <span class="sym">(</span>fannkuch n<span class="sym">))))</span>
