<span class="com">{-# OPTIONS -fbang-patterns #-}</span>

<span class="slc">--</span>
<span class="slc">-- The Great Computer Language Shootout</span>
<span class="slc">-- http://shootout.alioth.debian.org/</span>
<span class="slc">--</span>
<span class="slc">-- Simon Marlow</span>
<span class="slc">-- Rewritten by Don Stewart</span>
<span class="slc">--</span>

<span class="kwa">import</span> System
<span class="kwa">import</span> Data.Bits
<span class="kwa">import</span> Text.Printf

<span class="kwa">data</span> Tree <span class="sym">=</span> Nil <span class="sym">|</span> Node <span class="sym">!</span><span class="kwb">Int</span> Tree Tree

minDepth <span class="sym">=</span> <span class="num">4</span>

io s n t <span class="sym">=</span> printf <span class="str">&quot;%s of depth %d\t check: %d\n&quot;</span> s n t

main <span class="sym">=</span> <span class="kwa">do</span>
    maxDepth <span class="sym">&lt;-</span> getArgs <span class="sym">&gt;&gt;=</span> return . max <span class="sym">(</span>minDepth<span class="sym">+</span><span class="num">2</span><span class="sym">)</span> . read . head <span class="sym">::</span> IO <span class="kwb">Int</span>

    <span class="kwa">let</span> stretch <span class="sym">=</span> make <span class="num">0</span> <span class="sym">(</span>maxDepth<span class="sym">+</span><span class="num">1</span><span class="sym">)</span>
    io <span class="str">&quot;stretch tree&quot;</span> <span class="sym">(</span>maxDepth<span class="sym">+</span><span class="num">1</span><span class="sym">) (</span>check stretch<span class="sym">)</span>

    <span class="kwa">let</span> long    <span class="sym">=</span> make <span class="num">0</span> maxDepth

    <span class="kwa">let</span> vs <span class="sym">=</span> depth minDepth maxDepth
    mapM_ <span class="sym">(</span>\<span class="sym">(</span>P m d i<span class="sym">) -&gt;</span> io <span class="sym">(</span>show m <span class="sym">++</span> <span class="str">&quot;\t trees&quot;</span><span class="sym">)</span> d i<span class="sym">)</span> vs

    io <span class="str">&quot;long lived tree&quot;</span> maxDepth <span class="sym">(</span>check long<span class="sym">)</span>

<span class="kwa">data</span> P <span class="sym">=</span> P <span class="sym">!</span><span class="kwb">Int</span> <span class="sym">!</span><span class="kwb">Int</span> <span class="sym">!</span><span class="kwb">Int</span>

depth <span class="sym">::</span> <span class="kwb">Int</span> <span class="sym">-&gt;</span> <span class="kwb">Int</span> <span class="sym">-&gt; [</span>P<span class="sym">]</span>
depth <span class="sym">!</span>d <span class="sym">!</span>m
    <span class="sym">|</span> d <span class="sym">&gt;</span> m     <span class="sym">= []</span>
    <span class="sym">|</span> otherwise <span class="sym">=</span> P <span class="sym">(</span><span class="num">2</span><span class="sym">*</span>n<span class="sym">)</span> d <span class="sym">(</span>sumT n d <span class="num">0</span><span class="sym">) :</span> depth <span class="sym">(</span>d<span class="sym">+</span><span class="num">2</span><span class="sym">)</span> m
  <span class="kwa">where</span>
    n <span class="sym">=</span> <span class="num">1</span> `shiftL` <span class="sym">(</span>m <span class="sym">-</span> d <span class="sym">+</span> minDepth<span class="sym">)</span>

sumT <span class="sym">::</span> <span class="kwb">Int</span> <span class="sym">-&gt;</span> <span class="kwb">Int</span> <span class="sym">-&gt;</span> <span class="kwb">Int</span> <span class="sym">-&gt;</span> <span class="kwb">Int</span>
sumT <span class="sym">!</span><span class="num">0</span> <span class="sym">!</span>d <span class="sym">!</span>t <span class="sym">=</span> t
sumT i d t    <span class="sym">=</span> sumT <span class="sym">(</span>i<span class="sym">-</span><span class="num">1</span><span class="sym">)</span> d <span class="sym">(</span>t <span class="sym">+</span> a <span class="sym">+</span> b<span class="sym">)</span>
    <span class="kwa">where</span> a <span class="sym">=</span> check <span class="sym">(</span>make i    d<span class="sym">)</span>
          b <span class="sym">=</span> check <span class="sym">(</span>make <span class="sym">(-</span>i<span class="sym">)</span> d<span class="sym">)</span>

make <span class="sym">::</span> <span class="kwb">Int</span> <span class="sym">-&gt;</span> <span class="kwb">Int</span> <span class="sym">-&gt;</span> Tree
make <span class="sym">!</span>i <span class="sym">!</span><span class="num">0</span> <span class="sym">=</span> Node i Nil Nil
make  i  d <span class="sym">=</span> Node i <span class="sym">(</span>make <span class="sym">(</span>i2<span class="sym">-</span><span class="num">1</span><span class="sym">)</span> d2<span class="sym">) (</span>make i2 d2<span class="sym">)</span>
    <span class="kwa">where</span>
        i2 <span class="sym">=</span> <span class="num">2</span><span class="sym">*</span>i
        d2 <span class="sym">=</span> d<span class="sym">-</span><span class="num">1</span>

check <span class="sym">::</span> Tree <span class="sym">-&gt;</span> <span class="kwb">Int</span>
check Nil          <span class="sym">=</span> <span class="num">0</span>
check <span class="sym">(</span>Node i l r<span class="sym">) =</span> i <span class="sym">+</span> check l <span class="sym">-</span> check r
