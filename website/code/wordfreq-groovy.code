<span class="dir">#!/bin/env groovy
</span><span class="com">/*
	$Id: wordfreq-groovy.code,v 1.1 2005-09-21 05:17:34 bfulgham Exp $

	The Great Computer Language Shootout
	http://shootout.alioth.debian.org/

	contributed by Jochen Hinrichsen
	modified by

    Each program should do the same thing.

    Each program should:

        * read a text file from stdin
        * extract all the words
        * convert the words to lowercase
        * calculate the frequency of each word in the text file
        * print each word and word frequency, in descending order by frequency and descending alphabetic order by word

    Correct output for this 170KB input file is in this 50KB output file.

    Programs should use constant space over a range of input sizes. Programs may read the input file line-by-line, or with 4096 byte (or smaller) block reads.

    The input file to the tests is the text file The Prince, by Nicol&oacute; Machiavelli.

    (The bash program is really a pipeline using tr, grep, sort and uniq. This is the UNIX way of combining tools in the shell to get things done.)
*/</span>

<span class="slc">// def dict = [:]
</span>def dict <span class="sym">=</span> <span class="kwa">new</span> TreeMap<span class="sym">()

</span><span class="slc">// read input, build dictionary
</span>System<span class="sym">.</span>in<span class="sym">.</span>eachLine<span class="sym">() {</span> line <span class="sym">-&gt;
</span>	<span class="slc">// split on words
</span>	line<span class="sym">.</span>split<span class="sym">(</span><span class="str">&quot;</span><span class="esc">\\</span><span class="str">W&quot;</span><span class="sym">).</span>each<span class="sym">() {</span> word <span class="sym">-&gt;
</span>		def s <span class="sym">=</span> word<span class="sym">.</span>toLowerCase<span class="sym">()
</span>		def entry <span class="sym">=</span> dict<span class="sym">[</span>s<span class="sym">]
</span>		dict<span class="sym">[</span>s<span class="sym">] = (</span>entry <span class="sym">==</span> null<span class="sym">)</span> ? <span class="num">1</span> <span class="sym">:</span> entry<span class="sym">+</span><span class="num">1
</span>	<span class="sym">}
}

</span><span class="slc">// default sort() is smallest first
</span><span class="slc">// sort for multiple properties: [ it.value, it.key ]
</span>assert dict <span class="sym">!=</span> null
assert dict<span class="sym">.</span>values<span class="sym">() !=</span> null
assert <span class="sym">(</span>dict<span class="sym">.</span>values<span class="sym">().</span>sort<span class="sym">({</span> l<span class="sym">,</span> r <span class="sym">-&gt;</span> r <span class="sym">&lt;=&gt;</span> l<span class="sym">})) !=</span> null
dict<span class="sym">.</span>values<span class="sym">().</span>sort<span class="sym">({</span> l<span class="sym">,</span> r <span class="sym">-&gt;</span> r <span class="sym">&lt;=&gt;</span> l<span class="sym">}).</span>each<span class="sym">() {</span> value <span class="sym">-&gt;
</span><span class="com">/*
	assert value != null
    def entry = dict.find() { e -&gt;
        def v = e.getValue()
		assert v != null
        e.getValue() == value
    }
	assert entry != null
*/</span>
    <span class="slc">// println &quot;${value.toString().padLeft(8)} ${entry.key}&quot;
</span>    println <span class="str">&quot;${value.toString().padLeft(8)}&quot;</span>
<span class="sym">}

</span><span class="slc">// EOF
</span>
