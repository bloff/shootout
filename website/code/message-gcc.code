<span class="com">/* The Computer Language Shootout</span>
<span class="com"> * http://shootout.alioth.debian.org/</span>
<span class="com"> * contributed by anon</span>
<span class="com"> * compile with -Os -lpthread</span>
<span class="com"> */</span>

<span class="dir">#include &lt;stdio.h&gt;</span>
<span class="dir">#include &lt;stdlib.h&gt;</span>
<span class="dir">#include &lt;assert.h&gt;</span>
<span class="dir">#include &lt;unistd.h&gt;</span>
<span class="dir">#include &lt;pthread.h&gt;</span>	<span class="slc">// -lpthread</span>
<span class="dir"></span><span class="dir">#include &lt;semaphore.h&gt;</span>

<span class="dir">#define THREADS 500</span>

<span class="dir">#define STACKSZ (100*1024)</span> <span class="slc">// 100K</span>
<span class="dir"></span><span class="dir">#define SWL_SLEEP (1000000/1000)</span>

sem_t <span class="sym">*</span>s<span class="sym">;</span>

<span class="kwb">void</span>
<span class="kwd">semwaitlocked</span><span class="sym">(</span>sem_t <span class="sym">*</span>sem<span class="sym">)</span> <span class="slc">// profiling shows this is the bottleneck</span>
<span class="sym">{</span>
	<span class="kwb">int</span> v<span class="sym">;</span>
	<span class="kwa">for</span> <span class="sym">(</span><span class="kwd">sem_getvalue</span><span class="sym">(</span>sem<span class="sym">, &amp;</span>v<span class="sym">);</span>
		v <span class="sym">&gt;</span> <span class="num">0</span><span class="sym">;</span>
		<span class="kwd">usleep</span><span class="sym">(</span>SWL_SLEEP<span class="sym">),</span>
		<span class="kwd">sem_getvalue</span><span class="sym">(</span>sem<span class="sym">, &amp;</span>v<span class="sym">));</span>
<span class="sym">}</span>

<span class="kwb">void</span> <span class="sym">*</span>
<span class="kwd">work</span><span class="sym">(</span><span class="kwb">void</span> <span class="sym">*</span>a<span class="sym">)</span>
<span class="sym">{</span>
	<span class="kwa">for</span> <span class="sym">(;;) {</span>
		<span class="com">/*</span>
<span class="com">		 * sem_wait() can get interrupted, just call it again</span>
<span class="com">		 * TODO: see sys/kern/uipc_sem.c:618 in FreeBSD</span>
<span class="com">		 */</span>
		<span class="kwa">for</span> <span class="sym">(;</span> <span class="kwd">sem_wait</span><span class="sym">(</span>s<span class="sym">) !=</span> <span class="num">0</span><span class="sym">;</span> <span class="kwd">pthread_yield</span><span class="sym">());</span>
		<span class="kwd">semwaitlocked</span><span class="sym">(</span>s<span class="sym">);</span>
	<span class="sym">}</span>
	<span class="kwa">return</span> NULL<span class="sym">;</span>
<span class="sym">}</span>

<span class="kwb">int</span>
<span class="kwd">main</span><span class="sym">(</span><span class="kwb">int</span> argc<span class="sym">,</span> <span class="kwb">char</span> <span class="sym">*</span>argv<span class="sym">[])</span>
<span class="sym">{</span>
	<span class="kwb">unsigned int</span> times<span class="sym">;</span>
	<span class="kwd">assert</span><span class="sym">(</span>argc <span class="sym">==</span> <span class="num">2</span> <span class="sym">&amp;&amp;</span> <span class="kwd">sscanf</span><span class="sym">(</span>argv<span class="sym">[</span><span class="num">1</span><span class="sym">],</span> <span class="str">&quot;%u&quot;</span><span class="sym">, &amp;</span>times<span class="sym">) ==</span> <span class="num">1</span><span class="sym">);</span>

	<span class="kwb">int</span> sum <span class="sym">=</span> <span class="num">0</span><span class="sym">;</span>
	pthread_attr_t attr<span class="sym">;</span>
	pthread_t t<span class="sym">[</span>THREADS<span class="sym">];</span>
	<span class="kwb">int</span> i<span class="sym">,</span> j<span class="sym">;</span>

	s <span class="sym">=</span> <span class="kwd">malloc</span><span class="sym">(</span><span class="kwa">sizeof</span><span class="sym">(</span>sem_t<span class="sym">));</span>
	<span class="kwd">assert</span><span class="sym">(</span>s <span class="sym">!=</span> NULL<span class="sym">);</span>
	<span class="kwd">assert</span><span class="sym">(</span><span class="kwd">sem_init</span><span class="sym">(</span>s<span class="sym">,</span> <span class="num">0</span><span class="sym">,</span> <span class="num">0</span><span class="sym">) ==</span> <span class="num">0</span><span class="sym">);</span>
	<span class="kwd">assert</span><span class="sym">(</span><span class="kwd">pthread_attr_init</span><span class="sym">(&amp;</span>attr<span class="sym">) ==</span> <span class="num">0</span><span class="sym">);</span>
	<span class="slc">//size_t sztmp;</span>
	<span class="slc">//assert(pthread_attr_getstacksize(&amp;attr, &amp;sztmp) == 0);</span>
	<span class="slc">//printf(&quot;default stack size: %ub\n&quot;, (unsigned int)sztmp);</span>
	<span class="kwd">assert</span><span class="sym">(</span><span class="kwd">pthread_attr_setstacksize</span><span class="sym">(&amp;</span>attr<span class="sym">,</span> STACKSZ<span class="sym">) ==</span> <span class="num">0</span><span class="sym">);</span>
	<span class="kwa">for</span> <span class="sym">(</span>i <span class="sym">=</span> <span class="num">0</span><span class="sym">;</span> i <span class="sym">&lt;</span> THREADS<span class="sym">;</span> i<span class="sym">++) {</span>
		<span class="kwd">assert</span><span class="sym">(</span><span class="kwd">pthread_create</span><span class="sym">(&amp;</span>t<span class="sym">[</span>i<span class="sym">], &amp;</span>attr<span class="sym">,</span> work<span class="sym">,</span> NULL<span class="sym">) ==</span> <span class="num">0</span><span class="sym">);</span>
	<span class="sym">}</span>
	<span class="kwa">for</span> <span class="sym">(</span>j <span class="sym">=</span> <span class="num">0</span><span class="sym">;</span> j <span class="sym">&lt;</span> times<span class="sym">;</span> j<span class="sym">++) {</span>
		<span class="kwa">for</span> <span class="sym">(</span>i <span class="sym">=</span> <span class="num">0</span><span class="sym">;</span> i <span class="sym">&lt;</span> THREADS<span class="sym">;</span> i<span class="sym">++) {</span>
			<span class="com">/*</span>
<span class="com">			 * from sem_post(3) in freebsd:</span>
<span class="com">			 * &gt; If there are threads blocked on the semaphore</span>
<span class="com">			 * &gt; when sem_post() is called, then the highest</span>
<span class="com">			 * &gt; priority thread that has been blocked the</span>
<span class="com">			 * &gt; longest on the semaphore will be allowed to</span>
<span class="com">			 * &gt; return from sem_wait().</span>
<span class="com">			 */</span>
			<span class="kwd">sem_post</span><span class="sym">(</span>s<span class="sym">);</span>
		<span class="sym">}</span>
		<span class="kwd">semwaitlocked</span><span class="sym">(</span>s<span class="sym">);</span>
		sum <span class="sym">+=</span> THREADS<span class="sym">;</span>
	<span class="sym">}</span>
	<span class="kwd">printf</span><span class="sym">(</span><span class="str">&quot;%d</span><span class="esc">\n</span><span class="str">&quot;</span><span class="sym">,</span> sum<span class="sym">);</span>

	<span class="kwd">exit</span><span class="sym">(</span><span class="num">0</span><span class="sym">);</span>
<span class="sym">}</span>
