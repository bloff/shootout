#<span class="sym">!/</span>usr<span class="sym">/</span>bin<span class="sym">/</span>mzscheme <span class="sym">-</span>r
<span class="sym">;</span> $Id<span class="sym">:</span> pidigits.mzscheme<span class="sym">,</span>v <span class="num">1.1 2005</span><span class="sym">/</span><span class="num">04</span><span class="sym">/</span><span class="num">25 04</span><span class="sym">:</span><span class="num">23</span><span class="sym">:</span><span class="num">58</span> bfulgham Exp $
<span class="sym">;</span> The Computer Language Shootout
<span class="sym">;</span> http<span class="sym">:</span><span class="slc">//shootout.alioth.debian.org/
</span><span class="sym">;
;</span> Based on Sven Hartrumpf<span class="str">'s chicken program, which was (in turn) based
; on an implementation for SCM by Aubrey Jaffer and Jerry D. Hedden.
; Program implements the '</span>Spigot<span class="str">' algorithm origionally due to
; Stanly Rabinowitz.

(define (pi n d)
  (let* ((r (do ((s 1 (* 10 s)) (i d (- i 1))) ((zero? i) s))) ; chicken: this line is faster
         (p (+ (quotient n d) 1))
         (m (quotient (* p d 3322) 1000))
         (a (make-vector (+ m 1) 2))
         (digits 0))
    (vector-set! a m 4)
    (do ((j 1 (+ j 1))
         (q 0 0)
         (b 2 (remainder q r)))
      ((&gt; j p))
      (do ((k m (- k 1)))
        ((zero? k))
        (set! q (+ q (* (vector-ref a k) r)))
        (let ((t (+ (* k 2) 1))) ; maybe use something like bit-lsh
          (let-values ([(qq rr) (quotient/remainder q t)])
            (vector-set! a k rr)
            (set! q (* k qq)))))
      (let* ((s (number-&gt;string (+ b (quotient q r))))
             (l (string-length s)))
        (cond ((and (&gt; l 1) ; chicken: needs this cond because it uses floats for d&gt;5 (leads to appended . or .0), for version after 1.89 use 2, before 1.89 use 1 in this line and the following 2 lines
                    (char=? (string-ref s (- l 1)) #</span><span class="esc">\.</span><span class="str">))
               (set! l (- l 1))))
        (cond ((&gt; j 1)
               (do ((l l (+ l 1)))
                 ((&gt;= l d))
                 (cond ((&lt; digits n)
                        (write-char #</span><span class="esc">\0</span><span class="str">)
                        (set! digits (+ digits 1))
                        (cond ((zero? (modulo digits 10))
                               (display &quot;</span><span class="esc">\t</span><span class="str">:&quot;) (write digits) (newline))))))))
        (do ((i 0 (+ i 1)))
          ((= i l))
          (cond ((&lt; digits n)
                 (write-char (string-ref s i))
                 (set! digits (+ digits 1))
                 (cond ((zero? (modulo digits 10))
                        (display &quot;</span><span class="esc">\t</span><span class="str">:&quot;) (write digits) (newline))))))))))

(define (main args)
  (let ((n (if (= (vector-length args) 0)
               10
               (string-&gt;number (vector-ref args 0)))))
    (pi n 10)))

(main (current-command-line-arguments))</span>
