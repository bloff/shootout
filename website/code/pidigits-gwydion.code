<span class="kwb">module</span><span class="sym">:</span>  pidigits
<span class="kwa">use</span><span class="sym">-</span>libraries<span class="sym">:</span> common<span class="sym">-</span>dylan<span class="sym">,</span> io
<span class="kwa">use</span><span class="sym">-</span>modules<span class="sym">:</span> common<span class="sym">-</span>dylan<span class="sym">,</span> standard<span class="sym">-</span>io<span class="sym">,</span> streams<span class="sym">,</span> format<span class="sym">-</span>out

<span class="com">/*
 *  Based on Christopher Neufeld's  &lt;shootout0000&#64;cneufeld.ca&gt;
 *  SBCL implementation.
 */</span>

<span class="kwa">define constant</span> $digits<span class="sym">-</span>per<span class="sym">-</span>line <span class="sym">=</span> <span class="num">10</span><span class="sym">;
</span><span class="kwa">define constant</span> <span class="sym">*</span>stop<span class="sym">-</span>digits<span class="sym">* =</span> <span class="num">300</span><span class="sym">;

</span><span class="kwa">define function</span> compute<span class="sym">-</span>pi <span class="sym">(</span>next<span class="sym">,</span> safe<span class="sym">,</span> prod<span class="sym">,</span> consume<span class="sym">,</span> z<span class="sym">,</span> next<span class="sym">-</span>state<span class="sym">)
</span><span class="com">/*
  (do ((digits-out 0))
      ((&gt;= digits-out *stop-digits*))

    (let ((y (funcall next z)))
      (if (funcall safe z y)
          (progn
            (format t &quot;~D&quot; y)
            (incf digits-out)
            (if (zerop (mod digits-out *digits-per-line*))
                (format t &quot;	 :~D~%&quot; digits-out))
            (setf z (funcall prod z y)))
          (let ((state (funcall next-state)))
            (setf z (funcall consume z state))))))
*/</span>
<span class="kwa">end function</span> compute<span class="sym">-</span>pi<span class="sym">;

</span><span class="kwa">define function</span> comp <span class="sym">(</span>a1<span class="sym">,</span> a2<span class="sym">)
</span><span class="com">/*
  (let ((retval (make-array 4)))
    (setf (aref retval 0) (+ (* (aref a1 0) (aref a2 0))
                             (* (aref a1 1) (aref a2 2))))
    (setf (aref retval 1) (+ (* (aref a1 0) (aref a2 1))
                             (* (aref a1 1) (aref a2 3))))
    (setf (aref retval 2) (+ (* (aref a1 2) (aref a2 0))
                             (* (aref a1 3) (aref a2 2))))
    (setf (aref retval 3) (+ (* (aref a1 2) (aref a2 1))
                             (* (aref a1 3) (aref a2 3))))
    retval)
*/</span>
<span class="kwa">end function</span> comp<span class="sym">;

</span><span class="kwa">define function</span> extr <span class="sym">(</span>state<span class="sym">,</span> x<span class="sym">)
</span><span class="com">/*
  (declare (type (array integer 1) state))
  (declare (type integer x))
  (declare (optimize (speed 3) (safety 0) (space 0)))
  (/ (+ (* (aref state 0) x) (aref state 1))
     (+ (* (aref state 2) x) (aref state 3)))
*/</span>
<span class="kwa">end function</span> extr<span class="sym">;

</span><span class="kwa">define function</span> next<span class="sym">-</span>state <span class="sym">()
</span><span class="com">/*
  (incf (aref *curstate* 0))
  (incf (aref *curstate* 1) 4)
  (incf (aref *curstate* 3) 2)
  *curstate*)
*/</span>
<span class="kwa">end function</span> next<span class="sym">-</span>state<span class="sym">;

</span><span class="kwa">define function</span> safe? <span class="sym">(</span>z<span class="sym">,</span> n<span class="sym">)
  (=</span> n <span class="sym">(</span>floor <span class="sym">(</span>extr z <span class="num">4</span><span class="sym">)))
</span><span class="kwa">end function</span> safe?<span class="sym">;

</span><span class="kwa">define function</span> next <span class="sym">(</span>z<span class="sym">)
  (</span>floor <span class="sym">(</span>extr z <span class="num">3</span><span class="sym">)))
</span><span class="kwa">end function</span> next<span class="sym">;

</span><span class="kwa">define function</span> prod <span class="sym">(</span>z<span class="sym">,</span> n<span class="sym">)
  (</span><span class="kwa">let</span> <span class="sym">((</span>v1 <span class="sym">(</span>make<span class="sym">-</span>array <span class="num">4</span><span class="sym">)))
    (</span>setf <span class="sym">(</span>aref v1 <span class="num">0</span><span class="sym">)</span> <span class="num">10</span><span class="sym">)
    (</span>setf <span class="sym">(</span>aref v1 <span class="num">1</span><span class="sym">) (*</span> n <span class="num">-10</span><span class="sym">))
    (</span>setf <span class="sym">(</span>aref v1 <span class="num">2</span><span class="sym">)</span> <span class="num">0</span><span class="sym">)
    (</span>setf <span class="sym">(</span>aref v1 <span class="num">3</span><span class="sym">)</span> <span class="num">1</span><span class="sym">)
    (</span>comp v1 z<span class="sym">)))
</span><span class="kwa">end function</span> prod<span class="sym">;

</span><span class="kwa">define function</span> consume <span class="sym">(</span>z<span class="sym">,</span> z<span class="sym">-</span>prime<span class="sym">)
</span>  comp<span class="sym">(</span>z<span class="sym">,</span> z<span class="sym">-</span>prime<span class="sym">);
</span><span class="kwa">end function</span> consume<span class="sym">;

</span><span class="kwa">begin
  let</span> n <span class="sym">=</span> application<span class="sym">-</span>arguments<span class="sym">()[</span><span class="num">0</span><span class="sym">]</span>.string<span class="sym">-</span><span class="kwa">to</span><span class="sym">-</span>integer<span class="sym">;
  *</span>stop<span class="sym">-</span>digits<span class="sym">* =</span> n<span class="sym">;

</span>  <span class="kwa">let</span> $init <span class="sym">=</span> make<span class="sym">(</span><span class="kwa">&lt;vector&gt;</span><span class="sym">,</span> size<span class="sym">:</span> <span class="num">4</span><span class="sym">,</span> fill<span class="sym">:</span> <span class="num">0</span><span class="sym">);
</span>  <span class="kwa">let</span> $curstate <span class="sym">=</span> make<span class="sym">(</span><span class="kwa">&lt;vector&gt;</span><span class="sym">,</span> size<span class="sym">:</span> <span class="num">4</span><span class="sym">,</span> fill<span class="sym">:</span> <span class="num">0</span><span class="sym">);
</span>  $init<span class="sym">[</span><span class="num">0</span><span class="sym">] :=</span> <span class="num">1</span><span class="sym">;
</span>  $init<span class="sym">[</span><span class="num">3</span><span class="sym">] :=</span> <span class="num">1</span><span class="sym">;
</span>  $curstate<span class="sym">[</span><span class="num">1</span><span class="sym">] =</span> <span class="num">2</span><span class="sym">;
</span>  $curstate<span class="sym">[</span><span class="num">3</span><span class="sym">] =</span> <span class="num">1</span><span class="sym">;

</span>  compute<span class="sym">-</span>pi<span class="sym">(</span> #<span class="str">'next, #'</span>safe<span class="sym">,</span> #<span class="str">'prod, #'</span>consume<span class="sym">,</span> $init<span class="sym">,</span> #<span class="str">'next-state);
end;
</span>
