<span class="slc">;;; -*- mode: lisp -*-
</span><span class="slc">;;; http://shootout.alioth.debian.org/
</span><span class="slc">;;; written by Patrick Frankenberger
</span>

<span class="sym">(</span><span class="kwa">defun</span> complem <span class="sym">(</span>code<span class="sym">)
  (</span>declare <span class="sym">(</span><span class="kwa">type</span> base<span class="sym">-</span>char code<span class="sym">))
  (</span>let <span class="sym">((</span>upcode <span class="sym">(</span>char<span class="sym">-</span>upcase code<span class="sym">)))
    (</span><span class="kwa">cond</span> <span class="sym">((</span>char<span class="sym">=</span> upcode #\A<span class="sym">)</span> #\T<span class="sym">)
	  ((</span>char<span class="sym">=</span> upcode #\C<span class="sym">)</span> #\G<span class="sym">)
	  ((</span>char<span class="sym">=</span> upcode #\G<span class="sym">)</span> #\C<span class="sym">)
	  ((</span>char<span class="sym">=</span> upcode #\T<span class="sym">)</span> #\A<span class="sym">)
	  ((</span>char<span class="sym">=</span> upcode #\U<span class="sym">)</span> #\A<span class="sym">)
	  ((</span>char<span class="sym">=</span> upcode #\M<span class="sym">)</span> #\K<span class="sym">)
	  ((</span>char<span class="sym">=</span> upcode #\R<span class="sym">)</span> #\Y<span class="sym">)
	  ((</span>char<span class="sym">=</span> upcode #\Y<span class="sym">)</span> #\R<span class="sym">)
	  ((</span>char<span class="sym">=</span> upcode #\K<span class="sym">)</span> #\M<span class="sym">)
	  ((</span>char<span class="sym">=</span> upcode #\V<span class="sym">)</span> #\B<span class="sym">)
	  ((</span>char<span class="sym">=</span> upcode #\H<span class="sym">)</span> #\D<span class="sym">)
	  ((</span>char<span class="sym">=</span> upcode #\D<span class="sym">)</span> #\H<span class="sym">)
	  ((</span>char<span class="sym">=</span> upcode #\B<span class="sym">)</span> #\V<span class="sym">)
	  (</span>t upcode<span class="sym">))))

(</span><span class="kwa">defun</span> write<span class="sym">-</span><span class="kwa">fix</span><span class="sym">-</span>lines <span class="sym">(</span>data<span class="sym">)
  (</span>let <span class="sym">((</span>written <span class="num">0</span><span class="sym">))
    (</span>declare <span class="sym">(</span><span class="kwa">type</span> <span class="sym">(</span>mod <span class="num">1000000</span><span class="sym">)</span> written<span class="sym">))
    (</span>dolist <span class="sym">(</span><span class="kwa">line</span> data<span class="sym">)
      (</span>declare <span class="sym">(</span>simple<span class="sym">-</span>string <span class="kwa">line</span><span class="sym">))
      (</span>setf <span class="kwa">line</span> <span class="sym">(</span>map<span class="sym">-</span>into <span class="kwa">line</span> #<span class="str">'complem (nreverse line)))
      (dotimes (i (length line))
	(declare (type (mod 1000000) i))
	(write-char (aref line i))
	(when (= (mod (+ written i 1) 60) 0) (write-char #</span><span class="esc">\N</span><span class="str">ewline)))
      (setf written (+ written (length line))))
    (when (/= (mod written 60) 0) (write-char #</span><span class="esc">\N</span><span class="str">ewline))))

(defun write-reverse-complement (title data)
  (write-line title)
  (write-fix-lines data))

(defun main ()
  (let* ((title &quot;&quot;)
	 (data nil))
    (setf title (read-line))
    (do ((line (read-line *standard-input*)
	       (read-line *standard-input* nil '</span>eof<span class="sym">)))
	((</span><span class="kwa">eq line</span> <span class="str">'eof) (write-reverse-complement title data))
      (if (char= (aref line 0) #</span><span class="esc">\&gt;</span><span class="str">)
	  (progn
	    (when data (write-reverse-complement title data))
	    (setf data nil)
	    (setf title line))
	  (push line data)))))</span>
