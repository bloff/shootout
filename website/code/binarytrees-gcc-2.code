<span class="com">/*
	The Computer Language
	Shootout Benchmarks

	http://shootout.alioth.debian.org/

	Contributed by Lester Vecsey
*/</span>

<span class="dir">#include &lt;stdio.h&gt;
</span><span class="dir">#include &lt;stdlib.h&gt;
</span>
<span class="kwb">struct</span> tn <span class="sym">{
</span>	<span class="kwb">struct</span> tn <span class="sym">*</span>left<span class="sym">, *</span>right<span class="sym">;
</span>	<span class="kwb">signed long</span> item<span class="sym">;
	};

</span><span class="kwb">struct</span> tr <span class="sym">{
</span>	<span class="kwb">struct</span> tn <span class="sym">*</span>root<span class="sym">, *</span>nodes<span class="sym">;
</span>	<span class="kwb">int</span> num_nodes<span class="sym">;
	};

</span><span class="kwb">struct</span> tr_clamp <span class="sym">{
</span>	<span class="kwb">struct</span> tn <span class="sym">*</span>pos<span class="sym">, *</span>end<span class="sym">;
	};

</span><span class="kwb">int</span> allocate_tree<span class="sym">(</span><span class="kwb">struct</span> tr <span class="sym">*</span>t<span class="sym">,</span> <span class="kwb">int</span> node_depth<span class="sym">) {

</span>	<span class="kwa">if</span> <span class="sym">(</span>t<span class="sym">==</span>NULL <span class="sym">||</span> node_depth <span class="sym">&lt;=</span> <span class="num">0</span><span class="sym">)</span> <span class="kwa">return</span> <span class="num">-1</span><span class="sym">;

</span>	t<span class="sym">-&gt;</span>num_nodes <span class="sym">= (</span><span class="num">2</span> <span class="sym">&lt;&lt;</span> node_depth<span class="sym">) -</span> <span class="num">1</span><span class="sym">;

</span>	t<span class="sym">-&gt;</span>nodes <span class="sym">= (</span><span class="kwb">struct</span> tn<span class="sym">*)</span> malloc<span class="sym">(</span><span class="kwa">sizeof</span><span class="sym">(</span><span class="kwb">struct</span> tn<span class="sym">) *</span> t<span class="sym">-&gt;</span>num_nodes<span class="sym">);
</span>	<span class="kwa">if</span> <span class="sym">(</span>t<span class="sym">-&gt;</span>nodes<span class="sym">==</span>NULL<span class="sym">)</span> <span class="kwa">return</span> <span class="num">-1</span><span class="sym">;

</span>	<span class="kwa">return</span> <span class="num">0</span><span class="sym">;

	}

</span><span class="kwb">int</span> free_tree<span class="sym">(</span><span class="kwb">struct</span> tr <span class="sym">*</span>t<span class="sym">) {

</span>	<span class="kwa">if</span> <span class="sym">(</span>t<span class="sym">==</span>NULL<span class="sym">)</span> <span class="kwa">return</span> <span class="num">-1</span><span class="sym">;

</span>	free<span class="sym">(</span>t<span class="sym">-&gt;</span>nodes<span class="sym">);
</span>	free<span class="sym">(</span>t<span class="sym">);

</span>	<span class="kwa">return</span> <span class="num">0</span><span class="sym">;

	}

</span><span class="kwb">int</span> init_clamp<span class="sym">(</span><span class="kwb">struct</span> tr <span class="sym">*</span>t<span class="sym">,</span> <span class="kwb">struct</span> tr_clamp <span class="sym">*</span>x<span class="sym">) {

</span>	<span class="kwa">if</span> <span class="sym">(</span>t<span class="sym">==</span>NULL <span class="sym">||</span> x<span class="sym">==</span>NULL<span class="sym">)</span> <span class="kwa">return</span> <span class="num">-1</span><span class="sym">;

</span>	x<span class="sym">-&gt;</span>pos <span class="sym">=</span> t<span class="sym">-&gt;</span>nodes<span class="sym">;
</span>	x<span class="sym">-&gt;</span>end <span class="sym">=</span> x<span class="sym">-&gt;</span>pos <span class="sym">+</span> t<span class="sym">-&gt;</span>num_nodes<span class="sym">;

</span>	<span class="kwa">return</span> <span class="num">0</span><span class="sym">;

	}

</span><span class="kwb">int</span> tree_assign_pointers<span class="sym">(</span><span class="kwb">struct</span> tr_clamp <span class="sym">*</span>x<span class="sym">,</span> <span class="kwb">struct</span> tn <span class="sym">**</span>n<span class="sym">,</span> <span class="kwb">signed long</span> item<span class="sym">,</span> <span class="kwb">int</span> depth<span class="sym">) {

</span>	<span class="kwb">struct</span> tn <span class="sym">*</span>c<span class="sym">;

</span>	<span class="kwa">if</span> <span class="sym">(</span>x<span class="sym">==</span>NULL <span class="sym">||</span> n<span class="sym">==</span>NULL<span class="sym">)</span> <span class="kwa">return</span> <span class="num">-1</span><span class="sym">;

</span>	<span class="kwa">if</span> <span class="sym">(</span>x<span class="sym">-&gt;</span>pos <span class="sym">&gt;=</span> x<span class="sym">-&gt;</span>end<span class="sym">)</span> <span class="kwa">return</span> <span class="num">-1</span><span class="sym">;

</span>	c <span class="sym">=</span> x<span class="sym">-&gt;</span>pos<span class="sym">++;

</span>	<span class="kwa">if</span> <span class="sym">(</span>depth<span class="sym">==</span><span class="num">0</span><span class="sym">) {</span> c<span class="sym">-&gt;</span>left <span class="sym">=</span> c<span class="sym">-&gt;</span>right <span class="sym">=</span> NULL<span class="sym">;</span> c<span class="sym">-&gt;</span>item <span class="sym">=</span> <span class="num">0</span><span class="sym">; }
</span>		<span class="kwa">else</span> <span class="sym">{
</span>		tree_assign_pointers<span class="sym">(</span>x<span class="sym">, &amp; (</span>c<span class="sym">-&gt;</span>left<span class="sym">),</span> <span class="num">2</span><span class="sym">*</span>item<span class="num">-1</span><span class="sym">,</span> depth<span class="num">-1</span><span class="sym">);
</span>		tree_assign_pointers<span class="sym">(</span>x<span class="sym">, &amp; (</span>c<span class="sym">-&gt;</span>right<span class="sym">),</span> <span class="num">2</span><span class="sym">*</span>item<span class="sym">,</span> depth<span class="num">-1</span><span class="sym">);
</span>		c<span class="sym">-&gt;</span>item <span class="sym">=</span> item<span class="sym">;
		}

	*</span>n <span class="sym">=</span> c<span class="sym">;

</span>	<span class="kwa">return</span> <span class="num">0</span><span class="sym">;

	}

</span><span class="kwb">signed long</span> item_check<span class="sym">(</span><span class="kwb">struct</span> tn <span class="sym">*</span>n<span class="sym">) {

</span>	<span class="kwa">return</span> n<span class="sym">-&gt;</span>item <span class="sym">+ (</span>n<span class="sym">-&gt;</span>left<span class="sym">==</span>NULL ? <span class="num">0</span> <span class="sym">:</span> item_check<span class="sym">(</span>n<span class="sym">-&gt;</span>left<span class="sym">) -</span> item_check<span class="sym">(</span>n<span class="sym">-&gt;</span>right<span class="sym">));

	}

</span><span class="kwb">int</span> main<span class="sym">(</span><span class="kwb">int</span> argc<span class="sym">,</span> <span class="kwb">char</span> <span class="sym">*</span>argv<span class="sym">[]) {

</span>	<span class="kwb">struct</span> tr long_lived<span class="sym">,</span> a<span class="sym">,</span> b<span class="sym">,</span> c<span class="sym">;
</span>	<span class="kwb">struct</span> tr_clamp clamp<span class="sym">;

</span>	<span class="kwb">unsigned int</span> min <span class="sym">=</span> <span class="num">4</span><span class="sym">,</span> max <span class="sym">=</span> argc <span class="sym">&gt;</span> <span class="num">1</span> ? strtol<span class="sym">(</span>argv<span class="sym">[</span><span class="num">1</span><span class="sym">],</span> <span class="num">0</span><span class="sym">,</span> <span class="num">10</span><span class="sym">) :</span> <span class="num">10</span><span class="sym">;

</span>	<span class="kwb">unsigned int</span> depth<span class="sym">,</span> stretch_depth <span class="sym">=</span> max <span class="sym">+</span> <span class="num">1</span><span class="sym">;

</span>	<span class="kwb">unsigned long</span> iterations <span class="sym">= (</span><span class="num">1</span><span class="sym">&lt;&lt;</span>max<span class="sym">);

</span>	<span class="kwb">signed long</span> chk<span class="sym">;

</span>	<span class="kwb">int</span> count<span class="sym">;

</span>	<span class="kwa">if</span> <span class="sym">(</span>allocate_tree<span class="sym">(&amp;</span>c<span class="sym">,</span> stretch_depth<span class="sym">) == -</span><span class="num">1</span><span class="sym">)</span> <span class="kwa">return</span> <span class="num">-1</span><span class="sym">;
</span>	<span class="kwa">if</span> <span class="sym">(</span>init_clamp<span class="sym">(&amp;</span>c<span class="sym">, &amp;</span>clamp<span class="sym">) == -</span><span class="num">1</span><span class="sym">)</span> <span class="kwa">return</span> <span class="num">-1</span><span class="sym">;
</span>	<span class="kwa">if</span> <span class="sym">(</span>tree_assign_pointers<span class="sym">(&amp;</span>clamp<span class="sym">, &amp;</span>c<span class="sym">.</span>root<span class="sym">,</span> <span class="num">0</span><span class="sym">,</span> stretch_depth<span class="sym">) == -</span><span class="num">1</span><span class="sym">)</span> <span class="kwa">return</span> <span class="num">-1</span><span class="sym">;
</span>	chk <span class="sym">=</span> item_check<span class="sym">(</span>c<span class="sym">.</span>root<span class="sym">);

</span>	printf<span class="sym">(</span><span class="str">&quot;stretch tree of depth %u</span><span class="esc">\t  </span>  <span class="str">check: %li</span><span class="esc">\n</span><span class="str">&quot;</span><span class="sym">,</span> stretch_depth<span class="sym">,</span> chk<span class="sym">);

</span>	<span class="kwa">if</span> <span class="sym">(</span>allocate_tree<span class="sym">(&amp;</span>long_lived<span class="sym">,</span> max<span class="sym">) == -</span><span class="num">1</span><span class="sym">)</span> <span class="kwa">return</span> <span class="num">-1</span><span class="sym">;
</span>	<span class="kwa">if</span> <span class="sym">(</span>init_clamp<span class="sym">(&amp;</span>long_lived<span class="sym">, &amp;</span>clamp<span class="sym">) == -</span><span class="num">1</span><span class="sym">)</span> <span class="kwa">return</span> <span class="num">-1</span><span class="sym">;
</span>	<span class="kwa">if</span> <span class="sym">(</span>tree_assign_pointers<span class="sym">(&amp;</span>clamp<span class="sym">, &amp;</span>long_lived<span class="sym">.</span>root<span class="sym">,</span> <span class="num">0</span><span class="sym">,</span> max<span class="sym">) == -</span><span class="num">1</span><span class="sym">)</span> <span class="kwa">return</span><span class="num">- 1</span><span class="sym">;

</span>	<span class="kwa">for</span> <span class="sym">(</span>depth <span class="sym">=</span> min<span class="sym">;</span> depth <span class="sym">&lt;=</span> max<span class="sym">;</span> depth<span class="sym">+=</span><span class="num">2</span><span class="sym">,</span> iterations<span class="sym">&gt;&gt;=</span><span class="num">2</span><span class="sym">) {

</span>		<span class="kwa">for</span> <span class="sym">(</span>count<span class="sym">=</span><span class="num">1</span><span class="sym">,</span> chk<span class="sym">=</span><span class="num">0</span><span class="sym">;</span> count <span class="sym">&lt;=</span> iterations<span class="sym">;</span> count<span class="sym">++) {

</span>			<span class="kwa">if</span> <span class="sym">(</span>allocate_tree<span class="sym">(&amp;</span>a<span class="sym">,</span> depth<span class="sym">) == -</span><span class="num">1</span><span class="sym">)</span> <span class="kwa">return</span> <span class="num">-1</span><span class="sym">;
</span>			<span class="kwa">if</span> <span class="sym">(</span>allocate_tree<span class="sym">(&amp;</span>b<span class="sym">,</span> depth<span class="sym">) == -</span><span class="num">1</span><span class="sym">)</span> <span class="kwa">return</span> <span class="num">-1</span><span class="sym">;

</span>			init_clamp<span class="sym">(&amp;</span>a<span class="sym">, &amp;</span>clamp<span class="sym">);
</span>			tree_assign_pointers<span class="sym">(&amp;</span>clamp<span class="sym">, &amp;</span>a<span class="sym">.</span>root<span class="sym">,</span> count<span class="sym">,</span> depth<span class="sym">);

</span>			init_clamp<span class="sym">(&amp;</span>b<span class="sym">, &amp;</span>clamp<span class="sym">);
</span>			tree_assign_pointers<span class="sym">(&amp;</span>clamp<span class="sym">, &amp;</span>b<span class="sym">.</span>root<span class="sym">, -</span>count<span class="sym">,</span> depth<span class="sym">);

</span>			chk <span class="sym">+=</span> item_check<span class="sym">(</span>a<span class="sym">.</span>root<span class="sym">);</span> chk <span class="sym">+=</span> item_check<span class="sym">(</span>b<span class="sym">.</span>root<span class="sym">);
</span>			free_tree<span class="sym">(&amp;</span>a<span class="sym">);</span> free_tree<span class="sym">(&amp;</span>b<span class="sym">);

			}

</span>		printf<span class="sym">(</span><span class="str">&quot;%lu</span><span class="esc">\t </span> <span class="str">trees of depth %d</span><span class="esc">\t  </span>  <span class="str">check: %li</span><span class="esc">\n</span><span class="str">&quot;</span><span class="sym">,</span> iterations<span class="sym">*</span><span class="num">2</span><span class="sym">,</span> depth<span class="sym">,</span> chk<span class="sym">);

		}

</span>	chk <span class="sym">=</span> item_check<span class="sym">(</span>long_lived<span class="sym">.</span>nodes<span class="sym">);
</span>	printf<span class="sym">(</span><span class="str">&quot;long lived tree of depth %d</span><span class="esc">\t  </span>  <span class="str">check: %li</span><span class="esc">\n</span><span class="str">&quot;</span><span class="sym">,</span> max<span class="sym">,</span> chk<span class="sym">);

</span>	<span class="kwa">return</span> <span class="num">0</span><span class="sym">;

	}</span>
