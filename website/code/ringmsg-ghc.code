<span class="line">    1 </span><span class="com">{-
</span><span class="line">    2 </span><span class="com"> - ringmsg.hs
</span><span class="line">    3 </span><span class="com"> - http://shootout.alioth.debian.org/bench/ringmsg/
</span><span class="line">    4 </span><span class="com"> - Contributed by Aaron Denney
</span><span class="line">    5 </span><span class="com"> -
</span><span class="line">    6 </span><span class="com"> - There is no generalized message sending between Haskell threads, each
</span><span class="line">    7 </span><span class="com"> - bit of data has to have someplace to go.  This is implemented by
</span><span class="line">    8 </span><span class="com"> - giving each processes a rendezvous point (MVar a), telling
</span><span class="line">    9 </span><span class="com"> - each where to send, and where to receive.  In this light, the &quot;check
</span><span class="line">   10 </span><span class="com"> - sender&quot; is a bit silly, as the sender can only be the process that
</span><span class="line">   11 </span><span class="com"> - also has a reference.
</span><span class="line">   12 </span><span class="com"> -
</span><span class="line">   13 </span><span class="com"> - A closer match to what Erlang does would be to only have one channel,
</span><span class="line">   14 </span><span class="com"> - but stick a priority queue type thing (plus filtered access &amp; removal)
</span><span class="line">   15 </span><span class="com"> - on it.
</span><span class="line">   16 </span><span class="com"> -
</span><span class="line">   17 </span><span class="com"> - The Erlang implementation only checks for the low priority messages
</span><span class="line">   18 </span><span class="com"> - every 10 high priority messages, it looks like the &quot;after 0&quot; clause
</span><span class="line">   19 </span><span class="com"> - means it doesn't block for it.  We do.  This may change the behaviour.
</span><span class="line">   20 </span><span class="com"> -
</span><span class="line">   21 </span><span class="com"> - ghc ringmsg.hs -O2
</span><span class="line">   22 </span><span class="com"> -}</span>
<span class="line">   23 </span><span class="kwa">module</span> Main<span class="sym">(</span>main<span class="sym">)</span> <span class="kwa">where
</span><span class="line">   24 </span><span class="kwa">import</span> Control.Concurrent
<span class="line">   25 </span><span class="kwa">import</span> System<span class="sym">(</span>getArgs<span class="sym">)
</span><span class="line">   26 </span><span class="sym">
</span><span class="line">   27 </span><span class="sym"></span><span class="slc">-- Constants
</span><span class="line">   28 </span><span class="slc"></span>hiloratio <span class="sym">=</span> <span class="num">10</span>        <span class="slc">-- how many high priority messages to send per low priority.
</span><span class="line">   29 </span><span class="slc"></span>processes <span class="sym">=</span> <span class="num">8192</span>      <span class="slc">-- how many processes to put in a ring.
</span><span class="line">   30 </span><span class="slc"></span>message <span class="sym">=</span> <span class="str">&quot;the_ring&quot;</span>  <span class="slc">-- The high priority message to send around the ring
</span><span class="line">   31 </span><span class="slc"></span>low_priority <span class="sym">=</span> <span class="str">&quot;low&quot;</span>  <span class="slc">-- Just a fake message to be the 'low priority' guy
</span><span class="line">   32 </span><span class="slc"></span>fork <span class="sym">=</span> forkIO         <span class="slc">-- forkOS would be the other choice.
</span><span class="line">   33 </span><span class="slc"></span>
<span class="line">   34 </span><span class="slc">-- Channels or MVars
</span><span class="line">   35 </span><span class="slc"></span>receive <span class="sym">=</span> takeMVar     <span class="slc">-- or readChan
</span><span class="line">   36 </span><span class="slc"></span>write   <span class="sym">=</span> putMVar      <span class="slc">-- or writeChan
</span><span class="line">   37 </span><span class="slc"></span>newLink <span class="sym">=</span> newEmptyMVar <span class="slc">-- or newChan
</span><span class="line">   38 </span><span class="slc"></span>
<span class="line">   39 </span>forever <span class="sym">::</span> IO <span class="sym">() -&gt;</span> IO <span class="sym">()
</span><span class="line">   40 </span><span class="sym"></span>forever x <span class="sym">=</span> sequence_ $ repeat x
<span class="line">   41 </span>
<span class="line">   42 </span>for <span class="sym">::</span> <span class="kwb">Int</span> <span class="sym">-&gt;</span> IO <span class="sym">() -&gt;</span> IO <span class="sym">()
</span><span class="line">   43 </span><span class="sym"></span>for count x <span class="sym">=</span> sequence_ <span class="sym">[</span>x <span class="sym">|</span> i <span class="sym">&lt;- [</span><span class="num">1</span> .. count<span class="sym">]]
</span><span class="line">   44 </span><span class="sym">
</span><span class="line">   45 </span><span class="sym"></span><span class="kwa">type</span> ID <span class="sym">=</span> <span class="kwb">Int
</span><span class="line">   46 </span><span class="kwb"></span><span class="kwa">data</span> Message a <span class="sym">=</span> M ID a
<span class="line">   47 </span>
<span class="line">   48 </span>assert <span class="sym">::</span> <span class="kwb">Bool</span> <span class="sym">-&gt;</span> IO <span class="sym">()
</span><span class="line">   49 </span><span class="sym"></span>assert <span class="kwa">False</span> <span class="sym">=</span> error <span class="str">&quot;assert failed&quot;</span>
<span class="line">   50 </span>assert <span class="kwa">True</span>  <span class="sym">=</span> return <span class="sym">()
</span><span class="line">   51 </span><span class="sym">
</span><span class="line">   52 </span><span class="sym"></span><span class="slc">-- Each slave repeats the basic step of reading and writing forever.
</span><span class="line">   53 </span><span class="slc"></span>slaveproc a b <span class="sym">=</span> forever $ relay a b
<span class="line">   54 </span>
<span class="line">   55 </span><span class="slc">-- Read hiloratio highs, relay them, then handle the low.
</span><span class="line">   56 </span><span class="slc"></span>relay <span class="sym">(</span>sendid<span class="sym">,</span> loin<span class="sym">,</span> hiin<span class="sym">) (</span>myid<span class="sym">,</span> loout<span class="sym">,</span> hiout<span class="sym">) =</span> <span class="kwa">do
</span><span class="line">   57 </span><span class="kwa"></span>        for hiloratio $ sendhis sendid myid hiin hiout
<span class="line">   58 </span>        sendlos sendid myid loin loout
<span class="line">   59 </span>
<span class="line">   60 </span><span class="slc">-- The master process (the beginning and end):
</span><span class="line">   61 </span><span class="slc"></span><span class="slc">-- start one high, one lowpriority message, and wait for the low
</span><span class="line">   62 </span><span class="slc"></span><span class="slc">-- to travel around runs times.
</span><span class="line">   63 </span><span class="slc"></span>masterproc runs a&#64;<span class="sym">(</span>lastid<span class="sym">,</span> loin<span class="sym">,</span> hiin<span class="sym">)</span> b&#64;<span class="sym">(</span>myid<span class="sym">,</span> loout<span class="sym">,</span> hiout<span class="sym">) =</span> <span class="kwa">do
</span><span class="line">   64 </span><span class="kwa"></span>        startmsgs myid hiout loout
<span class="line">   65 </span>        <span class="kwa">let</span> runsB <span class="sym">=</span> runs <span class="num">- 1</span> <span class="kwa">in
</span><span class="line">   66 </span><span class="kwa"></span>                for runsB $ relay a b
<span class="line">   67 </span>        lastrcv a <span class="sym">&gt;&gt;=</span> return
<span class="line">   68 </span>
<span class="line">   69 </span><span class="slc">-- Sending a message involves waiting to get the message from the
</span><span class="line">   70 </span><span class="slc"></span><span class="slc">-- upstream slave, verifying it's who you expect it should be from,
</span><span class="line">   71 </span><span class="slc"></span><span class="slc">-- then passing the message on to the next one.
</span><span class="line">   72 </span><span class="slc"></span>sendhis sendid myid hiin hiout <span class="sym">=</span> <span class="kwa">do
</span><span class="line">   73 </span><span class="kwa"></span>        M s d <span class="sym">&lt;-</span> receive hiin
<span class="line">   74 </span>        assert $ sendid <span class="sym">==</span> s
<span class="line">   75 </span>        write hiout <span class="sym">(</span>M myid d<span class="sym">)
</span><span class="line">   76 </span><span class="sym">
</span><span class="line">   77 </span><span class="sym"></span>sendlos <span class="sym">=</span> sendhis
<span class="line">   78 </span>
<span class="line">   79 </span>startmsgs myid hiout loout <span class="sym">=</span> <span class="kwa">do
</span><span class="line">   80 </span><span class="kwa"></span>        write hiout <span class="sym">(</span>M myid message<span class="sym">)
</span><span class="line">   81 </span><span class="sym"></span>        write loout <span class="sym">(</span>M myid low_priority<span class="sym">)
</span><span class="line">   82 </span><span class="sym">
</span><span class="line">   83 </span><span class="sym"></span>lastrcv <span class="sym">(</span>sendid<span class="sym">,</span> loin<span class="sym">,</span> hiin<span class="sym">)  =</span> <span class="kwa">do
</span><span class="line">   84 </span><span class="kwa"></span>        M s d <span class="sym">&lt;-</span> receive hiin
<span class="line">   85 </span>        assert $ sendid <span class="sym">==</span> s
<span class="line">   86 </span>        return d
<span class="line">   87 </span>
<span class="line">   88 </span>main <span class="sym">=</span> <span class="kwa">do</span> ~<span class="sym">[</span>runs<span class="sym">] &lt;-</span> getArgs
<span class="line">   89 </span>          doit $ read runs
<span class="line">   90 </span>
<span class="line">   91 </span>doit <span class="sym">::</span> <span class="kwb">Int</span> <span class="sym">-&gt;</span> IO <span class="sym">()
</span><span class="line">   92 </span><span class="sym"></span>doit runs <span class="sym">=</span> <span class="kwa">do
</span><span class="line">   93 </span><span class="kwa">        let</span> ids <span class="sym">= [</span><span class="num">1</span>..processes<span class="sym">]
</span><span class="line">   94 </span><span class="sym"></span>        hichans <span class="sym">&lt;-</span> sequence $ replicate processes newLink
<span class="line">   95 </span>        lochans <span class="sym">&lt;-</span> sequence $ replicate processes newLink
<span class="line">   96 </span>        <span class="kwa">let</span> args <span class="sym">=</span> zip3 ids hichans lochans
<span class="line">   97 </span>        <span class="kwa">let</span> slaveprocs <span class="sym">=</span> zipWith slaveproc args <span class="sym">(</span>tail args<span class="sym">)
</span><span class="line">   98 </span><span class="sym"></span>        mapM fork slaveprocs
<span class="line">   99 </span>        last_msg <span class="sym">&lt;-</span> masterproc runs <span class="sym">(</span>last args<span class="sym">) (</span>head args<span class="sym">)
</span><span class="line">  100 </span><span class="sym"></span>        putStrLn last_msg
