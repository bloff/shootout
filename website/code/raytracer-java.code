<span class="slc">// The Great Computer Language Shootout
</span><span class="slc">// http://shootout.alioth.debian.org/
</span><span class="slc">// Fastest version under 100 LOC. Contributed by Jon Harrop, 2005
</span>
<span class="kwa">import</span> java<span class="sym">.</span>util<span class="sym">.*;
</span><span class="kwa">public final class</span> ray <span class="sym">{
</span>    <span class="slc">// Use &quot;double delta=Math.sqrt(Math.ulp(1.0))&quot; with Java 1.5 or better
</span>    <span class="kwb">double</span> delta<span class="sym">=</span><span class="kwc">Math</span><span class="sym">.</span>sqrt<span class="sym">(</span><span class="num">2.22044604925031e</span><span class="sym">-</span><span class="num">16</span><span class="sym">),</span> infinity<span class="sym">=</span><span class="kwc">Float</span><span class="sym">.</span>POSITIVE_INFINITY<span class="sym">;
</span>    <span class="kwa">class</span> Vec <span class="sym">{
</span>	<span class="kwa">public</span> <span class="kwb">double</span> x<span class="sym">,</span> y<span class="sym">,</span> z<span class="sym">;
</span>	<span class="kwa">public</span> Vec<span class="sym">(</span><span class="kwb">double</span> x2<span class="sym">,</span> <span class="kwb">double</span> y2<span class="sym">,</span> <span class="kwb">double</span> z2<span class="sym">) {</span> x<span class="sym">=</span>x2<span class="sym">;</span> y<span class="sym">=</span>y2<span class="sym">;</span> z<span class="sym">=</span>z2<span class="sym">; }
    }
</span>    Vec add<span class="sym">(</span>Vec a<span class="sym">,</span> Vec b<span class="sym">) {</span> <span class="kwa">return new</span> Vec<span class="sym">(</span>a<span class="sym">.</span>x<span class="sym">+</span>b<span class="sym">.</span>x<span class="sym">,</span> a<span class="sym">.</span>y<span class="sym">+</span>b<span class="sym">.</span>y<span class="sym">,</span> a<span class="sym">.</span>z<span class="sym">+</span>b<span class="sym">.</span>z<span class="sym">); }
</span>    Vec sub<span class="sym">(</span>Vec a<span class="sym">,</span> Vec b<span class="sym">) {</span> <span class="kwa">return new</span> Vec<span class="sym">(</span>a<span class="sym">.</span>x<span class="sym">-</span>b<span class="sym">.</span>x<span class="sym">,</span> a<span class="sym">.</span>y<span class="sym">-</span>b<span class="sym">.</span>y<span class="sym">,</span> a<span class="sym">.</span>z<span class="sym">-</span>b<span class="sym">.</span>z<span class="sym">); }
</span>    Vec scale<span class="sym">(</span><span class="kwb">double</span> s<span class="sym">,</span> Vec a<span class="sym">) {</span> <span class="kwa">return new</span> Vec<span class="sym">(</span>s<span class="sym">*</span>a<span class="sym">.</span>x<span class="sym">,</span> s<span class="sym">*</span>a<span class="sym">.</span>y<span class="sym">,</span> s<span class="sym">*</span>a<span class="sym">.</span>z<span class="sym">); }
</span>    <span class="kwb">double</span> dot<span class="sym">(</span>Vec a<span class="sym">,</span> Vec b<span class="sym">) {</span> <span class="kwa">return</span> a<span class="sym">.</span>x<span class="sym">*</span>b<span class="sym">.</span>x <span class="sym">+</span> a<span class="sym">.</span>y<span class="sym">*</span>b<span class="sym">.</span>y <span class="sym">+</span> a<span class="sym">.</span>z<span class="sym">*</span>b<span class="sym">.</span>z<span class="sym">; }
</span>    Vec unitise<span class="sym">(</span>Vec a<span class="sym">) {</span> <span class="kwa">return</span> scale<span class="sym">(</span><span class="num">1</span> <span class="sym">/</span> <span class="kwc">Math</span><span class="sym">.</span>sqrt<span class="sym">(</span>dot<span class="sym">(</span>a<span class="sym">,</span> a<span class="sym">)),</span> a<span class="sym">); }
</span>    <span class="kwa">class</span> Ray <span class="sym">{
</span>	<span class="kwa">public</span> Vec orig<span class="sym">,</span> dir<span class="sym">;
</span>	<span class="kwa">public</span> Ray<span class="sym">(</span>Vec o<span class="sym">,</span> Vec d<span class="sym">) {</span> orig<span class="sym">=</span>o<span class="sym">;</span> dir<span class="sym">=</span>d<span class="sym">; }
    }
</span>    <span class="kwa">class</span> Hit <span class="sym">{
</span>	<span class="kwa">public</span> <span class="kwb">double</span> lambda<span class="sym">;
</span>	<span class="kwa">public</span> Vec normal<span class="sym">;
</span> 	<span class="kwa">public</span> Hit<span class="sym">(</span><span class="kwb">double</span> l<span class="sym">,</span> Vec n<span class="sym">) {</span> lambda<span class="sym">=</span>l<span class="sym">;</span> normal<span class="sym">=</span>n<span class="sym">; }
    }
</span>    <span class="kwa">abstract class</span> Scene <span class="sym">{
</span>	<span class="kwa">abstract public</span> Hit intersect<span class="sym">(</span>Hit i<span class="sym">,</span> Ray ray<span class="sym">);
    }
</span>    <span class="kwa">class</span> Sphere <span class="kwa">extends</span> Scene <span class="sym">{
</span>	<span class="kwa">public</span> Vec center<span class="sym">;
</span>	<span class="kwa">public</span> <span class="kwb">double</span> radius<span class="sym">;
</span>	<span class="kwa">public</span> Sphere<span class="sym">(</span>Vec c<span class="sym">,</span> <span class="kwb">double</span> r<span class="sym">) {</span> center<span class="sym">=</span>c<span class="sym">;</span> radius<span class="sym">=</span>r<span class="sym">; }
</span>	<span class="kwa">public</span> <span class="kwb">double</span> ray_sphere<span class="sym">(</span>Ray ray<span class="sym">) {
</span>	    Vec v <span class="sym">=</span> sub<span class="sym">(</span>center<span class="sym">,</span> ray<span class="sym">.</span>orig<span class="sym">);
</span>	    <span class="kwb">double</span> b <span class="sym">=</span> dot<span class="sym">(</span>v<span class="sym">,</span> ray<span class="sym">.</span>dir<span class="sym">),
</span>		disc <span class="sym">=</span> b<span class="sym">*</span>b <span class="sym">-</span> dot<span class="sym">(</span>v<span class="sym">,</span> v<span class="sym">) +</span> radius<span class="sym">*</span>radius<span class="sym">;
</span>	    <span class="kwa">if</span> <span class="sym">(</span>disc <span class="sym">&lt;</span> <span class="num">0</span><span class="sym">)</span> <span class="kwa">return</span> infinity<span class="sym">;
</span>	    <span class="kwb">double</span> d <span class="sym">=</span> <span class="kwc">Math</span><span class="sym">.</span>sqrt<span class="sym">(</span>disc<span class="sym">),</span> t2 <span class="sym">=</span> b<span class="sym">+</span>d<span class="sym">;
</span>	    <span class="kwa">if</span> <span class="sym">(</span>t2 <span class="sym">&lt;</span> <span class="num">0</span><span class="sym">)</span> <span class="kwa">return</span> infinity<span class="sym">;
</span>	    <span class="kwb">double</span> t1 <span class="sym">=</span> b<span class="sym">-</span>d<span class="sym">;
</span>	    <span class="kwa">return</span> <span class="sym">(</span>t1 <span class="sym">&gt;</span> <span class="num">0</span> ? t1 <span class="sym">:</span> t2<span class="sym">);
	}
</span>	<span class="kwa">public</span> Hit intersect<span class="sym">(</span>Hit i<span class="sym">,</span> Ray ray<span class="sym">) {
</span>	    <span class="kwb">double</span> l <span class="sym">=</span> ray_sphere<span class="sym">(</span>ray<span class="sym">);
</span>	    <span class="kwa">if</span> <span class="sym">(</span>l <span class="sym">&gt;=</span> i<span class="sym">.</span>lambda<span class="sym">)</span> <span class="kwa">return</span> i<span class="sym">;
</span>	    Vec n <span class="sym">=</span> add<span class="sym">(</span>ray<span class="sym">.</span>orig<span class="sym">,</span> sub<span class="sym">(</span>scale<span class="sym">(</span>l<span class="sym">,</span> ray<span class="sym">.</span>dir<span class="sym">),</span> center<span class="sym">));
</span>	    <span class="kwa">return new</span> Hit<span class="sym">(</span>l<span class="sym">,</span> unitise<span class="sym">(</span>n<span class="sym">));
	}
    }
</span>    <span class="kwa">class</span> <span class="kwc">Group</span> <span class="kwa">extends</span> Scene <span class="sym">{
</span>	<span class="kwa">public</span> Sphere bound<span class="sym">;
</span>	<span class="kwa">public</span> <span class="kwc">LinkedList</span> objs<span class="sym">;
</span>	<span class="kwa">public</span> <span class="kwc">Group</span><span class="sym">(</span>Sphere b<span class="sym">) {
</span>	    bound <span class="sym">=</span> b<span class="sym">;
</span>	    objs <span class="sym">=</span> <span class="kwa">new</span> <span class="kwc">LinkedList</span><span class="sym">();
	}
</span>	<span class="kwa">public</span> Hit intersect<span class="sym">(</span>Hit i<span class="sym">,</span> Ray ray<span class="sym">) {
</span>	    <span class="kwb">double</span> l <span class="sym">=</span> bound<span class="sym">.</span>ray_sphere<span class="sym">(</span>ray<span class="sym">);
</span>	    <span class="kwa">if</span> <span class="sym">(</span>l <span class="sym">&gt;=</span> i<span class="sym">.</span>lambda<span class="sym">)</span> <span class="kwa">return</span> i<span class="sym">;
</span>	    <span class="kwc">ListIterator</span> it <span class="sym">=</span> objs<span class="sym">.</span>listIterator<span class="sym">(</span><span class="num">0</span><span class="sym">);
</span>	    <span class="kwa">while</span> <span class="sym">(</span>it<span class="sym">.</span>hasNext<span class="sym">()) {
</span>		Scene scene <span class="sym">= (</span>Scene<span class="sym">)</span>it<span class="sym">.</span>next<span class="sym">();
</span>		i <span class="sym">=</span> scene<span class="sym">.</span>intersect<span class="sym">(</span>i<span class="sym">,</span> ray<span class="sym">);
	    }
</span>	    <span class="kwa">return</span> i<span class="sym">;
	}
    }
</span>    <span class="kwb">double</span> ray_trace<span class="sym">(</span>Vec light<span class="sym">,</span> Ray ray<span class="sym">,</span> Scene scene<span class="sym">) {
</span>	Hit i <span class="sym">=</span> scene<span class="sym">.</span>intersect<span class="sym">(</span><span class="kwa">new</span> Hit<span class="sym">(</span>infinity<span class="sym">,</span> <span class="kwa">new</span> Vec<span class="sym">(</span><span class="num">0</span><span class="sym">,</span> <span class="num">0</span><span class="sym">,</span> <span class="num">0</span><span class="sym">)),</span> ray<span class="sym">);
</span>	<span class="kwa">if</span> <span class="sym">(</span>i<span class="sym">.</span>lambda <span class="sym">==</span> infinity<span class="sym">)</span> <span class="kwa">return</span> <span class="num">0</span><span class="sym">;
</span>	Vec o <span class="sym">=</span> add<span class="sym">(</span>ray<span class="sym">.</span>orig<span class="sym">,</span> add<span class="sym">(</span>scale<span class="sym">(</span>i<span class="sym">.</span>lambda<span class="sym">,</span> ray<span class="sym">.</span>dir<span class="sym">),
</span>				  scale<span class="sym">(</span>delta<span class="sym">,</span> i<span class="sym">.</span>normal<span class="sym">)));
</span>	<span class="kwb">double</span> g <span class="sym">=</span> dot<span class="sym">(</span>i<span class="sym">.</span>normal<span class="sym">,</span> light<span class="sym">);
</span>	<span class="kwa">if</span> <span class="sym">(</span>g <span class="sym">&gt;=</span> <span class="num">0</span><span class="sym">)</span> <span class="kwa">return</span> <span class="num">0</span><span class="sym">.;
</span>	Ray sray <span class="sym">=</span> <span class="kwa">new</span> Ray<span class="sym">(</span>o<span class="sym">,</span> scale<span class="sym">(-</span><span class="num">1</span><span class="sym">,</span> light<span class="sym">));
</span>	Hit si <span class="sym">=</span> scene<span class="sym">.</span>intersect<span class="sym">(</span><span class="kwa">new</span> Hit<span class="sym">(</span>infinity<span class="sym">,</span> <span class="kwa">new</span> Vec<span class="sym">(</span><span class="num">0</span><span class="sym">,</span> <span class="num">0</span><span class="sym">,</span> <span class="num">0</span><span class="sym">)),</span> sray<span class="sym">);
</span>	<span class="kwa">return</span> <span class="sym">(</span>si<span class="sym">.</span>lambda <span class="sym">==</span> infinity ? <span class="sym">-</span>g <span class="sym">:</span> <span class="num">0</span><span class="sym">);
    }
</span>    Scene create<span class="sym">(</span><span class="kwb">int</span> level<span class="sym">,</span> Vec c<span class="sym">,</span> <span class="kwb">double</span> r<span class="sym">) {
</span>	Sphere sphere <span class="sym">=</span> <span class="kwa">new</span> Sphere<span class="sym">(</span>c<span class="sym">,</span> r<span class="sym">);
</span>	<span class="kwa">if</span> <span class="sym">(</span>level <span class="sym">==</span> <span class="num">1</span><span class="sym">)</span> <span class="kwa">return</span> sphere<span class="sym">;
</span>	<span class="kwc">Group</span> group <span class="sym">=</span> <span class="kwa">new</span> <span class="kwc">Group</span><span class="sym">(</span><span class="kwa">new</span> Sphere<span class="sym">(</span>c<span class="sym">,</span> <span class="num">3</span><span class="sym">*</span>r<span class="sym">));
</span>	group<span class="sym">.</span>objs<span class="sym">.</span>addLast<span class="sym">(</span>sphere<span class="sym">);
</span>	<span class="kwb">double</span> rn <span class="sym">=</span> <span class="num">3</span><span class="sym">*</span>r<span class="sym">/</span><span class="kwc">Math</span><span class="sym">.</span>sqrt<span class="sym">(</span><span class="num">12</span><span class="sym">);
</span>	<span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> dz<span class="sym">=-</span><span class="num">1</span><span class="sym">;</span> dz<span class="sym">&lt;=</span><span class="num">1</span><span class="sym">;</span> dz<span class="sym">+=</span><span class="num">2</span><span class="sym">)
</span>	    <span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> dx<span class="sym">=-</span><span class="num">1</span><span class="sym">;</span> dx<span class="sym">&lt;=</span><span class="num">1</span><span class="sym">;</span> dx<span class="sym">+=</span><span class="num">2</span><span class="sym">) {
</span>		Vec c2 <span class="sym">=</span> <span class="kwa">new</span> Vec<span class="sym">(</span>c<span class="sym">.</span>x<span class="sym">+</span>dx<span class="sym">*</span>rn<span class="sym">,</span> c<span class="sym">.</span>y<span class="sym">+</span>rn<span class="sym">,</span> c<span class="sym">.</span>z<span class="sym">+</span>dz<span class="sym">*</span>rn<span class="sym">);
</span>		group<span class="sym">.</span>objs<span class="sym">.</span>addLast<span class="sym">(</span>create<span class="sym">(</span>level<span class="num">-1</span><span class="sym">,</span> c2<span class="sym">,</span> r<span class="sym">/</span><span class="num">2</span><span class="sym">));
	    }
</span>	<span class="kwa">return</span> group<span class="sym">;
    }
</span>    <span class="kwb">void</span> run<span class="sym">(</span><span class="kwb">int</span> n<span class="sym">,</span> <span class="kwb">int</span> level<span class="sym">,</span> <span class="kwb">int</span> ss<span class="sym">) {
</span>	Scene scene <span class="sym">=</span> create<span class="sym">(</span>level<span class="sym">,</span> <span class="kwa">new</span> Vec<span class="sym">(</span><span class="num">0</span><span class="sym">, -</span><span class="num">1</span><span class="sym">,</span> <span class="num">0</span><span class="sym">),</span> <span class="num">1</span><span class="sym">);
</span>	<span class="kwc">System</span><span class="sym">.</span>out<span class="sym">.</span>print<span class="sym">(</span><span class="str">&quot;P5</span><span class="esc">\n</span><span class="str">&quot;</span><span class="sym">+</span>n<span class="sym">+</span><span class="str">&quot; &quot;</span><span class="sym">+</span>n<span class="sym">+</span><span class="str">&quot;</span><span class="esc">\n</span><span class="str">255</span><span class="esc">\n</span><span class="str">&quot;</span><span class="sym">);
</span>	<span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> y<span class="sym">=</span>n<span class="num">-1</span><span class="sym">;</span> y<span class="sym">&gt;=</span><span class="num">0</span><span class="sym">; --</span>y<span class="sym">)
</span>	    <span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> x<span class="sym">=</span><span class="num">0</span><span class="sym">;</span> x<span class="sym">&lt;</span>n<span class="sym">; ++</span>x<span class="sym">) {
</span>		<span class="kwb">double</span> g<span class="sym">=</span><span class="num">0</span><span class="sym">;
</span>		<span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> dx<span class="sym">=</span><span class="num">0</span><span class="sym">;</span> dx<span class="sym">&lt;</span>ss<span class="sym">; ++</span>dx<span class="sym">)
</span>		    <span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> dy<span class="sym">=</span><span class="num">0</span><span class="sym">;</span> dy<span class="sym">&lt;</span>ss<span class="sym">; ++</span>dy<span class="sym">) {
</span>			Vec d <span class="sym">=</span> <span class="kwa">new</span> Vec<span class="sym">(</span>x<span class="sym">+</span>dx<span class="sym">*</span><span class="num">1</span><span class="sym">./</span>ss<span class="sym">-</span>n<span class="sym">/</span><span class="num">2</span><span class="sym">.,</span> y<span class="sym">+</span>dy<span class="sym">*</span><span class="num">1</span><span class="sym">./</span>ss<span class="sym">-</span>n<span class="sym">/</span><span class="num">2</span><span class="sym">.,</span> n<span class="sym">);
</span>			Ray ray <span class="sym">=</span> <span class="kwa">new</span> Ray<span class="sym">(</span><span class="kwa">new</span> Vec<span class="sym">(</span><span class="num">0</span><span class="sym">,</span> <span class="num">0</span><span class="sym">, -</span><span class="num">4</span><span class="sym">),</span> unitise<span class="sym">(</span>d<span class="sym">));
</span>			g <span class="sym">+=</span> ray_trace<span class="sym">(</span>unitise<span class="sym">(</span><span class="kwa">new</span> Vec<span class="sym">(-</span><span class="num">1</span><span class="sym">, -</span><span class="num">3</span><span class="sym">,</span> <span class="num">2</span><span class="sym">)),
</span>				       ray<span class="sym">,</span> scene<span class="sym">);
		    }
</span>                <span class="kwc">System</span><span class="sym">.</span>out<span class="sym">.</span>print<span class="sym">((</span><span class="kwb">char</span><span class="sym">)(</span><span class="num">.5</span><span class="sym">+</span><span class="num">255</span><span class="sym">*</span>g<span class="sym">/(</span>ss<span class="sym">*</span>ss<span class="sym">)));
	    }
    }
</span>    <span class="kwa">public static</span> <span class="kwb">void</span> main<span class="sym">(</span><span class="kwc">String</span><span class="sym">[]</span> args<span class="sym">) {
	(</span><span class="kwa">new</span> ray<span class="sym">()).</span>run<span class="sym">(</span><span class="kwc">Integer</span><span class="sym">.</span>parseInt<span class="sym">(</span>args<span class="sym">[</span><span class="num">0</span><span class="sym">]),</span> <span class="num">6</span><span class="sym">,</span> <span class="num">4</span><span class="sym">);
    }
}</span>
