<span class="line">    1 </span><span class="slc">-- $Id: lists-nhc98.code,v 1.4 2004-11-13 07:41:49 bfulgham Exp $
</span><span class="line">    2 </span><span class="slc"></span><span class="slc">-- http://shootout.alioth.debian.org/
</span><span class="line">    3 </span><span class="slc"></span><span class="slc">-- Contributed by Malcolm Wallace
</span><span class="line">    4 </span><span class="slc"></span><span class="kwa">import</span> System<span class="sym">(</span>getArgs<span class="sym">)
</span><span class="line">    5 </span><span class="sym"></span><span class="kwa">import</span> Prelude
<span class="line">    6 </span>
<span class="line">    7 </span>main  <span class="sym">=</span> getArgs <span class="sym">&gt;&gt;=</span> print . for . read . head
<span class="line">    8 </span>for n <span class="sym">=</span> foldr <span class="sym">(</span>\_ p <span class="sym">-&gt;</span> if test p <span class="sym">==</span> p <span class="kwa">then</span> p <span class="kwa">else</span> <span class="num">0</span><span class="sym">)</span> size <span class="sym">[</span><span class="num">1</span>..n<span class="sym">]
</span><span class="line">    9 </span><span class="sym"></span>size <span class="sym">=</span> <span class="num">10000
</span><span class="line">   10 </span><span class="num">
</span><span class="line">   11 </span><span class="num"></span>test <span class="sym">::</span> <span class="kwb">Int</span> <span class="sym">-&gt;</span> <span class="kwb">Int
</span><span class="line">   12 </span><span class="kwb"></span>test size <span class="sym">|</span> isok1 <span class="sym">&amp;&amp;</span> isok2  <span class="sym">=</span> dlength l1<span class="str">'
</span><span class="line">   13 </span><span class="str">          | otherwise       = error &quot;broken&quot;
</span><span class="line">   14 </span><span class="str">  where
</span><span class="line">   15 </span><span class="str">        l1    = deque [1..size]
</span><span class="line">   16 </span><span class="str">        l2    = l1         -- exactly the builtin copy operation!
</span><span class="line">   17 </span><span class="str">        l3    = dfoldl snoc empty l2
</span><span class="line">   18 </span><span class="str">        l2'</span>   <span class="sym">=</span> dfoldr <span class="sym">(</span>flip snoc<span class="sym">)</span> empty l3
<span class="line">   19 </span>        l1<span class="str">'   = dreverse l1
</span><span class="line">   20 </span><span class="str">        isok1 = dhead l1'</span> <span class="sym">==</span> size
<span class="line">   21 </span>        isok2 <span class="sym">=</span> l1<span class="str">' == l2'</span>
<span class="line">   22 </span>
<span class="line">   23 </span>
<span class="line">   24 </span><span class="slc">-- data type for reasonably efficient double-ended queues
</span><span class="line">   25 </span><span class="slc"></span><span class="kwa">data</span> Deque a <span class="sym">= [</span>a<span class="sym">] :</span># <span class="sym">[</span>a<span class="sym">]</span> <span class="kwa">deriving</span> Show
<span class="line">   26 </span><span class="kwa">infix</span> <span class="num">4</span> <span class="sym">:</span># <span class="slc">-- like ==, weaker than (:) and (++)
</span><span class="line">   27 </span><span class="slc"></span>
<span class="line">   28 </span>empty <span class="sym">= ([] :</span># <span class="sym">[])
</span><span class="line">   29 </span><span class="sym">
</span><span class="line">   30 </span><span class="sym"></span>deque <span class="sym">:: [</span>a<span class="sym">] -&gt;</span> Deque a
<span class="line">   31 </span>deque xs <span class="sym">=</span> take_half xs <span class="sym">:</span># reverse <span class="sym">(</span>drop_half xs<span class="sym">)
</span><span class="line">   32 </span><span class="sym">
</span><span class="line">   33 </span><span class="sym"></span>drop_half xs <span class="sym">=</span> dh xs xs
<span class="line">   34 </span>    <span class="kwa">where</span> dh xs     <span class="sym">[]       =</span> xs
<span class="line">   35 </span>          dh xs     <span class="sym">[</span>_<span class="sym">]      =</span> xs
<span class="line">   36 </span>          dh <span class="sym">(</span>x<span class="sym">:</span>xs<span class="sym">) (</span>_<span class="sym">:</span>_<span class="sym">:</span>fs<span class="sym">) =</span> dh xs fs
<span class="line">   37 </span>take_half xs <span class="sym">=</span> th xs xs
<span class="line">   38 </span>    <span class="kwa">where</span> th xs     <span class="sym">[]       = []
</span><span class="line">   39 </span><span class="sym"></span>          th xs     <span class="sym">[</span>_<span class="sym">]      = []
</span><span class="line">   40 </span><span class="sym"></span>          th <span class="sym">(</span>x<span class="sym">:</span>xs<span class="sym">) (</span>_<span class="sym">:</span>_<span class="sym">:</span>fs<span class="sym">) =</span> x <span class="sym">:</span> th xs fs
<span class="line">   41 </span>
<span class="line">   42 </span>cons x <span class="sym">(</span>xs <span class="sym">:</span># <span class="sym">[]) = [</span>x<span class="sym">] :</span># xs
<span class="line">   43 </span>cons x <span class="sym">(</span>xs <span class="sym">:</span># ys<span class="sym">) =</span> x<span class="sym">:</span>xs <span class="sym">:</span># ys
<span class="line">   44 </span>
<span class="line">   45 </span>snoc <span class="sym">([] :</span># ys<span class="sym">)</span> y <span class="sym">=</span> ys <span class="sym">:</span># <span class="sym">[</span>y<span class="sym">]
</span><span class="line">   46 </span><span class="sym"></span>snoc <span class="sym">(</span>xs <span class="sym">:</span># ys<span class="sym">)</span> y <span class="sym">=</span> xs <span class="sym">:</span># y<span class="sym">:</span>ys
<span class="line">   47 </span>
<span class="line">   48 </span>nil <span class="sym">([] :</span># <span class="sym">[]) =</span> <span class="kwa">True
</span><span class="line">   49 </span><span class="kwa"></span>nil _          <span class="sym">=</span> <span class="kwa">False
</span><span class="line">   50 </span><span class="kwa">
</span><span class="line">   51 </span><span class="kwa"></span>dlength <span class="sym">(</span>xs <span class="sym">:</span># ys<span class="sym">) =</span> length xs <span class="sym">+</span> length ys
<span class="line">   52 </span>
<span class="line">   53 </span>dhead <span class="sym">(</span>x<span class="sym">:</span>xs <span class="sym">:</span># ys <span class="sym">) =</span> x
<span class="line">   54 </span>dhead <span class="sym">([]   :</span># <span class="sym">[</span>y<span class="sym">]) =</span> y
<span class="line">   55 </span>
<span class="line">   56 </span>dtail <span class="sym">([]   :</span># <span class="sym">[</span>y<span class="sym">]) = [] :</span># <span class="sym">[]
</span><span class="line">   57 </span><span class="sym"></span>dtail <span class="sym">([</span>x<span class="sym">]  :</span># ys <span class="sym">) =</span> reverse <span class="sym">(</span>drop_half ys<span class="sym">) :</span># take_half ys
<span class="line">   58 </span>dtail <span class="sym">(</span>x<span class="sym">:</span>xs <span class="sym">:</span># ys <span class="sym">) =</span> xs <span class="sym">:</span># ys
<span class="line">   59 </span>
<span class="line">   60 </span>dlast <span class="sym">(</span>xs  <span class="sym">:</span># y<span class="sym">:</span>ys<span class="sym">) =</span> y
<span class="line">   61 </span>dlast <span class="sym">([</span>x<span class="sym">] :</span># <span class="sym">[]  ) =</span> x
<span class="line">   62 </span>
<span class="line">   63 </span>dinit <span class="sym">([</span>x<span class="sym">] :</span># <span class="sym">[]  ) = [] :</span># <span class="sym">[]
</span><span class="line">   64 </span><span class="sym"></span>dinit <span class="sym">(</span>xs  <span class="sym">:</span># <span class="sym">[</span>y<span class="sym">] ) =</span> take_half xs <span class="sym">:</span># reverse <span class="sym">(</span>drop_half xs<span class="sym">)
</span><span class="line">   65 </span><span class="sym"></span>dinit <span class="sym">(</span>xs  <span class="sym">:</span># y<span class="sym">:</span>ys<span class="sym">) =</span> xs <span class="sym">:</span># ys
<span class="line">   66 </span>
<span class="line">   67 </span>dreverse <span class="sym">(</span>xs <span class="sym">:</span># ys<span class="sym">) = (</span>ys <span class="sym">:</span># xs<span class="sym">)
</span><span class="line">   68 </span><span class="sym">
</span><span class="line">   69 </span><span class="sym">([] :</span># <span class="sym">[]) +++</span> deq <span class="sym">=</span> deq
<span class="line">   70 </span>deq <span class="sym">+++ ([] :</span># <span class="sym">[]) =</span> deq
<span class="line">   71 </span><span class="sym">(</span>xs <span class="sym">:</span># ys<span class="sym">) +++ (</span>bs <span class="sym">:</span># cs<span class="sym">) = (</span>xs<span class="sym">++</span>reverse ys<span class="sym">) :</span># <span class="sym">(</span>cs<span class="sym">++</span>reverse bs<span class="sym">)
</span><span class="line">   72 </span><span class="sym">
</span><span class="line">   73 </span><span class="sym"></span>dfoldr <span class="sym">(*)</span> e seq <span class="sym">=</span> f seq
<span class="line">   74 </span>        <span class="kwa">where</span> f seq <span class="sym">|</span> nil seq  <span class="sym">=</span> e
<span class="line">   75 </span>                    <span class="sym">|</span> otherwise <span class="sym">=</span> dhead seq <span class="sym">*</span> f <span class="sym">(</span>dtail seq<span class="sym">)
</span><span class="line">   76 </span><span class="sym">
</span><span class="line">   77 </span><span class="sym"></span>dfoldl <span class="sym">(*)</span> e seq <span class="sym">=</span> f seq
<span class="line">   78 </span>        <span class="kwa">where</span> f seq <span class="sym">|</span> nil seq  <span class="sym">=</span> e
<span class="line">   79 </span>                    <span class="sym">|</span> otherwise <span class="sym">=</span> f <span class="sym">(</span>dinit seq<span class="sym">) *</span> dlast seq
<span class="line">   80 </span>
<span class="line">   81 </span><span class="kwa">instance</span> Eq a <span class="sym">=&gt;</span> Eq <span class="sym">(</span>Deque a<span class="sym">)</span> <span class="kwa">where
</span><span class="line">   82 </span><span class="kwa"></span>    <span class="sym">(</span>xs <span class="sym">:</span># ys<span class="sym">) == (</span><span class="kwa">as</span> <span class="sym">:</span># bs<span class="sym">)  =</span>  xs<span class="sym">++</span>reverse ys  <span class="sym">==</span>  <span class="kwa">as</span><span class="sym">++</span>reverse bs
<span class="line">   83 </span>
