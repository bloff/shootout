<table width="100%" border="0" cellpadding="5" cellspacing="0"><tr><td bgcolor="#FFFFFF"><pre>
<I><FONT COLOR="#B22222">-- $Id: lists-nhc98.code,v 1.2 2004-11-08 08:15:15 bfulgham Exp $
</FONT></I><I><FONT COLOR="#B22222">-- http://shootout.alioth.debian.org/
</FONT></I><I><FONT COLOR="#B22222">-- Contributed by Malcolm Wallace
</FONT></I><B><FONT COLOR="#A020F0">import</FONT></B> System(getArgs)
<B><FONT COLOR="#A020F0">import</FONT></B> Prelude

main  = getArgs &gt;&gt;= print . for . read . head
for n = foldr (\<B><FONT COLOR="#A020F0">_ </FONT></B>p -&gt; <B><FONT COLOR="#A020F0">if</FONT></B> test p == p <B><FONT COLOR="#A020F0">then</FONT></B> p <B><FONT COLOR="#A020F0">else</FONT></B> 0) size [1..n]
size = 10000

test <B><FONT COLOR="#228B22">:: Int -&gt; Int
</FONT></B>test size | isok1 &amp;&amp; isok2  = dlength l1'
          | otherwise       = error <B><FONT COLOR="#BC8F8F">&quot;broken&quot;</FONT></B>
  <B><FONT COLOR="#A020F0">where</FONT></B>
        l1    = deque [1..size]
        l2    = l1 	<I><FONT COLOR="#B22222">-- exactly the builtin copy operation!
</FONT></I>        l3    = dfoldl snoc empty l2
        l2'   = dfoldr (flip snoc) empty l3
        l1'   = dreverse l1
        isok1 = dhead l1' == size
        isok2 = l1' == l2'


<I><FONT COLOR="#B22222">-- data type for reasonably efficient double-ended queues
</FONT></I><B><FONT COLOR="#A020F0">data</FONT></B> Deque a = [a] :# [a] <B><FONT COLOR="#A020F0">deriving</FONT></B> Show
<B><FONT COLOR="#A020F0">infix</FONT></B> 4 :# <I><FONT COLOR="#B22222">-- like ==, weaker than (:) and (++)
</FONT></I>
empty = ([] :# [])

deque <B><FONT COLOR="#228B22">:: [a] -&gt; Deque a
</FONT></B>deque xs = take_half xs :# reverse (drop_half xs)

drop_half xs = dh xs xs
    <B><FONT COLOR="#A020F0">where</FONT></B> dh xs     []       = xs
	  dh xs     [<B><FONT COLOR="#A020F0">_] </FONT></B>     = xs
	  dh (x:xs) (<B><FONT COLOR="#A020F0">_:_</FONT></B>:fs) = dh xs fs
take_half xs = th xs xs
    <B><FONT COLOR="#A020F0">where</FONT></B> th xs     []       = []
	  th xs     [<B><FONT COLOR="#A020F0">_] </FONT></B>     = []
	  th (x:xs) (<B><FONT COLOR="#A020F0">_:_</FONT></B>:fs) = x : th xs fs

cons x (xs :# []) = [x] :# xs  
cons x (xs :# ys) = x:xs :# ys

snoc ([] :# ys) y = ys :# [y]
snoc (xs :# ys) y = xs :# y:ys

nil ([] :# []) = True
nil <B><FONT COLOR="#A020F0">_ </FONT></B>         = False

dlength (xs :# ys) = length xs + length ys

dhead (x:xs :# ys ) = x
dhead ([]   :# [y]) = y

dtail ([]   :# [y]) = [] :# []
dtail ([x]  :# ys ) = reverse (drop_half ys) :# take_half ys
dtail (x:xs :# ys ) = xs :# ys

dlast (xs  :# y:ys) = y
dlast ([x] :# []  ) = x

dinit ([x] :# []  ) = [] :# []
dinit (xs  :# [y] ) = take_half xs :# reverse (drop_half xs)
dinit (xs  :# y:ys) = xs :# ys  

dreverse (xs :# ys) = (ys :# xs)

([] :# []) +++ deq = deq
deq +++ ([] :# []) = deq
(xs :# ys) +++ (bs :# cs) = (xs++reverse ys) :# (cs++reverse bs)

dfoldr (*) e seq = f seq
	<B><FONT COLOR="#A020F0">where</FONT></B> f seq | nil seq  = e
		    | otherwise = dhead seq * f (dtail seq)

dfoldl (*) e seq = f seq
	<B><FONT COLOR="#A020F0">where</FONT></B> f seq | nil seq  = e
		    | otherwise = f (dinit seq) * dlast seq

<B><FONT COLOR="#A020F0">instance</FONT></B> Eq a =&gt; Eq (Deque a) <B><FONT COLOR="#A020F0">where</FONT></B>
    (xs :# ys) == (as :# bs)  =  xs++reverse ys  ==  as++reverse bs
</pre></td></tr></table>
