<span class="com">/* The Great Computer Language Shootout
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy
*/</span>

<span class="kwa">using</span> System<span class="sym">;
</span><span class="kwa">using</span> System<span class="sym">.</span>Collections<span class="sym">;
</span><span class="kwa">using</span> System<span class="sym">.</span>IO<span class="sym">;


</span><span class="kwc">class</span> RayTracer
<span class="sym">{
</span>   <span class="kwb">const int</span> levels <span class="sym">=</span> <span class="num">6</span><span class="sym">,</span> ss <span class="sym">=</span> <span class="num">4</span><span class="sym">;
</span>   <span class="kwb">const double</span> Epsilon <span class="sym">=</span> <span class="num">1.49012e</span><span class="sym">-</span><span class="num">08</span><span class="sym">;</span> <span class="slc">// Normally we'd use double.Epsilon
</span>
   <span class="kwc">public</span> <span class="kwb">static void</span> Main<span class="sym">(</span>String<span class="sym">[]</span> args<span class="sym">){
</span>      <span class="kwb">int</span> n <span class="sym">=</span> <span class="num">0</span><span class="sym">;
</span>      <span class="kwa">if</span> <span class="sym">(</span>args<span class="sym">.</span>Length <span class="sym">&gt;</span> <span class="num">0</span><span class="sym">)</span> n <span class="sym">=</span> Int32<span class="sym">.</span>Parse<span class="sym">(</span>args<span class="sym">[</span><span class="num">0</span><span class="sym">]);

</span>      Scene scene <span class="sym">=</span> Scene<span class="sym">.</span>SphereScene<span class="sym">(</span>levels<span class="sym">,</span> <span class="kwa">new</span> Vector<span class="sym">(</span><span class="num">0.0</span><span class="sym">, -</span><span class="num">1.0</span><span class="sym">,</span> <span class="num">0.0</span><span class="sym">),</span> <span class="num">1.0</span><span class="sym">);

</span>      Console<span class="sym">.</span>WriteLine<span class="sym">(</span><span class="str">&quot;P5&quot;</span><span class="sym">);
</span>      Console<span class="sym">.</span>WriteLine<span class="sym">(</span><span class="str">&quot;{0} {1}&quot;</span><span class="sym">,</span> n<span class="sym">,</span>n<span class="sym">);
</span>      Console<span class="sym">.</span>WriteLine<span class="sym">(</span><span class="str">&quot;255&quot;</span><span class="sym">);

</span>      Stream stream <span class="sym">=</span> Console<span class="sym">.</span>OpenStandardOutput<span class="sym">(</span><span class="num">1024</span><span class="sym">);
</span>      byte<span class="sym">[]</span> temp <span class="sym">=</span> <span class="kwa">new</span> byte<span class="sym">[</span><span class="num">1</span><span class="sym">];

</span>      <span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> y<span class="sym">=</span>n<span class="num">-1</span><span class="sym">;</span> y<span class="sym">&gt;=</span><span class="num">0</span><span class="sym">; --</span>y<span class="sym">){
</span>         <span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> x<span class="sym">=</span><span class="num">0</span><span class="sym">;</span> x<span class="sym">&lt;</span>n<span class="sym">; ++</span>x<span class="sym">){

</span>            <span class="kwb">double</span> greyscale <span class="sym">=</span> <span class="num">0.0</span><span class="sym">;
</span>            <span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> dx<span class="sym">=</span><span class="num">0</span><span class="sym">;</span> dx<span class="sym">&lt;</span>ss<span class="sym">; ++</span>dx<span class="sym">){
</span>               <span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> dy<span class="sym">=</span><span class="num">0</span><span class="sym">;</span> dy<span class="sym">&lt;</span>ss<span class="sym">; ++</span>dy<span class="sym">){

</span>                  Vector v <span class="sym">=</span> <span class="kwa">new</span> Vector<span class="sym">(
</span>                       x <span class="sym">+</span> dx<span class="sym">/(</span><span class="kwb">double</span><span class="sym">)</span>ss <span class="sym">-</span> n<span class="sym">/</span><span class="num">2.0
</span>                     <span class="sym">,</span> y <span class="sym">+</span> dy<span class="sym">/(</span><span class="kwb">double</span><span class="sym">)</span>ss <span class="sym">-</span> n<span class="sym">/</span><span class="num">2.0
</span>                     <span class="sym">,</span> n<span class="sym">);

</span>                  Ray ray <span class="sym">=</span> <span class="kwa">new</span> Ray<span class="sym">(</span><span class="kwa">new</span> Vector<span class="sym">(</span><span class="num">0.0</span><span class="sym">,</span> <span class="num">0.0</span><span class="sym">, -</span><span class="num">4.0</span><span class="sym">),</span> v<span class="sym">.</span>Normalized<span class="sym">());

</span>                  greyscale <span class="sym">+=</span> scene<span class="sym">.</span>TraceRay<span class="sym">(</span>ray<span class="sym">,
</span>                     <span class="kwa">new</span> Vector<span class="sym">(-</span><span class="num">1.0</span><span class="sym">, -</span><span class="num">3.0</span><span class="sym">,</span> <span class="num">2.0</span><span class="sym">).</span>Normalized<span class="sym">() );
               }
            }

</span>            temp<span class="sym">[</span><span class="num">0</span><span class="sym">] = (</span>byte<span class="sym">)(</span><span class="num">0.5</span> <span class="sym">+</span> <span class="num">255.0</span><span class="sym">*</span>greyscale<span class="sym">/(</span>ss<span class="sym">*</span>ss<span class="sym">));
</span>            stream<span class="sym">.</span>Write<span class="sym">(</span>temp<span class="sym">,</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">);
         }
      }
   }


</span>   abstract <span class="kwc">class</span> Scene
   <span class="sym">{
</span>      abstract internal IntersectionPoint Intersect<span class="sym">(</span>Ray ray<span class="sym">,</span> IntersectionPoint p<span class="sym">);

</span>      internal <span class="kwb">static</span> Scene SphereScene<span class="sym">(</span><span class="kwb">int</span> level<span class="sym">,</span> Vector center<span class="sym">,</span> <span class="kwb">double</span> radius<span class="sym">){
</span>         Sphere sphere <span class="sym">=</span> <span class="kwa">new</span> Sphere<span class="sym">(</span>center<span class="sym">,</span> radius<span class="sym">);
</span>         <span class="kwa">if</span> <span class="sym">(</span>level <span class="sym">==</span> <span class="num">1</span><span class="sym">){
</span>            <span class="kwa">return</span> sphere<span class="sym">;
         }
</span>         <span class="kwa">else</span> <span class="sym">{
</span>            Group scene <span class="sym">=</span> <span class="kwa">new</span> Group<span class="sym">(</span><span class="kwa">new</span> Sphere<span class="sym">(</span>center<span class="sym">,</span> <span class="num">3.0</span><span class="sym">*</span>radius<span class="sym">));
</span>            scene<span class="sym">.</span>Add<span class="sym">(</span>sphere<span class="sym">);
</span>            <span class="kwb">double</span> rn <span class="sym">=</span> <span class="num">3.0</span><span class="sym">*</span>radius <span class="sym">/</span> Math<span class="sym">.</span>Sqrt<span class="sym">(</span><span class="num">12.0</span><span class="sym">);

</span>            <span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> dz<span class="sym">=-</span><span class="num">1</span><span class="sym">;</span> dz<span class="sym">&lt;=</span><span class="num">1</span><span class="sym">;</span> dz<span class="sym">+=</span><span class="num">2</span><span class="sym">){
</span>               <span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> dx<span class="sym">=-</span><span class="num">1</span><span class="sym">;</span> dx<span class="sym">&lt;=</span><span class="num">1</span><span class="sym">;</span> dx<span class="sym">+=</span><span class="num">2</span><span class="sym">){

</span>                  Vector c2 <span class="sym">=</span> <span class="kwa">new</span> Vector<span class="sym">(
</span>                       center<span class="sym">.</span>x <span class="sym">-</span> dx<span class="sym">*</span>rn
                     <span class="sym">,</span> center<span class="sym">.</span>y <span class="sym">+</span> rn
                     <span class="sym">,</span> center<span class="sym">.</span>z <span class="sym">-</span> dz<span class="sym">*</span>rn
                     <span class="sym">);

</span>                  scene<span class="sym">.</span>Add<span class="sym">(</span> SphereScene<span class="sym">(</span>level<span class="num">-1</span><span class="sym">,</span> c2<span class="sym">,</span> radius<span class="sym">/</span><span class="num">2.0</span><span class="sym">) );
               }
            }
</span>            <span class="kwa">return</span> scene<span class="sym">;
         }
      }


</span>      internal <span class="kwb">double</span> TraceRay <span class="sym">(</span>Ray ray<span class="sym">,</span> Vector light<span class="sym">){
</span>         IntersectionPoint p <span class="sym">=</span> Intersect<span class="sym">(</span>ray<span class="sym">,
</span>            <span class="kwa">new</span> IntersectionPoint<span class="sym">(
</span>                 <span class="kwb">double</span><span class="sym">.</span>PositiveInfinity<span class="sym">,</span> <span class="kwa">new</span> Vector<span class="sym">(</span><span class="num">0.0</span><span class="sym">,</span> <span class="num">0.0</span><span class="sym">,</span> <span class="num">0.0</span><span class="sym">)) );

</span>         <span class="kwa">if</span> <span class="sym">(</span><span class="kwb">double</span><span class="sym">.</span>IsInfinity<span class="sym">(</span>p<span class="sym">.</span>distance<span class="sym">))</span> <span class="kwa">return</span> <span class="num">0.0</span><span class="sym">;

</span>         <span class="kwb">double</span> greyscale <span class="sym">= -(</span>p<span class="sym">.</span>normal <span class="sym">*</span> light<span class="sym">);
</span>         <span class="kwa">if</span> <span class="sym">(</span>greyscale <span class="sym">&lt;=</span> <span class="num">0.0</span><span class="sym">)</span> <span class="kwa">return</span> <span class="num">0.0</span><span class="sym">;

</span>         Vector o <span class="sym">=</span> ray<span class="sym">.</span>origin <span class="sym">+
            (</span>p<span class="sym">.</span>distance <span class="sym">*</span> ray<span class="sym">.</span>direction<span class="sym">) + (</span>Epsilon <span class="sym">*</span> p<span class="sym">.</span>normal<span class="sym">);

</span>         Ray shadowRay <span class="sym">=</span> <span class="kwa">new</span> Ray<span class="sym">(</span>o<span class="sym">,</span> <span class="kwa">new</span> Vector<span class="sym">(</span><span class="num">0.0</span><span class="sym">,</span> <span class="num">0.0</span><span class="sym">,</span> <span class="num">0.0</span><span class="sym">) -</span> light<span class="sym">);
</span>         IntersectionPoint shadowp <span class="sym">=</span> Intersect<span class="sym">(</span>shadowRay<span class="sym">,
</span>            <span class="kwa">new</span> IntersectionPoint<span class="sym">(</span><span class="kwb">double</span><span class="sym">.</span>PositiveInfinity<span class="sym">,</span> p<span class="sym">.</span>normal<span class="sym">) );

</span>         <span class="kwa">return</span> <span class="kwb">double</span><span class="sym">.</span>IsInfinity<span class="sym">(</span>shadowp<span class="sym">.</span>distance<span class="sym">)</span> ? greyscale <span class="sym">:</span> <span class="num">0.0</span><span class="sym">;
      }
   }


</span>   <span class="slc">// a leaf node in the scene tree
</span>   <span class="kwc">class</span> Sphere <span class="sym">:</span> Scene
   <span class="sym">{
</span>      <span class="kwc">private</span> Vector center<span class="sym">;
</span>      <span class="kwc">private</span> <span class="kwb">double</span> radius<span class="sym">;

</span>      internal Sphere<span class="sym">(</span>Vector center<span class="sym">,</span> <span class="kwb">double</span> radius<span class="sym">){
</span>         <span class="kwa">this</span><span class="sym">.</span>center <span class="sym">=</span> center<span class="sym">;</span> <span class="kwa">this</span><span class="sym">.</span>radius <span class="sym">=</span> radius<span class="sym">;
      }

</span>      internal <span class="kwb">double</span> Distance<span class="sym">(</span>Ray ray<span class="sym">){
</span>         Vector v <span class="sym">=</span> center <span class="sym">-</span> ray<span class="sym">.</span>origin<span class="sym">;
</span>         <span class="kwb">double</span> b <span class="sym">=</span> v <span class="sym">*</span> ray<span class="sym">.</span>direction<span class="sym">;
</span>         <span class="kwb">double</span> disc <span class="sym">=</span> b<span class="sym">*</span>b <span class="sym">-</span> v<span class="sym">*</span>v <span class="sym">+</span> radius<span class="sym">*</span>radius<span class="sym">;
</span>         <span class="kwa">if</span> <span class="sym">(</span>disc <span class="sym">&lt;</span> <span class="num">0</span><span class="sym">)</span> <span class="kwa">return</span> <span class="kwb">double</span><span class="sym">.</span>PositiveInfinity<span class="sym">;</span> <span class="slc">// No intersection
</span>
         <span class="kwb">double</span> d <span class="sym">=</span> Math<span class="sym">.</span>Sqrt<span class="sym">(</span>disc<span class="sym">);
</span>         <span class="kwb">double</span> t1 <span class="sym">=</span> b <span class="sym">+</span> d<span class="sym">;
</span>         <span class="kwa">if</span> <span class="sym">(</span>t1 <span class="sym">&lt;</span> <span class="num">0</span><span class="sym">)</span> <span class="kwa">return</span> <span class="kwb">double</span><span class="sym">.</span>PositiveInfinity<span class="sym">;

</span>         <span class="kwb">double</span> t2 <span class="sym">=</span> b <span class="sym">-</span> d<span class="sym">;
</span>         <span class="kwa">return</span> t2 <span class="sym">&gt;</span> <span class="num">0</span> ? t2 <span class="sym">:</span> t1<span class="sym">;
      }

</span>      override internal IntersectionPoint Intersect<span class="sym">(</span>Ray r<span class="sym">,</span> IntersectionPoint p<span class="sym">){
</span>         <span class="kwb">double</span> d <span class="sym">=</span> Distance<span class="sym">(</span>r<span class="sym">);
</span>         <span class="kwa">if</span> <span class="sym">(</span>d <span class="sym">&lt;</span> p<span class="sym">.</span>distance<span class="sym">){
</span>            Vector v <span class="sym">=</span> r<span class="sym">.</span>origin <span class="sym">+ ((</span>d <span class="sym">*</span> r<span class="sym">.</span>direction<span class="sym">) -</span> center<span class="sym">);
</span>            p <span class="sym">=</span> <span class="kwa">new</span> IntersectionPoint<span class="sym">(</span>d<span class="sym">,</span> v<span class="sym">.</span>Normalized<span class="sym">());
         }
</span>         <span class="kwa">return</span> p<span class="sym">;
      }
   }


</span>   <span class="slc">// non-leaf node in the scene tree
</span>   <span class="kwc">class</span> Group <span class="sym">:</span> Scene
   <span class="sym">{
</span>      <span class="kwc">private</span> Sphere bound<span class="sym">;
</span>      <span class="kwc">private</span> ArrayList scenes <span class="sym">=</span> <span class="kwa">new</span> ArrayList<span class="sym">();

</span>      internal Group<span class="sym">(</span>Sphere bound<span class="sym">){
</span>         <span class="kwa">this</span><span class="sym">.</span>bound <span class="sym">=</span> bound<span class="sym">;
      }

</span>      override internal IntersectionPoint Intersect<span class="sym">(</span>Ray r<span class="sym">,</span> IntersectionPoint p<span class="sym">){
</span>         <span class="kwa">if</span> <span class="sym">(</span>bound<span class="sym">.</span>Distance<span class="sym">(</span>r<span class="sym">) &lt;</span> p<span class="sym">.</span>distance<span class="sym">){
</span>            foreach <span class="sym">(</span>Scene each in scenes<span class="sym">)
</span>               p <span class="sym">=</span> each<span class="sym">.</span>Intersect<span class="sym">(</span>r<span class="sym">,</span> p<span class="sym">);
         }
</span>         <span class="kwa">return</span> p<span class="sym">;
      }

</span>      internal <span class="kwb">void</span> Add<span class="sym">(</span>Scene s<span class="sym">){
</span>         scenes<span class="sym">.</span>Insert<span class="sym">(</span><span class="num">0</span><span class="sym">,</span>s<span class="sym">);
      }
   }
}


</span><span class="kwb">struct</span> Vector
<span class="sym">{
</span>   <span class="kwc">private</span> <span class="kwb">double</span> _x<span class="sym">,</span> _y<span class="sym">,</span> _z<span class="sym">;

</span>   internal Vector<span class="sym">(</span><span class="kwb">double</span> x<span class="sym">,</span> <span class="kwb">double</span> y<span class="sym">,</span> <span class="kwb">double</span> z<span class="sym">){
</span>      _x <span class="sym">=</span> x<span class="sym">;</span> _y <span class="sym">=</span> y<span class="sym">;</span> _z <span class="sym">=</span> z<span class="sym">;
   }

</span>   <span class="kwc">public</span> <span class="kwb">static</span> Vector <span class="kwc">operator</span> <span class="sym">+(</span>Vector a<span class="sym">,</span> Vector b<span class="sym">){
</span>      <span class="kwa">return new</span> Vector<span class="sym">(</span>a<span class="sym">.</span>_x <span class="sym">+</span> b<span class="sym">.</span>_x<span class="sym">,</span> a<span class="sym">.</span>_y <span class="sym">+</span> b<span class="sym">.</span>_y<span class="sym">,</span> a<span class="sym">.</span>_z <span class="sym">+</span> b<span class="sym">.</span>_z<span class="sym">);
   }

</span>   <span class="kwc">public</span> <span class="kwb">static</span> Vector <span class="kwc">operator</span> <span class="sym">-(</span>Vector a<span class="sym">,</span> Vector b<span class="sym">){
</span>      <span class="kwa">return new</span> Vector<span class="sym">(</span>a<span class="sym">.</span>_x <span class="sym">-</span> b<span class="sym">.</span>_x<span class="sym">,</span> a<span class="sym">.</span>_y <span class="sym">-</span> b<span class="sym">.</span>_y<span class="sym">,</span> a<span class="sym">.</span>_z <span class="sym">-</span> b<span class="sym">.</span>_z<span class="sym">);
   }

</span>   <span class="kwc">public</span> <span class="kwb">static double</span> <span class="kwc">operator</span> <span class="sym">*(</span>Vector a<span class="sym">,</span> Vector b<span class="sym">){
</span>      <span class="kwa">return</span> <span class="sym">(</span>a<span class="sym">.</span>_x <span class="sym">*</span> b<span class="sym">.</span>_x<span class="sym">) + (</span>a<span class="sym">.</span>_y <span class="sym">*</span> b<span class="sym">.</span>_y<span class="sym">) + (</span>a<span class="sym">.</span>_z <span class="sym">*</span> b<span class="sym">.</span>_z<span class="sym">);
   }

</span>   <span class="kwc">public</span> <span class="kwb">static</span> Vector <span class="kwc">operator</span> <span class="sym">*(</span><span class="kwb">double</span> s<span class="sym">,</span> Vector b<span class="sym">){
</span>      <span class="kwa">return new</span> Vector<span class="sym">(</span>s <span class="sym">*</span> b<span class="sym">.</span>_x<span class="sym">,</span> s <span class="sym">*</span> b<span class="sym">.</span>_y<span class="sym">,</span> s <span class="sym">*</span> b<span class="sym">.</span>_z<span class="sym">);
   }

</span>   <span class="kwc">public</span> <span class="kwb">static</span> Vector <span class="kwc">operator</span> <span class="sym">*(</span>Vector a<span class="sym">,</span> <span class="kwb">double</span> s<span class="sym">){
</span>      <span class="kwa">return new</span> Vector<span class="sym">(</span>a<span class="sym">.</span>_x <span class="sym">*</span> s<span class="sym">,</span> a<span class="sym">.</span>_y <span class="sym">*</span> s<span class="sym">,</span> a<span class="sym">.</span>_z <span class="sym">*</span> s<span class="sym">);
   }

</span>   internal Vector Normalized<span class="sym">(){
</span>      <span class="kwa">return</span> <span class="sym">(</span><span class="num">1.0</span> <span class="sym">/</span> Math<span class="sym">.</span>Sqrt<span class="sym">(</span><span class="kwa">this</span> <span class="sym">*</span> <span class="kwa">this</span><span class="sym">)) *</span> <span class="kwa">this</span><span class="sym">;
   }

</span>   internal <span class="kwb">double</span> x <span class="sym">{
</span>      get <span class="sym">{</span> <span class="kwa">return</span> _x<span class="sym">; }
   }

</span>   internal <span class="kwb">double</span> y <span class="sym">{
</span>      get <span class="sym">{</span> <span class="kwa">return</span> _y<span class="sym">; }
   }

</span>   internal <span class="kwb">double</span> z <span class="sym">{
</span>      get <span class="sym">{</span> <span class="kwa">return</span> _z<span class="sym">; }
   }
}


</span><span class="kwb">struct</span> Ray
<span class="sym">{
</span>   <span class="kwc">private</span> Vector _origin<span class="sym">,</span> _direction<span class="sym">;

</span>   internal Ray<span class="sym">(</span>Vector origin<span class="sym">,</span> Vector direction<span class="sym">){
</span>      _origin <span class="sym">=</span> origin<span class="sym">;</span> _direction <span class="sym">=</span> direction<span class="sym">;
   }

</span>   internal Vector origin <span class="sym">{
</span>      get <span class="sym">{</span> <span class="kwa">return</span> _origin<span class="sym">; }
   }

</span>   internal Vector direction <span class="sym">{
</span>      get <span class="sym">{</span> <span class="kwa">return</span> _direction<span class="sym">; }
   }
}


</span><span class="kwb">struct</span> IntersectionPoint
<span class="sym">{
</span>   <span class="kwc">private</span> <span class="kwb">double</span> _distance<span class="sym">;
</span>   <span class="kwc">private</span> Vector _normal<span class="sym">;

</span>   internal IntersectionPoint<span class="sym">(</span><span class="kwb">double</span> distance<span class="sym">,</span> Vector normal<span class="sym">){
</span>      _distance <span class="sym">=</span> distance<span class="sym">;</span> _normal <span class="sym">=</span> normal<span class="sym">;
   }

</span>   internal <span class="kwb">double</span> distance <span class="sym">{
</span>      get <span class="sym">{</span> <span class="kwa">return</span> _distance<span class="sym">; }
   }

</span>   internal Vector normal <span class="sym">{
</span>      get <span class="sym">{</span> <span class="kwa">return</span> _normal<span class="sym">; }
   }
}</span>
