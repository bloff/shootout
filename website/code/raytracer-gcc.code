<span class="com">/* -*- mode: c -*-
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Jon Harrop, 2005
 * Compile: gcc -Wall -O3 -ffast-math -lm -std=c99 raytracer.c -o raytracer
 */</span>


<span class="dir">#include &lt;float.h&gt;
</span><span class="dir">#include &lt;math.h&gt;
</span><span class="dir">#include &lt;stdlib.h&gt;
</span><span class="dir">#include &lt;stdio.h&gt;
</span>
<span class="kwb">double</span> delta<span class="sym">;

</span><span class="kwc">typedef</span> <span class="kwb">struct</span> <span class="sym">{</span> <span class="kwb">double</span> x<span class="sym">,</span> y<span class="sym">,</span> z<span class="sym">; }</span> Vec<span class="sym">;
</span>Vec vec<span class="sym">(</span><span class="kwb">double</span> ix<span class="sym">,</span> <span class="kwb">double</span> iy<span class="sym">,</span> <span class="kwb">double</span> iz<span class="sym">)
{</span> Vec a<span class="sym">;</span> a<span class="sym">.</span>x <span class="sym">=</span> ix<span class="sym">;</span> a<span class="sym">.</span>y <span class="sym">=</span> iy<span class="sym">;</span> a<span class="sym">.</span>z <span class="sym">=</span> iz<span class="sym">;</span> <span class="kwa">return</span> a<span class="sym">; }
</span>Vec add<span class="sym">(</span>Vec a<span class="sym">,</span> Vec b<span class="sym">) {</span> <span class="kwa">return</span> vec<span class="sym">(</span>a<span class="sym">.</span>x <span class="sym">+</span> b<span class="sym">.</span>x<span class="sym">,</span> a<span class="sym">.</span>y <span class="sym">+</span> b<span class="sym">.</span>y<span class="sym">,</span> a<span class="sym">.</span>z <span class="sym">+</span> b<span class="sym">.</span>z<span class="sym">); }
</span>Vec sub<span class="sym">(</span>Vec a<span class="sym">,</span> Vec b<span class="sym">) {</span> <span class="kwa">return</span> vec<span class="sym">(</span>a<span class="sym">.</span>x <span class="sym">-</span> b<span class="sym">.</span>x<span class="sym">,</span> a<span class="sym">.</span>y <span class="sym">-</span> b<span class="sym">.</span>y<span class="sym">,</span> a<span class="sym">.</span>z <span class="sym">-</span> b<span class="sym">.</span>z<span class="sym">); }
</span>Vec scale<span class="sym">(</span><span class="kwb">double</span> a<span class="sym">,</span> Vec b<span class="sym">) {</span> <span class="kwa">return</span> vec<span class="sym">(</span>a <span class="sym">*</span> b<span class="sym">.</span>x<span class="sym">,</span> a <span class="sym">*</span> b<span class="sym">.</span>y<span class="sym">,</span> a <span class="sym">*</span> b<span class="sym">.</span>z<span class="sym">); }
</span><span class="kwb">double</span> dot<span class="sym">(</span>Vec a<span class="sym">,</span> Vec b<span class="sym">) {</span> <span class="kwa">return</span> a<span class="sym">.</span>x<span class="sym">*</span>b<span class="sym">.</span>x <span class="sym">+</span> a<span class="sym">.</span>y<span class="sym">*</span>b<span class="sym">.</span>y <span class="sym">+</span> a<span class="sym">.</span>z<span class="sym">*</span>b<span class="sym">.</span>z<span class="sym">; }
</span>Vec unitise<span class="sym">(</span>Vec a<span class="sym">) {</span> <span class="kwa">return</span> scale<span class="sym">(</span><span class="num">1</span> <span class="sym">/</span> sqrt<span class="sym">(</span>dot<span class="sym">(</span>a<span class="sym">,</span> a<span class="sym">)),</span> a<span class="sym">); }

</span><span class="kwc">typedef</span> <span class="kwb">struct</span> <span class="sym">{</span> Vec orig<span class="sym">,</span> dir<span class="sym">; }</span> Ray<span class="sym">;
</span>Ray ray<span class="sym">(</span>Vec o<span class="sym">,</span> Vec d<span class="sym">) {</span> Ray r<span class="sym">;</span> r<span class="sym">.</span>orig <span class="sym">=</span> o<span class="sym">;</span> r<span class="sym">.</span>dir <span class="sym">=</span> d<span class="sym">;</span> <span class="kwa">return</span> r<span class="sym">; }

</span><span class="kwc">typedef</span> <span class="kwb">enum</span> <span class="sym">{</span>SphereTag<span class="sym">,</span> GroupTag<span class="sym">}</span> Tag<span class="sym">;
</span><span class="kwc">typedef</span> <span class="kwb">struct</span> <span class="sym">{</span> Vec center<span class="sym">;</span> <span class="kwb">double</span> radius<span class="sym">; }</span> Sphere<span class="sym">;
</span>Sphere sphere<span class="sym">(</span>Vec c<span class="sym">,</span> <span class="kwb">double</span> r<span class="sym">) {</span> Sphere s<span class="sym">;</span> s<span class="sym">.</span>center<span class="sym">=</span>c<span class="sym">;</span> s<span class="sym">.</span>radius<span class="sym">=</span>r<span class="sym">;</span> <span class="kwa">return</span> s<span class="sym">; }
</span><span class="kwc">typedef</span> <span class="kwb">struct</span> <span class="sym">{</span> Sphere bound<span class="sym">;</span> <span class="kwb">int</span> n<span class="sym">;</span> <span class="kwb">void</span> <span class="sym">*</span>child<span class="sym">; }</span> Group<span class="sym">;
</span><span class="kwc">typedef</span> <span class="kwb">struct</span> <span class="sym">{</span> Tag tag<span class="sym">;</span> <span class="kwb">union</span> <span class="sym">{</span> Sphere s<span class="sym">;</span> Group g<span class="sym">; }</span> data<span class="sym">; }</span> Scene<span class="sym">;

</span><span class="kwb">double</span> ray_sphere<span class="sym">(</span><span class="kwb">const</span> Ray <span class="sym">*</span>r<span class="sym">,</span> <span class="kwb">const</span> Sphere <span class="sym">*</span>s<span class="sym">) {
</span>  Vec v <span class="sym">=</span> sub<span class="sym">(</span>s<span class="sym">-&gt;</span>center<span class="sym">,</span> r<span class="sym">-&gt;</span>orig<span class="sym">);
</span>  <span class="kwb">double</span> b <span class="sym">=</span> dot<span class="sym">(</span>v<span class="sym">,</span> r<span class="sym">-&gt;</span>dir<span class="sym">),</span> disc <span class="sym">=</span> b<span class="sym">*</span>b <span class="sym">-</span> dot<span class="sym">(</span>v<span class="sym">,</span> v<span class="sym">) +</span> s<span class="sym">-&gt;</span>radius <span class="sym">*</span> s<span class="sym">-&gt;</span>radius<span class="sym">;
</span>  <span class="kwa">if</span> <span class="sym">(</span>disc <span class="sym">&lt;</span> <span class="num">0</span><span class="sym">)</span> <span class="kwa">return</span> INFINITY<span class="sym">;
</span>  <span class="kwb">double</span> d <span class="sym">=</span> sqrt<span class="sym">(</span>disc<span class="sym">),</span> t2 <span class="sym">=</span> b <span class="sym">+</span> d<span class="sym">;
</span>  <span class="kwa">if</span> <span class="sym">(</span>t2 <span class="sym">&lt;</span> <span class="num">0</span><span class="sym">)</span> <span class="kwa">return</span> INFINITY<span class="sym">;
</span>  <span class="kwb">double</span> t1 <span class="sym">=</span> b <span class="sym">-</span> d<span class="sym">;
</span>  <span class="kwa">return</span> <span class="sym">(</span>t1 <span class="sym">&gt;</span> <span class="num">0</span> ? t1 <span class="sym">:</span> t2<span class="sym">);
}

</span><span class="kwb">void</span> intersect<span class="sym">(</span><span class="kwb">double</span> <span class="sym">*</span>lambda<span class="sym">,</span> Vec <span class="sym">*</span>normal<span class="sym">,</span> <span class="kwb">const</span> Ray <span class="sym">*</span>r<span class="sym">,</span> <span class="kwb">const</span> Scene scene<span class="sym">) {
</span>  <span class="kwa">switch</span> <span class="sym">(</span>scene<span class="sym">.</span>tag<span class="sym">) {
</span>  <span class="kwa">case</span> SphereTag <span class="sym">: {
</span>    Sphere s <span class="sym">=</span> scene<span class="sym">.</span>data<span class="sym">.</span>s<span class="sym">;
</span>    <span class="kwb">double</span> l <span class="sym">=</span> ray_sphere<span class="sym">(</span>r<span class="sym">, &amp;</span>s<span class="sym">);
</span>    <span class="kwa">if</span> <span class="sym">(</span>l <span class="sym">&gt;= *</span>lambda<span class="sym">)</span> <span class="kwa">return</span><span class="sym">;
    *</span>lambda <span class="sym">=</span> l<span class="sym">;
    *</span>normal <span class="sym">=</span> unitise<span class="sym">(</span>add<span class="sym">(</span>r<span class="sym">-&gt;</span>orig<span class="sym">,</span> sub<span class="sym">(</span>scale<span class="sym">(</span>l<span class="sym">,</span> r<span class="sym">-&gt;</span>dir<span class="sym">),</span> s<span class="sym">.</span>center<span class="sym">)));
</span>    <span class="kwa">break</span><span class="sym">;
  }
</span>  <span class="kwa">case</span> GroupTag <span class="sym">: {
</span>    Group g <span class="sym">=</span> scene<span class="sym">.</span>data<span class="sym">.</span>g<span class="sym">;
</span>    <span class="kwa">if</span> <span class="sym">(</span>ray_sphere<span class="sym">(</span>r<span class="sym">, &amp;</span>g<span class="sym">.</span>bound<span class="sym">) &gt;= *</span>lambda<span class="sym">)</span> <span class="kwa">return</span><span class="sym">;
</span>    <span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> i<span class="sym">=</span><span class="num">0</span><span class="sym">;</span> i<span class="sym">&lt;</span>g<span class="sym">.</span>n<span class="sym">; ++</span>i<span class="sym">)
</span>      intersect<span class="sym">(</span>lambda<span class="sym">,</span> normal<span class="sym">,</span> r<span class="sym">, ((</span>Scene <span class="sym">*)</span>g<span class="sym">.</span>child<span class="sym">)[</span>i<span class="sym">]);
</span>    <span class="kwa">break</span><span class="sym">;
  }
  }
}

</span><span class="kwb">double</span> ray_trace<span class="sym">(</span>Vec light<span class="sym">,</span> Ray r<span class="sym">,</span> Scene scene<span class="sym">) {
</span>  <span class="kwb">double</span> lambda <span class="sym">=</span> INFINITY<span class="sym">;
</span>  Vec n <span class="sym">=</span> vec<span class="sym">(</span><span class="num">0</span><span class="sym">,</span> <span class="num">0</span><span class="sym">,</span> <span class="num">0</span><span class="sym">);
</span>  intersect<span class="sym">(&amp;</span>lambda<span class="sym">, &amp;</span>n<span class="sym">, &amp;</span>r<span class="sym">,</span> scene<span class="sym">);
</span>  <span class="kwa">if</span> <span class="sym">(</span>lambda <span class="sym">==</span> INFINITY<span class="sym">)</span> <span class="kwa">return</span> <span class="num">0</span><span class="sym">;
</span>  <span class="kwb">double</span> g <span class="sym">=</span> dot<span class="sym">(</span>n<span class="sym">,</span> light<span class="sym">),</span> l <span class="sym">=</span> INFINITY<span class="sym">;
</span>  <span class="kwa">if</span> <span class="sym">(</span>g <span class="sym">&lt;=</span> <span class="num">0</span><span class="sym">)</span> <span class="kwa">return</span> <span class="num">0</span><span class="sym">.;
</span>  Ray r2 <span class="sym">=</span> ray<span class="sym">(</span>add<span class="sym">(</span>r<span class="sym">.</span>orig<span class="sym">,</span> scale<span class="sym">(</span>lambda<span class="sym">,</span> add<span class="sym">(</span>r<span class="sym">.</span>dir<span class="sym">,</span> scale<span class="sym">(</span>delta<span class="sym">,</span> n<span class="sym">)))),
</span>	       light<span class="sym">);
</span>  intersect<span class="sym">(&amp;</span>l<span class="sym">, &amp;</span>n<span class="sym">, &amp;</span>r2<span class="sym">,</span> scene<span class="sym">);
</span>  <span class="kwa">return</span> <span class="sym">(</span>l <span class="sym">==</span> INFINITY ? g <span class="sym">:</span> <span class="num">0</span><span class="sym">);
}

</span>Scene create<span class="sym">(</span><span class="kwb">int</span> level<span class="sym">,</span> <span class="kwb">double</span> r<span class="sym">,</span> <span class="kwb">double</span> x<span class="sym">,</span> <span class="kwb">double</span> y<span class="sym">,</span> <span class="kwb">double</span> z<span class="sym">) {
</span>  Scene scene<span class="sym">;
</span>  <span class="kwa">if</span> <span class="sym">(</span>level <span class="sym">==</span> <span class="num">1</span><span class="sym">) {
</span>    scene<span class="sym">.</span>tag <span class="sym">=</span> SphereTag<span class="sym">;
</span>    scene<span class="sym">.</span>data<span class="sym">.</span>s <span class="sym">=</span> sphere<span class="sym">(</span>vec<span class="sym">(</span>x<span class="sym">,</span> y<span class="sym">,</span> z<span class="sym">),</span> r<span class="sym">);
  }</span> <span class="kwa">else</span> <span class="sym">{
</span>    Group <span class="sym">*</span>g <span class="sym">= &amp;</span>scene<span class="sym">.</span>data<span class="sym">.</span>g<span class="sym">;
</span>    Scene <span class="sym">*</span>cs<span class="sym">;
</span>    scene<span class="sym">.</span>tag <span class="sym">=</span> GroupTag<span class="sym">;
</span>    g<span class="sym">-&gt;</span>bound <span class="sym">=</span> sphere<span class="sym">(</span>vec<span class="sym">(</span>x<span class="sym">,</span> y<span class="sym">,</span> z<span class="sym">),</span> <span class="num">3</span><span class="sym">*</span>r<span class="sym">);
</span>    g<span class="sym">-&gt;</span>n <span class="sym">=</span> <span class="num">5</span><span class="sym">;
</span>    g<span class="sym">-&gt;</span>child <span class="sym">=</span> cs <span class="sym">= (</span>Scene <span class="sym">*)</span>malloc<span class="sym">(</span>g<span class="sym">-&gt;</span>n <span class="sym">*</span> <span class="kwa">sizeof</span><span class="sym">(</span>Scene<span class="sym">));
</span>    <span class="kwb">double</span> rn <span class="sym">=</span> <span class="num">3</span><span class="sym">*</span>r<span class="sym">/</span>sqrt<span class="sym">(</span><span class="num">12</span><span class="sym">.);
</span>    <span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> i<span class="sym">=</span><span class="num">0</span><span class="sym">;</span> i<span class="sym">&lt;</span><span class="num">4</span><span class="sym">; ++</span>i<span class="sym">)
</span>      cs<span class="sym">[</span>i<span class="sym">] =</span> create<span class="sym">(</span>level<span class="num">-1</span><span class="sym">,</span> r<span class="sym">/</span><span class="num">2</span><span class="sym">,
</span>		     x <span class="sym">- ((</span>i<span class="sym">&amp;</span><span class="num">1</span><span class="sym">)*</span><span class="num">2</span><span class="sym">-</span><span class="num">1</span><span class="sym">)*</span>rn<span class="sym">,</span> y <span class="sym">+</span> rn<span class="sym">,</span> z <span class="sym">- ((</span>i<span class="sym">/</span><span class="num">2</span><span class="sym">)*</span><span class="num">2</span><span class="sym">-</span><span class="num">1</span><span class="sym">)*</span>rn<span class="sym">);
</span>    cs<span class="sym">[</span>g<span class="sym">-&gt;</span>n <span class="num">- 1</span><span class="sym">] =</span> create<span class="sym">(</span><span class="num">1</span><span class="sym">,</span> r<span class="sym">,</span> x<span class="sym">,</span> y<span class="sym">,</span> z<span class="sym">);
  }
</span>  <span class="kwa">return</span> scene<span class="sym">;
}

</span><span class="kwb">void</span> destroy<span class="sym">(</span>Scene scene<span class="sym">) {
</span>  <span class="kwa">if</span> <span class="sym">(</span>scene<span class="sym">.</span>tag <span class="sym">==</span> GroupTag<span class="sym">) {
</span>    <span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> i<span class="sym">=</span><span class="num">0</span><span class="sym">;</span> i<span class="sym">&lt;</span>scene<span class="sym">.</span>data<span class="sym">.</span>g<span class="sym">.</span>n<span class="sym">; ++</span>i<span class="sym">)
</span>      destroy<span class="sym">(((</span>Scene <span class="sym">*)</span>scene<span class="sym">.</span>data<span class="sym">.</span>g<span class="sym">.</span>child<span class="sym">)[</span>i<span class="sym">]);
</span>    free<span class="sym">(</span>scene<span class="sym">.</span>data<span class="sym">.</span>g<span class="sym">.</span>child<span class="sym">);
  }
}

</span><span class="kwb">int</span> main<span class="sym">(</span><span class="kwb">int</span> argc<span class="sym">,</span> <span class="kwb">char</span> <span class="sym">*</span>argv<span class="sym">[]) {
</span>  delta <span class="sym">=</span> sqrt<span class="sym">(</span>DBL_EPSILON<span class="sym">);
</span>  <span class="kwb">int</span> level <span class="sym">=</span> <span class="num">6</span><span class="sym">,</span> n <span class="sym">= (</span>argc<span class="sym">==</span><span class="num">2</span> ? atoi<span class="sym">(</span>argv<span class="sym">[</span><span class="num">1</span><span class="sym">]) :</span> <span class="num">256</span><span class="sym">),</span> ss <span class="sym">=</span> <span class="num">4</span><span class="sym">;
</span>  Vec light <span class="sym">=</span> sub<span class="sym">(</span>vec<span class="sym">(</span><span class="num">0</span><span class="sym">,</span> <span class="num">0</span><span class="sym">,</span> <span class="num">0</span><span class="sym">),</span> unitise<span class="sym">(</span>vec<span class="sym">(-</span><span class="num">1</span><span class="sym">, -</span><span class="num">3</span><span class="sym">,</span> <span class="num">2</span><span class="sym">)));
</span>  Scene scene <span class="sym">=</span> create<span class="sym">(</span>level<span class="sym">,</span> <span class="num">1</span><span class="sym">,</span> <span class="num">0</span><span class="sym">, -</span><span class="num">1</span><span class="sym">,</span> <span class="num">0</span><span class="sym">);</span> <span class="slc">// Build the scene
</span>  printf<span class="sym">(</span><span class="str">&quot;P5</span><span class="esc">\n</span><span class="str">%d %d</span><span class="esc">\n</span><span class="str">255</span><span class="esc">\n</span><span class="str">&quot;</span><span class="sym">,</span> n<span class="sym">,</span> n<span class="sym">);
</span>  <span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> y<span class="sym">=</span>n<span class="num">-1</span><span class="sym">;</span> y<span class="sym">&gt;=</span><span class="num">0</span><span class="sym">; --</span>y<span class="sym">)
</span>    <span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> x<span class="sym">=</span><span class="num">0</span><span class="sym">;</span> x<span class="sym">&lt;</span>n<span class="sym">; ++</span>x<span class="sym">) {
</span>      <span class="kwb">double</span> g<span class="sym">=</span><span class="num">0</span><span class="sym">;
</span>      <span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> dx<span class="sym">=</span><span class="num">0</span><span class="sym">;</span> dx<span class="sym">&lt;</span>ss<span class="sym">; ++</span>dx<span class="sym">)
</span>	<span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> dy<span class="sym">=</span><span class="num">0</span><span class="sym">;</span> dy<span class="sym">&lt;</span>ss<span class="sym">; ++</span>dy<span class="sym">) {
</span>	  Vec d<span class="sym">=</span>vec<span class="sym">(</span>x<span class="sym">+(</span><span class="kwb">double</span><span class="sym">)</span>dx<span class="sym">/</span>ss<span class="sym">-</span>n<span class="sym">/</span><span class="num">2</span><span class="sym">.,</span> y<span class="sym">+(</span><span class="kwb">double</span><span class="sym">)</span>dy<span class="sym">/</span>ss<span class="sym">-</span>n<span class="sym">/</span><span class="num">2</span><span class="sym">.,</span> n<span class="sym">);
</span>	  g <span class="sym">+=</span> ray_trace<span class="sym">(</span>light<span class="sym">,</span> ray<span class="sym">(</span>vec<span class="sym">(</span><span class="num">0</span><span class="sym">,</span> <span class="num">0</span><span class="sym">, -</span><span class="num">4</span><span class="sym">),</span> unitise<span class="sym">(</span>d<span class="sym">)),</span> scene<span class="sym">);
	}
</span>      printf<span class="sym">(</span><span class="str">&quot;%c&quot;</span><span class="sym">, (</span><span class="kwb">char</span><span class="sym">)(</span><span class="num">.5</span> <span class="sym">+</span> <span class="num">255</span><span class="sym">*</span>g<span class="sym">/(</span>ss<span class="sym">*</span>ss<span class="sym">)));
    }
</span>  destroy<span class="sym">(</span>scene<span class="sym">);
</span>  <span class="kwa">return</span> <span class="num">0</span><span class="sym">;
}</span>
