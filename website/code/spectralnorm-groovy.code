<span class="dir">#!/bin/env groovy
</span><span class="com">/*
	$Id: spectralnorm-groovy.code,v 1.1 2005-09-21 05:17:34 bfulgham Exp $

	The Great Computer Language Shootout
	http://shootout.alioth.debian.org/

	contributed by Jochen Hinrichsen
	modified by

	Each program should calculate the spectral norm of an infinite matrix A, with entries a11=1, a12=1/2, a21=1/3, a13=1/4, a22=1/5, a31=1/6, etc

	Each program must implement 4 separate functions / procedures / methods like the C# program.

	Correct output N = 100 is:

	1.274219991


	For more information see challenge #3 in Eric W. Weisstein, &quot;Hundred-Dollar, Hundred-Digit Challenge Problems&quot; and &quot;Spectral Norm&quot;

	From MathWorld--A Wolfram Web Resource.
	http://mathworld.wolfram.com/Hundred-DollarHundred-DigitChallengeProblems.html
	http://mathworld.wolfram.com/SpectralNorm.html

	Thanks to Sebastien Loisel for this benchmark.

	as double:		28s
	as Double:		28s
	.0D:			24s
	as double[]:	25s

*/</span>
def approximate<span class="sym">(</span>n<span class="sym">) {
</span>    <span class="slc">// create unit vector
</span>	def u <span class="sym">= [</span><span class="num">1.0D</span><span class="sym">] *</span> n

    <span class="slc">// 20 steps of the power method
</span>	def v <span class="sym">= [</span><span class="num">0.0D</span><span class="sym">] *</span> n

    <span class="kwa">for</span> <span class="sym">(</span>i in <span class="num">1</span><span class="sym">.</span><span class="num">.10</span><span class="sym">) {
</span>        MultiplyAtAv<span class="sym">(</span>n<span class="sym">,</span>u<span class="sym">,</span>v<span class="sym">)
</span>        MultiplyAtAv<span class="sym">(</span>n<span class="sym">,</span>v<span class="sym">,</span>u<span class="sym">)
    }

</span>    <span class="slc">// B=AtA         A multiplied by A transposed
</span>    <span class="slc">// v.Bv /(v.v)   eigenvalue of v
</span>    <span class="kwb">double</span> vBv <span class="sym">=</span> vv <span class="sym">=</span> <span class="num">0.0D
</span>    <span class="kwa">for</span> <span class="sym">(</span>i in <span class="num">0</span><span class="sym">..&lt;</span>n<span class="sym">) {
</span>        vBv <span class="sym">+=</span> u<span class="sym">[</span>i<span class="sym">]*</span>v<span class="sym">[</span>i<span class="sym">]
</span>        vv  <span class="sym">+=</span> v<span class="sym">[</span>i<span class="sym">]*</span>v<span class="sym">[</span>i<span class="sym">]
    }

</span>    <span class="kwa">return</span> Math<span class="sym">.</span>sqrt<span class="sym">(</span>vBv<span class="sym">/</span>vv<span class="sym">)
}


</span><span class="com">/* return element i,j of infinite matrix A */</span>
def A<span class="sym">(</span>i<span class="sym">,</span> j<span class="sym">) {
</span>    <span class="kwa">return</span> <span class="sym">(</span><span class="num">1.0D</span><span class="sym">) / ((</span>i<span class="sym">+</span>j<span class="sym">)*(</span>i<span class="sym">+</span>j<span class="sym">+(</span><span class="num">1.0D</span><span class="sym">))/(</span><span class="num">2.0D</span><span class="sym">) +</span>i<span class="sym">+(</span><span class="num">1.0D</span><span class="sym">))
}

</span><span class="com">/* multiply vector v by matrix A */</span>
def MultiplyAv<span class="sym">(</span>n<span class="sym">,</span> v<span class="sym">,</span> Av<span class="sym">){
</span>    <span class="kwa">for</span> <span class="sym">(</span>i in <span class="num">0</span><span class="sym">..&lt;</span>n<span class="sym">) {
</span>        Av<span class="sym">[</span>i<span class="sym">] =</span> <span class="num">0.0D
</span>        <span class="kwa">for</span> <span class="sym">(</span>j in <span class="num">0</span><span class="sym">..&lt;</span>n<span class="sym">)</span> Av<span class="sym">[</span>i<span class="sym">] +=</span> A<span class="sym">(</span>i<span class="sym">,</span>j<span class="sym">)*</span>v<span class="sym">[</span>j<span class="sym">]
    }
}

</span><span class="com">/* multiply vector v by matrix A transposed */</span>
def MultiplyAtv<span class="sym">(</span>n<span class="sym">,</span> v<span class="sym">,</span> Atv<span class="sym">){
</span>    <span class="kwa">for</span> <span class="sym">(</span>i in <span class="num">0</span><span class="sym">..&lt;</span>n<span class="sym">) {
</span>        Atv<span class="sym">[</span>i<span class="sym">] =</span> <span class="num">0.0D
</span>        <span class="kwa">for</span> <span class="sym">(</span>j in <span class="num">0</span><span class="sym">..&lt;</span>n<span class="sym">)</span> Atv<span class="sym">[</span>i<span class="sym">] +=</span> A<span class="sym">(</span>j<span class="sym">,</span>i<span class="sym">)*</span>v<span class="sym">[</span>j<span class="sym">]
    }
}

</span><span class="com">/* multiply vector v by matrix A and then by matrix A transposed */</span>
def MultiplyAtAv<span class="sym">(</span>n<span class="sym">,</span> v<span class="sym">,</span> AtAv<span class="sym">){
</span>    <span class="kwb">double</span><span class="sym">[]</span> u <span class="sym">=</span> <span class="kwa">new</span> <span class="kwb">double</span><span class="sym">[</span>n<span class="sym">]
</span>    MultiplyAv<span class="sym">(</span>n<span class="sym">,</span> v<span class="sym">,</span> u<span class="sym">)
</span>    MultiplyAtv<span class="sym">(</span>n<span class="sym">,</span> u<span class="sym">,</span> AtAv<span class="sym">)
}

</span>def n <span class="sym">= (</span>args<span class="sym">.</span>length <span class="sym">==</span> <span class="num">0</span> ? <span class="num">100</span> <span class="sym">:</span> args<span class="sym">[</span><span class="num">0</span><span class="sym">].</span>toInteger<span class="sym">())
</span>def nf <span class="sym">=</span> java<span class="sym">.</span>text<span class="sym">.</span>NumberFormat<span class="sym">.</span>getInstance<span class="sym">()
</span>nf<span class="sym">.</span>setMaximumFractionDigits<span class="sym">(</span><span class="num">9</span><span class="sym">)
</span>nf<span class="sym">.</span>setMinimumFractionDigits<span class="sym">(</span><span class="num">9</span><span class="sym">)
</span>nf<span class="sym">.</span>setGroupingUsed<span class="sym">(</span><span class="kwa">false</span><span class="sym">)
</span>println<span class="sym">(</span>nf<span class="sym">.</span>format<span class="sym">(</span>approximate<span class="sym">(</span>n<span class="sym">)))

</span><span class="slc">// EOF
</span>
