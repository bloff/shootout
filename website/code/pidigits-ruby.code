<span class="slc"># The Great Computer Language Shootout
</span><span class="slc"># http://shootout.alioth.debian.org/
</span><span class="slc">#
</span><span class="slc"># contributed by Gabriele Renzi
</span>
<span class="kwa">class</span> PiDigitSpigot

    <span class="kwa">def</span> initialize<span class="sym">()
</span>        &#64;z = Transformation.new <span class="num">1</span><span class="sym">,</span><span class="num">0</span><span class="sym">,</span><span class="num">0</span><span class="sym">,</span><span class="num">1
</span>        &#64;x = Transformation.new <span class="num">0</span><span class="sym">,</span><span class="num">0</span><span class="sym">,</span><span class="num">0</span><span class="sym">,</span><span class="num">0
</span>        &#64;inverse = Transformation.new <span class="num">0</span><span class="sym">,</span><span class="num">0</span><span class="sym">,</span><span class="num">0</span><span class="sym">,</span><span class="num">0
</span>    <span class="kwa">end

    def next</span><span class="sym">!
</span>        &#64;y = &#64;z.extract<span class="sym">(</span><span class="num">3</span><span class="sym">)
</span>        <span class="kwa">if</span> safe? &#64;y
            &#64;z = produce<span class="sym">(</span>&#64;y<span class="sym">)
</span>            &#64;y
        <span class="kwa">else
</span>            &#64;z = consume &#64;x.<span class="kwa">next</span><span class="sym">!()
</span>            <span class="kwa">next</span><span class="sym">!()
</span>        <span class="kwa">end
    end

    def</span> safe?<span class="sym">(</span>digit<span class="sym">)
</span>        digit == &#64;z.extract<span class="sym">(</span><span class="num">4</span><span class="sym">)
</span>    <span class="kwa">end

    def</span> produce<span class="sym">(</span>i<span class="sym">)
</span>        &#64;inverse.qrst<span class="sym">(</span><span class="num">10</span><span class="sym">,-</span><span class="num">10</span><span class="sym">*</span>i<span class="sym">,</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">)</span>.compose<span class="sym">(</span>&#64;z<span class="sym">)
</span>    <span class="kwa">end

    def</span> consume<span class="sym">(</span>a<span class="sym">)
</span>        &#64;z.compose<span class="sym">(</span>a<span class="sym">)
</span>    <span class="kwa">end
end


class</span> Transformation
    attr_reader <span class="sym">:</span>q<span class="sym">, :</span>r<span class="sym">, :</span>s<span class="sym">, :</span>t
    <span class="kwa">def</span> initialize <span class="sym">(</span>q<span class="sym">,</span> r<span class="sym">,</span> s<span class="sym">,</span> t<span class="sym">)
</span>        &#64;q<span class="sym">,</span>&#64;r<span class="sym">,</span>&#64;s<span class="sym">,</span>&#64;t<span class="sym">,</span>&#64;k = q<span class="sym">,</span>r<span class="sym">,</span>s<span class="sym">,</span>t<span class="sym">,</span><span class="num">0
</span>    <span class="kwa">end

    def next</span><span class="sym">!()
</span>        &#64;q = &#64;k = &#64;k <span class="sym">+</span> <span class="num">1
</span>        &#64;r = <span class="num">4</span> <span class="sym">*</span> &#64;k <span class="sym">+</span> <span class="num">2
</span>        &#64;s = <span class="num">0
</span>        &#64;t = <span class="num">2</span> <span class="sym">*</span> &#64;k <span class="sym">+</span> <span class="num">1
</span>        <span class="kwa">self
    end

    def</span> extract<span class="sym">(</span>j<span class="sym">)
        (</span>&#64;q <span class="sym">*</span> j <span class="sym">+</span> &#64;r<span class="sym">) / (</span>&#64;s <span class="sym">*</span> j <span class="sym">+</span> &#64;t<span class="sym">)
</span>    <span class="kwa">end

    def</span> compose<span class="sym">(</span>a<span class="sym">)
</span>        <span class="kwa">self</span>.<span class="kwa">class</span>.new<span class="sym">(</span> &#64;q <span class="sym">*</span> a.q<span class="sym">,
</span>                        &#64;q <span class="sym">*</span> a.r <span class="sym">+</span> r <span class="sym">*</span> a.t<span class="sym">,
</span>                        &#64;s <span class="sym">*</span> a.q <span class="sym">+</span> t <span class="sym">*</span> a.s<span class="sym">,
</span>                        &#64;s <span class="sym">*</span> a.r <span class="sym">+</span> t <span class="sym">*</span> a.t
                    <span class="sym">)
</span>    <span class="kwa">end

    def</span> qrst <span class="sym">*</span>args
        initialize <span class="sym">*</span>args
        <span class="kwa">self
    end


end


</span>WIDTH = <span class="num">10
</span>n = Integer<span class="sym">(</span><span class="kwa">ARGV</span><span class="sym">[</span><span class="num">0</span><span class="sym">])
</span>j = <span class="num">0

</span>digits = PiDigitSpigot.new

<span class="kwa">while</span> n <span class="sym">&gt;</span> <span class="num">0
</span>    <span class="kwa">if</span> n <span class="sym">&gt;</span>= WIDTH
        WIDTH.times <span class="sym">{</span>print digits.<span class="kwa">next</span><span class="sym">!}
</span>        j <span class="sym">+</span>= WIDTH
    <span class="kwa">else
</span>        n.times <span class="sym">{</span>print digits.<span class="kwa">next</span><span class="sym">!}
        (</span>WIDTH-n<span class="sym">)</span>.times <span class="sym">{</span>print <span class="str">&quot; &quot;</span><span class="sym">}
</span>        j <span class="sym">+</span>= n
    <span class="kwa">end
</span>    puts <span class="str">&quot;\t:&quot;</span><span class="sym">+</span>j.to_s
    n <span class="sym">-</span>= WIDTH
<span class="kwa">end
</span>
