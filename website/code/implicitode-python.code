<span class="slc">#!/usr/bin/env python
</span><span class="slc">#
</span><span class="slc"># The Great Computer Language Shootout
</span><span class="slc"># http://shootout.alioth.debian.org/
</span><span class="slc">#
</span><span class="slc"># Contributed by Sebastien Loisel
</span><span class="slc">#
</span><span class="slc"># OVERVIEW: In this test, we solve an ordinary differential equation
</span><span class="slc">#    u'=f(t,u)
</span><span class="slc"># using the Trapezoid numerical method, which can be written as
</span><span class="slc">#    (u[k+1]-u[k])=(f(t[k],u[k])+f(t[k]+dt,u[k+1]))*dt/2,
</span><span class="slc"># where t[k], u[k], dt and the function f are known and u[k+1] is the
</span><span class="slc"># unknown.
</span><span class="slc">#
</span><span class="slc"># Since u[k+1] appears on both sides of the equation, we use an iterative
</span><span class="slc"># solver called the newton iteration to compute u[k+1]. The newton iteration
</span><span class="slc"># computes the solution to
</span><span class="slc">#    h(x)=0
</span><span class="slc"># where h is a known function and x is the unknown 0 of h, using the method
</span><span class="slc">#    x[k+1]=x[k]-f(x[k])/f'(x[k]).
</span><span class="slc"># Here, f' denotes the derivative of f.
</span><span class="slc">#
</span><span class="slc"># To compute f' from the definition of f alone, we use a technique called
</span><span class="slc"># automatic differentiation. This works by replacing all floating point
</span><span class="slc"># variables by a special type we call ad (for automatic differentiation.)
</span><span class="slc"># If the python program for f is called with parameter x of type ad,
</span><span class="slc"># it will do the same work as if it were called with the equivalent parameter
</span><span class="slc"># of type floating point, but will also return f'. That's why it's called
</span><span class="slc"># &quot;automatic.&quot;
</span><span class="slc">#
</span><span class="slc"># To shake things up, we also have another type, fl (for &quot;float&quot;) which
</span><span class="slc"># works exactly like a double precision floating point, but with much
</span><span class="slc"># less precision.
</span><span class="slc">#
</span><span class="slc"># Summary of classes:
</span><span class="slc">#
</span><span class="slc"># ad -- automatic differentiation type
</span><span class="slc"># fl -- low precision floating point type
</span><span class="slc"># mycomplex -- complex numbers whose real and imaginary parts can be fl
</span><span class="slc"># trapezoid_method_rooter -- implements the function that the trapezoid method
</span><span class="slc">#                            must solve
</span>
<span class="kwc">import</span> sys
<span class="kwc">from</span> math <span class="kwc">import</span> log<span class="sym">,</span>exp<span class="sym">,</span>floor<span class="sym">,</span>fabs

<span class="kwb">def</span> sqr<span class="sym">(</span>x<span class="sym">):
</span>    <span class="str">&quot;&quot;&quot;sqr(x): a helper function that computes the square of any &quot;number&quot; x.&quot;&quot;&quot;</span>
    <span class="kwb">return</span> x<span class="sym">*</span>x

<span class="kwb">def</span> pwr<span class="sym">(</span>x<span class="sym">,</span>k<span class="sym">):
</span>    <span class="str">&quot;&quot;&quot;pwr(x,k): a helper function that computes the kth power of any
    &quot;number&quot; x.&quot;&quot;&quot;</span>
    <span class="kwb">if</span> k<span class="sym">&lt;=</span><span class="num">0</span><span class="sym">:
</span>        <span class="kwb">return</span> <span class="num">1
</span>    <span class="kwb">elif</span> <span class="sym">(</span>k<span class="sym">&amp;</span><span class="num">1</span><span class="sym">):
</span>        <span class="kwb">return</span> x<span class="sym">*</span>pwr<span class="sym">(</span>x<span class="sym">,</span>k<span class="num">-1</span><span class="sym">)
</span>    <span class="kwb">return</span> sqr<span class="sym">(</span>pwr<span class="sym">(</span>x<span class="sym">,</span>k<span class="sym">/</span><span class="num">2</span><span class="sym">))

</span><span class="kwb">def</span> pr<span class="sym">(</span>x<span class="sym">):
</span>    <span class="str">&quot;&quot;&quot;Print a value depending on its type.&quot;&quot;&quot;</span>
    <span class="kwb">if</span> <span class="kwa">isinstance</span><span class="sym">(</span>x<span class="sym">,</span><span class="kwa">float</span><span class="sym">):
</span>        <span class="kwb">return</span> <span class="str">&quot;%.12e&quot;</span><span class="sym">%</span>x
    <span class="kwb">elif</span> <span class="kwa">isinstance</span><span class="sym">(</span>x<span class="sym">,</span><span class="kwa">complex</span><span class="sym">):
</span>        <span class="kwb">return</span> <span class="str">&quot;%.12e %.12e&quot;</span><span class="sym">%(</span>x<span class="sym">.</span>real<span class="sym">,</span>x<span class="sym">.</span>imag<span class="sym">)
</span>    <span class="kwb">else</span><span class="sym">:
</span>        <span class="kwb">return</span> x<span class="sym">.</span>pr<span class="sym">()

</span><span class="kwa">class</span> fl<span class="sym">:
</span>    <span class="str">&quot;&quot;&quot;A low-precision floating point class.&quot;&quot;&quot;</span>
    <span class="kwb">def</span> pr<span class="sym">(</span>x<span class="sym">):
</span>        <span class="kwb">return</span> <span class="str">&quot;%.2e&quot;</span><span class="sym">%</span>x<span class="sym">.</span>a
    <span class="kwb">def</span> __init__<span class="sym">(</span>x<span class="sym">,</span>a<span class="sym">=</span><span class="num">0</span><span class="sym">):
</span>        <span class="kwa">global</span> count
        <span class="kwb">if</span> a<span class="sym">==</span><span class="num">0</span><span class="sym">:
</span>            x<span class="sym">.</span>a<span class="sym">=</span><span class="num">0.0
</span>        <span class="kwb">else</span><span class="sym">:
</span>            k<span class="sym">=</span><span class="kwa">int</span><span class="sym">(</span>log<span class="sym">(</span>fabs<span class="sym">(</span>a<span class="sym">)))
</span>            x<span class="sym">.</span>a<span class="sym">=</span>floor<span class="sym">(</span>a<span class="sym">*</span>exp<span class="sym">(-</span>k<span class="sym">+</span><span class="num">6</span><span class="sym">)+</span><span class="num">0.5</span><span class="sym">)*</span>exp<span class="sym">(</span>k<span class="num">-6</span><span class="sym">)
</span>    <span class="kwb">def</span> __add__<span class="sym">(</span>x<span class="sym">,</span>y<span class="sym">):
</span>        <span class="kwb">return</span> fl<span class="sym">(</span>x<span class="sym">.</span>a<span class="sym">+</span>y<span class="sym">.</span>a<span class="sym">)
</span>    <span class="kwb">def</span> __radd__<span class="sym">(</span>y<span class="sym">,</span>x<span class="sym">):
</span>        <span class="kwb">return</span> x<span class="sym">+</span>y
    <span class="kwb">def</span> __sub__<span class="sym">(</span>x<span class="sym">,</span>y<span class="sym">):
</span>        <span class="kwb">return</span> fl<span class="sym">(</span>x<span class="sym">.</span>a<span class="sym">-</span>y<span class="sym">.</span>a<span class="sym">)
</span>    <span class="kwb">def</span> __mul__<span class="sym">(</span>x<span class="sym">,</span>y<span class="sym">):
</span>        <span class="kwb">return</span> fl<span class="sym">(</span>x<span class="sym">.</span>a<span class="sym">*</span>y<span class="sym">.</span>a<span class="sym">)
</span>    <span class="kwb">def</span> __rmul__<span class="sym">(</span>y<span class="sym">,</span>x<span class="sym">):
</span>        <span class="kwb">return</span> x<span class="sym">*</span>y
    <span class="kwb">def</span> __div__<span class="sym">(</span>x<span class="sym">,</span>y<span class="sym">):
</span>        <span class="kwb">return</span> fl<span class="sym">(</span>x<span class="sym">.</span>a<span class="sym">/</span>y<span class="sym">.</span>a<span class="sym">)
</span>    <span class="kwb">def</span> __coerce__<span class="sym">(</span>x<span class="sym">,</span>y<span class="sym">):
</span>        <span class="kwb">if</span> <span class="kwa">isinstance</span><span class="sym">(</span>y<span class="sym">,</span>fl<span class="sym">):
</span>            <span class="kwb">return</span> <span class="sym">(</span>x<span class="sym">,</span>y<span class="sym">)
</span>        <span class="kwb">return</span> <span class="sym">(</span>x<span class="sym">,</span>fl<span class="sym">(</span>y<span class="sym">))

</span><span class="kwa">class</span> mycomplex<span class="sym">:
</span>    <span class="str">&quot;&quot;&quot;A complex type so that the type of the real or imaginary part can be
    any kind of number.&quot;&quot;&quot;</span>
    <span class="kwb">def</span> __init__<span class="sym">(</span>x<span class="sym">,</span>a<span class="sym">=</span><span class="num">0</span><span class="sym">,</span>b<span class="sym">=</span><span class="num">0</span><span class="sym">):
</span>        x<span class="sym">.</span>real<span class="sym">,</span>x<span class="sym">.</span>imag<span class="sym">=</span>a<span class="sym">,</span>b
    <span class="kwb">def</span> __add__<span class="sym">(</span>a<span class="sym">,</span>b<span class="sym">):
</span>        <span class="kwb">return</span> mycomplex<span class="sym">(</span>a<span class="sym">.</span>real<span class="sym">+</span>b<span class="sym">.</span>real<span class="sym">,</span>a<span class="sym">.</span>imag<span class="sym">+</span>b<span class="sym">.</span>imag<span class="sym">)
</span>    <span class="kwb">def</span> __radd__<span class="sym">(</span>b<span class="sym">,</span>a<span class="sym">):
</span>        <span class="kwb">return</span> a<span class="sym">+</span>b
    <span class="kwb">def</span> __sub__<span class="sym">(</span>a<span class="sym">,</span>b<span class="sym">):
</span>        <span class="kwb">return</span> mycomplex<span class="sym">(</span>a<span class="sym">.</span>real<span class="sym">-</span>b<span class="sym">.</span>real<span class="sym">,</span>a<span class="sym">.</span>imag<span class="sym">-</span>b<span class="sym">.</span>imag<span class="sym">)
</span>    <span class="kwb">def</span> __mul__<span class="sym">(</span>a<span class="sym">,</span>b<span class="sym">):
</span>        <span class="kwb">return</span> mycomplex<span class="sym">(</span>a<span class="sym">.</span>real<span class="sym">*</span>b<span class="sym">.</span>real<span class="sym">-</span>a<span class="sym">.</span>imag<span class="sym">*</span>b<span class="sym">.</span>imag<span class="sym">,
</span>                         a<span class="sym">.</span>real<span class="sym">*</span>b<span class="sym">.</span>imag<span class="sym">+</span>a<span class="sym">.</span>imag<span class="sym">*</span>b<span class="sym">.</span>real<span class="sym">)
</span>    <span class="kwb">def</span> __rmul__<span class="sym">(</span>b<span class="sym">,</span>a<span class="sym">):
</span>        <span class="kwb">return</span> a<span class="sym">*</span>b
    <span class="kwb">def</span> __div__<span class="sym">(</span>a<span class="sym">,</span>b<span class="sym">):
</span>        mag<span class="sym">=</span>b<span class="sym">.</span>real<span class="sym">*</span>b<span class="sym">.</span>real<span class="sym">+</span>b<span class="sym">.</span>imag<span class="sym">*</span>b<span class="sym">.</span>imag
        <span class="kwb">return</span> mycomplex<span class="sym">((</span>a<span class="sym">.</span>real<span class="sym">*</span>b<span class="sym">.</span>real<span class="sym">+</span>a<span class="sym">.</span>imag<span class="sym">*</span>b<span class="sym">.</span>imag<span class="sym">)/</span>mag<span class="sym">,
                         (</span>a<span class="sym">.</span>imag<span class="sym">*</span>b<span class="sym">.</span>real<span class="sym">-</span>a<span class="sym">.</span>real<span class="sym">*</span>b<span class="sym">.</span>imag<span class="sym">)/</span>mag<span class="sym">)
</span>    <span class="kwb">def</span> __coerce__<span class="sym">(</span>a<span class="sym">,</span>b<span class="sym">):
</span>        <span class="kwb">if</span> <span class="kwa">isinstance</span><span class="sym">(</span>b<span class="sym">,</span>mycomplex<span class="sym">):
</span>            <span class="kwb">return</span> <span class="sym">(</span>a<span class="sym">,</span>b<span class="sym">)
</span>        <span class="kwb">return</span> <span class="sym">(</span>a<span class="sym">,</span>mycomplex<span class="sym">(</span>b<span class="sym">))
</span>    <span class="kwb">def</span> pr<span class="sym">(</span>a<span class="sym">):
</span>        <span class="kwb">return</span> pr<span class="sym">(</span>a<span class="sym">.</span>real<span class="sym">)+</span><span class="str">' '</span><span class="sym">+</span>pr<span class="sym">(</span>a<span class="sym">.</span>imag<span class="sym">)

</span><span class="kwb">def</span> one<span class="sym">(</span>x<span class="sym">):
</span>    <span class="kwb">if</span> <span class="kwa">isinstance</span><span class="sym">(</span>x<span class="sym">,</span><span class="kwa">float</span><span class="sym">):
</span>        <span class="kwb">return</span> <span class="num">1.0
</span>    <span class="kwb">if</span> <span class="kwa">isinstance</span><span class="sym">(</span>x<span class="sym">,</span><span class="kwa">complex</span><span class="sym">):
</span>        <span class="kwb">return</span> <span class="num">1.0</span><span class="sym">+</span><span class="num">0.0j
</span>    <span class="kwb">if</span> <span class="kwa">isinstance</span><span class="sym">(</span>x<span class="sym">,</span>fl<span class="sym">):
</span>        <span class="kwb">return</span> fl<span class="sym">(</span><span class="num">1.0</span><span class="sym">)
</span>    <span class="kwb">if</span> <span class="kwa">isinstance</span><span class="sym">(</span>x<span class="sym">,</span>mycomplex<span class="sym">):
</span>        <span class="kwb">return</span> mycomplex<span class="sym">(</span>one<span class="sym">(</span>x<span class="sym">.</span>real<span class="sym">),</span><span class="num">0.0</span><span class="sym">)

</span><span class="kwa">class</span> ad<span class="sym">:
</span>    <span class="str">&quot;&quot;&quot;Automatic differentiation type. An ad has two attributes, x and dx.&quot;&quot;&quot;</span>
    <span class="kwb">def</span> __init__<span class="sym">(</span><span class="kwc">self</span><span class="sym">,</span>x<span class="sym">=</span><span class="num">0</span><span class="sym">,</span>dx<span class="sym">=</span><span class="num">0</span><span class="sym">):
</span>        <span class="kwc">self</span><span class="sym">.</span>x<span class="sym">,</span><span class="kwc">self</span><span class="sym">.</span>dx<span class="sym">=</span>x<span class="sym">,</span>dx
    <span class="kwb">def</span> __add__<span class="sym">(</span>a<span class="sym">,</span>b<span class="sym">):
</span>        <span class="str">&quot;&quot;&quot;ad's add like vectors.&quot;&quot;&quot;</span>
        <span class="kwb">return</span> ad<span class="sym">(</span>a<span class="sym">.</span>x<span class="sym">+</span>b<span class="sym">.</span>x<span class="sym">,</span>a<span class="sym">.</span>dx<span class="sym">+</span>b<span class="sym">.</span>dx<span class="sym">)
</span>    <span class="kwb">def</span> __sub__<span class="sym">(</span>a<span class="sym">,</span>b<span class="sym">):
</span>        <span class="str">&quot;&quot;&quot;ad's subtract like vectors.&quot;&quot;&quot;</span>
        <span class="kwb">return</span> ad<span class="sym">(</span>a<span class="sym">.</span>x<span class="sym">-</span>b<span class="sym">.</span>x<span class="sym">,</span>a<span class="sym">.</span>dx<span class="sym">-</span>b<span class="sym">.</span>dx<span class="sym">)
</span>    <span class="kwb">def</span> __mul__<span class="sym">(</span>a<span class="sym">,</span>b<span class="sym">):
</span>        <span class="str">&quot;&quot;&quot;The product of ad's is given by the &quot;product rule&quot; of differentation:
        (x,dx)*(y,dy)=(xy,xdy+ydx).&quot;&quot;&quot;</span>
	<span class="kwb">return</span> ad<span class="sym">(</span>a<span class="sym">.</span>x<span class="sym">*</span>b<span class="sym">.</span>x<span class="sym">,</span>a<span class="sym">.</span>dx<span class="sym">*</span>b<span class="sym">.</span>x<span class="sym">+</span>a<span class="sym">.</span>x<span class="sym">*</span>b<span class="sym">.</span>dx<span class="sym">)
</span>    <span class="kwb">def</span> __div__<span class="sym">(</span>a<span class="sym">,</span>b<span class="sym">):
</span>        <span class="str">&quot;&quot;&quot;The quotient rule of differentiation gives
        (x,dx)/(y,dy)=(x/y,(ydx-xdy)/(y*y)).&quot;&quot;&quot;</span>
        <span class="kwb">return</span> ad<span class="sym">(</span>a<span class="sym">.</span>x<span class="sym">/</span>b<span class="sym">.</span>x<span class="sym">,(</span>a<span class="sym">.</span>dx<span class="sym">*</span>b<span class="sym">.</span>x<span class="sym">-</span>a<span class="sym">.</span>x<span class="sym">*</span>b<span class="sym">.</span>dx<span class="sym">)/(</span>b<span class="sym">.</span>x<span class="sym">*</span>b<span class="sym">.</span>x<span class="sym">))
</span>    <span class="kwb">def</span> __coerce__<span class="sym">(</span><span class="kwc">self</span><span class="sym">,</span>other<span class="sym">):
</span>        <span class="kwb">if</span> <span class="kwa">isinstance</span><span class="sym">(</span>other<span class="sym">,</span>ad<span class="sym">):
</span>            <span class="kwb">return</span> <span class="sym">(</span><span class="kwc">self</span><span class="sym">,</span>other<span class="sym">)
</span>        <span class="kwb">return</span> <span class="sym">(</span><span class="kwc">self</span><span class="sym">,</span>ad<span class="sym">(</span>other<span class="sym">))
</span>    <span class="kwb">def</span> pr<span class="sym">(</span>a<span class="sym">):
</span>        <span class="kwb">return</span> pr<span class="sym">(</span>a<span class="sym">.</span>x<span class="sym">)+</span><span class="str">' '</span><span class="sym">+</span>pr<span class="sym">(</span>a<span class="sym">.</span>dx<span class="sym">)

</span><span class="kwb">def</span> rat<span class="sym">(</span>x<span class="sym">):
</span>    <span class="str">&quot;&quot;&quot;This is just a quotient of two polynomials p/q, with degree p=11 and
    degree q=7.&quot;&quot;&quot;</span>
    <span class="kwb">return</span> <span class="sym">(</span>x<span class="sym">*</span><span class="num">2</span><span class="sym">+</span>pwr<span class="sym">(</span>x<span class="sym">,</span><span class="num">2</span><span class="sym">)*</span><span class="num">3</span><span class="sym">+</span>pwr<span class="sym">(</span>x<span class="sym">,</span><span class="num">6</span><span class="sym">)*</span><span class="num">7</span><span class="sym">+</span>pwr<span class="sym">(</span>x<span class="sym">,</span><span class="num">11</span><span class="sym">)*</span><span class="num">5</span><span class="sym">+</span><span class="num">1</span><span class="sym">)/(</span>x<span class="sym">*</span><span class="num">5</span><span class="sym">-</span>pwr<span class="sym">(</span>x<span class="sym">,</span><span class="num">3</span><span class="sym">)*</span><span class="num">6</span><span class="sym">-</span>pwr<span class="sym">(</span>x<span class="sym">,</span><span class="num">7</span><span class="sym">)*</span><span class="num">3</span><span class="sym">+</span><span class="num">2</span><span class="sym">)

</span><span class="kwb">def</span> newton<span class="sym">(</span>x0<span class="sym">,</span>n<span class="sym">,</span>g<span class="sym">):
</span>    <span class="str">&quot;&quot;&quot;The newton iteration computes the zero of g starting with initial guess
    x0. This implementation iterates n times and then returns the answer.&quot;&quot;&quot;</span>
    <span class="kwb">for</span> i <span class="kwb">in</span> <span class="kwa">range</span><span class="sym">(</span>n<span class="sym">):
</span>        val<span class="sym">=</span>g<span class="sym">(</span>ad<span class="sym">(</span>x0<span class="sym">,</span>one<span class="sym">(</span>x0<span class="sym">)))
</span>        x0<span class="sym">=</span>x0<span class="sym">-</span>val<span class="sym">.</span>x<span class="sym">/</span>val<span class="sym">.</span>dx
    <span class="kwb">return</span> x0

<span class="kwb">def</span> mysqrt<span class="sym">(</span>x<span class="sym">):
</span>    <span class="str">&quot;&quot;&quot;This isn't actually a square root. However, newton(1,10,mysqrt) should
    return the square root of 2 (1.4142...).&quot;&quot;&quot;</span>
    <span class="kwb">return</span> sqr<span class="sym">(</span>x<span class="sym">)-</span>ad<span class="sym">(</span><span class="num">2</span><span class="sym">)

</span><span class="kwa">class</span> trapezoid_method_rooter<span class="sym">:
</span>    <span class="str">&quot;&quot;&quot;The trapezoid method (see below) works by computing the solution of some
    problem of the form h(x)=0. This class implements the function h needed
    in the trapezoid method.&quot;&quot;&quot;</span>
    <span class="kwb">def</span> __init__<span class="sym">(</span><span class="kwc">self</span><span class="sym">,</span>g<span class="sym">,</span>y0<span class="sym">,</span>t0<span class="sym">,</span>t1<span class="sym">):
</span>        <span class="kwc">self</span><span class="sym">.</span>g<span class="sym">,</span><span class="kwc">self</span><span class="sym">.</span>y0<span class="sym">,</span><span class="kwc">self</span><span class="sym">.</span>t0<span class="sym">,</span><span class="kwc">self</span><span class="sym">.</span>t1<span class="sym">=</span>g<span class="sym">,</span>y0<span class="sym">,</span>t0<span class="sym">,</span>t1
        <span class="kwc">self</span><span class="sym">.</span>g0<span class="sym">=</span>g<span class="sym">(</span>t0<span class="sym">,</span>y0<span class="sym">)
</span>    <span class="kwb">def</span> __call__<span class="sym">(</span><span class="kwc">self</span><span class="sym">,</span>y1<span class="sym">):
</span>        <span class="str">&quot;&quot;&quot;The function is (g(t1,y1)-g(t0,y0))*(t1-t0)/2+y0-y1. The parameters
        t0,y0,t1,g are set at construction time, so the only parameter left is
        y1.&quot;&quot;&quot;</span>
<span class="slc">#        raz=(self.g(ad(self.t1),y1))
</span>        ret<span class="sym">=(</span><span class="kwc">self</span><span class="sym">.</span>g<span class="sym">(</span>ad<span class="sym">(</span><span class="kwc">self</span><span class="sym">.</span>t1<span class="sym">),</span>y1<span class="sym">)+</span><span class="kwc">self</span><span class="sym">.</span>g0<span class="sym">)*((</span><span class="kwc">self</span><span class="sym">.</span>t1<span class="sym">-</span><span class="kwc">self</span><span class="sym">.</span>t0<span class="sym">)/</span><span class="num">2</span><span class="sym">)+</span>ad<span class="sym">(</span><span class="kwc">self</span><span class="sym">.</span>y0<span class="sym">)-</span>y1
<span class="slc">#        print &quot;t0&quot;,pr(self.t0),&quot;t1&quot;,pr(self.t1),&quot;y0&quot;,pr(self.y0),&quot;g0&quot;,pr(self.g0),&quot;y1&quot;,pr(y1),&quot;ret&quot;,pr(ret),&quot;raz&quot;,pr(raz)
</span>        <span class="kwb">return</span> ret

<span class="kwb">def</span> trapezoid_method<span class="sym">(</span>t0<span class="sym">,</span>dt<span class="sym">,</span>y0<span class="sym">,</span>g<span class="sym">,</span>numsteps<span class="sym">):
</span>    <span class="str">&quot;&quot;&quot;This function will approximate the solution of y'=g(t,y) at time
    t0+numsteps*dt with initial value y(t0)=y0 using the trapezoid method
    of numerical integration.&quot;&quot;&quot;</span>
    <span class="kwb">for</span> i <span class="kwb">in</span> <span class="kwa">range</span><span class="sym">(</span>numsteps<span class="sym">):
</span>        foo<span class="sym">=</span>trapezoid_method_rooter<span class="sym">(</span>g<span class="sym">,</span>y0<span class="sym">,</span>t0<span class="sym">,</span>t0<span class="sym">+</span>dt<span class="sym">)
</span>        y0<span class="sym">=</span>newton<span class="sym">(</span>y0<span class="sym">,</span><span class="num">10</span><span class="sym">,</span>foo<span class="sym">)
</span>        t0<span class="sym">=</span>t0<span class="sym">+</span>dt
    <span class="kwb">return</span> y0

<span class="kwb">def</span> sqrintegrand<span class="sym">(</span>t<span class="sym">,</span>y<span class="sym">):
</span>    <span class="str">&quot;&quot;&quot;This is a version of sqr which has the correct signature so that it can
    be passed to trapezoid_method. The first parameter, t, is ignored.
    The second parameter, y, is passed on to sqr.&quot;&quot;&quot;</span>
    <span class="kwb">return</span> sqr<span class="sym">(</span>y<span class="sym">)
</span><span class="kwb">def</span> ratintegrand<span class="sym">(</span>t<span class="sym">,</span>y<span class="sym">):
</span>    <span class="str">&quot;&quot;&quot;This is a version of the rational function rat above that can be passed
    to trapezoid_method. In this instance, we do use the t parameter.&quot;&quot;&quot;</span>
    <span class="kwb">return</span> rat<span class="sym">(</span>y<span class="sym">)-</span>t

<span class="kwb">def</span> integrate_functions<span class="sym">(</span>t0<span class="sym">,</span>x0<span class="sym">,</span>dt<span class="sym">,</span>n<span class="sym">):
</span>    <span class="str">&quot;&quot;&quot;Integrate sqrintegrand and ratintegrand with given initial value.
    Depending on the type of initial value, this will result in float, complex,
    iv or complex iv integration.&quot;&quot;&quot;</span>
    <span class="kwb">print</span> <span class="sym">(</span><span class="str">'i1 '</span><span class="sym">+</span>pr<span class="sym">(</span>trapezoid_method<span class="sym">(</span>t0<span class="sym">,</span>dt<span class="sym">,</span>x0<span class="sym">,</span>sqrintegrand<span class="sym">,</span>n<span class="sym">)))
</span>    <span class="kwb">print</span> <span class="sym">(</span><span class="str">'i2 '</span><span class="sym">+</span>pr<span class="sym">(</span>trapezoid_method<span class="sym">(</span>t0<span class="sym">,</span>dt<span class="sym">,</span>x0<span class="sym">,</span>ratintegrand<span class="sym">,</span>n<span class="sym">)))

</span><span class="kwb">try</span><span class="sym">:
</span>    N <span class="sym">=</span> <span class="kwa">int</span><span class="sym">(</span>sys<span class="sym">.</span>argv<span class="sym">[</span><span class="num">1</span><span class="sym">])
</span><span class="kwb">except</span><span class="sym">:
</span>    N <span class="sym">=</span> <span class="num">50
</span><span class="kwb">print</span> <span class="sym">(</span><span class="str">'rational_taylor_series: '</span><span class="sym">+</span>pr<span class="sym">(</span>rat<span class="sym">(</span>ad<span class="sym">(</span><span class="num">0.25</span><span class="sym">,</span><span class="num">1</span><span class="sym">))))
</span><span class="kwb">print</span> <span class="sym">(</span><span class="str">'newton-sqrt_2: '</span><span class="sym">+</span>pr<span class="sym">(</span>newton<span class="sym">(</span><span class="num">1.0</span><span class="sym">,</span><span class="num">10</span><span class="sym">,</span>mysqrt<span class="sym">)))
</span>x<span class="sym">=</span>newton<span class="sym">(-</span><span class="num">1.0</span><span class="sym">,</span><span class="num">6</span><span class="sym">,</span>rat<span class="sym">)
</span><span class="kwb">print</span> <span class="sym">(</span><span class="str">'newton-rat: '</span><span class="sym">+</span>pr<span class="sym">(</span>x<span class="sym">))
</span>integrate_functions<span class="sym">(</span><span class="num">1.0</span><span class="sym">,</span><span class="num">0.02</span><span class="sym">,</span><span class="num">1.0</span><span class="sym">/(</span><span class="num">4</span><span class="sym">*</span>N<span class="sym">),</span><span class="num">4</span><span class="sym">*</span>N<span class="sym">)
</span>integrate_functions<span class="sym">(</span>fl<span class="sym">(</span><span class="num">1.0</span><span class="sym">),</span>fl<span class="sym">(</span><span class="num">0.02</span><span class="sym">),</span>fl<span class="sym">(</span><span class="num">1.0</span><span class="sym">)/</span>fl<span class="sym">(</span><span class="kwa">float</span><span class="sym">(</span>N<span class="sym">)),</span>N<span class="sym">)
</span>integrate_functions<span class="sym">(</span><span class="num">1.0</span><span class="sym">+</span><span class="num">0.0j</span><span class="sym">,</span><span class="num">0.02</span><span class="sym">+</span><span class="num">0.02</span>j<span class="sym">,</span><span class="num">1.0</span><span class="sym">/</span>N<span class="sym">,</span>N<span class="sym">)
</span>integrate_functions<span class="sym">(</span>mycomplex<span class="sym">(</span>fl<span class="sym">(</span><span class="num">1.0</span><span class="sym">),</span>fl<span class="sym">(</span><span class="num">0.0</span><span class="sym">)),</span>mycomplex<span class="sym">(</span>fl<span class="sym">(</span><span class="num">0.02</span><span class="sym">),</span>fl<span class="sym">(</span><span class="num">0.02</span><span class="sym">)),</span>mycomplex<span class="sym">(</span>fl<span class="sym">(</span><span class="num">1.0</span><span class="sym">))/</span>mycomplex<span class="sym">(</span>fl<span class="sym">(</span><span class="kwa">float</span><span class="sym">(</span>N<span class="sym">))),</span>N<span class="sym">)
</span>
