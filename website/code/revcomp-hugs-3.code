<span class="com">{-# OPTIONS -fglasgow-exts -O2 -optc-O3 #-}</span>
<span class="slc">-- The Great Computer Language Shootout</span>
<span class="slc">-- http://shootout.alioth.debian.org/</span>
<span class="slc">-- contributed by Don Stewart, translated from C version</span>

<span class="kwa">import</span> Data.<span class="kwb">Char</span>
<span class="kwa">import</span> Control.Arrow
<span class="kwa">import</span> Foreign.Marshal.Array
<span class="kwa">import</span> Foreign.Storable
<span class="kwa">import</span> Control.Monad
<span class="kwa">import qualified</span> Control.Exception <span class="kwa">as</span> C
<span class="kwa">import</span> System.IO
<span class="kwa">import</span> GHC.IOBase
<span class="kwa">import</span> GHC.Base
<span class="kwa">import</span> GHC.Ptr
<span class="kwa">import</span> GHC.Word

pairs <span class="sym">=</span> map <span class="sym">(</span>c2w <span class="sym">***</span> c2w<span class="sym">) [(</span><span class="str">'A'</span><span class="sym">,</span><span class="str">'T'</span><span class="sym">),(</span><span class="str">'C'</span><span class="sym">,</span><span class="str">'G'</span><span class="sym">),(</span><span class="str">'B'</span><span class="sym">,</span><span class="str">'V'</span><span class="sym">),(</span><span class="str">'D'</span><span class="sym">,</span><span class="str">'H'</span><span class="sym">),(</span><span class="str">'K'</span><span class="sym">,</span><span class="str">'M'</span><span class="sym">),(</span><span class="str">'R'</span><span class="sym">,</span><span class="str">'Y'</span><span class="sym">),(</span><span class="str">'\0'</span><span class="sym">,</span><span class="str">'\0'</span><span class="sym">)]</span>

main <span class="sym">=</span> <span class="kwa">do</span>
    inp  <span class="sym">&lt;-</span> mallocArray <span class="num">129</span>  <span class="sym">::</span> IO <span class="sym">(</span>Ptr Word8<span class="sym">)</span>
    buf  <span class="sym">&lt;-</span> mallocArray <span class="num">1024</span> <span class="sym">::</span> IO <span class="sym">(</span>Ptr Word8<span class="sym">)</span>
    iubP <span class="sym">&lt;-</span> sequence <span class="sym">[</span> newArray <span class="sym">[</span>x<span class="sym">,</span>y<span class="sym">] | (</span>x<span class="sym">,</span>y<span class="sym">) &lt;-</span> pairs <span class="sym">] &gt;&gt;=</span> newArray
    iubC <span class="sym">&lt;-</span> newArray <span class="sym">(</span>map c2w <span class="sym">[</span><span class="str">'\0'</span>..<span class="str">'\255'</span><span class="sym">]++[</span><span class="num">0</span><span class="sym">])</span>
    buildIubComplement iubC iubP <span class="sym">(</span><span class="num">0</span> <span class="sym">::</span> <span class="kwb">Int</span><span class="sym">)</span>
    <span class="sym">(</span>slen<span class="sym">,</span>inp<span class="sym">) &lt;-</span> go <span class="num">0 128</span> inp buf iubC
    when <span class="sym">(</span>slen <span class="sym">&gt;</span> <span class="num">0</span><span class="sym">)</span> $ process iubC inp slen

go slen mlen inp buffer iubC <span class="sym">=</span> <span class="kwa">do</span>
    eof <span class="sym">&lt;-</span> C.catch <span class="sym">(</span>getLine <span class="sym">&gt;&gt;=</span> pokeArray0 <span class="num">0</span> buffer . c2ws . take <span class="num">1023</span> <span class="sym">&gt;&gt;</span> return <span class="kwa">False</span><span class="sym">)</span>
                   <span class="sym">(</span>\_ <span class="sym">-&gt;</span> return <span class="kwa">True</span><span class="sym">)</span>
    if eof <span class="kwa">then</span> return <span class="sym">(</span>slen<span class="sym">,</span>inp<span class="sym">)</span> <span class="kwa">else do</span>
        b0 <span class="sym">&lt;-</span> buffer <span class="sym">! (</span><span class="num">0</span><span class="sym">::</span><span class="kwb">Int</span><span class="sym">)</span>
        if b0 <span class="sym">==</span> c2w <span class="str">'&gt;'</span>
            <span class="kwa">then do</span> when <span class="sym">(</span>slen <span class="sym">&gt;</span> <span class="num">0</span><span class="sym">)</span> $ process iubC inp slen
                    lengthArray0 <span class="num">0</span> buffer <span class="sym">&gt;&gt;=</span> hPutBuf stdout buffer <span class="sym">&gt;&gt;</span> putChar <span class="str">'\n'</span>
                    go <span class="num">0</span> mlen inp buffer iubC

            <span class="kwa">else do</span> l <span class="sym">&lt;-</span> lengthArray0 <span class="num">0</span> buffer <span class="sym">&gt;&gt;=</span> shrink buffer . <span class="sym">(+</span><span class="num">1</span><span class="sym">)</span>
                    <span class="sym">(</span>inp<span class="str">',mlen'</span><span class="sym">) &lt;-</span> tweak slen mlen l inp
                    copyArray <span class="sym">(</span>inp<span class="str">' `plusPtr` slen) buffer l</span>
<span class="str">                    go (slen + l) mlen'</span> inp<span class="str">' buffer iubC</span>
<span class="str"></span>
<span class="str">process iubc strand len = do</span>
<span class="str">    inplacereverse iubc strand len</span>
<span class="str">    (s,l) &lt;- print60 strand len</span>
<span class="str">    hPutBuf stdout s l &gt;&gt; putChar '</span>\n<span class="str">'</span>
<span class="str"></span>
<span class="str">print60 s n</span>
<span class="str">    | n &lt;= 60 = return (s,n)</span>
<span class="str">    | otherwise = do</span>
<span class="str">        hPutBuf stdout s 60 &gt;&gt; putChar '</span>\n<span class="str">'</span>
<span class="str">        print60 (s `advancePtr` 60) (n - 60)</span>
<span class="str"></span>
<span class="str">tweak slen mlen l inp</span>
<span class="str">    | slen + l &lt;= mlen = return (inp,mlen)</span>
<span class="str">    | otherwise        = do</span>
<span class="str">        let mlen'</span> <span class="sym">=</span> mlen <span class="sym">+</span> mlen
        inp<span class="str">' &lt;- reallocArray0 inp mlen'</span>
        tweak slen mlen<span class="str">' l inp'</span>

shrink b l <span class="sym">|</span> l <span class="sym">&lt;=</span> <span class="num">0</span>  <span class="sym">=</span> return l
           <span class="sym">|</span> otherwise <span class="sym">=</span> <span class="kwa">do</span>
                bl1 <span class="sym">&lt;-</span> b <span class="sym">! (</span>l<span class="sym">-</span><span class="num">1</span><span class="sym">)</span>
                if not . isAlpha . w2c $ bl1 <span class="kwa">then</span> shrink b <span class="sym">(</span>l<span class="sym">-</span><span class="num">1</span><span class="sym">)</span> <span class="kwa">else</span> return l

buildIubComplement iubC iubP i <span class="sym">=</span> <span class="kwa">do</span>
    i0 <span class="sym">&lt;-</span> index2 iubP i <span class="sym">(</span><span class="num">0</span><span class="sym">::</span><span class="kwb">Int</span><span class="sym">)</span>
    when <span class="sym">(</span>i0 <span class="sym">/=</span> <span class="num">0</span><span class="sym">)</span> $ <span class="kwa">do</span>
        i1 <span class="sym">&lt;-</span> index2 iubP i <span class="sym">(</span><span class="num">1</span><span class="sym">::</span><span class="kwb">Int</span><span class="sym">)</span>
        set iubC i0 i1
        set iubC i1 i0
        set iubC <span class="sym">(</span>tolower i0<span class="sym">)</span> i1
        set iubC <span class="sym">(</span>tolower i1<span class="sym">)</span> i0
        buildIubComplement iubC iubP <span class="sym">(</span>i<span class="sym">+</span><span class="num">1</span><span class="sym">)</span>

inplacereverse iubc&#64;<span class="sym">(</span>Ptr r<span class="sym">)</span> strand&#64;<span class="sym">(</span>Ptr s<span class="sym">)</span> len&#64;<span class="sym">(</span>I# ln<span class="sym">) =</span> <span class="kwa">do</span>
    <span class="sym">(</span>i<span class="sym">,</span>l<span class="sym">) &lt;-</span> IO $ reverseit r s <span class="num">0</span># <span class="sym">(</span>ln <span class="sym">-</span># <span class="num">1</span>#<span class="sym">)</span>
    when <span class="sym">(</span>i <span class="sym">==</span> l<span class="sym">)</span> $ strand <span class="sym">!</span> i <span class="sym">&gt;&gt;= (</span>iubc <span class="sym">!) &gt;&gt;=</span> set strand i

reverseit iubc strand i l s <span class="sym">=</span>
    if i <span class="sym">&gt;=</span># l
        <span class="kwa">then</span> <span class="sym">(</span># s<span class="sym">, (</span>I# i<span class="sym">,</span> I# l<span class="sym">)</span> #<span class="sym">)</span>
        <span class="kwa">else case</span> readWord8OffAddr# strand i s  <span class="kwa">of</span> { <span class="sym">(</span># s<span class="sym">,</span> c #<span class="sym">) -&gt;</span>
             <span class="kwa">case</span> readWord8OffAddr# strand l s  <span class="kwa">of</span> { <span class="sym">(</span># s<span class="sym">,</span> x #<span class="sym">) -&gt;</span>
             <span class="kwa">case</span> readWord8OffAddr# iubc   <span class="sym">(</span>word2Int# x<span class="sym">)</span> s  <span class="kwa">of</span> { <span class="sym">(</span># s<span class="sym">,</span> y #<span class="sym">) -&gt;</span>
             <span class="kwa">case</span> readWord8OffAddr# iubc   <span class="sym">(</span>word2Int# c<span class="sym">)</span> s  <span class="kwa">of</span> { <span class="sym">(</span># s<span class="sym">,</span> z #<span class="sym">) -&gt;</span>
             <span class="kwa">case</span> writeWord8OffAddr# strand i y s <span class="kwa">of</span> { s <span class="sym">-&gt;</span>
             <span class="kwa">case</span> writeWord8OffAddr# strand l z s <span class="kwa">of</span> { s <span class="sym">-&gt;</span>
             reverseit iubc strand <span class="sym">(</span>i <span class="sym">+</span># <span class="num">1</span>#<span class="sym">) (</span>l <span class="sym">-</span># <span class="num">1</span>#<span class="sym">)</span> s
        } } } } } }

arr <span class="sym">!</span> i     <span class="sym">=</span> peekElemOff arr <span class="sym">(</span>fromIntegral i<span class="sym">)</span>
set arr i n <span class="sym">=</span> pokeElemOff arr <span class="sym">(</span>fromIntegral i<span class="sym">)</span> n

index2 arr i j <span class="sym">=</span> arr <span class="sym">!</span> i <span class="sym">&gt;&gt;= (!</span> j<span class="sym">)</span>
set2 arr i j n <span class="sym">=</span> arr <span class="sym">!</span> i <span class="sym">&gt;&gt;=</span> \arr<span class="str">' -&gt; set arr'</span> j n

c2w     <span class="sym">=</span> fromIntegral . ord
w2c     <span class="sym">=</span> chr . fromIntegral
c2ws    <span class="sym">=</span> unsafeCoerce#
tolower <span class="sym">=</span> fromIntegral . ord . toLower . chr . fromIntegral

