
<span class="sym">!</span> nsieve implementation
<span class="sym">!</span> Simon Geard<span class="sym">,</span> <span class="num">16</span><span class="sym">/</span><span class="num">12</span><span class="sym">/</span><span class="num">04
</span><span class="sym">!
!</span> Building info<span class="sym">.
! ==============
!
!</span> Linux  <span class="sym">-</span> <span class="kwa">using</span> the Intel Fortran90 compiler<span class="sym">:
!
!</span>          ifort nsieve<span class="sym">.</span>f90 <span class="sym">-</span>O3 <span class="sym">-</span><span class="kwb">static</span><span class="sym">-</span>libcxa <span class="sym">-</span>o nsieve
<span class="sym">!
!        -</span> <span class="kwa">using</span> g95<span class="sym">:
!
!</span>          g95 nsieve<span class="sym">.</span>f90 <span class="sym">-</span>O3 <span class="sym">-</span>o nsieve

program nsieve

  implicit none
  integer num<span class="sym">,</span> m
  character<span class="sym">(</span>len<span class="sym">=</span><span class="num">8</span><span class="sym">)</span> argv
  logical<span class="sym">,</span> dimension<span class="sym">(:),</span> allocatable <span class="sym">::</span> flags

  call getarg<span class="sym">(</span><span class="num">1</span><span class="sym">,</span>argv<span class="sym">)
</span>  read<span class="sym">(</span>argv<span class="sym">,*)</span> num

  m <span class="sym">= (</span><span class="num">2</span><span class="sym">**</span>num<span class="sym">)*</span><span class="num">10000
</span>  allocate<span class="sym">(</span>flags<span class="sym">(</span>m<span class="sym">))
</span>  write<span class="sym">(*,</span><span class="str">'(A,I8,A,I8)'</span><span class="sym">)</span>  <span class="str">'Primes up to '</span><span class="sym">,</span>m<span class="sym">,</span><span class="str">' '</span><span class="sym">,</span>nsi<span class="sym">(</span>m<span class="sym">,</span>flags<span class="sym">)

</span>  m <span class="sym">= (</span><span class="num">2</span><span class="sym">**(</span>num<span class="num">-1</span><span class="sym">))*</span><span class="num">10000
</span>  write<span class="sym">(*,</span><span class="str">'(A,I8,A,I8)'</span><span class="sym">)</span>  <span class="str">'Primes up to '</span><span class="sym">,</span>m<span class="sym">,</span><span class="str">' '</span><span class="sym">,</span>nsi<span class="sym">(</span>m<span class="sym">,</span>flags<span class="sym">)

</span>  m <span class="sym">= (</span><span class="num">2</span><span class="sym">**(</span>num<span class="num">-2</span><span class="sym">))*</span><span class="num">10000
</span>  write<span class="sym">(*,</span><span class="str">'(A,I8,A,I8)'</span><span class="sym">)</span>  <span class="str">'Primes up to '</span><span class="sym">,</span>m<span class="sym">,</span><span class="str">' '</span><span class="sym">,</span>nsi<span class="sym">(</span>m<span class="sym">,</span>flags<span class="sym">)


</span>  deallocate<span class="sym">(</span>flags<span class="sym">)

</span>contains

  integer function nsi<span class="sym">(</span>m<span class="sym">,</span> flags<span class="sym">)
</span>    integer<span class="sym">,</span> intent<span class="sym">(</span>in<span class="sym">) ::</span> m
    logical<span class="sym">,</span> dimension<span class="sym">(:) ::</span> flags
    integer i<span class="sym">,</span> count<span class="sym">,</span> k

    <span class="kwa">do</span> i<span class="sym">=</span><span class="num">2</span><span class="sym">,</span>m
       flags<span class="sym">(</span>i<span class="sym">) = .</span><span class="kwa">true</span><span class="sym">.
</span>    end <span class="kwa">do
</span>    count <span class="sym">=</span> <span class="num">0
</span>    <span class="kwa">do</span> i<span class="sym">=</span><span class="num">2</span><span class="sym">,</span>m
       <span class="kwa">if</span> <span class="sym">(</span>flags<span class="sym">(</span>i<span class="sym">))</span> then
          <span class="kwa">do</span> k<span class="sym">=</span>i<span class="sym">+</span>i<span class="sym">,</span> m<span class="sym">,</span> i
             flags<span class="sym">(</span>k<span class="sym">) = .</span><span class="kwa">false</span><span class="sym">.
</span>          end <span class="kwa">do
</span>          count <span class="sym">=</span> count <span class="sym">+</span> <span class="num">1
</span>       end <span class="kwa">if
</span>    end <span class="kwa">do

</span>    nsi <span class="sym">=</span> count
  end function nsi

end program nsieve



