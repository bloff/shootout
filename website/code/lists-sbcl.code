<table width="100%" border="0" cellpadding="5" cellspacing="0"><tr><td bgcolor="#FFFFFF"><pre>
<I><FONT COLOR="#B22222">;;; -*- mode: lisp -*-
</FONT></I><I><FONT COLOR="#B22222">;;; $Id: lists-sbcl.code,v 1.2 2004-11-08 08:15:15 bfulgham Exp $
</FONT></I><I><FONT COLOR="#B22222">;;; http://shootout.alioth.debian.org/
</FONT></I><I><FONT COLOR="#B22222">;;; from Paul Foley
</FONT></I><I><FONT COLOR="#B22222">;;; Multi-lisp changes by Brent Fulgham
</FONT></I>
(defparameter *SIZE* 10000)

(declaim (fixnum *SIZE*) (inline xcons push-queue))

(defvar *free-conses*)

(defun xcons (A B)
  (<B><FONT COLOR="#A020F0">let</FONT></B> ((x *free-conses*))
    (<B><FONT COLOR="#A020F0">if</FONT></B> x (progn (setf *free-conses* (cdr x) (car x) A (cdr x) B) x) (cons A B))))

(defmacro xpop (X)
  `(prog1 (car ,x) (psetf ,x (cdr ,x) (cdr ,x) *free-conses* *free-conses* ,x)))

(defun push-queue (item queue &amp;aux (new (xcons item nil)))
  (<B><FONT COLOR="#A020F0">if</FONT></B> (cdr queue) (setf (cddr queue) new) (setf (car queue) new))
  (setf (cdr queue) new)
  (car queue))

(defmacro with-collector ((name) &amp;body body)
  (<B><FONT COLOR="#A020F0">let</FONT></B> ((collector (gensym)))
    `(<B><FONT COLOR="#A020F0">let</FONT></B> ((,collector (xcons nil nil)))
       (flet ((,name (value) (push-queue value ,collector)))
         ,@body
         (car ,collector)))))

(defun test-list ()
  (<B><FONT COLOR="#A020F0">let*</FONT></B> ((L1 (with-collector (conc) (loop for x fixnum from 1 to *SIZE* <B><FONT COLOR="#A020F0">do</FONT></B> (conc x))))
         (L2 (with-collector (conc) (loop for x in L1 <B><FONT COLOR="#A020F0">do</FONT></B> (conc x))))
         (L3 nil))
    <I><FONT COLOR="#B22222">;; Move items from left of L2 to right of L3 (preserve order)
</FONT></I>    (setf L3 (with-collector (conc) (loop while L2 <B><FONT COLOR="#A020F0">do</FONT></B> (conc (xpop L2)))))
    <I><FONT COLOR="#B22222">;; Move from tail of L3 to tail of L2 (reversing list)
</FONT></I>    <I><FONT COLOR="#B22222">;; start by reversing L3 so we can pop from the front
</FONT></I>    (setf L3 (nreverse L3))
    (setf L2 (with-collector (conc) (loop while L3 <B><FONT COLOR="#A020F0">do</FONT></B> (conc (xpop L3)))))
    <I><FONT COLOR="#B22222">;; Reverse L1 in place
</FONT></I>    (setf L1 (nreverse L1))
    <I><FONT COLOR="#B22222">;; Check that (first L1) == *SIZE*
</FONT></I>    (assert (= (the fixnum (first L1)) *SIZE*))
    <I><FONT COLOR="#B22222">;; Compare L1 and L2 for equality
</FONT></I>    (assert (equal L1 L2))
    <I><FONT COLOR="#B22222">;; Return the length -- and return the conses to the free list
</FONT></I>    (prog1 (length (the list L1))
      (setf *free-conses* (nconc *free-conses* L3 L2 L1)))))

(defun main ()
  (<B><FONT COLOR="#A020F0">let</FONT></B> ((n (parse-integer (<B><FONT COLOR="#A020F0">or</FONT></B> (car (last #+sbcl sb-ext:*posix-argv*
                                         #+cmu  ext:*command-line-strings*)) <B><FONT COLOR="#BC8F8F">&quot;1&quot;</FONT></B>)))
        (num 0) (*free-conses* nil))
    (loop repeat n <B><FONT COLOR="#A020F0">do</FONT></B> (setf num (test-list)))
  (format t <B><FONT COLOR="#BC8F8F">&quot;~D~%&quot;</FONT></B> num)))</pre></td></tr></table>
