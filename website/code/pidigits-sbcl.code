<span class="slc">;;    The Great Computer Language Shootout</span>
<span class="slc">;;    http://shootout.alioth.debian.org/</span>

<span class="slc">;;    contributed by Christopher Neufeld  &lt;shootout0000&#64;cneufeld.ca&gt;</span>

<span class="slc">;;; A streaming pidigits implementation in ANSI Lisp for the debian</span>
<span class="slc">;;; shootout.  Aimed at sbcl, but tested on clisp and gcl as well.</span>


<span class="sym">(</span>defparameter <span class="sym">*</span>digits<span class="sym">-</span>per<span class="sym">-</span><span class="kwa">line</span><span class="sym">*</span> <span class="num">10</span><span class="sym">)</span>
<span class="sym">(</span>defparameter <span class="sym">*</span>stop<span class="sym">-</span>digits<span class="sym">*</span> <span class="num">300</span><span class="sym">)</span>


<span class="sym">(</span><span class="kwa">defun</span> compute<span class="sym">-</span>pi <span class="sym">(</span>next safe prod consume z next<span class="sym">-</span>state<span class="sym">)</span>
  <span class="sym">(</span>do <span class="sym">((</span>digits<span class="sym">-</span>out <span class="num">0</span><span class="sym">))</span>
      <span class="sym">((&gt;=</span> digits<span class="sym">-</span>out <span class="sym">*</span>stop<span class="sym">-</span>digits<span class="sym">*))</span>

    <span class="sym">(</span>let <span class="sym">((</span>y <span class="sym">(</span>funcall next z<span class="sym">)))</span>
      <span class="sym">(</span><span class="kwa">if</span> <span class="sym">(</span>funcall safe z y<span class="sym">)</span>
          <span class="sym">(</span><span class="kwa">progn</span>
            <span class="sym">(</span>format t <span class="str">&quot;~D&quot;</span> y<span class="sym">)</span>
            <span class="sym">(</span>incf digits<span class="sym">-</span>out<span class="sym">)</span>
            <span class="sym">(</span><span class="kwa">if</span> <span class="sym">(</span><span class="kwa">zerop</span> <span class="sym">(</span>mod digits<span class="sym">-</span>out <span class="sym">*</span>digits<span class="sym">-</span>per<span class="sym">-</span><span class="kwa">line</span><span class="sym">*))</span>
                <span class="sym">(</span>format t <span class="str">&quot;	 :~D~%&quot;</span> digits<span class="sym">-</span>out<span class="sym">))</span>
            <span class="sym">(</span>setf z <span class="sym">(</span>funcall prod z y<span class="sym">)))</span>
          <span class="sym">(</span>let <span class="sym">((</span>state <span class="sym">(</span>funcall next<span class="sym">-</span>state<span class="sym">)))</span>
            <span class="sym">(</span>setf z <span class="sym">(</span>funcall consume z state<span class="sym">)))))))</span>



<span class="sym">(</span><span class="kwa">defun</span> comp <span class="sym">(</span>a1 a2<span class="sym">)</span>
  <span class="sym">(</span>let <span class="sym">((</span>retval <span class="sym">(</span>make<span class="sym">-</span>array <span class="num">4</span><span class="sym">)))</span>
    <span class="sym">(</span>setf <span class="sym">(</span>aref retval <span class="num">0</span><span class="sym">) (+ (* (</span>aref a1 <span class="num">0</span><span class="sym">) (</span>aref a2 <span class="num">0</span><span class="sym">))</span>
                             <span class="sym">(* (</span>aref a1 <span class="num">1</span><span class="sym">) (</span>aref a2 <span class="num">2</span><span class="sym">))))</span>
    <span class="sym">(</span>setf <span class="sym">(</span>aref retval <span class="num">1</span><span class="sym">) (+ (* (</span>aref a1 <span class="num">0</span><span class="sym">) (</span>aref a2 <span class="num">1</span><span class="sym">))</span>
                             <span class="sym">(* (</span>aref a1 <span class="num">1</span><span class="sym">) (</span>aref a2 <span class="num">3</span><span class="sym">))))</span>
    <span class="sym">(</span>setf <span class="sym">(</span>aref retval <span class="num">2</span><span class="sym">) (+ (* (</span>aref a1 <span class="num">2</span><span class="sym">) (</span>aref a2 <span class="num">0</span><span class="sym">))</span>
                             <span class="sym">(* (</span>aref a1 <span class="num">3</span><span class="sym">) (</span>aref a2 <span class="num">2</span><span class="sym">))))</span>
    <span class="sym">(</span>setf <span class="sym">(</span>aref retval <span class="num">3</span><span class="sym">) (+ (* (</span>aref a1 <span class="num">2</span><span class="sym">) (</span>aref a2 <span class="num">1</span><span class="sym">))</span>
                             <span class="sym">(* (</span>aref a1 <span class="num">3</span><span class="sym">) (</span>aref a2 <span class="num">3</span><span class="sym">))))</span>
    retval<span class="sym">))</span>

<span class="sym">(</span><span class="kwa">defun</span> extr <span class="sym">(</span>state x<span class="sym">)</span>
  <span class="sym">(</span>declare <span class="sym">(</span><span class="kwa">type</span> <span class="sym">(</span>array integer <span class="num">1</span><span class="sym">)</span> state<span class="sym">))</span>
  <span class="sym">(</span>declare <span class="sym">(</span><span class="kwa">type</span> integer x<span class="sym">))</span>
  <span class="sym">(</span>declare <span class="sym">(</span>optimize <span class="sym">(</span>speed <span class="num">3</span><span class="sym">) (</span>safety <span class="num">0</span><span class="sym">) (</span>space <span class="num">0</span><span class="sym">)))</span>
  <span class="sym">(/ (+ (* (</span>aref state <span class="num">0</span><span class="sym">)</span> x<span class="sym">) (</span>aref state <span class="num">1</span><span class="sym">))</span>
     <span class="sym">(+ (* (</span>aref state <span class="num">2</span><span class="sym">)</span> x<span class="sym">) (</span>aref state <span class="num">3</span><span class="sym">))))</span>

<span class="sym">(</span>defparameter init <span class="sym">(</span>make<span class="sym">-</span>array <span class="num">4</span> <span class="sym">:</span>element<span class="sym">-</span><span class="kwa">type</span> <span class="str">'integer :initial-contents #(1 0 0 1)))</span>
<span class="str">(defparameter *curstate* (make-array 4 :element-type '</span>integer <span class="sym">:</span>initial<span class="sym">-</span>contents #<span class="sym">(</span><span class="num">0 2 0 1</span><span class="sym">)))</span>


<span class="sym">(</span><span class="kwa">defun</span> next<span class="sym">-</span>state <span class="sym">()</span>
  <span class="sym">(</span>incf <span class="sym">(</span>aref <span class="sym">*</span>curstate<span class="sym">*</span> <span class="num">0</span><span class="sym">))</span>
  <span class="sym">(</span>incf <span class="sym">(</span>aref <span class="sym">*</span>curstate<span class="sym">*</span> <span class="num">1</span><span class="sym">)</span> <span class="num">4</span><span class="sym">)</span>
  <span class="sym">(</span>incf <span class="sym">(</span>aref <span class="sym">*</span>curstate<span class="sym">*</span> <span class="num">3</span><span class="sym">)</span> <span class="num">2</span><span class="sym">)</span>
  <span class="sym">*</span>curstate<span class="sym">*)</span>

<span class="sym">(</span><span class="kwa">defun</span> safe <span class="sym">(</span>z n<span class="sym">)</span>
  <span class="sym">(=</span> n <span class="sym">(</span>floor <span class="sym">(</span>extr z <span class="num">4</span><span class="sym">))))</span>

<span class="sym">(</span><span class="kwa">defun</span> next <span class="sym">(</span>z<span class="sym">)</span>
  <span class="sym">(</span>floor <span class="sym">(</span>extr z <span class="num">3</span><span class="sym">)))</span>

<span class="sym">(</span><span class="kwa">defun</span> prod <span class="sym">(</span>z n<span class="sym">)</span>
  <span class="sym">(</span>let <span class="sym">((</span>v1 <span class="sym">(</span>make<span class="sym">-</span>array <span class="num">4</span><span class="sym">)))</span>
    <span class="sym">(</span>setf <span class="sym">(</span>aref v1 <span class="num">0</span><span class="sym">)</span> <span class="num">10</span><span class="sym">)</span>
    <span class="sym">(</span>setf <span class="sym">(</span>aref v1 <span class="num">1</span><span class="sym">) (*</span> n <span class="sym">-</span><span class="num">10</span><span class="sym">))</span>
    <span class="sym">(</span>setf <span class="sym">(</span>aref v1 <span class="num">2</span><span class="sym">)</span> <span class="num">0</span><span class="sym">)</span>
    <span class="sym">(</span>setf <span class="sym">(</span>aref v1 <span class="num">3</span><span class="sym">)</span> <span class="num">1</span><span class="sym">)</span>
    <span class="sym">(</span>comp v1 z<span class="sym">)))</span>

<span class="sym">(</span><span class="kwa">defun</span> consume <span class="sym">(</span>z z<span class="sym">-</span>prime<span class="sym">)</span>
  <span class="sym">(</span>comp z z<span class="sym">-</span>prime<span class="sym">))</span>


<span class="sym">(</span><span class="kwa">defun</span> main <span class="sym">()</span>
  <span class="sym">(</span>let <span class="sym">((</span>n <span class="sym">(</span>parse<span class="sym">-</span>integer <span class="sym">(</span><span class="kwa">or</span> <span class="sym">(</span><span class="kwa">car</span> <span class="sym">(</span><span class="kwa">last</span> #<span class="sym">+</span>sbcl sb<span class="sym">-</span>ext<span class="sym">:*</span>posix<span class="sym">-</span>argv<span class="sym">*</span>
                                         #<span class="sym">+</span>clisp ext<span class="sym">:*</span>args<span class="sym">*</span>
					 #<span class="sym">+</span>cmu extensions<span class="sym">:*</span><span class="kwa">command</span><span class="sym">-</span><span class="kwa">line</span><span class="sym">-</span>strings<span class="sym">*</span>
					 #<span class="sym">+</span>gcl  si<span class="sym">::*</span><span class="kwa">command</span><span class="sym">-</span>args<span class="sym">*))</span> <span class="str">&quot;300&quot;</span><span class="sym">))))</span>

    <span class="sym">(</span><span class="kwa">if</span> n
        <span class="sym">(</span>setf <span class="sym">*</span>stop<span class="sym">-</span>digits<span class="sym">*</span> n<span class="sym">)))</span>
  <span class="sym">(</span>compute<span class="sym">-</span>pi #<span class="str">'next #'</span>safe #<span class="str">'prod #'</span>consume init #<span class="str">'next-state))</span>
<span class="str"></span>
<span class="str"></span>
<span class="str">;; #+sbcl (progn</span>
<span class="str">;;          (sb-profile:profile compute-pi)</span>
<span class="str">;;          (sb-profile:profile comp)</span>
<span class="str">;;          (sb-profile:profile extr)</span>
<span class="str">;;          (sb-profile:profile next-state)</span>
<span class="str">;;          (sb-profile:profile safe)</span>
<span class="str">;;          (sb-profile:profile next)</span>
<span class="str">;;          (sb-profile:profile prod)</span>
<span class="str">;;          (sb-profile:profile consume))</span>
<span class="str"></span>
<span class="str">;; Here'</span>s the profiling run for sbcl from a recent <span class="sym">(</span>post<span class="sym">-</span><span class="num">0.9.3</span><span class="sym">)</span> CVS
<span class="slc">;; checkout.  The results show that we're basically using all our time</span>
<span class="slc">;; in the bignum arithmetic in &quot;extr&quot;.  I can't optimize this program</span>
<span class="slc">;; any further, further improvements have to come from the SBCL</span>
<span class="slc">;; implementation of bignums.</span>

<span class="slc">;; measuring PROFILE overhead..done</span>

<span class="slc">;;   seconds  |   consed   | calls |  sec/call  |  name</span>
<span class="slc">;; --------------------------------------------------------</span>
<span class="slc">;;      5.235 | 36,546,776 | 2,580 |   0.002029 | EXTR</span>
<span class="slc">;;      0.068 |  6,957,232 | 1,290 |   0.000053 | COMP</span>
<span class="slc">;;      0.063 |  2,084,384 | 1,290 |   0.000049 | NEXT</span>
<span class="slc">;;      0.035 |    701,960 |     1 |   0.035188 | COMPUTE-PI</span>
<span class="slc">;;      0.030 |  2,246,800 | 1,290 |   0.000023 | SAFE</span>
<span class="slc">;;      0.007 |          0 |   990 |   0.000007 | NEXT-STATE</span>
<span class="slc">;;      0.001 |          0 |   300 |   0.000004 | PROD</span>
<span class="slc">;;      0.001 |     35,360 |   990 |   0.000001 | CONSUME</span>
<span class="slc">;; --------------------------------------------------------</span>
<span class="slc">;;      5.440 | 48,572,512 | 8,731 |            | Total</span>

<span class="slc">;; estimated total profiling overhead: 0.02 seconds</span>
<span class="slc">;; overhead estimation parameters:</span>
<span class="slc">;;   2.8e-8s/call, 2.35e-6s total profiling, 7.68e-7s internal profiling</span>


<span class="slc">;; For compiled code on my home machine:</span>
<span class="slc">;; - sbcl runs 300 digits in 5.4 seconds of user time</span>
<span class="slc">;; - clisp runs 300 digits in 1.6 seconds of user time</span>
<span class="slc">;; - gcl runs 300 digits in 19.2 seconds of user time</span>
<span class="slc">;;</span>
<span class="slc">;; So, it looks to me like sbcl and gcl could learn a thing or two</span>
<span class="slc">;; from clisp's bignum implementation</span>
