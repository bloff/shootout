<span class="slc">! -*- mode: f90 -*-
</span><span class="slc">!
</span><span class="slc">! $Id: fannkuch-ifc.code,v 1.5 2005-06-08 07:55:42 bfulgham Exp $ ; $Name:  $
</span><span class="slc">!
</span><span class="slc">! Fannkuch access function implementation
</span><span class="slc">! Simon Geard, 1/12/04
</span><span class="slc">!
</span><span class="slc">! Building info.
</span><span class="slc">! ==============
</span><span class="slc">!
</span><span class="slc">! Linux  - using the Intel Fortran90 compiler:
</span><span class="slc">!
</span><span class="slc">!          ifort fannkuch.f90 -O3 -static-libcxa -o fannkuch
</span><span class="slc">!
</span>
program fannkuch
  implicit none
  integer count<span class="sym">,</span> i<span class="sym">,</span> num
  character<span class="sym">(</span>len<span class="sym">=</span><span class="num">8</span><span class="sym">)</span> argv
  integer<span class="sym">,</span> dimension<span class="sym">(:),</span> allocatable <span class="sym">::</span> data
  intrinsic max

  call getarg<span class="sym">(</span><span class="num">1</span><span class="sym">,</span>argv<span class="sym">)
</span>  read<span class="sym">(</span>argv<span class="sym">,*)</span> num
  allocate<span class="sym">(</span>data<span class="sym">(</span>num<span class="sym">))

</span>  count <span class="sym">=</span> <span class="num">0
</span>  data <span class="sym">= (/ (</span>i<span class="sym">,</span>i<span class="sym">=</span><span class="num">1</span><span class="sym">,</span>num<span class="sym">) /)</span> <span class="slc">! Must start with the smallest number
</span>  do i<span class="sym">=</span><span class="num">1</span><span class="sym">,</span>factorial<span class="sym">(</span>num<span class="sym">)
</span>     count <span class="sym">=</span> max<span class="sym">(</span>count<span class="sym">,</span>countFlips<span class="sym">(</span>data<span class="sym">))
</span>     call getNextPerm<span class="sym">(</span>data<span class="sym">)
</span>  end do

  deallocate<span class="sym">(</span>data<span class="sym">)

</span>  write<span class="sym">(*,</span><span class="str">'(2(a,i0))'</span><span class="sym">)</span> <span class="str">'Pfannkuchen('</span><span class="sym">,</span>num<span class="sym">,</span><span class="str">') = '</span><span class="sym">,</span>count

contains

  recursive integer function factorial<span class="sym">(</span>n<span class="sym">)</span> result<span class="sym">(</span>if<span class="sym">)
</span>    integer<span class="sym">,</span> intent<span class="sym">(</span>in<span class="sym">) ::</span> n
    if <span class="sym">(</span>n <span class="sym">==</span> <span class="num">1</span><span class="sym">)</span> then
       if <span class="sym">=</span> <span class="num">1
</span>    else
       if <span class="sym">=</span> n<span class="sym">*</span>factorial<span class="sym">(</span>n<span class="num">-1</span><span class="sym">)
</span>    end if
  end function factorial

  <span class="slc">! Reverse an array
</span>  subroutine reverse<span class="sym">(</span>data<span class="sym">)
</span>    integer<span class="sym">,</span> dimension<span class="sym">(:),</span> intent<span class="sym">(</span>inout<span class="sym">) ::</span> data
    integer<span class="sym">,</span> dimension<span class="sym">(</span>size<span class="sym">(</span>data<span class="sym">)) ::</span> work
    integer i
   <span class="slc">! print *,'reversing ',data
</span>    forall <span class="sym">(</span>i<span class="sym">=</span><span class="num">1</span><span class="sym">:</span>size<span class="sym">(</span>data<span class="sym">))
</span>       work<span class="sym">(</span>i<span class="sym">) =</span> data<span class="sym">(</span>size<span class="sym">(</span>data<span class="sym">)-</span>i<span class="sym">+</span><span class="num">1</span><span class="sym">)
</span>    end forall
    data <span class="sym">=</span> work
  end subroutine reverse

  <span class="slc">! Count the number of flips in a permutation
</span>  integer function countFlips<span class="sym">(</span>data<span class="sym">)
</span>    integer<span class="sym">,</span> dimension<span class="sym">(:),</span> intent<span class="sym">(</span>in<span class="sym">) ::</span> data
    integer<span class="sym">,</span> dimension<span class="sym">(</span>size<span class="sym">(</span>data<span class="sym">)) ::</span> work
    work <span class="sym">=</span> data
    countFlips <span class="sym">=</span> <span class="num">0
</span>    do
       if <span class="sym">(</span>work<span class="sym">(</span><span class="num">1</span><span class="sym">) &lt;=</span> <span class="num">1</span><span class="sym">)</span> exit
       call reverse<span class="sym">(</span>work<span class="sym">(</span><span class="num">1</span><span class="sym">:</span>work<span class="sym">(</span><span class="num">1</span><span class="sym">)))
</span>       countFlips <span class="sym">=</span> countFlips <span class="sym">+</span> <span class="num">1
</span>    end do
  end function countFlips

  <span class="slc">! Get next permutation
</span>  subroutine getNextPerm<span class="sym">(</span>data<span class="sym">)
</span>    integer<span class="sym">,</span> dimension<span class="sym">(:),</span> intent<span class="sym">(</span>inout<span class="sym">) ::</span> data
    integer <span class="sym">::</span> i<span class="sym">,</span> kx<span class="sym">,</span> e<span class="sym">,</span> ci<span class="sym">,</span> ce<span class="sym">,</span> tmp<span class="sym">,</span> N

    <span class="slc">! Find largest k s.t. data(k) &lt; data(k+1)
</span>    N <span class="sym">=</span> size<span class="sym">(</span>data<span class="sym">)
</span>    kx <span class="sym">=</span> <span class="num">0
</span>    do i<span class="sym">=</span><span class="num">1</span><span class="sym">,</span>N<span class="num">-1
</span>       if <span class="sym">(</span>data<span class="sym">(</span>i<span class="sym">) &lt;</span> data<span class="sym">(</span>i<span class="sym">+</span><span class="num">1</span><span class="sym">))</span> then
          kx <span class="sym">=</span> i
       end if
    end do

    <span class="slc">! Find smallest data(k+j) &gt; data(k)
</span>    e <span class="sym">=</span> data<span class="sym">(</span>kx<span class="sym">)
</span>    ci <span class="sym">=</span> kx
    do i<span class="sym">=</span>kx<span class="sym">+</span><span class="num">1</span><span class="sym">,</span>N
       if <span class="sym">(</span>data<span class="sym">(</span>i<span class="sym">) &gt;</span> e .and. <span class="sym">(</span>ci <span class="sym">==</span> kx .or. data<span class="sym">(</span>i<span class="sym">) &lt;</span> ce<span class="sym">))</span> then
          ci <span class="sym">=</span> i
          ce <span class="sym">=</span> data<span class="sym">(</span>i<span class="sym">)
</span>       end if
    end do

    <span class="slc">! Swap data(k) and data(k+j)
</span>    tmp <span class="sym">=</span> data<span class="sym">(</span>kx<span class="sym">)
</span>    data<span class="sym">(</span>kx<span class="sym">) =</span> data<span class="sym">(</span>ci<span class="sym">)
</span>    data<span class="sym">(</span>ci<span class="sym">) =</span> tmp

    <span class="slc">! Reverse data(k+1) ... data(N)
</span>    call reverse<span class="sym">(</span>data<span class="sym">(</span>kx<span class="sym">+</span><span class="num">1</span><span class="sym">:</span>N<span class="sym">))

</span>  end subroutine getNextPerm

end program fannkuch
