<span class="sym">!</span> Fannkuch access function implementation
 <span class="sym">!</span> Simon Geard<span class="sym">,</span> <span class="num">1</span><span class="sym">/</span><span class="num">12</span><span class="sym">/</span><span class="num">04
 </span><span class="sym">!
 !</span> Building info<span class="sym">.
 ! ==============
 !
 !</span> Linux  <span class="sym">-</span> <span class="kwa">using</span> the Intel Fortran90 compiler<span class="sym">:
 !
 !</span>          ifort fannkuch<span class="sym">.</span>f90 <span class="sym">-</span>O3 <span class="sym">-</span><span class="kwb">static</span><span class="sym">-</span>libcxa <span class="sym">-</span>o fannkuch
 <span class="sym">!
 !</span> WinXP  <span class="sym">-</span> Compaq Visual Fortran <span class="num">6.6c
 </span><span class="sym">!
 !</span>          f90 fannkuch<span class="sym">.</span>f90 <span class="sym">/</span>link <span class="sym">/</span>libpath<span class="sym">:</span><span class="str">&quot;d:</span><span class="esc">\P</span><span class="str">rogram Files</span><span class="esc">\M</span><span class="str">icrosoft Visual Studio</span><span class="esc">\d</span><span class="str">f98</span><span class="esc">\l</span><span class="str">ib&quot;</span>
 <span class="sym">!
 !</span> Cygwin <span class="sym">-</span> g95 compiler
 <span class="sym">!
 !</span>          g95 fannkuch<span class="sym">.</span>f90 <span class="sym">-</span>O3 <span class="sym">-</span>o fannkuch<span class="sym">.</span>exe
 <span class="sym">!
 !!</span>$<span class="str">&quot;Take a permutation of {1,...,n}, for example: {4,2,1,5,3}. Take the first element, here 4, and reverse the order of the first 4 elements: {5,1,2,4,3}. Repeat this until the first element is a 1, so flipping won't change anything more: {3,4,2,1,5}, {2,4,3,1,5}, {4,2,3,1,5}, {1,3,2,4,5}. Count the number of flips, here 5. Do this for all n! permutations, and record the maximum number of flips needed for any permutation. The conjecture is that this maximum count is approximated by n*log(n) when n goes to infinity.
 !!$
 !!$FANNKUCH is an abbreviation for the German word Pfannkuchen, or pancakes, in analogy to flipping pancakes.&quot;</span>
 <span class="sym">!!</span>$
 <span class="sym">!!</span>$Correct output N <span class="sym">=</span> <span class="num">7</span> is<span class="sym">:
 !!</span>$
 <span class="sym">!!</span>$Pfannkuchen<span class="sym">(</span><span class="num">7</span><span class="sym">) =</span> <span class="num">16
 </span><span class="sym">!!</span>$
 <span class="sym">!!</span>$
 <span class="sym">!!</span>$Correct output N <span class="sym">=</span> <span class="num">8</span> is<span class="sym">:
 !!</span>$
 <span class="sym">!!</span>$Pfannkuchen<span class="sym">(</span><span class="num">8</span><span class="sym">) =</span> <span class="num">22
 </span><span class="sym">!!</span>$
 <span class="sym">!!</span>$
 <span class="sym">!!</span>$Correct output N <span class="sym">=</span> <span class="num">9</span> is<span class="sym">:
 !!</span>$
 <span class="sym">!!</span>$Pfannkuchen<span class="sym">(</span><span class="num">9</span><span class="sym">) =</span> <span class="num">30
 </span><span class="sym">!!</span>$
 <span class="sym">!!</span>$
 <span class="sym">!!</span>$Correct output N <span class="sym">=</span> <span class="num">10</span> is<span class="sym">:
 !!</span>$
 <span class="sym">!!</span>$Pfannkuchen<span class="sym">(</span><span class="num">10</span><span class="sym">) =</span> <span class="num">38
 
 </span>program fannkuch
   implicit none
   integer count<span class="sym">,</span> i<span class="sym">,</span> num
   character<span class="sym">(</span>len<span class="sym">=</span><span class="num">8</span><span class="sym">)</span> argv
   integer<span class="sym">,</span> dimension<span class="sym">(:),</span> allocatable <span class="sym">::</span> data
   intrinsic max

    call getarg<span class="sym">(</span><span class="num">1</span><span class="sym">,</span>argv<span class="sym">)
 </span>  read<span class="sym">(</span>argv<span class="sym">,*)</span> num
   allocate<span class="sym">(</span>data<span class="sym">(</span>num<span class="sym">))
 
 </span>  count <span class="sym">=</span> <span class="num">0
 </span>  data <span class="sym">= (/ (</span>i<span class="sym">,</span>i<span class="sym">=</span><span class="num">1</span><span class="sym">,</span>num<span class="sym">) /) !</span> Must start with the smallest number
   <span class="kwa">do</span> i<span class="sym">=</span><span class="num">1</span><span class="sym">,</span>factorial<span class="sym">(</span>num<span class="sym">)
 </span>     count <span class="sym">=</span> max<span class="sym">(</span>count<span class="sym">,</span>countFlips<span class="sym">(</span>data<span class="sym">))
 </span>     call getNextPerm<span class="sym">(</span>data<span class="sym">)
 </span>  end <span class="kwa">do
 
   </span>  deallocate<span class="sym">(</span>data<span class="sym">)
 
   </span>  write<span class="sym">(*,</span><span class="str">'(2(a,i0))'</span><span class="sym">)</span> <span class="str">'Pfannkuchen('</span><span class="sym">,</span>num<span class="sym">,</span><span class="str">') = '</span><span class="sym">,</span>count

  contains

    recursive integer function factorial<span class="sym">(</span>n<span class="sym">)</span> result<span class="sym">(</span><span class="kwa">if</span><span class="sym">)
 </span>    integer<span class="sym">,</span> intent<span class="sym">(</span>in<span class="sym">) ::</span> n
     <span class="kwa">if</span> <span class="sym">(</span>n <span class="sym">==</span> <span class="num">1</span><span class="sym">)</span> then
        <span class="kwa">if</span> <span class="sym">=</span> <span class="num">1
 </span>    <span class="kwa">else
        if</span> <span class="sym">=</span> n<span class="sym">*</span>factorial<span class="sym">(</span>n<span class="num">-1</span><span class="sym">)
 </span>    end <span class="kwa">if
 </span>  end function factorial

    <span class="sym">!</span> Reverse an array
   subroutine reverse<span class="sym">(</span>data<span class="sym">)
 </span>    integer<span class="sym">,</span> dimension<span class="sym">(:),</span> intent<span class="sym">(</span>inout<span class="sym">) ::</span> data
     integer<span class="sym">,</span> dimension<span class="sym">(</span>size<span class="sym">(</span>data<span class="sym">)) ::</span> work
     integer i
    <span class="sym">!</span> print <span class="sym">*,</span><span class="str">'reversing '</span><span class="sym">,</span>data
     forall <span class="sym">(</span>i<span class="sym">=</span><span class="num">1</span><span class="sym">:</span>size<span class="sym">(</span>data<span class="sym">))
 </span>       work<span class="sym">(</span>i<span class="sym">) =</span> data<span class="sym">(</span>size<span class="sym">(</span>data<span class="sym">)-</span>i<span class="sym">+</span><span class="num">1</span><span class="sym">)
 </span>    end forall
     data <span class="sym">=</span> work
   end subroutine reverse

    <span class="sym">!</span> Count the number of flips in a permutation
   integer function countFlips<span class="sym">(</span>data<span class="sym">)
 </span>    integer<span class="sym">,</span> dimension<span class="sym">(:),</span> intent<span class="sym">(</span>in<span class="sym">) ::</span> data
     integer<span class="sym">,</span> dimension<span class="sym">(</span>size<span class="sym">(</span>data<span class="sym">)) ::</span> work
     work <span class="sym">=</span> data
     countFlips <span class="sym">=</span> <span class="num">0
 </span>    <span class="kwa">do
        if</span> <span class="sym">(</span>work<span class="sym">(</span><span class="num">1</span><span class="sym">) &lt;=</span> <span class="num">1</span><span class="sym">)</span> exit
        call reverse<span class="sym">(</span>work<span class="sym">(</span><span class="num">1</span><span class="sym">:</span>work<span class="sym">(</span><span class="num">1</span><span class="sym">)))
 </span>       countFlips <span class="sym">=</span> countFlips <span class="sym">+</span> <span class="num">1
 </span>    end <span class="kwa">do
 </span>  end function countFlips

    <span class="sym">!</span> Get next permutation
   subroutine getNextPerm<span class="sym">(</span>data<span class="sym">)
 </span>    integer<span class="sym">,</span> dimension<span class="sym">(:),</span> intent<span class="sym">(</span>inout<span class="sym">) ::</span> data
     integer <span class="sym">::</span> i<span class="sym">,</span> kx<span class="sym">,</span> e<span class="sym">,</span> ci<span class="sym">,</span> ce<span class="sym">,</span> tmp<span class="sym">,</span> N

      <span class="sym">!</span> Find largest k s<span class="sym">.</span>t<span class="sym">.</span> data<span class="sym">(</span>k<span class="sym">) &lt;</span> data<span class="sym">(</span>k<span class="sym">+</span><span class="num">1</span><span class="sym">)
 </span>    N <span class="sym">=</span> size<span class="sym">(</span>data<span class="sym">)
 </span>    kx <span class="sym">=</span> <span class="num">0
 </span>    <span class="kwa">do</span> i<span class="sym">=</span><span class="num">1</span><span class="sym">,</span>N<span class="num">-1
 </span>       <span class="kwa">if</span> <span class="sym">(</span>data<span class="sym">(</span>i<span class="sym">) &lt;</span> data<span class="sym">(</span>i<span class="sym">+</span><span class="num">1</span><span class="sym">))</span> then
           kx <span class="sym">=</span> i
        end <span class="kwa">if
 </span>    end <span class="kwa">do
 
 </span>    <span class="sym">!</span> Find smallest data<span class="sym">(</span>k<span class="sym">+</span>j<span class="sym">) &gt;</span> data<span class="sym">(</span>k<span class="sym">)
 </span>    e <span class="sym">=</span> data<span class="sym">(</span>kx<span class="sym">)
 </span>    ci <span class="sym">=</span> kx
     <span class="kwa">do</span> i<span class="sym">=</span>kx<span class="sym">+</span><span class="num">1</span><span class="sym">,</span>N
        <span class="kwa">if</span> <span class="sym">(</span>data<span class="sym">(</span>i<span class="sym">) &gt;</span> e <span class="sym">.</span><span class="kwa">and</span><span class="sym">. (</span>ci <span class="sym">==</span> kx <span class="sym">.</span><span class="kwa">or</span><span class="sym">.</span> data<span class="sym">(</span>i<span class="sym">) &lt;</span> ce<span class="sym">))</span> then
           ci <span class="sym">=</span> i
           ce <span class="sym">=</span> data<span class="sym">(</span>i<span class="sym">)
 </span>       end <span class="kwa">if
 </span>    end <span class="kwa">do
 
 </span>    <span class="sym">!</span> Swap data<span class="sym">(</span>k<span class="sym">)</span> <span class="kwa">and</span> data<span class="sym">(</span>k<span class="sym">+</span>j<span class="sym">)
 </span>    tmp <span class="sym">=</span> data<span class="sym">(</span>kx<span class="sym">)
 </span>    data<span class="sym">(</span>kx<span class="sym">) =</span> data<span class="sym">(</span>ci<span class="sym">)
 </span>    data<span class="sym">(</span>ci<span class="sym">) =</span> tmp

      <span class="sym">!</span> Reverse data<span class="sym">(</span>k<span class="sym">+</span><span class="num">1</span><span class="sym">) ...</span> data<span class="sym">(</span>N<span class="sym">)
 </span>    call reverse<span class="sym">(</span>data<span class="sym">(</span>kx<span class="sym">+</span><span class="num">1</span><span class="sym">:</span>N<span class="sym">))
 
     </span>  end subroutine getNextPerm

  end program fannkuch 
