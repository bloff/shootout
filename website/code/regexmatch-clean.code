<table width="100%" border="0" cellpadding="5" cellspacing="0"><tr><td bgcolor="#FFFFFF"><pre>
<B><FONT COLOR="#A020F0">module</FONT></B> regexmatch

<B><FONT COLOR="#A020F0">import</FONT></B> StdEnv,ArgEnv
argi = <B><FONT COLOR="#A020F0">if</FONT></B> (size cl == 2) (toInt (cl.[1])) 1
<B><FONT COLOR="#A020F0">where</FONT></B>
	cl = getCommandLine

Start world
	# (console, world)	= stdio world
	# (phones,console)	= readInput [] console
	# tb			= 0
	# (errptr,tb)		= malloc 1024 tb
	# (errhdl,tb)		= malloc 4 tb
	# tb			= store errhdl errptr tb
	# (erroffset,tb)	= malloc 4 tb
	# tb			= store erroffset 0 tb
//	# (re,tb)		= pcre_compile pattern 0 errhdl erroffset NULL tb
	# (re,tb)		= pcre_compile pattern` 0 errhdl erroffset NULL tb
	| re == 0		= abort <B><FONT COLOR="#BC8F8F">&quot;pcre_compile failed\n&quot;</FONT></B>
	# (study,tb)		= pcre_study re 0 errhdl tb
	# (errres,tb)		= load errhdl tb
	| study == 0 &amp;&amp; errres &lt;&gt; 0
		= abort <B><FONT COLOR="#BC8F8F">&quot;pcre_study failed\n&quot;</FONT></B>
	# (nmptr,tb)		= malloc 4 tb
	# tb			= store nmptr 0 tb
	# (cnt,tb)		= pcre_fullinfo re NULL PCRE_INFO_CAPTURECOUNT nmptr tb
	| cnt &lt;&gt; 0		= abort <B><FONT COLOR="#BC8F8F">&quot;pcre_fullinfo failed\n&quot;</FONT></B>
	# (nm,tb)		= load nmptr tb
	# nm			= nm + 1
	# tb			= store nmptr nm tb
	# ovecsize		= 4 * nm * 3
	# (ovec,tb)		= malloc ovecsize tb
	
	
	# (out,tb)		= oloop argi console phones nm ovec ovecsize re study tb
	# (ok,world)		= fclose out world
	= world

oloop cnt out phones nm ovec ovecsize re study tb
	# count		= 1
//	# num		= createArray 256 <B><FONT COLOR="#BC8F8F">'@'</FONT></B>
	# num		= <B><FONT COLOR="#BC8F8F">&quot;(@@@) @@@-@@@@&quot;</FONT></B>
	# nb		= nm*2*4
	# ovecs` 	= createArray nb 0
	# (count,num,ovecs`,out,tb) = seq [iloop (n==cnt) ovec ovecsize nm nb re study phones \\ n &lt;- [1..cnt]] (count,num,ovecs`,out,tb)
	= (out,tb)

iloop <B><FONT COLOR="#228B22">:: !.Bool !.Int !.Int !.Int !.Int !.Int !.Int ![String] !*(!.Int,!*String,!{#Int},!*File,!*Toolbox) -&gt; (!Int,!*String,!{#Int},!*File,!*Toolbox)
</FONT></B>iloop print ovec ovecsize nm nb  re study [] (count,num,ovecs`,out,tb)
	= (count,num,ovecs`,out,tb)
iloop print ovec ovecsize nm nb re study [phones_i:phones] (count,num,ovecs`,out,tb)
	# (count,num,ovecs`,out,tb) = match print ovec ovecsize nm nb re study phones_i (count,num,ovecs`,out,tb)
	= iloop print ovec ovecsize nm nb re study phones (count,num,ovecs`,out,tb)

match <B><FONT COLOR="#228B22">:: !.Bool !.Int !.Int !.Int !.Int !.Int !.Int !String !*(!.Int,!*String,!{#Int},!*File,!*Toolbox) -&gt; (!Int,!*String,!{#Int},!*File,!*Toolbox)
</FONT></B>match print ovec ovecsize nm nb re study phones_i (count,num,ovecs`,out,tb)
	# (n,tb)	= pcre_exec re study phones_i (size phones_i) 0 0 ovec ovecsize tb
	| n &lt;&gt; nm
		= (count,num,ovecs`,out,tb)
	# (ovecs`,tb)	= LoadOvec ovecs` ovec nb tb
	# ss1		= ss phones_i ovecs` 1
	# ss2		= ss phones_i ovecs` 2
	# ss3		= ss phones_i ovecs` 3
	# ss4		= ss phones_i ovecs` 4
//	# ss5		= ss phones_i ovecs` 5
//	# ss6		= ss phones_i ovecs` 6
	# ss0		= ss phones_i ovecs` 0
//	# area		= <B><FONT COLOR="#A020F0">if</FONT></B> (size ss3 == 0) ss4 ss3
//	# exch		= ss5
//	# exts		= ss6
	# area		= ss2
	# exch		= ss3
	# exts		= ss4
//	# num		= <B><FONT COLOR="#BC8F8F">&quot;(&quot;</FONT></B>+++area+++<B><FONT COLOR="#BC8F8F">&quot;) &quot;</FONT></B>+++exch+++<B><FONT COLOR="#BC8F8F">&quot;-&quot;</FONT></B>+++exts
	# num		= ss` phones_i ovecs` 2 num 1
	# num		= ss` phones_i ovecs` 3 num 6
	# num		= ss` phones_i ovecs` 4 num 10
	| not print
		= (count,num,ovecs`,out,tb)
	#! out = out &lt;&lt;&lt; count &lt;&lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;: &quot;</FONT></B> &lt;&lt;&lt; num &lt;&lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>
	= (count+1,num,ovecs`,out,tb)

//
ss <B><FONT COLOR="#228B22">:: !String !{#Int} !.Int -&gt; String
</FONT></B>ss string ovecs i
	# j		= i * 2
	# b		= ovecs.[j]
	# e		= ovecs.[j+1]
	= string%(b,e-1)

ss` <B><FONT COLOR="#228B22">:: !String !{#Int} !.Int !*String !Int -&gt; *String
</FONT></B>ss` string ovecs i res k
	# j		= i * 2
	# b		= ovecs.[j]
	# e		= ovecs.[j+1]
	# res	= ssloop string k b e res
	= res
<B><FONT COLOR="#A020F0">where</FONT></B>
	ssloop <B><FONT COLOR="#228B22">:: !String !Int !Int !.Int !*{#Char} -&gt; *{#Char}
</FONT></B>	ssloop string x y s res
		| y &gt;= s
			= res
		= ssloop string (x+1) (y+1) s {res &amp; [x] = string.[y]}

LoadOvec <B><FONT COLOR="#228B22">:: !{#Int} !Int !Int !*Toolbox -&gt; (!{#Int},!*Toolbox)
</FONT></B>LoadOvec a ptr nb tb
	# tb	= mmove a ptr nb tb
	= (a,tb)
	
readInput acc input
	# (l,input)	= freadline input
	| size l == 0
		= (reverse acc,input)
	= readInput [l:acc] input

	
NULL				:== 0
PCRE_INFO_CAPTURECOUNT		:== 2
pattern = 
   <B><FONT COLOR="#BC8F8F">&quot;(^|[^0-9\\(]+)&quot;</FONT></B> +++				// $1
   <B><FONT COLOR="#BC8F8F">&quot;(&quot;</FONT></B> +++					// $2
   <B><FONT COLOR="#BC8F8F">&quot;\\(([0-9][0-9][0-9])\\)&quot;</FONT></B> +++		// $3
   <B><FONT COLOR="#BC8F8F">&quot;|&quot;</FONT></B> +++
   <B><FONT COLOR="#BC8F8F">&quot;([0-9][0-9][0-9])&quot;</FONT></B> +++			// $4
   <B><FONT COLOR="#BC8F8F">&quot;)&quot;</FONT></B> +++
   <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> +++
   <B><FONT COLOR="#BC8F8F">&quot;([0-9][0-9][0-9])&quot;</FONT></B> +++			// $5
   <B><FONT COLOR="#BC8F8F">&quot;[ -]&quot;</FONT></B>  +++
   <B><FONT COLOR="#BC8F8F">&quot;([0-9][0-9][0-9][0-9])&quot;</FONT></B> +++			// $6
   <B><FONT COLOR="#BC8F8F">&quot;[^0-9]&quot;</FONT></B> +++
   <B><FONT COLOR="#BC8F8F">&quot;\0&quot;</FONT></B>

pattern` = 
   <B><FONT COLOR="#BC8F8F">&quot;(?:^|[^\\d\\(])&quot;</FONT></B>	+++	/* must be preceeded by non-digit */
   <B><FONT COLOR="#BC8F8F">&quot;(\\()?&quot;</FONT></B>		+++	/* match 1: possible initial left paren */
   <B><FONT COLOR="#BC8F8F">&quot;(\\d\\d\\d)&quot;</FONT></B>	+++	/* match 2: area code is 3 digits */
   <B><FONT COLOR="#BC8F8F">&quot;(?(1)\\))&quot;</FONT></B>		+++	/* <B><FONT COLOR="#A020F0">if</FONT></B> match1 <B><FONT COLOR="#A020F0">then</FONT></B> match right paren */
   <B><FONT COLOR="#BC8F8F">&quot;[ ]&quot;</FONT></B>		+++	/* area code followed by one space */
   <B><FONT COLOR="#BC8F8F">&quot;(\\d\\d\\d)&quot;</FONT></B>	+++	/* match 3: prefix <B><FONT COLOR="#A020F0">of</FONT></B> 3 digits */
   <B><FONT COLOR="#BC8F8F">&quot;[ -]&quot;</FONT></B>		+++	/* separator is either space or dash */
   <B><FONT COLOR="#BC8F8F">&quot;(\\d\\d\\d\\d)&quot;</FONT></B>	+++	/* match 4: last 4 digits */
   <B><FONT COLOR="#BC8F8F">&quot;\\D&quot;</FONT></B>			/* must be followed by a non-digit */


<B><FONT COLOR="#228B22">:: MyPtr a	:== Int
</FONT></B><B><FONT COLOR="#228B22">:: PCRE		:== Int
</FONT></B><B><FONT COLOR="#228B22">:: PCREE	:== Int
</FONT></B>pcre_compile <B><FONT COLOR="#228B22">:: !String !Int !(MyPtr String) !(MyPtr Int) !Int !*Toolbox -&gt; (!PCRE,!*Toolbox)
</FONT></B>pcre_compile <B><FONT COLOR="#A020F0">_ </FONT></B><B><FONT COLOR="#A020F0">_ </FONT></B><B><FONT COLOR="#A020F0">_ </FONT></B><B><FONT COLOR="#A020F0">_ </FONT></B><B><FONT COLOR="#A020F0">_ </FONT></B><B><FONT COLOR="#A020F0">_ </FONT></B>= code {
	ccall pcre_compile <B><FONT COLOR="#BC8F8F">&quot;sIIII:I:I&quot;</FONT></B>
	}
pcre_study <B><FONT COLOR="#228B22">:: !PCRE !Int !(MyPtr String) !*Toolbox -&gt; (!PCREE,!*Toolbox)
</FONT></B>pcre_study <B><FONT COLOR="#A020F0">_ </FONT></B><B><FONT COLOR="#A020F0">_ </FONT></B><B><FONT COLOR="#A020F0">_ </FONT></B><B><FONT COLOR="#A020F0">_ </FONT></B>= code {
	ccall pcre_study <B><FONT COLOR="#BC8F8F">&quot;III:I:I&quot;</FONT></B>
	}
pcre_fullinfo <B><FONT COLOR="#228B22">:: !PCRE !PCREE !Int !Int !*Toolbox -&gt; (!Int,!*Toolbox)
</FONT></B>pcre_fullinfo <B><FONT COLOR="#A020F0">_ </FONT></B><B><FONT COLOR="#A020F0">_ </FONT></B><B><FONT COLOR="#A020F0">_ </FONT></B><B><FONT COLOR="#A020F0">_ </FONT></B><B><FONT COLOR="#A020F0">_ </FONT></B>= code {
	ccall pcre_fullinfo <B><FONT COLOR="#BC8F8F">&quot;IIII:I:I&quot;</FONT></B>
	}
pcre_exec <B><FONT COLOR="#228B22">:: !PCRE !PCREE !String !Int !Int !Int !(MyPtr Int) !Int !*Toolbox -&gt; (!Int,!*Toolbox)
</FONT></B>pcre_exec <B><FONT COLOR="#A020F0">_ </FONT></B><B><FONT COLOR="#A020F0">_ </FONT></B><B><FONT COLOR="#A020F0">_ </FONT></B><B><FONT COLOR="#A020F0">_ </FONT></B><B><FONT COLOR="#A020F0">_ </FONT></B><B><FONT COLOR="#A020F0">_ </FONT></B><B><FONT COLOR="#A020F0">_ </FONT></B><B><FONT COLOR="#A020F0">_ </FONT></B><B><FONT COLOR="#A020F0">_ </FONT></B>= code {
	ccall pcre_exec <B><FONT COLOR="#BC8F8F">&quot;IIsIIIII:I:I&quot;</FONT></B>
	}

// memory access
<B><FONT COLOR="#228B22">:: Ptr		:== Int
</FONT></B><B><FONT COLOR="#228B22">:: Toolbox	:== Int
</FONT></B>// win32
/*
<B><FONT COLOR="#A020F0">import</FONT></B> code from library <B><FONT COLOR="#BC8F8F">&quot;pcre_library&quot;</FONT></B>
malloc <B><FONT COLOR="#228B22">:: !Int !*Toolbox -&gt; (!Ptr,!*Toolbox)
</FONT></B>malloc n tb = (GlobalAlloc GPTR n,tb)
<B><FONT COLOR="#A020F0">where</FONT></B>
	GPTR	= 0x0040
	
	GlobalAlloc <B><FONT COLOR="#228B22">:: !Int !Int -&gt; Ptr
</FONT></B>	GlobalAlloc uFlags dwBytes = code {
		ccall GlobalAlloc@8 <B><FONT COLOR="#BC8F8F">&quot;PII:I&quot;</FONT></B>
		}
load <B><FONT COLOR="#228B22">:: !Ptr !*Toolbox -&gt; (!Int,!*Toolbox)
</FONT></B>load ptr tb = (read4 ptr,tb)
<B><FONT COLOR="#A020F0">where</FONT></B>
	read4 <B><FONT COLOR="#228B22">:: !Ptr -&gt; Int
</FONT></B>	read4 p = code {
		instruction 139
		instruction 0 | mov   eax,dword ptr [eax]
		}
store <B><FONT COLOR="#228B22">:: !Ptr !Int !*Toolbox -&gt; *Toolbox
</FONT></B>store ptr val tb
	= write4 ptr val tb
<B><FONT COLOR="#A020F0">where</FONT></B>
	write4 <B><FONT COLOR="#228B22">:: !Ptr !Int !.env -&gt; .env
</FONT></B>	write4 address value env = code {
			instruction 137		| movl %eax, (%ebx)
			instruction 3
			pop_b	2
		}
mmove <B><FONT COLOR="#228B22">:: !.{#Int} !Int !Int !*Toolbox -&gt; *Toolbox
</FONT></B>mmove dst src len tb = code {
	ccall RtlMoveMemory@12 <B><FONT COLOR="#BC8F8F">&quot;PAII:V:I&quot;</FONT></B>
	}
*/

// linux386
malloc <B><FONT COLOR="#228B22">:: !Int !*Toolbox -&gt; (!Ptr,!*Toolbox)
</FONT></B>malloc n tb
	# (ptr,tb)	= malloc_ n tb
	| ptr == 0	= abort <B><FONT COLOR="#BC8F8F">&quot;malloc failed\n&quot;</FONT></B>
	= (ptr,tb)
<B><FONT COLOR="#A020F0">where</FONT></B>
	malloc_ <B><FONT COLOR="#228B22">:: !Int !*Toolbox -&gt; (!MyPtr a,!*Toolbox)
</FONT></B>	malloc_ <B><FONT COLOR="#A020F0">_ </FONT></B><B><FONT COLOR="#A020F0">_ </FONT></B>= code {
		ccall malloc <B><FONT COLOR="#BC8F8F">&quot;I:I:I&quot;</FONT></B>
		}
load <B><FONT COLOR="#228B22">:: !Ptr !*Toolbox -&gt; (!Int,!*Toolbox)
</FONT></B>load ptr tb = (read4 ptr,tb)
<B><FONT COLOR="#A020F0">where</FONT></B>
	read4 <B><FONT COLOR="#228B22">:: !Ptr -&gt; Int
</FONT></B>	read4 p = code {
		instruction 139
		instruction 0 | mov   eax,dword ptr [eax]
		}
store <B><FONT COLOR="#228B22">:: !Ptr !Int !*Toolbox -&gt; *Toolbox
</FONT></B>store ptr val tb
	= write4 ptr val tb
<B><FONT COLOR="#A020F0">where</FONT></B>
	write4 <B><FONT COLOR="#228B22">:: !Ptr !Int !.env -&gt; .env
</FONT></B>	write4 address value env = code {
			instruction 137		| movl %eax, (%ebx)
			instruction 3
			pop_b	2
		}

mmove <B><FONT COLOR="#228B22">:: !.{#Int} !Int !Int !*Toolbox -&gt; *Toolbox
</FONT></B>mmove dst src len tb = code {
	ccall memmove <B><FONT COLOR="#BC8F8F">&quot;AII:V:I&quot;</FONT></B>
	}
// mosx
/*
malloc <B><FONT COLOR="#228B22">:: !Int !*Toolbox -&gt; (!Ptr,!*Toolbox)
</FONT></B>malloc n tb
	# (ptr,tb)	= malloc_ n tb
	| ptr == 0	= abort <B><FONT COLOR="#BC8F8F">&quot;malloc failed\n&quot;</FONT></B>
	= (ptr,tb)
<B><FONT COLOR="#A020F0">where</FONT></B>
	malloc_ <B><FONT COLOR="#228B22">:: !Int !*Toolbox -&gt; (!MyPtr a,!*Toolbox)
</FONT></B>	malloc_ <B><FONT COLOR="#A020F0">_ </FONT></B><B><FONT COLOR="#A020F0">_ </FONT></B>= code {
		ccall malloc <B><FONT COLOR="#BC8F8F">&quot;I:I:I&quot;</FONT></B>
		}
load <B><FONT COLOR="#228B22">:: !Ptr !*Toolbox -&gt; (!Int,!*Toolbox)
</FONT></B>load ptr tb
	= (LoadLong1 ptr, tb)
<B><FONT COLOR="#A020F0">where</FONT></B>
	LoadLong1 <B><FONT COLOR="#228B22">:: !Ptr -&gt; Int
</FONT></B>	LoadLong1 p = code (p=U)(r=A0){
		instruction 0x83180000	|	lwz	r24,0(r24)
		}
store <B><FONT COLOR="#228B22">:: !Ptr !Int !*Toolbox -&gt; *Toolbox
</FONT></B>store ptr val tb
	= StoreLong1 ptr val
<B><FONT COLOR="#A020F0">where</FONT></B>
	StoreLong1 <B><FONT COLOR="#228B22">:: !Ptr !Int -&gt; *Ptr
</FONT></B>	StoreLong1 p v = code (p=U,v=U)(q=A0){
		instruction	0x93190000	|	stw	r24,0(r25)
		instruction	0x7F38CB78	|	mr	r24,r25
		}
*/</pre></td></tr></table>
