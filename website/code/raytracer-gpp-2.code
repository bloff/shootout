<span class="slc">// The Great Computer Language Shootout
</span><span class="slc">// http://shootout.alioth.debian.org/
</span><span class="slc">// Fastest version under 100 LOC. Contributed by Jon Harrop, 2005
</span><span class="slc">// Compile: g++ -Wall -O3 -ffast-math ray.cpp -o ray
</span>
<span class="dir">#include &lt;list&gt;
</span><span class="dir">#include &lt;iostream&gt;
</span><span class="dir">#include &lt;limits&gt;
</span><span class="dir">#include &lt;cmath&gt;
</span><span class="kwa">using namespace</span> std<span class="sym">;
</span>numeric_limits<span class="sym">&lt;</span><span class="kwb">double</span><span class="sym">&gt;</span> real<span class="sym">;
</span><span class="kwb">double</span> delta <span class="sym">=</span> sqrt<span class="sym">(</span>real<span class="sym">.</span>epsilon<span class="sym">()),</span> infinity <span class="sym">=</span> real<span class="sym">.</span>infinity<span class="sym">();
</span><span class="kwb">struct</span> Vec <span class="sym">{
</span>  <span class="kwb">double</span> x<span class="sym">,</span> y<span class="sym">,</span> z<span class="sym">;
</span>  Vec<span class="sym">(</span><span class="kwb">double</span> x2<span class="sym">,</span> <span class="kwb">double</span> y2<span class="sym">,</span> <span class="kwb">double</span> z2<span class="sym">) :</span> x<span class="sym">(</span>x2<span class="sym">),</span> y<span class="sym">(</span>y2<span class="sym">),</span> z<span class="sym">(</span>z2<span class="sym">) {}
};
</span>Vec <span class="kwc">operator</span><span class="sym">+(</span><span class="kwb">const</span> Vec <span class="sym">&amp;</span>a<span class="sym">,</span> <span class="kwb">const</span> Vec <span class="sym">&amp;</span>b<span class="sym">)
{</span> <span class="kwa">return</span> Vec<span class="sym">(</span>a<span class="sym">.</span>x<span class="sym">+</span>b<span class="sym">.</span>x<span class="sym">,</span> a<span class="sym">.</span>y<span class="sym">+</span>b<span class="sym">.</span>y<span class="sym">,</span> a<span class="sym">.</span>z<span class="sym">+</span>b<span class="sym">.</span>z<span class="sym">); }
</span>Vec <span class="kwc">operator</span><span class="sym">-(</span><span class="kwb">const</span> Vec <span class="sym">&amp;</span>a<span class="sym">,</span> <span class="kwb">const</span> Vec <span class="sym">&amp;</span>b<span class="sym">)
{</span> <span class="kwa">return</span> Vec<span class="sym">(</span>a<span class="sym">.</span>x<span class="sym">-</span>b<span class="sym">.</span>x<span class="sym">,</span> a<span class="sym">.</span>y<span class="sym">-</span>b<span class="sym">.</span>y<span class="sym">,</span> a<span class="sym">.</span>z<span class="sym">-</span>b<span class="sym">.</span>z<span class="sym">); }
</span>Vec <span class="kwc">operator</span><span class="sym">*(</span><span class="kwb">double</span> a<span class="sym">,</span> <span class="kwb">const</span> Vec <span class="sym">&amp;</span>b<span class="sym">) {</span> <span class="kwa">return</span> Vec<span class="sym">(</span>a<span class="sym">*</span>b<span class="sym">.</span>x<span class="sym">,</span> a<span class="sym">*</span>b<span class="sym">.</span>y<span class="sym">,</span> a<span class="sym">*</span>b<span class="sym">.</span>z<span class="sym">); }
</span><span class="kwb">double</span> dot<span class="sym">(</span><span class="kwb">const</span> Vec <span class="sym">&amp;</span>a<span class="sym">,</span> <span class="kwb">const</span> Vec <span class="sym">&amp;</span>b<span class="sym">) {</span> <span class="kwa">return</span> a<span class="sym">.</span>x<span class="sym">*</span>b<span class="sym">.</span>x <span class="sym">+</span> a<span class="sym">.</span>y<span class="sym">*</span>b<span class="sym">.</span>y <span class="sym">+</span> a<span class="sym">.</span>z<span class="sym">*</span>b<span class="sym">.</span>z<span class="sym">; }
</span>Vec unitise<span class="sym">(</span><span class="kwb">const</span> Vec <span class="sym">&amp;</span>a<span class="sym">) {</span> <span class="kwa">return</span> <span class="sym">(</span><span class="num">1</span> <span class="sym">/</span> sqrt<span class="sym">(</span>dot<span class="sym">(</span>a<span class="sym">,</span> a<span class="sym">))) *</span> a<span class="sym">; }
</span><span class="kwc">typedef</span> pair<span class="sym">&lt;</span><span class="kwb">double</span><span class="sym">,</span> Vec<span class="sym">&gt;</span> Hit<span class="sym">;
</span><span class="kwb">struct</span> Ray <span class="sym">{
</span>  Vec orig<span class="sym">,</span> dir<span class="sym">;
</span>  Ray<span class="sym">(</span><span class="kwb">const</span> Vec <span class="sym">&amp;</span>o<span class="sym">,</span> <span class="kwb">const</span> Vec <span class="sym">&amp;</span>d<span class="sym">) :</span> orig<span class="sym">(</span>o<span class="sym">),</span> dir<span class="sym">(</span>d<span class="sym">) {}
};
</span><span class="kwb">struct</span> Scene <span class="sym">{
</span>  <span class="kwc">virtual</span> <span class="sym">~</span>Scene<span class="sym">() {};
</span>  <span class="kwc">virtual</span> Hit intersect<span class="sym">(</span><span class="kwb">const</span> Hit <span class="sym">&amp;,</span> <span class="kwb">const</span> Ray <span class="sym">&amp;)</span> <span class="kwb">const</span> <span class="sym">=</span> <span class="num">0</span><span class="sym">;
};
</span><span class="kwb">struct</span> Sphere <span class="sym">:</span> <span class="kwc">public</span> Scene <span class="sym">{
</span>  Vec center<span class="sym">;
</span>  <span class="kwb">double</span> radius<span class="sym">;
</span>  Sphere<span class="sym">(</span>Vec c<span class="sym">,</span> <span class="kwb">double</span> r<span class="sym">) :</span> center<span class="sym">(</span>c<span class="sym">),</span> radius<span class="sym">(</span>r<span class="sym">) {}
  ~</span>Sphere<span class="sym">() {}
</span>  <span class="kwb">double</span> ray_sphere<span class="sym">(</span><span class="kwb">const</span> Ray <span class="sym">&amp;</span>ray<span class="sym">)</span> <span class="kwb">const</span> <span class="sym">{
</span>    Vec v <span class="sym">=</span> center <span class="sym">-</span> ray<span class="sym">.</span>orig<span class="sym">;
</span>    <span class="kwb">double</span> b <span class="sym">=</span> dot<span class="sym">(</span>v<span class="sym">,</span> ray<span class="sym">.</span>dir<span class="sym">),</span> disc <span class="sym">=</span> b<span class="sym">*</span>b <span class="sym">-</span> dot<span class="sym">(</span>v<span class="sym">,</span> v<span class="sym">) +</span> radius <span class="sym">*</span> radius<span class="sym">;
</span>    <span class="kwa">if</span> <span class="sym">(</span>disc <span class="sym">&lt;</span> <span class="num">0</span><span class="sym">)</span> <span class="kwa">return</span> infinity<span class="sym">;
</span>    <span class="kwb">double</span> d <span class="sym">=</span> sqrt<span class="sym">(</span>disc<span class="sym">),</span> t2 <span class="sym">=</span> b <span class="sym">+</span> d<span class="sym">;
</span>    <span class="kwa">if</span> <span class="sym">(</span>t2 <span class="sym">&lt;</span> <span class="num">0</span><span class="sym">)</span> <span class="kwa">return</span> infinity<span class="sym">;
</span>    <span class="kwb">double</span> t1 <span class="sym">=</span> b <span class="sym">-</span> d<span class="sym">;
</span>    <span class="kwa">return</span> <span class="sym">(</span>t1 <span class="sym">&gt;</span> <span class="num">0</span> ? t1 <span class="sym">:</span> t2<span class="sym">);
  }
</span>  Hit intersect<span class="sym">(</span><span class="kwb">const</span> Hit <span class="sym">&amp;</span>hit<span class="sym">,</span> <span class="kwb">const</span> Ray <span class="sym">&amp;</span>ray<span class="sym">)</span> <span class="kwb">const</span> <span class="sym">{
</span>    <span class="kwb">double</span> lambda <span class="sym">=</span> ray_sphere<span class="sym">(</span>ray<span class="sym">);
</span>    <span class="kwa">if</span> <span class="sym">(</span>lambda <span class="sym">&gt;=</span> hit<span class="sym">.</span>first<span class="sym">)</span> <span class="kwa">return</span> hit<span class="sym">;
</span>    <span class="kwa">return</span> Hit<span class="sym">(</span>lambda<span class="sym">,</span> unitise<span class="sym">(</span>ray<span class="sym">.</span>orig <span class="sym">+</span> lambda<span class="sym">*</span>ray<span class="sym">.</span>dir <span class="sym">-</span> center<span class="sym">));
  }
};
</span><span class="kwc">typedef</span> list<span class="sym">&lt;</span>Scene <span class="sym">*&gt;</span> Scenes<span class="sym">;
</span><span class="kwb">struct</span> Group <span class="sym">:</span> <span class="kwc">public</span> Scene <span class="sym">{
</span>  Sphere bound<span class="sym">;
</span>  Scenes child<span class="sym">;
</span>  Group<span class="sym">(</span>Sphere b<span class="sym">,</span> Scenes c<span class="sym">) :</span> bound<span class="sym">(</span>b<span class="sym">),</span> child<span class="sym">(</span>c<span class="sym">) {}
  ~</span>Group<span class="sym">() {
</span>    <span class="kwa">for</span> <span class="sym">(</span>Scenes<span class="sym">::</span>const_iterator it<span class="sym">=</span>child<span class="sym">.</span>begin<span class="sym">();</span> it<span class="sym">!=</span>child<span class="sym">.</span>end<span class="sym">(); ++</span>it<span class="sym">)
</span>      <span class="kwa">delete</span> <span class="sym">*</span>it<span class="sym">;
  }
</span>  Hit intersect<span class="sym">(</span><span class="kwb">const</span> Hit <span class="sym">&amp;</span>hit<span class="sym">,</span> <span class="kwb">const</span> Ray <span class="sym">&amp;</span>ray<span class="sym">)</span> <span class="kwb">const</span> <span class="sym">{
</span>    Hit hit2<span class="sym">=</span>hit<span class="sym">;
</span>    <span class="kwb">double</span> l <span class="sym">=</span> bound<span class="sym">.</span>ray_sphere<span class="sym">(</span>ray<span class="sym">);
</span>    <span class="kwa">if</span> <span class="sym">(</span>l <span class="sym">&gt;=</span> hit<span class="sym">.</span>first<span class="sym">)</span> <span class="kwa">return</span> hit<span class="sym">;
</span>    <span class="kwa">for</span> <span class="sym">(</span>Scenes<span class="sym">::</span>const_iterator it<span class="sym">=</span>child<span class="sym">.</span>begin<span class="sym">();</span> it<span class="sym">!=</span>child<span class="sym">.</span>end<span class="sym">(); ++</span>it<span class="sym">)
</span>      hit2 <span class="sym">= (*</span>it<span class="sym">)-&gt;</span>intersect<span class="sym">(</span>hit2<span class="sym">,</span> ray<span class="sym">);
</span>    <span class="kwa">return</span> hit2<span class="sym">;
  }
};
</span><span class="kwb">double</span> ray_trace<span class="sym">(</span><span class="kwb">const</span> Vec <span class="sym">&amp;</span>light<span class="sym">,</span> <span class="kwb">const</span> Ray <span class="sym">&amp;</span>ray<span class="sym">,</span> <span class="kwb">const</span> Scene <span class="sym">&amp;</span>s<span class="sym">) {
</span>  Hit no_hit<span class="sym">(</span>infinity<span class="sym">,</span> Vec<span class="sym">(</span><span class="num">0</span><span class="sym">,</span> <span class="num">0</span><span class="sym">,</span> <span class="num">0</span><span class="sym">));
</span>  Hit hit <span class="sym">=</span> s<span class="sym">.</span>intersect<span class="sym">(</span>no_hit<span class="sym">,</span> ray<span class="sym">);
</span>  <span class="kwa">if</span> <span class="sym">(</span>hit<span class="sym">.</span>first <span class="sym">==</span> infinity<span class="sym">)</span> <span class="kwa">return</span> <span class="num">0</span><span class="sym">;
</span>  <span class="kwb">double</span> g <span class="sym">=</span> dot<span class="sym">(</span>hit<span class="sym">.</span>second<span class="sym">,</span> light<span class="sym">);
</span>  <span class="kwa">if</span> <span class="sym">(</span>g <span class="sym">&gt;=</span> <span class="num">0</span><span class="sym">)</span> <span class="kwa">return</span> <span class="num">0</span><span class="sym">.;
</span>  Vec p <span class="sym">=</span> ray<span class="sym">.</span>orig <span class="sym">+</span> hit<span class="sym">.</span>first<span class="sym">*</span>ray<span class="sym">.</span>dir <span class="sym">+</span> delta<span class="sym">*</span>hit<span class="sym">.</span>second<span class="sym">;
</span>  <span class="kwa">return</span> <span class="sym">(</span>s<span class="sym">.</span>intersect<span class="sym">(</span>no_hit<span class="sym">,</span> Ray<span class="sym">(</span>p<span class="sym">, -</span><span class="num">1</span><span class="sym">. *</span> light<span class="sym">)).</span>first <span class="sym">&lt;</span> infinity ? <span class="num">0</span> <span class="sym">: -</span>g<span class="sym">);
}
</span>Scene <span class="sym">*</span>create<span class="sym">(</span><span class="kwb">int</span> level<span class="sym">,</span> <span class="kwb">const</span> Vec <span class="sym">&amp;</span>c<span class="sym">,</span> <span class="kwb">double</span> r<span class="sym">) {
</span>  Scene <span class="sym">*</span>s <span class="sym">=</span> <span class="kwa">new</span> Sphere<span class="sym">(</span>c<span class="sym">,</span> r<span class="sym">);
</span>  <span class="kwa">if</span> <span class="sym">(</span>level <span class="sym">==</span> <span class="num">1</span><span class="sym">)</span> <span class="kwa">return</span> s<span class="sym">;
</span>  Scenes child<span class="sym">;
</span>  child<span class="sym">.</span>push_back<span class="sym">(</span>s<span class="sym">);
</span>  <span class="kwb">double</span> rn <span class="sym">=</span> <span class="num">3</span><span class="sym">*</span>r<span class="sym">/</span>sqrt<span class="sym">(</span><span class="num">12</span><span class="sym">.);
</span>  <span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> dz<span class="sym">=-</span><span class="num">1</span><span class="sym">;</span> dz<span class="sym">&lt;=</span><span class="num">1</span><span class="sym">;</span> dz<span class="sym">+=</span><span class="num">2</span><span class="sym">)
</span>    <span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> dx<span class="sym">=-</span><span class="num">1</span><span class="sym">;</span> dx<span class="sym">&lt;=</span><span class="num">1</span><span class="sym">;</span> dx<span class="sym">+=</span><span class="num">2</span><span class="sym">)
</span>      child<span class="sym">.</span>push_back<span class="sym">(</span>create<span class="sym">(</span>level<span class="num">-1</span><span class="sym">,</span> c <span class="sym">+</span> rn<span class="sym">*</span>Vec<span class="sym">(</span>dx<span class="sym">,</span> <span class="num">1</span><span class="sym">,</span> dz<span class="sym">),</span> r<span class="sym">/</span><span class="num">2</span><span class="sym">));
</span>  <span class="kwa">return new</span> Group<span class="sym">(</span>Sphere<span class="sym">(</span>c<span class="sym">,</span> <span class="num">3</span><span class="sym">*</span>r<span class="sym">),</span> child<span class="sym">);
}
</span><span class="kwb">int</span> main<span class="sym">(</span><span class="kwb">int</span> argc<span class="sym">,</span> <span class="kwb">char</span> <span class="sym">*</span>argv<span class="sym">[]) {
</span>  <span class="kwb">int</span> level <span class="sym">=</span> <span class="num">6</span><span class="sym">,</span> n <span class="sym">= (</span>argc<span class="sym">==</span><span class="num">2</span> ? atoi<span class="sym">(</span>argv<span class="sym">[</span><span class="num">1</span><span class="sym">]) :</span> <span class="num">256</span><span class="sym">),</span> ss <span class="sym">=</span> <span class="num">4</span><span class="sym">;
</span>  Vec light <span class="sym">=</span> unitise<span class="sym">(</span>Vec<span class="sym">(-</span><span class="num">1</span><span class="sym">, -</span><span class="num">3</span><span class="sym">,</span> <span class="num">2</span><span class="sym">));
</span>  Scene <span class="sym">*</span>s<span class="sym">(</span>create<span class="sym">(</span>level<span class="sym">,</span> Vec<span class="sym">(</span><span class="num">0</span><span class="sym">, -</span><span class="num">1</span><span class="sym">,</span> <span class="num">0</span><span class="sym">),</span> <span class="num">1</span><span class="sym">));
</span>  cout <span class="sym">&lt;&lt;</span> <span class="str">&quot;P5</span><span class="esc">\n</span><span class="str">&quot;</span> <span class="sym">&lt;&lt;</span> n <span class="sym">&lt;&lt;</span> <span class="str">&quot; &quot;</span> <span class="sym">&lt;&lt;</span> n <span class="sym">&lt;&lt;</span> <span class="str">&quot;</span><span class="esc">\n</span><span class="str">255</span><span class="esc">\n</span><span class="str">&quot;</span><span class="sym">;
</span>  <span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> y<span class="sym">=</span>n<span class="num">-1</span><span class="sym">;</span> y<span class="sym">&gt;=</span><span class="num">0</span><span class="sym">; --</span>y<span class="sym">)
</span>    <span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> x<span class="sym">=</span><span class="num">0</span><span class="sym">;</span> x<span class="sym">&lt;</span>n<span class="sym">; ++</span>x<span class="sym">) {
</span>      <span class="kwb">double</span> g<span class="sym">=</span><span class="num">0</span><span class="sym">;
</span>      <span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> dx<span class="sym">=</span><span class="num">0</span><span class="sym">;</span> dx<span class="sym">&lt;</span>ss<span class="sym">; ++</span>dx<span class="sym">)
</span>	<span class="kwa">for</span> <span class="sym">(</span><span class="kwb">int</span> dy<span class="sym">=</span><span class="num">0</span><span class="sym">;</span> dy<span class="sym">&lt;</span>ss<span class="sym">; ++</span>dy<span class="sym">) {
</span>	  Vec dir<span class="sym">(</span>unitise<span class="sym">(</span>Vec<span class="sym">(</span>x<span class="sym">+</span>dx<span class="sym">*</span><span class="num">1</span><span class="sym">./</span>ss<span class="sym">-</span>n<span class="sym">/</span><span class="num">2</span><span class="sym">.,</span> y<span class="sym">+</span>dy<span class="sym">*</span><span class="num">1</span><span class="sym">./</span>ss<span class="sym">-</span>n<span class="sym">/</span><span class="num">2</span><span class="sym">.,</span> n<span class="sym">)));
</span>	  g <span class="sym">+=</span> ray_trace<span class="sym">(</span>light<span class="sym">,</span> Ray<span class="sym">(</span>Vec<span class="sym">(</span><span class="num">0</span><span class="sym">,</span> <span class="num">0</span><span class="sym">, -</span><span class="num">4</span><span class="sym">),</span> dir<span class="sym">), *</span>s<span class="sym">);
	}
</span>      cout <span class="sym">&lt;&lt;</span> <span class="kwb">char</span><span class="sym">(</span><span class="num">.5</span> <span class="sym">+</span> <span class="num">255</span><span class="sym">. *</span> g <span class="sym">/ (</span>ss<span class="sym">*</span>ss<span class="sym">));
    }
</span>  <span class="kwa">delete</span> s<span class="sym">;
</span>  <span class="kwa">return</span> <span class="num">0</span><span class="sym">;
}</span>
