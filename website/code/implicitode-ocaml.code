<span class="com">(* implicitode.ml                                           -*-tuareg-*-
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Sebastien Loisel
 * Cleaned up and made more idiomatic by Christophe Troestler
 *)</span>

<span class="kwa">module type</span> SCALAR <span class="sym">=</span> <span class="kwa">sig
  type</span> t
  <span class="kwa">val</span> <span class="sym">( + ) :</span> t <span class="sym">-&gt;</span> t <span class="sym">-&gt;</span> t
  <span class="kwa">val</span> <span class="sym">( - ) :</span> t <span class="sym">-&gt;</span> t <span class="sym">-&gt;</span> t
  <span class="kwa">val</span> <span class="sym">( * ) :</span> t <span class="sym">-&gt;</span> t <span class="sym">-&gt;</span> t
  <span class="kwa">val</span> <span class="sym">( / ) :</span> t <span class="sym">-&gt;</span> t <span class="sym">-&gt;</span> t
  <span class="kwa">val</span> mk <span class="sym">:</span> <span class="kwb">int</span> <span class="sym">-&gt;</span> t
  <span class="kwa">val</span> mf <span class="sym">:</span> <span class="kwb">float</span> <span class="sym">-&gt;</span> t
  <span class="kwa">val</span> pr <span class="sym">:</span> t <span class="sym">-&gt;</span> <span class="kwb">string
</span><span class="kwa">end

module</span> FL64 <span class="sym">:</span> SCALAR <span class="sym">=</span> <span class="kwa">struct
  type</span> t <span class="sym">=</span> <span class="kwb">float
</span>  <span class="kwa">let</span> <span class="sym">( + )</span> x y <span class="sym">=</span> x <span class="sym">+</span>. y
  <span class="kwa">let</span> <span class="sym">( - )</span> x y <span class="sym">=</span> x <span class="sym">-</span>. y
  <span class="kwa">let</span> <span class="sym">( * )</span> x y <span class="sym">=</span> x <span class="sym">*</span>. y
  <span class="kwa">let</span> <span class="sym">( / )</span> x y <span class="sym">=</span> x <span class="sym">/</span>. y
  <span class="kwa">let</span> mk <span class="sym">=</span> <span class="kwb">float
</span>  <span class="kwa">let</span> mf x <span class="sym">=</span> x
  <span class="kwa">let</span> pr x <span class="sym">=</span> Printf.sprintf <span class="str">&quot;%.12e&quot;</span> x
<span class="kwa">end

</span><span class="com">(* Low precision floating point type. *)</span>
<span class="kwa">module</span> FL <span class="sym">:</span> SCALAR <span class="sym">=</span> <span class="kwa">struct
  type</span> t <span class="sym">=</span> <span class="kwb">float
</span>  <span class="kwa">let</span> pr x <span class="sym">=</span> Printf.sprintf <span class="str">&quot;%.2e&quot;</span> x
  <span class="kwa">let</span> mf x <span class="sym">=
</span>    <span class="kwa">if</span> x <span class="sym">=</span> <span class="num">0.0</span> <span class="kwa">then</span> <span class="num">0.0</span> <span class="kwa">else
      let</span> k <span class="sym">=</span> truncate<span class="sym">(</span>log<span class="sym">(</span>abs_float x<span class="sym">))</span> <span class="kwa">in
      let</span> fk <span class="sym">=</span> <span class="kwb">float</span> k <span class="kwa">in</span> floor<span class="sym">(</span>x <span class="sym">*</span>. exp<span class="sym">(</span><span class="num">6</span>. <span class="sym">-</span>. fk<span class="sym">) +</span>. <span class="num">0.5</span><span class="sym">) *</span>. exp<span class="sym">(</span>fk <span class="sym">-</span>. <span class="num">6</span>.<span class="sym">)
</span>  <span class="kwa">let</span> mk x <span class="sym">=</span> mf <span class="sym">(</span><span class="kwb">float</span> x<span class="sym">)
</span>  <span class="kwa">let</span> <span class="sym">( + )</span> x y <span class="sym">=</span> mf <span class="sym">(</span>x <span class="sym">+</span>. y<span class="sym">)
</span>  <span class="kwa">let</span> <span class="sym">( - )</span> x y <span class="sym">=</span> mf <span class="sym">(</span>x <span class="sym">-</span>. y<span class="sym">)
</span>  <span class="kwa">let</span> <span class="sym">( * )</span> x y <span class="sym">=</span> mf <span class="sym">(</span>x <span class="sym">*</span>. y<span class="sym">)
</span>  <span class="kwa">let</span> <span class="sym">( / )</span> x y <span class="sym">=</span> mf <span class="sym">(</span>x <span class="sym">/</span>. y<span class="sym">)
</span><span class="kwa">end

</span><span class="com">(* Complex numbers on the field [F].  Overflow is not handled. *)</span>
<span class="kwa">module</span> C<span class="sym">(</span>F <span class="sym">:</span> SCALAR<span class="sym">) =</span> <span class="kwa">struct
  type</span> t <span class="sym">= {</span> re<span class="sym">:</span> F.t<span class="sym">;</span> im<span class="sym">:</span> F.t <span class="sym">}
</span>  <span class="kwa">let</span> mk a <span class="sym">= {</span> re <span class="sym">=</span> F.mk a<span class="sym">;</span>  im <span class="sym">=</span> F.mk <span class="num">0</span> <span class="sym">}
</span>  <span class="kwa">let</span> mf a <span class="sym">= {</span> re <span class="sym">=</span> F.mf a<span class="sym">;</span>  im <span class="sym">=</span> F.mk <span class="num">0</span> <span class="sym">}
</span>  <span class="kwa">let</span> mc a b <span class="sym">= {</span> re <span class="sym">=</span> a<span class="sym">;</span> im <span class="sym">=</span> b <span class="sym">}
</span>  <span class="kwa">let</span> pr a <span class="sym">=</span> F.pr a.re ^ <span class="str">&quot; &quot;</span> ^ F.pr a.im

  <span class="kwa">open</span> F
  <span class="kwa">let</span> <span class="sym">( + )</span> a b <span class="sym">= {</span> re <span class="sym">=</span> a.re <span class="sym">+</span> b.re<span class="sym">;</span>  im <span class="sym">=</span> a.im <span class="sym">+</span> b.im <span class="sym">}
</span>  <span class="kwa">and</span> <span class="sym">( - )</span> a b <span class="sym">= {</span> re <span class="sym">=</span> a.re <span class="sym">-</span> b.re<span class="sym">;</span>  im <span class="sym">=</span> a.im <span class="sym">-</span> b.im <span class="sym">}
</span>  <span class="kwa">and</span> <span class="sym">( * )</span> a b <span class="sym">= {</span> re <span class="sym">=</span> a.re <span class="sym">*</span> b.re <span class="sym">-</span> a.im <span class="sym">*</span> b.im<span class="sym">;
</span>		    im <span class="sym">=</span> a.re <span class="sym">*</span> b.im <span class="sym">+</span> a.im <span class="sym">*</span> b.re <span class="sym">}
</span>  <span class="kwa">and</span> <span class="sym">( / )</span> a b <span class="sym">=
</span>    <span class="kwa">let</span> mag <span class="sym">=</span> b.re <span class="sym">*</span> b.re <span class="sym">+</span> b.im <span class="sym">*</span> b.im <span class="kwa">in
</span>    <span class="sym">{</span> re <span class="sym">= (</span>a.re <span class="sym">*</span> b.re <span class="sym">+</span> a.im <span class="sym">*</span> b.im<span class="sym">) /</span> mag<span class="sym">;
</span>      im <span class="sym">= (</span>a.im <span class="sym">*</span> b.re <span class="sym">-</span> a.re <span class="sym">*</span> b.im<span class="sym">) /</span> mag <span class="sym">}
</span><span class="kwa">end

module</span> Functions<span class="sym">(</span>F <span class="sym">:</span> SCALAR<span class="sym">) =</span> <span class="kwa">struct
  let</span> f0 <span class="sym">=</span> F.mk <span class="num">0</span> <span class="kwa">and</span> f1 <span class="sym">=</span> F.mk <span class="num">1</span> <span class="kwa">and</span> f2 <span class="sym">=</span> F.mk <span class="num">2</span> <span class="kwa">and</span> f3 <span class="sym">=</span> F.mk <span class="num">3
</span>  <span class="kwa">let</span> f5 <span class="sym">=</span> F.mk <span class="num">5</span> <span class="kwa">and</span> f6 <span class="sym">=</span> F.mk <span class="num">6</span> <span class="kwa">and</span> f7 <span class="sym">=</span> F.mk <span class="num">7
</span>  <span class="kwa">let</span> sqr x <span class="sym">=</span> F.<span class="sym">( * )</span> x x
  <span class="kwa">let rec</span> <span class="sym">( ** )</span> x k <span class="sym">=
</span>    <span class="kwa">if</span> k <span class="sym">=</span> <span class="num">0</span> <span class="kwa">then</span> f1
    <span class="kwa">else if</span> k <span class="kwa">mod</span> <span class="num">2</span> <span class="sym">=</span> <span class="num">0</span> <span class="kwa">then</span> sqr<span class="sym">(</span>x<span class="sym">**(</span>k<span class="sym">/</span><span class="num">2</span><span class="sym">))</span> <span class="kwa">else</span> F.<span class="sym">( * )</span> x <span class="sym">(</span>x<span class="sym">**(</span>k<span class="num">-1</span><span class="sym">))

</span>  <span class="kwa">open</span> F
  <span class="kwa">let</span> rat x <span class="sym">= ((</span>f2 <span class="sym">*</span> x <span class="sym">+</span> f3 <span class="sym">*</span> x<span class="sym">**</span><span class="num">2</span> <span class="sym">+</span> f7 <span class="sym">*</span> x<span class="sym">**</span><span class="num">6</span> <span class="sym">+</span> f5 <span class="sym">*</span> x<span class="sym">**</span><span class="num">11</span> <span class="sym">+</span> f1<span class="sym">)
	       / (</span>f5 <span class="sym">*</span> x <span class="sym">-</span> f6 <span class="sym">*</span> x<span class="sym">**</span><span class="num">3</span> <span class="sym">-</span> f3 <span class="sym">*</span> x<span class="sym">**</span><span class="num">7</span> <span class="sym">+</span> f2<span class="sym">))

</span>  <span class="com">(* Automatic differentiation type on the field [F]. *)</span>
  <span class="kwa">module</span> AD <span class="sym">=</span> <span class="kwa">struct
    type</span> t <span class="sym">= {</span> x <span class="sym">:</span> F.t<span class="sym">;</span> dx <span class="sym">:</span> F.t <span class="sym">}
</span>    <span class="kwa">let</span> mk i <span class="sym">= {</span> x <span class="sym">=</span> F.mk i<span class="sym">;</span> dx <span class="sym">=</span> f0 <span class="sym">}
</span>    <span class="kwa">let</span> mf x <span class="sym">= {</span> x <span class="sym">=</span> F.mf x<span class="sym">;</span> dx <span class="sym">=</span> f0 <span class="sym">}
</span>    <span class="kwa">let</span> pr a <span class="sym">=</span> pr a.x ^ <span class="str">&quot; &quot;</span> ^ pr a.dx
    <span class="kwa">let</span> vr y dy <span class="sym">= {</span> x <span class="sym">=</span> y<span class="sym">;</span> dx <span class="sym">=</span> dy <span class="sym">}
</span>    <span class="kwa">let</span> <span class="sym">( + )</span> a b <span class="sym">= {</span> x <span class="sym">=</span> a.x <span class="sym">+</span> b.x<span class="sym">;</span>  dx <span class="sym">=</span> a.dx <span class="sym">+</span> b.dx <span class="sym">}
</span>    <span class="kwa">and</span> <span class="sym">( - )</span> a b <span class="sym">= {</span> x <span class="sym">=</span> a.x <span class="sym">-</span> b.x<span class="sym">;</span>  dx <span class="sym">=</span> a.dx <span class="sym">-</span> b.dx <span class="sym">}
</span>    <span class="kwa">and</span> <span class="sym">( * )</span> a b <span class="sym">= {</span> x <span class="sym">=</span> a.x <span class="sym">*</span> b.x<span class="sym">;</span>  dx <span class="sym">=</span> a.dx <span class="sym">*</span> b.x <span class="sym">+</span> a.x <span class="sym">*</span> b.dx <span class="sym">}
</span>    <span class="kwa">and</span> <span class="sym">( / )</span> a b <span class="sym">= {</span> x <span class="sym">=</span> a.x<span class="sym">/</span>b.x<span class="sym">;</span> dx <span class="sym">= (</span>a.dx<span class="sym">*</span>b.x<span class="sym">-</span>a.x<span class="sym">*</span>b.dx<span class="sym">)/(</span>b.x<span class="sym">*</span>b.x<span class="sym">) }

</span>    <span class="kwa">let</span> newton x0 n g <span class="sym">=
</span>      <span class="kwa">let</span> x <span class="sym">=</span> ref x0 <span class="kwa">in
      for</span> i <span class="sym">=</span> <span class="num">1</span> <span class="kwa">to</span> n <span class="kwa">do
	let</span> v <span class="sym">=</span> g<span class="sym">(</span>vr <span class="sym">!</span>x f1<span class="sym">)</span> <span class="kwa">in
</span>	x <span class="sym">:=</span> F.<span class="sym">(-) !</span>x <span class="sym">(</span>F.<span class="sym">(/)</span> v.x v.dx<span class="sym">)
</span>      <span class="kwa">done</span><span class="sym">; !</span>x
    <span class="kwa">let</span> trapezoid_method_rooter gad gf y0 t0 t1 <span class="sym">=
</span>      <span class="kwa">let</span> z0  <span class="sym">=</span> f0 <span class="kwa">in
      let</span> vt0 <span class="sym">=</span> vr t0 z0
      <span class="kwa">and</span> vt1 <span class="sym">=</span> vr t1 z0
      <span class="kwa">and</span> dt2 <span class="sym">=</span> vr <span class="sym">(</span>F.<span class="sym">(/) (</span>F.<span class="sym">(-)</span> t1 t0<span class="sym">)</span> f2<span class="sym">)</span> z0
      <span class="kwa">and</span> vy0 <span class="sym">=</span> vr y0 z0
      <span class="kwa">and</span> g0  <span class="sym">=</span> gf t0 y0 <span class="kwa">in
      let</span> vg0 <span class="sym">=</span> vr g0 z0 <span class="kwa">in
      let</span> foo y1 <span class="sym">=
</span>	<span class="kwa">let</span> ret <span class="sym">= (</span>gad vt1 y1 <span class="sym">+</span> vg0<span class="sym">) *</span> dt2 <span class="sym">+</span> vy0 <span class="sym">-</span> y1 <span class="kwa">in
</span><span class="com">(*	print_string (&quot;t0 &quot; ^ (F.pr t0) ^ &quot; t1 &quot; ^ (F.pr t1) ^ &quot; y0 &quot; ^
		(F.pr y0) ^ &quot; g0 &quot; ^ (F.pr g0) ^ &quot; y1 &quot; ^ (pr y1) ^ &quot; ret &quot; ^
		(pr ret) ^ &quot; raz &quot; ^ (pr raz) ^ &quot;\n&quot;) ; *)</span>
	ret <span class="kwa">in
</span>      foo
    <span class="kwa">let</span> trapezoid_method t0 dt y0 gad gf numsteps <span class="sym">=
</span>      <span class="kwa">let</span> y <span class="sym">=</span> ref y0
      <span class="kwa">and</span> t <span class="sym">=</span> ref t0 <span class="kwa">in
      for</span> i <span class="sym">=</span> <span class="num">1</span> <span class="kwa">to</span> numsteps <span class="kwa">do
</span>	y <span class="sym">:=</span> newton <span class="sym">!</span>y <span class="num">10</span> <span class="sym">(</span>trapezoid_method_rooter gad gf <span class="sym">!</span>y <span class="sym">!</span>t <span class="sym">(</span>F.<span class="sym">(+) !</span>t dt<span class="sym">));
</span>	t <span class="sym">:=</span> F.<span class="sym">(+) !</span>t dt<span class="sym">;
</span>      <span class="kwa">done</span><span class="sym">; !</span>y
  <span class="kwa">end
end

module</span> Integrate_functions<span class="sym">(</span>F <span class="sym">:</span> SCALAR<span class="sym">) =</span> <span class="kwa">struct
  module</span> Funs <span class="sym">=</span> Functions<span class="sym">(</span>F<span class="sym">)
</span>  <span class="kwa">module</span> AD <span class="sym">=</span> Funs.AD
  <span class="kwa">module</span> ADFuns <span class="sym">=</span> Functions<span class="sym">(</span>AD<span class="sym">)
</span>  <span class="kwa">open</span> F

  <span class="kwa">let</span> sqrintegrandad t y <span class="sym">=</span> ADFuns.sqr y
  <span class="kwa">let</span> sqrintegrandf t y <span class="sym">=</span> Funs.sqr y
  <span class="kwa">let</span> ratintegrandad t y <span class="sym">=</span> AD.<span class="sym">(-) (</span>ADFuns.rat y<span class="sym">)</span> t
  <span class="kwa">let</span> ratintegrandf t y <span class="sym">=</span> Funs.rat y <span class="sym">-</span>  t
  <span class="kwa">let</span> integrate_functions x0 n <span class="sym">=
</span>    <span class="kwa">let</span> integ f df <span class="sym">=</span> AD.trapezoid_method <span class="sym">(</span>mk <span class="num">1</span><span class="sym">) (</span>mk <span class="num">1</span> <span class="sym">/</span> mk n<span class="sym">)</span> x0 f df n <span class="kwa">in
</span>    print_string <span class="sym">(</span><span class="str">&quot;i1 &quot;</span> ^ <span class="sym">(</span>pr <span class="sym">(</span>integ sqrintegrandad sqrintegrandf<span class="sym">))</span> ^<span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span><span class="sym">);
</span>    print_string <span class="sym">(</span><span class="str">&quot;i2 &quot;</span> ^ <span class="sym">(</span>pr <span class="sym">(</span>integ ratintegrandad ratintegrandf<span class="sym">))</span> ^<span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span><span class="sym">)
</span>  <span class="kwa">end

module</span> Funs <span class="sym">=</span> Functions<span class="sym">(</span>FL64<span class="sym">)
</span><span class="kwa">module</span> AD <span class="sym">=</span> Funs.AD
<span class="kwa">module</span> ADFuns <span class="sym">=</span> Functions<span class="sym">(</span>AD<span class="sym">)

</span><span class="kwa">let</span> mysqrt x <span class="sym">=</span> AD.<span class="sym">(-) (</span>ADFuns.sqr x<span class="sym">) (</span>AD.mk <span class="num">2</span><span class="sym">)
</span><span class="kwa">let</span> <span class="sym">() =
</span>  <span class="kwa">let</span> f1 <span class="sym">=</span> FL64.mk <span class="num">1</span> <span class="kwa">in
</span>  print_string<span class="sym">(</span><span class="str">&quot;rational_taylor_series: &quot;</span> ^
		 <span class="sym">(</span>AD.pr <span class="sym">(</span>ADFuns.rat <span class="sym">(</span>AD.vr <span class="sym">(</span>FL64.mf <span class="num">0.25</span><span class="sym">)</span> f1<span class="sym">)))</span> ^ <span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span><span class="sym">);
</span>  print_string<span class="sym">(</span><span class="str">&quot;newton-sqrt_2: &quot;</span> ^ <span class="sym">(</span>FL64.pr <span class="sym">(</span>AD.newton f1 <span class="num">10</span> mysqrt<span class="sym">))</span> ^ <span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span><span class="sym">);
</span>  print_string<span class="sym">(</span><span class="str">&quot;newton-rat: &quot;</span> ^
		 <span class="sym">(</span>FL64.pr <span class="sym">(</span>AD.newton <span class="sym">(</span>FL64.mk <span class="sym">(-</span><span class="num">1</span><span class="sym">))</span> <span class="num">6</span> ADFuns.rat<span class="sym">))</span> ^ <span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span><span class="sym">)

</span><span class="kwa">let</span> n <span class="sym">=</span> int_of_string<span class="sym">(</span>Array.get Sys.argv <span class="num">1</span><span class="sym">)
</span><span class="kwa">let</span> pfl64 <span class="sym">=</span> FL64.mf <span class="num">0.02
</span><span class="kwa">let</span> pfl <span class="sym">=</span> FL.mf <span class="num">0.02
</span><span class="kwa">module</span> I1 <span class="sym">=</span> Integrate_functions<span class="sym">(</span>FL64<span class="sym">)
</span><span class="kwa">module</span> I2 <span class="sym">=</span> Integrate_functions<span class="sym">(</span>FL<span class="sym">)
</span><span class="kwa">let</span> <span class="sym">() =
</span>  I1.integrate_functions pfl64 <span class="sym">(</span>n<span class="sym">*</span><span class="num">4</span><span class="sym">);
</span>  I2.integrate_functions pfl n

<span class="kwa">module</span> CFL64 <span class="sym">=</span> C<span class="sym">(</span>FL64<span class="sym">)
</span><span class="kwa">module</span> CFL <span class="sym">=</span> C<span class="sym">(</span>FL<span class="sym">)
</span><span class="kwa">module</span> I3 <span class="sym">=</span> Integrate_functions<span class="sym">(</span>CFL64<span class="sym">)
</span><span class="kwa">module</span> I4 <span class="sym">=</span> Integrate_functions<span class="sym">(</span>CFL<span class="sym">)
</span><span class="kwa">let</span> <span class="sym">() =
</span>  I3.integrate_functions <span class="sym">(</span>CFL64.mc pfl64 pfl64<span class="sym">)</span> n<span class="sym">;
</span>  I4.integrate_functions <span class="sym">(</span>CFL.mc pfl pfl<span class="sym">)</span> n
