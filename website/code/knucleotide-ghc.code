<span class="slc">-- knucleotide.hs</span>
<span class="slc">--</span>
<span class="slc">-- The Great Computer Language Shootout</span>
<span class="slc">-- http://shootout.alioth.debian.org/</span>
<span class="slc">--</span>
<span class="slc">-- Contributed by Einar Karttunen</span>
<span class="slc">-- This is a purely functional solution to the problem.</span>
<span class="slc">-- An alternative which keeps a mutable table of occurences would be faster.</span>
<span class="slc">--</span>

<span class="kwa">import</span> Data.<span class="kwb">Char</span>
<span class="kwa">import</span> Data.List
<span class="kwa">import</span> Numeric

counts <span class="sym">::</span> <span class="kwb">Int</span> <span class="sym">-&gt;</span> String <span class="sym">-&gt; [</span>String<span class="sym">]</span>
counts k dna <span class="sym">=</span> filter <span class="sym">(</span>not.null<span class="sym">)</span> $ map <span class="sym">(</span>taker k <span class="sym">[]) (</span>tails dna<span class="sym">)</span>
    <span class="kwa">where</span> taker <span class="num">0</span> acc _      <span class="sym">=</span> reverse acc
          taker i acc <span class="sym">(</span>x<span class="sym">:</span>xs<span class="sym">) =</span> taker <span class="sym">(</span>i<span class="sym">-</span><span class="num">1</span><span class="sym">) (</span>x<span class="sym">:</span>acc<span class="sym">)</span> xs
          taker i acc <span class="sym">[]     = []</span>

writeFrequencies k dna <span class="sym">=</span>
  <span class="kwa">let</span> cnt <span class="sym">=</span> counts k dna
      tot <span class="sym">::</span> <span class="kwb">Float</span>
      tot <span class="sym">=</span> fromIntegral $ length cnt
      frr <span class="sym">=</span> map <span class="sym">(</span>\ks <span class="sym">-&gt; (</span>head ks<span class="sym">,</span> fromIntegral <span class="sym">(</span>length ks<span class="sym">) *</span> <span class="num">100</span> <span class="sym">/</span> tot<span class="sym">))</span> $ group $ sort cnt
      frq <span class="sym">=</span> sortBy <span class="sym">(</span>\<span class="sym">(</span>_<span class="sym">,</span>x<span class="sym">) (</span>_<span class="sym">,</span>y<span class="sym">) -&gt;</span> y `compare` x<span class="sym">)</span> frr
      <span class="kwa">in</span> mapM_ <span class="sym">(</span>\<span class="sym">(</span>k<span class="sym">,</span>f<span class="sym">) -&gt;</span> putStr <span class="sym">(</span>k<span class="sym">++</span><span class="str">&quot; &quot;</span><span class="sym">++</span>showFFloat <span class="sym">(</span>Just <span class="num">3</span><span class="sym">)</span> f <span class="str">&quot;\n&quot;</span><span class="sym">))</span> frq <span class="sym">&gt;&gt;</span> putStrLn <span class="str">&quot;&quot;</span>

writeCount sq dna <span class="sym">=</span> putStrLn <span class="sym">(</span>show cnt <span class="sym">++</span> <span class="str">&quot;\t&quot;</span> <span class="sym">++</span> sq<span class="sym">)</span>
    <span class="kwa">where</span> cnt <span class="sym">=</span> length $ filter <span class="sym">(</span>\c <span class="sym">-&gt;</span> c<span class="sym">==</span>sq<span class="sym">)</span> $ counts <span class="sym">(</span>length sq<span class="sym">)</span> dna

dnaThree <span class="sym">=</span> process <span class="sym">=&lt;&lt;</span> getContents
    <span class="kwa">where</span> process ls  <span class="sym">=</span> return $ ul $ takeNorm $ tail $ dropComment $ dropOther $ lines ls
          dropOther   <span class="sym">=</span> dropWhile <span class="sym">(</span>\str <span class="sym">-&gt;</span> not <span class="sym">(</span><span class="str">&quot;&gt;THREE&quot;</span> `isPrefixOf` str<span class="sym">))</span>
          dropComment <span class="sym">=</span> dropWhile <span class="sym">(</span>\str <span class="sym">-&gt;</span> head str <span class="sym">==</span> <span class="str">';'</span><span class="sym">)</span>
          takeNorm    <span class="sym">=</span> takeWhile <span class="sym">(</span>\str <span class="sym">-&gt;</span> head str <span class="sym">/=</span> <span class="str">'&gt;'</span><span class="sym">)</span>
          ul str      <span class="sym">=</span> map toUpper $ concat str

main <span class="sym">=</span> <span class="kwa">do</span> three <span class="sym">&lt;-</span> dnaThree
          writeFrequencies <span class="num">1</span> three
          writeFrequencies <span class="num">2</span> three
          mapM_ <span class="sym">(</span>\k <span class="sym">-&gt;</span> writeCount k three<span class="sym">) [</span><span class="str">&quot;GGT&quot;</span><span class="sym">,</span> <span class="str">&quot;GGTA&quot;</span><span class="sym">,</span> <span class="str">&quot;GGTATT&quot;</span><span class="sym">,</span> <span class="str">&quot;GGTATTTTAATT&quot;</span><span class="sym">,</span> <span class="str">&quot;GGTATTTTAATTTATAGT&quot;</span><span class="sym">]</span>
