<span class="com">/* The Great Computer Language Shootout
   http://shootout.alioth.debian.org/

   contributed by Dennis Decker Jensen
              and Vladimir Zabrodsky (the sqrt-function)

Vladimir Zabrodsky has a &quot;Album of Algorithms and Techniques for
Standard Rexx&quot; containing, among other things, the sqrt-function,
which has been slightly edited for this program:

http://www.geocities.com/SiliconValley/Garage/3323/aat/a_sqrt.html

Many Rexx (e.g. BRexx) implement mathematical functions not in
the standard, but Regina doesn't (yet).

*/</span>

numeric digits <span class="num">12</span> <span class="com">/* 15 digits precision isn't needed for this job */</span>
arg n
PARSE VALUE <span class="num">0.0 0.0</span> n n WITH vBv vv u<span class="num">.0</span> v<span class="num">.0

</span><span class="kwa">do</span> i <span class="sym">=</span> <span class="num">1</span> <span class="kwa">for</span> u<span class="num">.0</span><span class="sym">;</span> u<span class="sym">.</span>i <span class="sym">=</span> <span class="num">1.0</span><span class="sym">;</span> end
<span class="kwa">do</span> <span class="num">10
</span>	call mulAtAv <span class="str">'u.'</span><span class="sym">,</span> <span class="str">'v.'</span>
	call mulAtAv <span class="str">'v.'</span><span class="sym">,</span> <span class="str">'u.'</span>
end

<span class="kwa">do</span> i <span class="sym">=</span> <span class="num">1</span> <span class="kwa">for</span> u<span class="num">.0
</span>	vBv <span class="sym">=</span> vBv <span class="sym">+</span> u<span class="sym">.</span>i<span class="sym">*</span>v<span class="sym">.</span>i
	vv <span class="sym">=</span> vv <span class="sym">+</span> v<span class="sym">.</span>i<span class="sym">*</span>v<span class="sym">.</span>i
end

say format<span class="sym">(</span>sqrt<span class="sym">(</span>vBv<span class="sym">/</span>vv<span class="sym">), ,</span> <span class="num">9</span><span class="sym">);
</span>exit

sqrt<span class="sym">:</span> procedure
parse arg N<span class="sym">,</span> P
<span class="kwa">if</span> P \<span class="sym">=</span> <span class="str">&quot;&quot;</span> then numeric digits P
parse value format<span class="sym">(</span>N<span class="sym">, , , ,</span> <span class="num">0</span><span class="sym">)</span> with N <span class="str">&quot;E&quot;</span> Exp
	<span class="kwa">if</span> Exp <span class="sym">=</span> <span class="str">&quot;&quot;</span> then Exp <span class="sym">=</span> <span class="num">0
</span><span class="kwa">if</span> <span class="sym">(</span>Exp <span class="slc">// 2) \= 0 then /* Odd exponent? */
</span>	<span class="kwa">if</span> Exp <span class="sym">&gt;</span> <span class="num">0
</span>		then parse value N<span class="sym">*</span><span class="num">10</span> Exp<span class="num">-1</span> with N Exp
		<span class="kwa">else</span> parse value N<span class="sym">/</span><span class="num">10</span> Exp<span class="sym">+</span><span class="num">1</span> with N Exp
X <span class="sym">=</span> <span class="num">0.5</span> <span class="sym">* (</span>N <span class="sym">+</span> <span class="num">1</span><span class="sym">)</span> <span class="com">/* a &quot;reasonable&quot; start guess */</span>
<span class="kwa">do</span> forever
	NewX <span class="sym">=</span> <span class="num">0.5</span> <span class="sym">* (</span>X <span class="sym">+</span> N<span class="sym">/</span>X<span class="sym">)
</span>	<span class="kwa">if</span> X <span class="sym">=</span> NewX then <span class="kwa">return</span> X <span class="sym">*</span> <span class="num">10</span><span class="sym">**(</span>Exp <span class="sym">%</span> <span class="num">2</span><span class="sym">)
</span>	X <span class="sym">=</span> NewX
end

A<span class="sym">:</span> procedure
parse arg i<span class="sym">,</span> j
parse value i<span class="num">-1</span> j<span class="num">-1</span> with i j <span class="com">/* calculation of A is zerobased */</span>
<span class="kwa">return</span> <span class="num">1</span> <span class="sym">/ ((</span>i<span class="sym">+</span>j<span class="sym">)*(</span>i<span class="sym">+</span>j<span class="sym">+</span><span class="num">1</span><span class="sym">) /</span> <span class="num">2</span> <span class="sym">+</span> i<span class="sym">+</span><span class="num">1</span><span class="sym">)

</span>mulAv<span class="sym">:
</span>parse arg v<span class="sym">,</span> Av
procedure expose <span class="sym">(</span>v<span class="sym">) (</span>Av<span class="sym">)
</span>call value Av<span class="sym">||</span><span class="num">0</span><span class="sym">,</span> value<span class="sym">(</span>v<span class="sym">||</span><span class="num">0</span><span class="sym">)
</span><span class="kwa">do</span> i <span class="sym">=</span> <span class="num">1</span> <span class="kwa">for</span> value<span class="sym">(</span>Av<span class="sym">||</span><span class="num">0</span><span class="sym">)
</span>	call value Av<span class="sym">||</span>i<span class="sym">,</span> <span class="num">0.0
</span>	<span class="kwa">do</span> j <span class="sym">=</span> <span class="num">1</span> <span class="kwa">for</span> value<span class="sym">(</span>v<span class="sym">||</span><span class="num">0</span><span class="sym">)
</span>		call value Av<span class="sym">||</span>i<span class="sym">, ,
</span>				value<span class="sym">(</span>Av<span class="sym">||</span>i<span class="sym">) +</span> A<span class="sym">(</span>i<span class="sym">,</span> j<span class="sym">) *</span> value<span class="sym">(</span>v<span class="sym">||</span>j<span class="sym">)
</span>	end
end
<span class="kwa">return

</span>mulAtv<span class="sym">:
</span>parse arg v<span class="sym">,</span> Atv
procedure expose <span class="sym">(</span>v<span class="sym">) (</span>Atv<span class="sym">)
</span>call value Atv<span class="sym">||</span><span class="num">0</span><span class="sym">,</span> value<span class="sym">(</span>v<span class="sym">||</span><span class="num">0</span><span class="sym">)
</span><span class="kwa">do</span> i <span class="sym">=</span> <span class="num">1</span> <span class="kwa">for</span> value<span class="sym">(</span>Atv<span class="sym">||</span><span class="num">0</span><span class="sym">)
</span>	call value Atv<span class="sym">||</span>i<span class="sym">,</span> <span class="num">0.0
</span>	<span class="kwa">do</span> j <span class="sym">=</span> <span class="num">1</span> <span class="kwa">for</span> value<span class="sym">(</span>v<span class="sym">||</span><span class="num">0</span><span class="sym">)
</span>		call value Atv<span class="sym">||</span>i<span class="sym">, ,
</span>				 value<span class="sym">(</span>Atv<span class="sym">||</span>i<span class="sym">) +</span> A<span class="sym">(</span>j<span class="sym">,</span> i<span class="sym">) *</span> value<span class="sym">(</span>v<span class="sym">||</span>j<span class="sym">)
</span>	end
end
<span class="kwa">return

</span>mulAtAv<span class="sym">:
</span>parse arg v<span class="sym">,</span> AtAv
procedure expose <span class="sym">(</span>v<span class="sym">) (</span>AtAv<span class="sym">)
</span>call mulAv v<span class="sym">,</span> <span class="str">'tmp.'</span>
call mulAtv <span class="str">'tmp.'</span><span class="sym">,</span> AtAv
<span class="kwa">return
</span>
