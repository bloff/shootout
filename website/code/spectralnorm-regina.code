<span class="com">/* The Great Computer Language Shootout</span>
<span class="com">   http://shootout.alioth.debian.org/</span>
<span class="com"></span>
<span class="com">   contributed by Dennis Decker Jensen</span>
<span class="com">              and Vladimir Zabrodsky (the sqrt-function)</span>
<span class="com"></span>
<span class="com">Vladimir Zabrodsky has a &quot;Album of Algorithms and Techniques for</span>
<span class="com">Standard Rexx&quot; containing, among other things, the sqrt-function,</span>
<span class="com">which has been slightly edited for this program:</span>
<span class="com"></span>
<span class="com">http://www.geocities.com/SiliconValley/Garage/3323/aat/a_sqrt.html</span>
<span class="com"></span>
<span class="com">Many Rexx (e.g. BRexx) implement mathematical functions not in</span>
<span class="com">the standard, but Regina doesn't (yet).</span>
<span class="com"></span>
<span class="com">*/</span>

<span class="kwa">numeric digits</span> <span class="num">12</span> <span class="com">/* 15 digits precision isn't needed for this job */</span>
<span class="kwa">arg</span> n
<span class="kwa">PARSE</span> <span class="kwb">VALUE</span> <span class="num">0.0 0.0</span> n n <span class="kwa">WITH</span> vBv vv u<span class="num">.0</span> v<span class="num">.0</span>

<span class="kwa">do</span> i <span class="sym">=</span> <span class="num">1</span> <span class="kwa">for</span> u<span class="num">.0</span><span class="sym">;</span> u.i <span class="sym">=</span> <span class="num">1.0</span><span class="sym">;</span> <span class="kwa">end</span>
<span class="kwa">do</span> <span class="num">10</span>
	<span class="kwa">call</span> mulAtAv <span class="str">'u.'</span><span class="sym">,</span> <span class="str">'v.'</span>
	<span class="kwa">call</span> mulAtAv <span class="str">'v.'</span><span class="sym">,</span> <span class="str">'u.'</span>
<span class="kwa">end</span>

<span class="kwa">do</span> i <span class="sym">=</span> <span class="num">1</span> <span class="kwa">for</span> u<span class="num">.0</span>
	vBv <span class="sym">=</span> vBv <span class="sym">+</span> u.i<span class="sym">*</span>v.i
	vv <span class="sym">=</span> vv <span class="sym">+</span> v.i<span class="sym">*</span>v.i
<span class="kwa">end</span>

<span class="kwa">say</span> <span class="kwb">format</span><span class="sym">(</span>sqrt<span class="sym">(</span>vBv<span class="sym">/</span>vv<span class="sym">), ,</span> <span class="num">9</span><span class="sym">);</span>
<span class="kwa">exit</span>

sqrt<span class="sym">:</span> <span class="kwa">procedure</span>
<span class="kwa">parse arg</span> N<span class="sym">,</span> P
<span class="kwa">if</span> P \<span class="sym">=</span> <span class="str">&quot;&quot;</span> <span class="kwa">then numeric digits</span> P
<span class="kwa">parse</span> <span class="kwb">value format</span><span class="sym">(</span>N<span class="sym">, , , ,</span> <span class="num">0</span><span class="sym">)</span> <span class="kwa">with</span> N <span class="str">&quot;E&quot;</span> Exp
	<span class="kwa">if</span> Exp <span class="sym">=</span> <span class="str">&quot;&quot;</span> <span class="kwa">then</span> Exp <span class="sym">=</span> <span class="num">0</span>
<span class="kwa">if</span> <span class="sym">(</span>Exp <span class="sym">//</span> <span class="num">2</span><span class="sym">)</span> \<span class="sym">=</span> <span class="num">0</span> <span class="kwa">then</span> <span class="com">/* Odd exponent? */</span>
	<span class="kwa">if</span> Exp <span class="sym">&gt;</span> <span class="num">0</span>
		<span class="kwa">then parse</span> <span class="kwb">value</span> N<span class="sym">*</span><span class="num">10</span> Exp<span class="sym">-</span><span class="num">1</span> <span class="kwa">with</span> N Exp
		<span class="kwa">else parse</span> <span class="kwb">value</span> N<span class="sym">/</span><span class="num">10</span> Exp<span class="sym">+</span><span class="num">1</span> <span class="kwa">with</span> N Exp
X <span class="sym">=</span> <span class="num">0.5</span> <span class="sym">* (</span>N <span class="sym">+</span> <span class="num">1</span><span class="sym">)</span> <span class="com">/* a &quot;reasonable&quot; start guess */</span>
<span class="kwa">do forever</span>
	NewX <span class="sym">=</span> <span class="num">0.5</span> <span class="sym">* (</span>X <span class="sym">+</span> N<span class="sym">/</span>X<span class="sym">)</span>
	<span class="kwa">if</span> X <span class="sym">=</span> NewX <span class="kwa">then return</span> X <span class="sym">*</span> <span class="num">10</span><span class="sym">**(</span>Exp <span class="sym">%</span> <span class="num">2</span><span class="sym">)</span>
	X <span class="sym">=</span> NewX
<span class="kwa">end</span>

A<span class="sym">:</span> <span class="kwa">procedure</span>
<span class="kwa">parse arg</span> i<span class="sym">,</span> j
<span class="kwa">parse</span> <span class="kwb">value</span> i<span class="sym">-</span><span class="num">1</span> j<span class="sym">-</span><span class="num">1</span> <span class="kwa">with</span> i j <span class="com">/* calculation of A is zerobased */</span>
<span class="kwa">return</span> <span class="num">1</span> <span class="sym">/ ((</span>i<span class="sym">+</span>j<span class="sym">)*(</span>i<span class="sym">+</span>j<span class="sym">+</span><span class="num">1</span><span class="sym">) /</span> <span class="num">2</span> <span class="sym">+</span> i<span class="sym">+</span><span class="num">1</span><span class="sym">)</span>

mulAv<span class="sym">:</span>
<span class="kwa">parse arg</span> v<span class="sym">,</span> Av
<span class="kwa">procedure expose</span> <span class="sym">(</span>v<span class="sym">) (</span>Av<span class="sym">)</span>
<span class="kwa">call</span> <span class="kwb">value</span> Av<span class="sym">||</span><span class="num">0</span><span class="sym">,</span> <span class="kwb">value</span><span class="sym">(</span>v<span class="sym">||</span><span class="num">0</span><span class="sym">)</span>
<span class="kwa">do</span> i <span class="sym">=</span> <span class="num">1</span> <span class="kwa">for</span> <span class="kwb">value</span><span class="sym">(</span>Av<span class="sym">||</span><span class="num">0</span><span class="sym">)</span>
	<span class="kwa">call</span> <span class="kwb">value</span> Av<span class="sym">||</span>i<span class="sym">,</span> <span class="num">0.0</span>
	<span class="kwa">do</span> j <span class="sym">=</span> <span class="num">1</span> <span class="kwa">for</span> <span class="kwb">value</span><span class="sym">(</span>v<span class="sym">||</span><span class="num">0</span><span class="sym">)</span>
		<span class="kwa">call</span> <span class="kwb">value</span> Av<span class="sym">||</span>i<span class="sym">, ,</span>
				<span class="kwb">value</span><span class="sym">(</span>Av<span class="sym">||</span>i<span class="sym">) +</span> A<span class="sym">(</span>i<span class="sym">,</span> j<span class="sym">) *</span> <span class="kwb">value</span><span class="sym">(</span>v<span class="sym">||</span>j<span class="sym">)</span>
	<span class="kwa">end</span>
<span class="kwa">end</span>
<span class="kwa">return</span>

mulAtv<span class="sym">:</span>
<span class="kwa">parse arg</span> v<span class="sym">,</span> Atv
<span class="kwa">procedure expose</span> <span class="sym">(</span>v<span class="sym">) (</span>Atv<span class="sym">)</span>
<span class="kwa">call</span> <span class="kwb">value</span> Atv<span class="sym">||</span><span class="num">0</span><span class="sym">,</span> <span class="kwb">value</span><span class="sym">(</span>v<span class="sym">||</span><span class="num">0</span><span class="sym">)</span>
<span class="kwa">do</span> i <span class="sym">=</span> <span class="num">1</span> <span class="kwa">for</span> <span class="kwb">value</span><span class="sym">(</span>Atv<span class="sym">||</span><span class="num">0</span><span class="sym">)</span>
	<span class="kwa">call</span> <span class="kwb">value</span> Atv<span class="sym">||</span>i<span class="sym">,</span> <span class="num">0.0</span>
	<span class="kwa">do</span> j <span class="sym">=</span> <span class="num">1</span> <span class="kwa">for</span> <span class="kwb">value</span><span class="sym">(</span>v<span class="sym">||</span><span class="num">0</span><span class="sym">)</span>
		<span class="kwa">call</span> <span class="kwb">value</span> Atv<span class="sym">||</span>i<span class="sym">, ,</span>
				 <span class="kwb">value</span><span class="sym">(</span>Atv<span class="sym">||</span>i<span class="sym">) +</span> A<span class="sym">(</span>j<span class="sym">,</span> i<span class="sym">) *</span> <span class="kwb">value</span><span class="sym">(</span>v<span class="sym">||</span>j<span class="sym">)</span>
	<span class="kwa">end</span>
<span class="kwa">end</span>
<span class="kwa">return</span>

mulAtAv<span class="sym">:</span>
<span class="kwa">parse arg</span> v<span class="sym">,</span> AtAv
<span class="kwa">procedure expose</span> <span class="sym">(</span>v<span class="sym">) (</span>AtAv<span class="sym">)</span>
<span class="kwa">call</span> mulAv v<span class="sym">,</span> <span class="str">'tmp.'</span>
<span class="kwa">call</span> mulAtv <span class="str">'tmp.'</span><span class="sym">,</span> AtAv
<span class="kwa">return</span>

