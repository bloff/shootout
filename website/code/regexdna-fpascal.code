<span class="com">{ The Computer Language Benchmarks Game</span>
<span class="com">  http://shootout.alioth.debian.org</span>
<span class="com"></span>
<span class="com">  contributed by Steve Fisher</span>
<span class="com"></span>
<span class="com">  compile with</span>
<span class="com">  fpc -O3 regex-dna.pp</span>
<span class="com">}</span>

<span class="kwa">uses</span> regexpr<span class="sym">,</span> strutils<span class="sym">;</span>

<span class="kwa">function</span> <span class="kwd">replace_matches</span><span class="sym">(</span> <span class="kwa">const</span> target<span class="sym">:</span> pchar<span class="sym">;</span>  <span class="kwa">const</span> repl<span class="sym">:</span> pchar<span class="sym">;</span>
                <span class="kwa">const</span> str<span class="sym">:</span> ansistring<span class="sym">;</span>  <span class="kwa">var</span> dest<span class="sym">:</span> ansistring <span class="sym">):</span> <span class="kwb">longint</span><span class="sym">;</span>
<span class="kwa">var</span>
  engine <span class="sym">:</span> tRegexprEngine<span class="sym">;</span>
  substr <span class="sym">:</span> ansistring<span class="sym">;</span>
  count<span class="sym">,</span> index<span class="sym">,</span> size <span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;</span>
<span class="kwa">begin</span>
  <span class="kwa">if not</span> <span class="kwd">GenerateRegExprEngine</span><span class="sym">(</span> target<span class="sym">, [],</span> engine<span class="sym">)</span> <span class="kwa">then</span>
  <span class="kwa">begin</span>
    <span class="kwd">writeln</span><span class="sym">(</span> <span class="str">'Failed to generate regex. engine for &quot;'</span><span class="sym">,</span>target<span class="sym">,</span><span class="str">'&quot;.'</span> <span class="sym">);</span>
    <span class="kwd">halt</span><span class="sym">(</span><span class="num">1</span><span class="sym">)</span>
  <span class="kwa">end</span><span class="sym">;</span>
  count <span class="sym">:=</span> <span class="num">0</span><span class="sym">;</span>
  dest <span class="sym">:=</span> <span class="str">''</span><span class="sym">;</span>
  substr <span class="sym">:=</span> str<span class="sym">;</span>
  <span class="kwa">while</span> <span class="kwd">length</span><span class="sym">(</span>substr<span class="sym">) &gt;</span> <span class="num">0</span> <span class="kwa">do</span>
  <span class="kwa">begin</span>
    <span class="kwa">if</span> <span class="kwd">RegExprPos</span><span class="sym">(</span>engine<span class="sym">,</span> <span class="kwd">pchar</span><span class="sym">(</span>substr<span class="sym">),</span> index<span class="sym">,</span> size <span class="sym">)</span> <span class="kwa">then</span>
    <span class="kwa">begin</span>
      count <span class="sym">+=</span> <span class="num">1</span><span class="sym">;</span>
      dest <span class="sym">+=</span> <span class="kwd">ansiLeftStr</span><span class="sym">(</span> substr<span class="sym">,</span> index<span class="sym">) +</span> repl<span class="sym">;</span>
      substr <span class="sym">:=</span> <span class="kwd">ansiRightStr</span><span class="sym">(</span>substr<span class="sym">,</span><span class="kwd">length</span><span class="sym">(</span>substr<span class="sym">)-</span>index<span class="sym">-</span>size<span class="sym">);</span>
    <span class="kwa">end</span>
    <span class="kwa">else</span>
      break
  <span class="kwa">end</span><span class="sym">;</span>
  <span class="kwd">DestroyRegExprEngine</span><span class="sym">(</span> engine <span class="sym">);</span>
  dest <span class="sym">+=</span> substr<span class="sym">;</span>
  <span class="kwd">exit</span><span class="sym">(</span>count<span class="sym">)</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">function</span> <span class="kwd">count_matches</span><span class="sym">(</span> target<span class="sym">:</span> pchar<span class="sym">;</span> <span class="kwa">const</span> str<span class="sym">:</span> ansistring <span class="sym">):</span> <span class="kwb">longint</span><span class="sym">;</span>
<span class="kwa">var</span>
  engine <span class="sym">:</span> tRegexprEngine<span class="sym">;</span>
  substr <span class="sym">:</span> ansistring<span class="sym">;</span>
  count<span class="sym">,</span> index<span class="sym">,</span> size <span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;</span>
<span class="kwa">begin</span>
  <span class="kwa">if not</span> <span class="kwd">GenerateRegExprEngine</span><span class="sym">(</span> target<span class="sym">, [</span>ref_caseinsensitive<span class="sym">],</span> engine<span class="sym">)</span> <span class="kwa">then</span>
  <span class="kwa">begin</span>
    <span class="kwd">writeln</span><span class="sym">(</span> <span class="str">'Failed to generate regex. engine for &quot;'</span><span class="sym">,</span>target<span class="sym">,</span><span class="str">'&quot;.'</span> <span class="sym">);</span>
    <span class="kwd">halt</span><span class="sym">(</span><span class="num">1</span><span class="sym">)</span>
  <span class="kwa">end</span><span class="sym">;</span>
  count <span class="sym">:=</span> <span class="num">0</span><span class="sym">;</span>
  substr <span class="sym">:=</span> str<span class="sym">;</span>
  <span class="kwa">while</span> <span class="kwd">length</span><span class="sym">(</span>substr<span class="sym">) &gt;</span> <span class="num">0</span> <span class="kwa">do</span>
  <span class="kwa">begin</span>
    <span class="kwa">if</span> <span class="kwd">RegExprPos</span><span class="sym">(</span>engine<span class="sym">,</span> <span class="kwd">pchar</span><span class="sym">(</span>substr<span class="sym">),</span> index<span class="sym">,</span> size <span class="sym">)</span> <span class="kwa">then</span>
    <span class="kwa">begin</span>
      count <span class="sym">+=</span> <span class="num">1</span><span class="sym">;</span>
      substr <span class="sym">:=</span> <span class="kwd">ansiRightStr</span><span class="sym">(</span>substr<span class="sym">,</span><span class="kwd">length</span><span class="sym">(</span>substr<span class="sym">)-</span>index<span class="sym">-</span>size<span class="sym">);</span>
    <span class="kwa">end</span>
    <span class="kwa">else</span>
      break
  <span class="kwa">end</span><span class="sym">;</span>
  <span class="kwd">DestroyRegExprEngine</span><span class="sym">(</span> engine <span class="sym">);</span>
  <span class="kwd">exit</span><span class="sym">(</span>count<span class="sym">)</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">const</span>
  patterns <span class="sym">:</span> <span class="kwa">array</span><span class="sym">[</span><span class="num">1</span>.<span class="num">.9</span><span class="sym">]</span> <span class="kwa">of</span> pchar <span class="sym">=</span>
    <span class="sym">(</span>
      <span class="str">'(agggtaaa)|(tttaccct)'</span><span class="sym">,</span>
      <span class="str">'([cgt]gggtaaa)|(tttaccc[acg])'</span><span class="sym">,</span>
      <span class="str">'(a[act]ggtaaa)|(tttacc[agt]t)'</span><span class="sym">,</span>
      <span class="str">'(ag[act]gtaaa)|(tttac[agt]ct)'</span><span class="sym">,</span>
      <span class="str">'(agg[act]taaa)|(ttta[agt]cct)'</span><span class="sym">,</span>
      <span class="str">'(aggg[acg]aaa)|(ttt[cgt]ccct)'</span><span class="sym">,</span>
      <span class="str">'(agggt[cgt]aa)|(tt[acg]accct)'</span><span class="sym">,</span>
      <span class="str">'(agggta[cgt]a)|(t[acg]taccct)'</span><span class="sym">,</span>
      <span class="str">'(agggtaa[cgt])|([acg]ttaccct)'</span>
    <span class="sym">);</span>
  replacements <span class="sym">:</span> <span class="kwa">array</span><span class="sym">[</span><span class="num">1</span>.<span class="num">.11</span><span class="sym">,</span><span class="num">1</span>.<span class="num">.2</span><span class="sym">]</span> <span class="kwa">of</span> pchar <span class="sym">=</span>
  <span class="sym">(</span>
    <span class="sym">(</span><span class="str">'B'</span><span class="sym">,</span> <span class="str">'(c|g|t)'</span><span class="sym">), (</span><span class="str">'D'</span><span class="sym">,</span> <span class="str">'(a|g|t)'</span><span class="sym">), (</span><span class="str">'H'</span><span class="sym">,</span> <span class="str">'(a|c|t)'</span><span class="sym">), (</span><span class="str">'K'</span><span class="sym">,</span> <span class="str">'(g|t)'</span><span class="sym">),</span>
    <span class="sym">(</span><span class="str">'M'</span><span class="sym">,</span> <span class="str">'(a|c)'</span><span class="sym">), (</span><span class="str">'N'</span><span class="sym">,</span> <span class="str">'(a|c|g|t)'</span><span class="sym">), (</span><span class="str">'R'</span><span class="sym">,</span> <span class="str">'(a|g)'</span><span class="sym">), (</span><span class="str">'S'</span><span class="sym">,</span> <span class="str">'(c|t)'</span><span class="sym">),</span>
    <span class="sym">(</span><span class="str">'V'</span><span class="sym">,</span> <span class="str">'(a|c|g)'</span><span class="sym">), (</span><span class="str">'W'</span><span class="sym">,</span> <span class="str">'(a|t)'</span><span class="sym">), (</span><span class="str">'Y'</span><span class="sym">,</span> <span class="str">'(c|t)'</span><span class="sym">)</span>
  <span class="sym">);</span>


<span class="kwa">var</span>
  pattern <span class="sym">:</span> pchar<span class="sym">;</span>
  sequence<span class="sym">,</span> new_seq <span class="sym">:</span> ansiString<span class="sym">;</span>
  line<span class="sym">,</span> tmp<span class="sym">:</span> <span class="kwa">string</span><span class="sym">[</span><span class="num">255</span><span class="sym">];</span>
  letter<span class="sym">,</span> repl <span class="sym">:</span> pchar<span class="sym">;</span>
  i<span class="sym">,</span> count<span class="sym">,</span> init_length<span class="sym">,</span> clean_length<span class="sym">,</span> reps <span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;</span>

<span class="kwa">begin</span>
  sequence <span class="sym">:=</span> <span class="str">''</span><span class="sym">;</span>
  init_length <span class="sym">:=</span> <span class="num">0</span><span class="sym">;</span>
  <span class="kwa">while not</span> eof <span class="kwa">do</span>
  <span class="kwa">begin</span>
    <span class="kwd">readln</span><span class="sym">(</span> line <span class="sym">);</span>
    init_length <span class="sym">+=</span> <span class="kwd">length</span><span class="sym">(</span> line <span class="sym">) +</span> <span class="num">1</span><span class="sym">;</span>
    <span class="kwa">if</span> line<span class="sym">[</span><span class="num">1</span><span class="sym">] &lt;&gt;</span> <span class="str">'&gt;'</span> <span class="kwa">then</span>
      sequence <span class="sym">:=</span> sequence <span class="sym">+</span> line<span class="sym">;</span>
  <span class="kwa">end</span><span class="sym">;</span>
  clean_length <span class="sym">:=</span> <span class="kwd">length</span><span class="sym">(</span>sequence<span class="sym">);</span>

  <span class="kwa">for</span> i <span class="sym">:=</span> <span class="kwd">low</span><span class="sym">(</span>patterns<span class="sym">)</span> <span class="kwa">to</span> <span class="kwd">high</span><span class="sym">(</span>patterns<span class="sym">)</span> <span class="kwa">do</span>
  <span class="kwa">begin</span>
    pattern <span class="sym">:=</span> patterns<span class="sym">[</span>i<span class="sym">];</span>
    count <span class="sym">:=</span> <span class="kwd">count_matches</span><span class="sym">(</span> pattern<span class="sym">,</span> sequence <span class="sym">);</span>
    tmp <span class="sym">:=</span> <span class="kwd">delChars</span><span class="sym">(</span> <span class="kwd">delChars</span><span class="sym">(</span>pattern<span class="sym">,</span><span class="str">'('</span><span class="sym">),</span> <span class="str">')'</span> <span class="sym">);</span>
    <span class="kwd">writeln</span><span class="sym">(</span> tmp<span class="sym">,</span> <span class="str">' '</span><span class="sym">,</span> count<span class="sym">);</span>
  <span class="kwa">end</span><span class="sym">;</span>


  <span class="slc">//  Replace.</span>
  <span class="kwa">for</span> i <span class="sym">:=</span> <span class="kwd">low</span><span class="sym">(</span>replacements<span class="sym">)</span> <span class="kwa">to</span> <span class="kwd">high</span><span class="sym">(</span>replacements<span class="sym">)</span> <span class="kwa">do</span>
  <span class="kwa">begin</span>
    letter <span class="sym">:=</span> replacements<span class="sym">[</span>i<span class="sym">][</span><span class="num">1</span><span class="sym">];</span>  repl <span class="sym">:=</span> replacements<span class="sym">[</span>i<span class="sym">][</span><span class="num">2</span><span class="sym">];</span>
    reps <span class="sym">:=</span> <span class="kwd">replace_matches</span><span class="sym">(</span>letter<span class="sym">,</span>repl<span class="sym">,</span>sequence<span class="sym">,</span>new_seq<span class="sym">);</span>
    sequence <span class="sym">:=</span> new_seq<span class="sym">;</span>
  <span class="kwa">end</span><span class="sym">;</span>


  writeln<span class="sym">;</span>
  <span class="kwd">writeln</span><span class="sym">(</span> init_length <span class="sym">);</span>
  <span class="kwd">writeln</span><span class="sym">(</span> clean_length <span class="sym">);</span>
  <span class="kwd">writeln</span><span class="sym">(</span> <span class="kwd">length</span><span class="sym">(</span>sequence<span class="sym">) );</span>
<span class="kwa">end</span>.
