<span class="com">(* -*- mode: sml -*-
 * $Id: wordfreq-mlton.code,v 1.7 2005-05-25 07:32:57 bfulgham Exp $
 * http://shootout.alioth.debian.org/
 * from Stephen Weeks
 *
 *)</span>

<span class="kwa">fun</span> incr r <span class="sym">=</span> r <span class="sym">:=</span> <span class="num">1</span> <span class="sym">+ !</span>r
<span class="kwa">val</span> sub <span class="sym">=</span> Array.sub
<span class="kwa">val</span> update <span class="sym">=</span> Array.update

<span class="kwa">signature</span> HASH_SET <span class="sym">=
</span>   <span class="kwa">sig
      type</span> 'a t

      <span class="kwa">val</span> foreach<span class="sym">:</span> 'a t <span class="sym">* (</span>'a <span class="sym">-&gt;</span> unit<span class="sym">) -&gt;</span> unit
      <span class="com">(* lookupOrInsert (s, h, p, f)  looks in the set s for an entry with hash h
       * satisfying predicate p.  If the entry is there, it is returned.
       * Otherwise, the function f is called to create a new entry, which is
       * inserted and returned.
       *)</span>
      <span class="kwa">val</span> lookupOrInsert<span class="sym">:</span> 'a t <span class="sym">*</span> <span class="kwb">word</span> <span class="sym">* (</span>'a <span class="sym">-&gt;</span> <span class="kwb">bool</span><span class="sym">) * (</span>unit <span class="sym">-&gt;</span> 'a<span class="sym">) -&gt;</span> 'a
      <span class="kwa">val</span> new<span class="sym">: {</span>hash<span class="sym">:</span> 'a <span class="sym">-&gt;</span> <span class="kwb">word</span><span class="sym">} -&gt;</span> 'a t
      <span class="kwa">val</span> size<span class="sym">:</span> 'a t <span class="sym">-&gt;</span> <span class="kwb">int
</span>   <span class="kwa">end

structure</span> HashSet<span class="sym">:</span> HASH_SET <span class="sym">=
</span><span class="kwa">struct

datatype</span> 'a t <span class="sym">=
</span>   T <span class="kwa">of</span> <span class="sym">{</span>buckets<span class="sym">:</span> 'a list array ref<span class="sym">,
</span>	 hash<span class="sym">:</span> 'a <span class="sym">-&gt;</span> <span class="kwb">word</span><span class="sym">,
</span>	 mask<span class="sym">:</span> <span class="kwb">word</span> ref<span class="sym">,
</span>	 numItems<span class="sym">:</span> <span class="kwb">int</span> ref<span class="sym">}

</span><span class="kwa">val</span> initialSize<span class="sym">:</span> <span class="kwb">int</span> <span class="sym">=</span> <span class="num">65536
</span><span class="kwa">val</span> initialMask<span class="sym">:</span> <span class="kwb">word</span> <span class="sym">=</span> <span class="kwa">Word</span>.fromInt initialSize <span class="num">- 0w1

</span><span class="kwa">fun</span> 'a new <span class="sym">{</span>hash<span class="sym">}:</span> 'a t <span class="sym">=
</span>   T <span class="sym">{</span>buckets <span class="sym">=</span> ref <span class="sym">(</span>Array.array <span class="sym">(</span>initialSize<span class="sym">, [])),
</span>      hash <span class="sym">=</span> hash<span class="sym">,
</span>      numItems <span class="sym">=</span> ref <span class="num">0</span><span class="sym">,
</span>      mask <span class="sym">=</span> ref initialMask<span class="sym">}

</span><span class="kwa">fun</span> size <span class="sym">(</span>T <span class="sym">{</span>numItems<span class="sym">,</span> ...<span class="sym">}) = !</span>numItems
<span class="kwa">fun</span> numBuckets <span class="sym">(</span>T <span class="sym">{</span>buckets<span class="sym">,</span> ...<span class="sym">}) =</span> Array.length <span class="sym">(!</span>buckets<span class="sym">)

</span><span class="kwa">fun</span> index <span class="sym">(</span>w<span class="sym">:</span> <span class="kwb">word</span><span class="sym">,</span> mask<span class="sym">:</span> <span class="kwb">word</span><span class="sym">):</span> <span class="kwb">int</span> <span class="sym">=
</span>   <span class="kwa">Word</span>.toInt <span class="sym">(</span><span class="kwa">Word</span>.andb <span class="sym">(</span>w<span class="sym">,</span> mask<span class="sym">))

</span><span class="kwa">fun</span> resize <span class="sym">(</span>T <span class="sym">{</span>buckets<span class="sym">,</span> hash<span class="sym">,</span> mask<span class="sym">,</span> ...<span class="sym">},</span> size<span class="sym">:</span> <span class="kwb">int</span><span class="sym">,</span> newMask<span class="sym">:</span> <span class="kwb">word</span><span class="sym">):</span> unit <span class="sym">=
</span>   <span class="kwa">let
      val</span> newBuckets <span class="sym">=</span> Array.array <span class="sym">(</span>size<span class="sym">, [])
</span>   <span class="kwa">in</span> Array.app <span class="sym">(</span><span class="kwa">fn</span> r <span class="sym">=&gt;
</span>		 <span class="kwa">List</span>.app <span class="sym">(</span><span class="kwa">fn</span> a <span class="sym">=&gt;
</span>			       <span class="kwa">let val</span> j <span class="sym">=</span> index <span class="sym">(</span>hash a<span class="sym">,</span> newMask<span class="sym">)
</span>			       <span class="kwa">in</span> Array.update
				  <span class="sym">(</span>newBuckets<span class="sym">,</span> j<span class="sym">,
</span>				   a <span class="sym">::</span> Array.sub <span class="sym">(</span>newBuckets<span class="sym">,</span> j<span class="sym">))
</span>			       <span class="kwa">end</span><span class="sym">)</span> r<span class="sym">) (!</span>buckets<span class="sym">)
      ;</span> buckets <span class="sym">:=</span> newBuckets
      <span class="sym">;</span> mask <span class="sym">:=</span> newMask
   <span class="kwa">end

fun</span> maybeGrow <span class="sym">(</span>s <span class="kwa">as</span> T <span class="sym">{</span>buckets<span class="sym">,</span> mask<span class="sym">,</span> numItems<span class="sym">,</span> ...<span class="sym">}):</span> unit <span class="sym">=
</span>   <span class="kwa">let
      val</span> n <span class="sym">=</span> Array.length <span class="sym">(!</span>buckets<span class="sym">)
</span>   <span class="kwa">in if</span> <span class="sym">!</span>numItems <span class="sym">*</span> <span class="num">4</span> <span class="sym">&gt;</span> n
	 <span class="kwa">then</span> resize <span class="sym">(</span>s<span class="sym">,
</span>		      n <span class="sym">*</span> <span class="num">2</span><span class="sym">,
</span>		      <span class="com">(* The new mask depends on growFactor being 2. *)</span>
		      <span class="kwa">Word</span>.orb <span class="sym">(</span><span class="num">0w1</span><span class="sym">,</span> <span class="kwa">Word</span>.<span class="sym">&lt;&lt; (!</span>mask<span class="sym">,</span> <span class="num">0w1</span><span class="sym">)))
</span>      <span class="kwa">else</span> <span class="sym">()
</span>   <span class="kwa">end

fun</span> peekGen <span class="sym">(</span>T <span class="sym">{</span>buckets <span class="sym">=</span> ref buckets<span class="sym">,</span> mask<span class="sym">,</span> ...<span class="sym">},</span> w<span class="sym">,</span> p<span class="sym">,</span> no<span class="sym">,</span> yes<span class="sym">) =
</span>   <span class="kwa">let
      val</span> j <span class="sym">=</span> index <span class="sym">(</span>w<span class="sym">, !</span>mask<span class="sym">)
</span>      <span class="kwa">val</span> b <span class="sym">=</span> Array.sub <span class="sym">(</span>buckets<span class="sym">,</span> j<span class="sym">)
</span>   <span class="kwa">in case List</span>.find p b <span class="kwa">of
</span>      NONE <span class="sym">=&gt;</span> no <span class="sym">(</span>j<span class="sym">,</span> b<span class="sym">)
    |</span> SOME a <span class="sym">=&gt;</span> yes a
   <span class="kwa">end

fun</span> lookupOrInsert <span class="sym">(</span>table <span class="kwa">as</span> T <span class="sym">{</span>buckets<span class="sym">,</span> numItems<span class="sym">,</span> ...<span class="sym">},</span> w<span class="sym">,</span> p<span class="sym">,</span> f<span class="sym">) =
</span>   <span class="kwa">let
      fun</span> no <span class="sym">(</span>j<span class="sym">,</span> b<span class="sym">) =
</span>	 <span class="kwa">let val</span> a <span class="sym">=</span> f <span class="sym">()
</span>	    <span class="kwa">val</span> _ <span class="sym">=</span> incr numItems
	    <span class="kwa">val</span> _ <span class="sym">=</span> Array.update <span class="sym">(!</span>buckets<span class="sym">,</span> j<span class="sym">,</span> a <span class="sym">::</span> b<span class="sym">)
</span>	    <span class="kwa">val</span> _ <span class="sym">=</span> maybeGrow table
	 <span class="kwa">in</span> a
	 <span class="kwa">end
   in</span> peekGen <span class="sym">(</span>table<span class="sym">,</span> w<span class="sym">,</span> p<span class="sym">,</span> no<span class="sym">,</span> <span class="kwa">fn</span> x <span class="sym">=&gt;</span> x<span class="sym">)
</span>   <span class="kwa">end

fun</span> foreach <span class="sym">(</span>T <span class="sym">{</span>buckets<span class="sym">,</span> ...<span class="sym">},</span> f<span class="sym">) =
</span>   Array.app <span class="sym">(</span><span class="kwa">fn</span> r <span class="sym">=&gt;</span> <span class="kwa">List</span>.app f r<span class="sym">) (!</span>buckets<span class="sym">)

</span><span class="kwa">end

structure</span> Buffer<span class="sym">:
</span>   <span class="kwa">sig
      type</span> t

      <span class="kwa">val</span> add<span class="sym">:</span> t <span class="sym">*</span> <span class="kwa">Word8</span>.<span class="kwb">word</span> <span class="sym">-&gt;</span> unit
      <span class="kwa">val</span> clear<span class="sym">:</span> t <span class="sym">-&gt;</span> unit
      <span class="kwa">val</span> contents<span class="sym">:</span> t <span class="sym">-&gt;</span> <span class="kwb">string
</span>      <span class="kwa">val</span> new<span class="sym">:</span> <span class="kwb">int</span> <span class="sym">-&gt;</span> t
   <span class="kwa">end</span> <span class="sym">=
</span>   <span class="kwa">struct
      datatype</span> t <span class="sym">=</span> T <span class="kwa">of</span> <span class="sym">{</span>elts<span class="sym">:</span> Word8Array.array ref<span class="sym">,
</span>			 size<span class="sym">:</span> <span class="kwb">int</span> ref<span class="sym">}

</span>      <span class="kwa">fun</span> contents <span class="sym">(</span>T <span class="sym">{</span>elts<span class="sym">,</span> size<span class="sym">,</span> ...<span class="sym">}) =
</span>	 Byte.bytesToString
	 <span class="sym">(</span>Word8ArraySlice.vector
	  <span class="sym">(</span>Word8ArraySlice.slice <span class="sym">(!</span>elts<span class="sym">,</span> <span class="num">0</span><span class="sym">,</span> SOME <span class="sym">(!</span>size<span class="sym">))))

</span>      <span class="kwa">fun</span> clear <span class="sym">(</span>T <span class="sym">{</span>size<span class="sym">,</span> ...<span class="sym">}) =</span> size <span class="sym">:=</span> <span class="num">0

</span>      <span class="kwa">fun</span> new <span class="sym">(</span>bufSize<span class="sym">) =
</span>	 T <span class="sym">{</span>elts <span class="sym">=</span> ref <span class="sym">(</span>Word8Array.array <span class="sym">(</span>bufSize<span class="sym">,</span> <span class="num">0w0</span><span class="sym">)),
</span>	    size <span class="sym">=</span> ref <span class="num">0</span><span class="sym">}

</span>      <span class="kwa">fun</span> add <span class="sym">(</span>T <span class="sym">{</span>elts<span class="sym">,</span> size<span class="sym">},</span> x<span class="sym">) =
</span>	 <span class="kwa">let
	    val</span> s <span class="sym">= !</span>size
	    <span class="kwa">val</span> _ <span class="sym">=</span> size <span class="sym">:=</span> s <span class="sym">+</span> <span class="num">1
</span>	    <span class="kwa">val</span> a <span class="sym">= !</span>elts
	    <span class="kwa">val</span> n <span class="sym">=</span> Word8Array.length a
	 <span class="kwa">in
	    if</span> s <span class="sym">=</span> n
	       <span class="kwa">then
		  let
		     val</span> a' <span class="sym">=
</span>			Word8Array.tabulate
			<span class="sym">(</span><span class="num">2</span> <span class="sym">*</span> n<span class="sym">,</span> <span class="kwa">fn</span> i <span class="sym">=&gt;
</span>			 <span class="kwa">if</span> i <span class="sym">&lt;</span> n <span class="kwa">then</span> Word8Array.sub <span class="sym">(</span>a<span class="sym">,</span> i<span class="sym">)</span> <span class="kwa">else</span> <span class="num">0w0</span><span class="sym">)
</span>		     <span class="kwa">val</span> _ <span class="sym">=</span> elts <span class="sym">:=</span> a'
		     <span class="kwa">val</span> _ <span class="sym">=</span> Word8Array.update <span class="sym">(</span>a'<span class="sym">,</span> s<span class="sym">,</span> x<span class="sym">)
</span>		  <span class="kwa">in</span> <span class="sym">()
</span>		  <span class="kwa">end
	    else</span> Word8Array.update <span class="sym">(</span>a<span class="sym">,</span> s<span class="sym">,</span> x<span class="sym">)
</span>	 <span class="kwa">end
   end

structure</span> Quicksort<span class="sym">:
</span>   <span class="kwa">sig
      val</span> quicksort<span class="sym">:</span> 'a array <span class="sym">* (</span>'a <span class="sym">*</span> 'a <span class="sym">-&gt;</span> <span class="kwb">bool</span><span class="sym">) -&gt;</span> unit
   <span class="kwa">end</span> <span class="sym">=
</span>   <span class="kwa">struct
      fun</span> assert <span class="sym">(</span>s<span class="sym">,</span> f<span class="sym">:</span> unit <span class="sym">-&gt;</span> <span class="kwb">bool</span><span class="sym">) =
</span>	 <span class="kwa">if true orelse</span> f <span class="sym">()
</span>	    <span class="kwa">then</span> <span class="sym">()
</span>	 <span class="kwa">else raise</span> Fail <span class="sym">(</span>concat <span class="sym">[</span><span class="str">&quot;assert: &quot;</span><span class="sym">,</span> s<span class="sym">])

</span>      <span class="kwa">fun</span> forall <span class="sym">(</span>low<span class="sym">,</span> high<span class="sym">,</span> f<span class="sym">) =
</span>	 <span class="kwa">let
	    fun</span> loop i <span class="sym">=</span> i <span class="sym">&gt;</span> high <span class="kwa">orelse</span> <span class="sym">(</span>f i <span class="kwa">andalso</span> loop <span class="sym">(</span>i <span class="sym">+</span> <span class="num">1</span><span class="sym">))
</span>	 <span class="kwa">in
</span>	    loop low
	 <span class="kwa">end

      fun</span> fold <span class="sym">(</span>l<span class="sym">,</span> u<span class="sym">,</span> state<span class="sym">,</span> f<span class="sym">) =
</span>	 <span class="kwa">let
	    fun</span> loop <span class="sym">(</span>i<span class="sym">,</span> state<span class="sym">) =
</span>	       <span class="kwa">if</span> i <span class="sym">&gt;</span> u
		  <span class="kwa">then</span> state
	       <span class="kwa">else</span> loop <span class="sym">(</span>i <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> f <span class="sym">(</span>i<span class="sym">,</span> state<span class="sym">))
</span>	 <span class="kwa">in
</span>	    loop <span class="sym">(</span>l<span class="sym">,</span> state<span class="sym">)
</span>	 <span class="kwa">end

</span>      <span class="com">(* Check if entries in a[lo ... hi] are sorted. *)</span>
      <span class="kwa">fun</span> 'a isSorted <span class="sym">(</span>a<span class="sym">:</span> 'a array<span class="sym">,
</span>		       lo<span class="sym">:</span> <span class="kwb">int</span><span class="sym">,
</span>		       hi<span class="sym">:</span> <span class="kwb">int</span><span class="sym">,
</span>		       <span class="kwa">op</span> <span class="sym">&lt;= :</span> 'a <span class="sym">*</span> 'a <span class="sym">-&gt;</span> <span class="kwb">bool</span><span class="sym">) =
</span>	 <span class="kwa">let
	    fun</span> loop <span class="sym">(</span>i<span class="sym">,</span> x<span class="sym">) =
</span>	       i <span class="sym">&gt;</span> hi
	       <span class="kwa">orelse let
			 val</span> y <span class="sym">=</span> sub <span class="sym">(</span>a<span class="sym">,</span> i<span class="sym">)
</span>		      <span class="kwa">in
</span>			 x <span class="sym">&lt;=</span> y <span class="kwa">andalso</span> loop <span class="sym">(</span>i <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> y<span class="sym">)
</span>		      <span class="kwa">end
	 in
</span>	    lo <span class="sym">&gt;=</span> hi <span class="kwa">orelse</span> loop <span class="sym">(</span>lo <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> sub <span class="sym">(</span>a<span class="sym">,</span> lo<span class="sym">))
</span>	 <span class="kwa">end

</span>      <span class="com">(* From page 284 of Numerical Recipes in C. *)</span>
      <span class="kwa">local
	 open Word
	 val</span> seed <span class="sym">=</span> ref <span class="num">0w13
</span>      <span class="kwa">in
	 fun</span> rand <span class="sym">() =
</span>	    <span class="kwa">let
	       val</span> res <span class="sym">=</span> <span class="num">0w1664525</span> <span class="sym">* !</span>seed <span class="sym">+</span> <span class="num">0w1013904223
</span>	       <span class="kwa">val</span> _ <span class="sym">=</span> seed <span class="sym">:=</span> res
	    <span class="kwa">in
</span>	       toIntX res
	    <span class="kwa">end
      end

      fun</span> randInt <span class="sym">(</span>lo<span class="sym">,</span> hi<span class="sym">) =</span> lo <span class="sym">+</span> <span class="kwa">Int</span>.mod <span class="sym">(</span>rand<span class="sym">(),</span> hi <span class="sym">-</span> lo <span class="sym">+</span> <span class="num">1</span><span class="sym">)

</span>      <span class="com">(* insertion sort based on page 108 of Programming Pearls, by Bentley. *)</span>
      <span class="kwa">fun</span> insertionSort <span class="sym">(</span>a<span class="sym">:</span> 'a array<span class="sym">,</span> <span class="kwa">op</span> <span class="sym">&lt;= :</span> 'a <span class="sym">*</span> 'a <span class="sym">-&gt;</span> <span class="kwb">bool</span><span class="sym">):</span> unit <span class="sym">=
</span>	 <span class="kwa">let
	    fun</span> x i <span class="sym">=</span> sub <span class="sym">(</span>a<span class="sym">,</span> i<span class="sym">)
</span>	 <span class="kwa">in
</span>	    for <span class="sym">(</span><span class="num">1</span><span class="sym">,</span> Array.length a<span class="sym">,</span> <span class="kwa">fn</span> i <span class="sym">=&gt;
</span>		 <span class="kwa">let
		    val</span> _ <span class="sym">=
</span>		       assert <span class="sym">(</span><span class="str">&quot;insertionSort1&quot;</span><span class="sym">,</span> <span class="kwa">fn</span> <span class="sym">() =&gt;
</span>			       isSorted <span class="sym">(</span>a<span class="sym">,</span> <span class="num">0</span><span class="sym">,</span> i <span class="num">- 1</span><span class="sym">,</span> <span class="kwa">op</span> <span class="sym">&lt;=))
</span>		    <span class="kwa">val</span> t <span class="sym">=</span> x i
		    <span class="kwa">fun</span> sift <span class="sym">(</span>j<span class="sym">:</span> <span class="kwb">int</span><span class="sym">) =
		       (</span>assert <span class="sym">(</span><span class="str">&quot;insertionSort2&quot;</span><span class="sym">,</span> <span class="kwa">fn</span> <span class="sym">() =&gt;
</span>				isSorted <span class="sym">(</span>a<span class="sym">,</span> <span class="num">0</span><span class="sym">,</span> j <span class="num">- 1</span><span class="sym">,</span> <span class="kwa">op</span> <span class="sym">&lt;=)
</span>				<span class="kwa">andalso</span> isSorted <span class="sym">(</span>a<span class="sym">,</span> j <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> i<span class="sym">,</span> <span class="kwa">op</span> <span class="sym">&lt;=)
</span>				<span class="kwa">andalso</span> forall <span class="sym">(</span>j <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> i<span class="sym">,</span> <span class="kwa">fn</span> k <span class="sym">=&gt;</span> t <span class="sym">&lt;=</span> x k<span class="sym">))
			;</span> <span class="kwa">if</span> j <span class="sym">&gt;</span> <span class="num">0
</span>			     <span class="kwa">then
				let
				   val</span> j' <span class="sym">=</span> j <span class="num">- 1
</span>				   <span class="kwa">val</span> z <span class="sym">=</span> x j'
				<span class="kwa">in if</span> t <span class="sym">&lt;=</span> z
				      <span class="kwa">then</span> <span class="sym">(</span>update <span class="sym">(</span>a<span class="sym">,</span> j<span class="sym">,</span> z<span class="sym">);
</span>					    sift j'<span class="sym">)
</span>				   <span class="kwa">else</span> j
				<span class="kwa">end
			  else</span> j<span class="sym">)
</span>		    <span class="kwa">val</span> _ <span class="sym">=</span> update <span class="sym">(</span>a<span class="sym">,</span> sift i<span class="sym">,</span> t<span class="sym">)
</span>		 <span class="kwa">in</span> <span class="sym">()
</span>		 <span class="kwa">end</span><span class="sym">)
</span>	 <span class="kwa">end

</span>      <span class="com">(* quicksort based on page 112 of Programming Pearls, by Bentley. *)</span>
      <span class="kwa">fun</span> 'a quicksort <span class="sym">(</span>a<span class="sym">:</span> 'a array<span class="sym">,</span> <span class="kwa">op</span> <span class="sym">&lt;= :</span> 'a <span class="sym">*</span> 'a <span class="sym">-&gt;</span> <span class="kwb">bool</span><span class="sym">):</span> unit <span class="sym">=
</span>	 <span class="kwa">let
	    fun</span> x i <span class="sym">=</span> Array.sub <span class="sym">(</span>a<span class="sym">,</span> i<span class="sym">)
</span>	    <span class="kwa">fun</span> swap <span class="sym">(</span>i<span class="sym">,</span> j<span class="sym">) =
</span>	       <span class="kwa">let
		  val</span> t <span class="sym">=</span> x i
		  <span class="kwa">val</span> _ <span class="sym">=</span> update <span class="sym">(</span>a<span class="sym">,</span> i<span class="sym">,</span> x j<span class="sym">)
</span>		  <span class="kwa">val</span> _ <span class="sym">=</span> update <span class="sym">(</span>a<span class="sym">,</span> j<span class="sym">,</span> t<span class="sym">)
</span>	       <span class="kwa">in</span> <span class="sym">()
</span>	       <span class="kwa">end
	    val</span> cutoff <span class="sym">=</span> <span class="num">20
</span>	    <span class="kwa">fun</span> qsort <span class="sym">(</span>l<span class="sym">:</span> <span class="kwb">int</span><span class="sym">,</span> u<span class="sym">:</span> <span class="kwb">int</span><span class="sym">):</span> unit <span class="sym">=
</span>	       <span class="kwa">if</span> u <span class="sym">-</span> l <span class="sym">&gt;</span> cutoff
		  <span class="kwa">then
		     let
			val</span> _ <span class="sym">=</span> swap <span class="sym">(</span>l<span class="sym">,</span> randInt <span class="sym">(</span>l<span class="sym">,</span> u<span class="sym">))
</span>			<span class="kwa">val</span> t <span class="sym">=</span> x l
			<span class="kwa">val</span> m <span class="sym">=
</span>			   fold
			   <span class="sym">(</span>l <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> u<span class="sym">,</span> l<span class="sym">,</span> <span class="kwa">fn</span> <span class="sym">(</span>i<span class="sym">,</span> m<span class="sym">) =&gt;
			    (</span>assert
			     <span class="sym">(</span><span class="str">&quot;qsort&quot;</span><span class="sym">,</span> <span class="kwa">fn</span> <span class="sym">() =&gt;
</span>			      forall <span class="sym">(</span>l <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> m<span class="sym">,</span> <span class="kwa">fn</span> k <span class="sym">=&gt;</span> x k <span class="sym">&lt;=</span> t<span class="sym">)
</span>			      <span class="kwa">andalso</span> forall <span class="sym">(</span>m <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> i <span class="num">- 1</span><span class="sym">,</span> <span class="kwa">fn</span> k <span class="sym">=&gt;</span> not <span class="sym">(</span>x k <span class="sym">&lt;=</span> t<span class="sym">)))
			     ;</span> <span class="kwa">if</span> x i <span class="sym">&lt;=</span> t
				  <span class="kwa">then</span> <span class="sym">(</span>swap <span class="sym">(</span>m <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> i<span class="sym">)
					;</span> m <span class="sym">+</span> <span class="num">1</span><span class="sym">)
</span>			       <span class="kwa">else</span> m<span class="sym">))
</span>			<span class="kwa">val</span> _ <span class="sym">=</span> swap <span class="sym">(</span>l<span class="sym">,</span> m<span class="sym">)
</span>			<span class="kwa">val</span> _ <span class="sym">=</span> qsort <span class="sym">(</span>l<span class="sym">,</span> m <span class="num">- 1</span><span class="sym">)
</span>			<span class="kwa">val</span> _ <span class="sym">=</span> qsort <span class="sym">(</span>m <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> u<span class="sym">)
</span>		     <span class="kwa">in</span> <span class="sym">()
</span>		     <span class="kwa">end
	       else</span> <span class="sym">()
</span>	    <span class="kwa">val</span> max <span class="sym">=</span> Array.length a <span class="num">- 1
</span>	    <span class="kwa">val</span> _ <span class="sym">=</span> qsort <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> max<span class="sym">)
</span>	    <span class="kwa">val</span> _ <span class="sym">=</span> insertionSort <span class="sym">(</span>a<span class="sym">,</span> <span class="kwa">op</span> <span class="sym">&lt;=)
</span>	 <span class="kwa">in
</span>	    <span class="sym">()
</span>	 <span class="kwa">end
   end

structure</span> Test <span class="sym">:</span> <span class="kwa">sig
    val</span> main <span class="sym">: (</span><span class="kwb">string</span> <span class="sym">*</span> <span class="kwb">string</span> list<span class="sym">) -&gt;</span> OS.Process.status
<span class="kwa">end</span> <span class="sym">=</span> <span class="kwa">struct

</span><span class="com">(* This hash function is taken from pages 56-57 of
 * The Practice of Programming by Kernighan and Pike.
 *)</span>
<span class="kwa">fun</span> hash <span class="sym">(</span>s<span class="sym">:</span> <span class="kwb">string</span><span class="sym">):</span> <span class="kwb">word</span> <span class="sym">=
</span>   <span class="kwa">let
      val</span> n <span class="sym">=</span> <span class="kwa">String</span>.size s
      <span class="kwa">fun</span> loop <span class="sym">(</span>i<span class="sym">,</span> w<span class="sym">) =
</span>	 <span class="kwa">if</span> i <span class="sym">=</span> n
	    <span class="kwa">then</span> w
	 <span class="kwa">else Word</span>.fromInt <span class="sym">(</span><span class="kwa">Char</span>.ord <span class="sym">(</span><span class="kwa">String</span>.sub <span class="sym">(</span>s<span class="sym">,</span> i<span class="sym">))) +</span> <span class="kwa">Word</span>.<span class="sym">* (</span>w<span class="sym">,</span> <span class="num">0w31</span><span class="sym">)
</span>   <span class="kwa">in
</span>      loop <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> <span class="num">0w0</span><span class="sym">)
</span>   <span class="kwa">end

fun</span> hash <span class="sym">(</span>s<span class="sym">:</span> <span class="kwb">string</span><span class="sym">):</span> <span class="kwb">word</span> <span class="sym">=
</span>   <span class="kwa">let
      val</span> n <span class="sym">=</span> <span class="kwa">String</span>.size s
      <span class="kwa">fun</span> loop <span class="sym">(</span>i<span class="sym">,</span> w<span class="sym">) =
</span>	 <span class="kwa">if</span> i <span class="sym">=</span> n
	    <span class="kwa">then</span> w
	 <span class="kwa">else</span> loop <span class="sym">(</span>i <span class="sym">+</span> <span class="num">1</span><span class="sym">,
</span>		    <span class="kwa">Word</span>.fromInt <span class="sym">(</span><span class="kwa">Char</span>.ord <span class="sym">(</span><span class="kwa">String</span>.sub <span class="sym">(</span>s<span class="sym">,</span> i<span class="sym">)))
		       +</span> <span class="kwa">Word</span>.<span class="sym">* (</span>w<span class="sym">,</span> <span class="num">0w31</span><span class="sym">))
</span>   <span class="kwa">in
</span>      loop <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> <span class="num">0w0</span><span class="sym">)
</span>   <span class="kwa">end

</span><span class="com">(* Based on wordfreq.ocaml. *)</span>

<span class="kwa">val</span> max <span class="sym">=</span> <span class="num">4096
</span><span class="kwa">val</span> buf <span class="sym">=</span> Word8Array.array <span class="sym">(</span>max<span class="sym">,</span> <span class="num">0w0</span><span class="sym">)
</span><span class="kwa">val</span> count<span class="sym">: {</span>hash<span class="sym">:</span> <span class="kwb">word</span><span class="sym">,
</span>	    <span class="kwb">word</span><span class="sym">:</span> <span class="kwb">string</span><span class="sym">,
</span>	    count<span class="sym">:</span> <span class="kwb">int</span> ref<span class="sym">}</span> HashSet.t <span class="sym">=</span> HashSet.new <span class="sym">{</span>hash <span class="sym">=</span> #hash<span class="sym">}
</span><span class="kwa">val</span> wbuf <span class="sym">=</span> Buffer.new <span class="num">64

</span><span class="kwa">val</span> c2b <span class="sym">=</span> Byte.charToByte
<span class="kwa">fun</span> scan_words <span class="sym">(</span>i<span class="sym">,</span> n<span class="sym">,</span> inword<span class="sym">) =
</span>  <span class="kwa">if</span> i <span class="sym">&lt;</span> n
     <span class="kwa">then
	let
	   val</span> c <span class="sym">=</span> Word8Array.sub <span class="sym">(</span>buf<span class="sym">,</span> i<span class="sym">)
</span>	<span class="kwa">in
	   if</span> c2b #<span class="str">&quot;a&quot;</span> <span class="sym">&lt;=</span> c <span class="kwa">andalso</span> c <span class="sym">&lt;=</span> c2b #<span class="str">&quot;z&quot;</span>
	      <span class="kwa">then</span> <span class="sym">(</span>Buffer.add <span class="sym">(</span>wbuf<span class="sym">,</span> c<span class="sym">);
</span>		    scan_words <span class="sym">(</span>i <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> n<span class="sym">,</span> <span class="kwa">true</span><span class="sym">))
</span>	   <span class="kwa">else
	      if</span> c2b #<span class="str">&quot;A&quot;</span> <span class="sym">&lt;=</span> c <span class="kwa">andalso</span> c <span class="sym">&lt;=</span> c2b #<span class="str">&quot;Z&quot;</span>
		 <span class="kwa">then
</span>		    <span class="sym">(</span>Buffer.add <span class="sym">(</span>wbuf<span class="sym">,</span> c <span class="sym">+</span> <span class="num">0w32</span><span class="sym">);
</span>		     scan_words <span class="sym">(</span>i <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> n<span class="sym">,</span> <span class="kwa">true</span><span class="sym">))
</span>	      <span class="kwa">else
		 if</span> inword
		    <span class="kwa">then
		       let
			  val</span> w <span class="sym">=</span> Buffer.contents wbuf
			  <span class="kwa">val</span> h <span class="sym">=</span> hash w
		       <span class="kwa">in
</span>			  incr <span class="sym">(</span>#count
				<span class="sym">(</span>HashSet.lookupOrInsert
				 <span class="sym">(</span>count<span class="sym">,</span> h<span class="sym">,
</span>				  <span class="kwa">fn</span> <span class="sym">{</span>hash<span class="sym">,</span> <span class="kwb">word</span><span class="sym">,</span> ...<span class="sym">} =&gt;
</span>				  hash <span class="sym">=</span> h <span class="kwa">andalso</span> <span class="kwb">word</span> <span class="sym">=</span> w<span class="sym">,
</span>				  <span class="kwa">fn</span> <span class="sym">() =&gt; {</span>hash <span class="sym">=</span> h<span class="sym">,</span> <span class="kwb">word</span> <span class="sym">=</span> w<span class="sym">,</span> count <span class="sym">=</span> ref <span class="num">0</span><span class="sym">})));
</span>			  Buffer.clear wbuf<span class="sym">;
</span>			  scan_words <span class="sym">(</span>i <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> n<span class="sym">,</span> <span class="kwa">false</span><span class="sym">)
</span>		       <span class="kwa">end
		 else</span> scan_words <span class="sym">(</span>i <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> n<span class="sym">,</span> <span class="kwa">false</span><span class="sym">)
</span>	<span class="kwa">end
  else
     let
	val</span> nread <span class="sym">=
</span>	   Posix.IO.readArr <span class="sym">(</span>Posix.FileSys.stdin<span class="sym">,</span> Word8ArraySlice.full buf<span class="sym">)
</span>     <span class="kwa">in
	if</span> nread <span class="sym">=</span> <span class="num">0
</span>	   <span class="kwa">then</span> <span class="sym">()
</span>	<span class="kwa">else</span> scan_words <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> nread<span class="sym">,</span> inword<span class="sym">)
</span>     <span class="kwa">end

fun</span> printl <span class="sym">[] =</span> print <span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span> <span class="sym">|</span> printl<span class="sym">(</span>h<span class="sym">::</span>t<span class="sym">) = (</span> print h <span class="sym">;</span> printl t <span class="sym">)

</span><span class="kwa">fun</span> rightJustify <span class="sym">(</span>s<span class="sym">:</span> <span class="kwb">string</span><span class="sym">,</span> width<span class="sym">:</span> <span class="kwb">int</span><span class="sym">) =
</span>   <span class="kwa">let
      val</span> n <span class="sym">=</span> <span class="kwa">String</span>.size s
   <span class="kwa">in</span> concat <span class="sym">[</span>CharVector.tabulate <span class="sym">(</span>width <span class="sym">-</span> n<span class="sym">,</span> <span class="kwa">fn</span> _ <span class="sym">=&gt;</span> #<span class="str">&quot; &quot;</span><span class="sym">),</span> s<span class="sym">]
</span>   <span class="kwa">end

fun</span> main <span class="sym">(</span>name<span class="sym">,</span> args<span class="sym">) =
</span>   <span class="kwa">let
	val</span> _ <span class="sym">=</span> scan_words <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> <span class="num">0</span><span class="sym">,</span> <span class="kwa">false</span><span class="sym">)
</span>	<span class="kwa">val</span> a <span class="sym">=</span> Array.array <span class="sym">(</span>HashSet.size count<span class="sym">, (</span><span class="num">0</span><span class="sym">,</span> <span class="str">&quot;&quot;</span><span class="sym">))
</span>	<span class="kwa">val</span> i <span class="sym">=</span> ref <span class="num">0
</span>	<span class="kwa">val</span> _ <span class="sym">=</span> HashSet.foreach <span class="sym">(</span>count<span class="sym">,</span> <span class="kwa">fn</span> <span class="sym">{</span><span class="kwb">word</span><span class="sym">,</span> count<span class="sym">,</span> ...<span class="sym">} =&gt;
			 (</span>Array.update <span class="sym">(</span>a<span class="sym">, !</span>i<span class="sym">, (!</span>count<span class="sym">,</span> <span class="kwb">word</span><span class="sym">));</span> incr i<span class="sym">))
</span>	<span class="kwa">val</span> _ <span class="sym">=</span> Quicksort.quicksort <span class="sym">(</span>a<span class="sym">,</span> <span class="kwa">fn</span> <span class="sym">((</span>c<span class="sym">,</span> w<span class="sym">), (</span>c'<span class="sym">,</span> w'<span class="sym">)) =&gt;
</span>			     c <span class="sym">&gt;</span> c' <span class="kwa">orelse</span> c <span class="sym">=</span> c' <span class="kwa">andalso</span> w <span class="sym">&gt;=</span> w'<span class="sym">)
</span>	<span class="kwa">val</span> _ <span class="sym">=</span> Array.app <span class="sym">(</span><span class="kwa">fn</span> <span class="sym">(</span>c<span class="sym">,</span> w<span class="sym">) =&gt;
</span>		   printl <span class="sym">[</span>rightJustify <span class="sym">(</span><span class="kwa">Int</span>.toString c<span class="sym">,</span> <span class="num">7</span><span class="sym">),</span> <span class="str">&quot; &quot;</span><span class="sym">,</span> w<span class="sym">])</span> a
   <span class="kwa">in
</span>      OS.Process.success
   <span class="kwa">end
end

val</span> _ <span class="sym">=</span> Test.main<span class="sym">(</span> CommandLine.name<span class="sym">(),</span> CommandLine.arguments<span class="sym">() )</span>
