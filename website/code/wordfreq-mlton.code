<span class="com">(* -*- mode: sml -*-</span>
<span class="com"> * $Id: wordfreq-mlton.code,v 1.9 2006-01-01 17:59:58 bfulgham Exp $</span>
<span class="com"> * http://shootout.alioth.debian.org/</span>
<span class="com"> * from Stephen Weeks</span>
<span class="com"> *</span>
<span class="com"> *)</span>

<span class="kwa">fun</span> incr r <span class="sym">=</span> r <span class="sym">:=</span> <span class="num">1</span> <span class="sym">+ !</span>r
<span class="kwa">val</span> sub <span class="sym">=</span> Array.sub
<span class="kwa">val</span> update <span class="sym">=</span> Array.update

<span class="kwa">signature</span> HASH_SET <span class="sym">=</span>
   <span class="kwa">sig</span>
      <span class="kwa">type</span> 'a t

      <span class="kwa">val</span> foreach<span class="sym">:</span> 'a t <span class="sym">* (</span>'a <span class="sym">-&gt;</span> unit<span class="sym">) -&gt;</span> unit
      <span class="com">(* lookupOrInsert (s, h, p, f)  looks in the set s for an entry with hash h</span>
<span class="com">       * satisfying predicate p.  If the entry is there, it is returned.</span>
<span class="com">       * Otherwise, the function f is called to create a new entry, which is</span>
<span class="com">       * inserted and returned.</span>
<span class="com">       *)</span>
      <span class="kwa">val</span> lookupOrInsert<span class="sym">:</span> 'a t <span class="sym">*</span> <span class="kwb">word</span> <span class="sym">* (</span>'a <span class="sym">-&gt;</span> <span class="kwb">bool</span><span class="sym">) * (</span>unit <span class="sym">-&gt;</span> 'a<span class="sym">) -&gt;</span> 'a
      <span class="kwa">val</span> new<span class="sym">: {</span>hash<span class="sym">:</span> 'a <span class="sym">-&gt;</span> <span class="kwb">word</span><span class="sym">} -&gt;</span> 'a t
      <span class="kwa">val</span> size<span class="sym">:</span> 'a t <span class="sym">-&gt;</span> <span class="kwb">int</span>
   <span class="kwa">end</span>

<span class="kwa">structure</span> HashSet<span class="sym">:</span> HASH_SET <span class="sym">=</span>
<span class="kwa">struct</span>

<span class="kwa">datatype</span> 'a t <span class="sym">=</span>
   T <span class="kwa">of</span> <span class="sym">{</span>buckets<span class="sym">:</span> 'a list array ref<span class="sym">,</span>
	 hash<span class="sym">:</span> 'a <span class="sym">-&gt;</span> <span class="kwb">word</span><span class="sym">,</span>
	 mask<span class="sym">:</span> <span class="kwb">word</span> ref<span class="sym">,</span>
	 numItems<span class="sym">:</span> <span class="kwb">int</span> ref<span class="sym">}</span>

<span class="kwa">val</span> initialSize<span class="sym">:</span> <span class="kwb">int</span> <span class="sym">=</span> <span class="num">65536</span>
<span class="kwa">val</span> initialMask<span class="sym">:</span> <span class="kwb">word</span> <span class="sym">=</span> <span class="kwa">Word</span>.fromInt initialSize <span class="sym">-</span> <span class="num">0</span>w1

<span class="kwa">fun</span> 'a new <span class="sym">{</span>hash<span class="sym">}:</span> 'a t <span class="sym">=</span>
   T <span class="sym">{</span>buckets <span class="sym">=</span> ref <span class="sym">(</span>Array.array <span class="sym">(</span>initialSize<span class="sym">, [])),</span>
      hash <span class="sym">=</span> hash<span class="sym">,</span>
      numItems <span class="sym">=</span> ref <span class="num">0</span><span class="sym">,</span>
      mask <span class="sym">=</span> ref initialMask<span class="sym">}</span>

<span class="kwa">fun</span> size <span class="sym">(</span>T <span class="sym">{</span>numItems<span class="sym">,</span> ...<span class="sym">}) = !</span>numItems
<span class="kwa">fun</span> numBuckets <span class="sym">(</span>T <span class="sym">{</span>buckets<span class="sym">,</span> ...<span class="sym">}) =</span> Array.length <span class="sym">(!</span>buckets<span class="sym">)</span>

<span class="kwa">fun</span> index <span class="sym">(</span>w<span class="sym">:</span> <span class="kwb">word</span><span class="sym">,</span> mask<span class="sym">:</span> <span class="kwb">word</span><span class="sym">):</span> <span class="kwb">int</span> <span class="sym">=</span>
   <span class="kwa">Word</span>.toInt <span class="sym">(</span><span class="kwa">Word</span>.andb <span class="sym">(</span>w<span class="sym">,</span> mask<span class="sym">))</span>

<span class="kwa">fun</span> resize <span class="sym">(</span>T <span class="sym">{</span>buckets<span class="sym">,</span> hash<span class="sym">,</span> mask<span class="sym">,</span> ...<span class="sym">},</span> size<span class="sym">:</span> <span class="kwb">int</span><span class="sym">,</span> newMask<span class="sym">:</span> <span class="kwb">word</span><span class="sym">):</span> unit <span class="sym">=</span>
   <span class="kwa">let</span>
      <span class="kwa">val</span> newBuckets <span class="sym">=</span> Array.array <span class="sym">(</span>size<span class="sym">, [])</span>
   <span class="kwa">in</span> Array.app <span class="sym">(</span><span class="kwa">fn</span> r <span class="sym">=&gt;</span>
		 <span class="kwa">List</span>.app <span class="sym">(</span><span class="kwa">fn</span> a <span class="sym">=&gt;</span>
			       <span class="kwa">let val</span> j <span class="sym">=</span> index <span class="sym">(</span>hash a<span class="sym">,</span> newMask<span class="sym">)</span>
			       <span class="kwa">in</span> Array.update
				  <span class="sym">(</span>newBuckets<span class="sym">,</span> j<span class="sym">,</span>
				   a <span class="sym">::</span> Array.sub <span class="sym">(</span>newBuckets<span class="sym">,</span> j<span class="sym">))</span>
			       <span class="kwa">end</span><span class="sym">)</span> r<span class="sym">) (!</span>buckets<span class="sym">)</span>
      <span class="sym">;</span> buckets <span class="sym">:=</span> newBuckets
      <span class="sym">;</span> mask <span class="sym">:=</span> newMask
   <span class="kwa">end</span>

<span class="kwa">fun</span> maybeGrow <span class="sym">(</span>s <span class="kwa">as</span> T <span class="sym">{</span>buckets<span class="sym">,</span> mask<span class="sym">,</span> numItems<span class="sym">,</span> ...<span class="sym">}):</span> unit <span class="sym">=</span>
   <span class="kwa">let</span>
      <span class="kwa">val</span> n <span class="sym">=</span> Array.length <span class="sym">(!</span>buckets<span class="sym">)</span>
   <span class="kwa">in if</span> <span class="sym">!</span>numItems <span class="sym">*</span> <span class="num">4</span> <span class="sym">&gt;</span> n
	 <span class="kwa">then</span> resize <span class="sym">(</span>s<span class="sym">,</span>
		      n <span class="sym">*</span> <span class="num">2</span><span class="sym">,</span>
		      <span class="com">(* The new mask depends on growFactor being 2. *)</span>
		      <span class="kwa">Word</span>.orb <span class="sym">(</span><span class="num">0</span>w1<span class="sym">,</span> <span class="kwa">Word</span>.<span class="sym">&lt;&lt; (!</span>mask<span class="sym">,</span> <span class="num">0</span>w1<span class="sym">)))</span>
      <span class="kwa">else</span> <span class="sym">()</span>
   <span class="kwa">end</span>

<span class="kwa">fun</span> peekGen <span class="sym">(</span>T <span class="sym">{</span>buckets <span class="sym">=</span> ref buckets<span class="sym">,</span> mask<span class="sym">,</span> ...<span class="sym">},</span> w<span class="sym">,</span> p<span class="sym">,</span> no<span class="sym">,</span> yes<span class="sym">) =</span>
   <span class="kwa">let</span>
      <span class="kwa">val</span> j <span class="sym">=</span> index <span class="sym">(</span>w<span class="sym">, !</span>mask<span class="sym">)</span>
      <span class="kwa">val</span> b <span class="sym">=</span> Array.sub <span class="sym">(</span>buckets<span class="sym">,</span> j<span class="sym">)</span>
   <span class="kwa">in case List</span>.find p b <span class="kwa">of</span>
      NONE <span class="sym">=&gt;</span> no <span class="sym">(</span>j<span class="sym">,</span> b<span class="sym">)</span>
    <span class="sym">|</span> SOME a <span class="sym">=&gt;</span> yes a
   <span class="kwa">end</span>

<span class="kwa">fun</span> lookupOrInsert <span class="sym">(</span>table <span class="kwa">as</span> T <span class="sym">{</span>buckets<span class="sym">,</span> numItems<span class="sym">,</span> ...<span class="sym">},</span> w<span class="sym">,</span> p<span class="sym">,</span> f<span class="sym">) =</span>
   <span class="kwa">let</span>
      <span class="kwa">fun</span> no <span class="sym">(</span>j<span class="sym">,</span> b<span class="sym">) =</span>
	 <span class="kwa">let val</span> a <span class="sym">=</span> f <span class="sym">()</span>
	    <span class="kwa">val</span> _ <span class="sym">=</span> incr numItems
	    <span class="kwa">val</span> _ <span class="sym">=</span> Array.update <span class="sym">(!</span>buckets<span class="sym">,</span> j<span class="sym">,</span> a <span class="sym">::</span> b<span class="sym">)</span>
	    <span class="kwa">val</span> _ <span class="sym">=</span> maybeGrow table
	 <span class="kwa">in</span> a
	 <span class="kwa">end</span>
   <span class="kwa">in</span> peekGen <span class="sym">(</span>table<span class="sym">,</span> w<span class="sym">,</span> p<span class="sym">,</span> no<span class="sym">,</span> <span class="kwa">fn</span> x <span class="sym">=&gt;</span> x<span class="sym">)</span>
   <span class="kwa">end</span>

<span class="kwa">fun</span> foreach <span class="sym">(</span>T <span class="sym">{</span>buckets<span class="sym">,</span> ...<span class="sym">},</span> f<span class="sym">) =</span>
   Array.app <span class="sym">(</span><span class="kwa">fn</span> r <span class="sym">=&gt;</span> <span class="kwa">List</span>.app f r<span class="sym">) (!</span>buckets<span class="sym">)</span>

<span class="kwa">end</span>

<span class="kwa">structure</span> Buffer<span class="sym">:</span>
   <span class="kwa">sig</span>
      <span class="kwa">type</span> t

      <span class="kwa">val</span> add<span class="sym">:</span> t <span class="sym">*</span> <span class="kwa">Word8</span>.<span class="kwb">word</span> <span class="sym">-&gt;</span> unit
      <span class="kwa">val</span> clear<span class="sym">:</span> t <span class="sym">-&gt;</span> unit
      <span class="kwa">val</span> contents<span class="sym">:</span> t <span class="sym">-&gt;</span> <span class="kwb">string</span>
      <span class="kwa">val</span> new<span class="sym">:</span> <span class="kwb">int</span> <span class="sym">-&gt;</span> t
   <span class="kwa">end</span> <span class="sym">=</span>
   <span class="kwa">struct</span>
      <span class="kwa">datatype</span> t <span class="sym">=</span> T <span class="kwa">of</span> <span class="sym">{</span>elts<span class="sym">:</span> Word8Array.array ref<span class="sym">,</span>
			 size<span class="sym">:</span> <span class="kwb">int</span> ref<span class="sym">}</span>

      <span class="kwa">fun</span> contents <span class="sym">(</span>T <span class="sym">{</span>elts<span class="sym">,</span> size<span class="sym">,</span> ...<span class="sym">}) =</span>
	 Byte.bytesToString
	 <span class="sym">(</span>Word8ArraySlice.vector
	  <span class="sym">(</span>Word8ArraySlice.slice <span class="sym">(!</span>elts<span class="sym">,</span> <span class="num">0</span><span class="sym">,</span> SOME <span class="sym">(!</span>size<span class="sym">))))</span>

      <span class="kwa">fun</span> clear <span class="sym">(</span>T <span class="sym">{</span>size<span class="sym">,</span> ...<span class="sym">}) =</span> size <span class="sym">:=</span> <span class="num">0</span>

      <span class="kwa">fun</span> new <span class="sym">(</span>bufSize<span class="sym">) =</span>
	 T <span class="sym">{</span>elts <span class="sym">=</span> ref <span class="sym">(</span>Word8Array.array <span class="sym">(</span>bufSize<span class="sym">,</span> <span class="num">0</span>w0<span class="sym">)),</span>
	    size <span class="sym">=</span> ref <span class="num">0</span><span class="sym">}</span>

      <span class="kwa">fun</span> add <span class="sym">(</span>T <span class="sym">{</span>elts<span class="sym">,</span> size<span class="sym">},</span> x<span class="sym">) =</span>
	 <span class="kwa">let</span>
	    <span class="kwa">val</span> s <span class="sym">= !</span>size
	    <span class="kwa">val</span> _ <span class="sym">=</span> size <span class="sym">:=</span> s <span class="sym">+</span> <span class="num">1</span>
	    <span class="kwa">val</span> a <span class="sym">= !</span>elts
	    <span class="kwa">val</span> n <span class="sym">=</span> Word8Array.length a
	 <span class="kwa">in</span>
	    <span class="kwa">if</span> s <span class="sym">=</span> n
	       <span class="kwa">then</span>
		  <span class="kwa">let</span>
		     <span class="kwa">val</span> a' <span class="sym">=</span>
			Word8Array.tabulate
			<span class="sym">(</span><span class="num">2</span> <span class="sym">*</span> n<span class="sym">,</span> <span class="kwa">fn</span> i <span class="sym">=&gt;</span>
			 <span class="kwa">if</span> i <span class="sym">&lt;</span> n <span class="kwa">then</span> Word8Array.sub <span class="sym">(</span>a<span class="sym">,</span> i<span class="sym">)</span> <span class="kwa">else</span> <span class="num">0</span>w0<span class="sym">)</span>
		     <span class="kwa">val</span> _ <span class="sym">=</span> elts <span class="sym">:=</span> a'
		     <span class="kwa">val</span> _ <span class="sym">=</span> Word8Array.update <span class="sym">(</span>a'<span class="sym">,</span> s<span class="sym">,</span> x<span class="sym">)</span>
		  <span class="kwa">in</span> <span class="sym">()</span>
		  <span class="kwa">end</span>
	    <span class="kwa">else</span> Word8Array.update <span class="sym">(</span>a<span class="sym">,</span> s<span class="sym">,</span> x<span class="sym">)</span>
	 <span class="kwa">end</span>
   <span class="kwa">end</span>

<span class="kwa">structure</span> Quicksort<span class="sym">:</span>
   <span class="kwa">sig</span>
      <span class="kwa">val</span> quicksort<span class="sym">:</span> 'a array <span class="sym">* (</span>'a <span class="sym">*</span> 'a <span class="sym">-&gt;</span> <span class="kwb">bool</span><span class="sym">) -&gt;</span> unit
   <span class="kwa">end</span> <span class="sym">=</span>
   <span class="kwa">struct</span>
      <span class="kwa">fun</span> assert <span class="sym">(</span>s<span class="sym">,</span> f<span class="sym">:</span> unit <span class="sym">-&gt;</span> <span class="kwb">bool</span><span class="sym">) =</span>
	 <span class="kwa">if true orelse</span> f <span class="sym">()</span>
	    <span class="kwa">then</span> <span class="sym">()</span>
	 <span class="kwa">else raise</span> Fail <span class="sym">(</span>concat <span class="sym">[</span><span class="str">&quot;assert: &quot;</span><span class="sym">,</span> s<span class="sym">])</span>

      <span class="kwa">fun</span> forall <span class="sym">(</span>low<span class="sym">,</span> high<span class="sym">,</span> f<span class="sym">) =</span>
	 <span class="kwa">let</span>
	    <span class="kwa">fun</span> loop i <span class="sym">=</span> i <span class="sym">&gt;</span> high <span class="kwa">orelse</span> <span class="sym">(</span>f i <span class="kwa">andalso</span> loop <span class="sym">(</span>i <span class="sym">+</span> <span class="num">1</span><span class="sym">))</span>
	 <span class="kwa">in</span>
	    loop low
	 <span class="kwa">end</span>

      <span class="kwa">fun</span> fold <span class="sym">(</span>l<span class="sym">,</span> u<span class="sym">,</span> state<span class="sym">,</span> f<span class="sym">) =</span>
	 <span class="kwa">let</span>
	    <span class="kwa">fun</span> loop <span class="sym">(</span>i<span class="sym">,</span> state<span class="sym">) =</span>
	       <span class="kwa">if</span> i <span class="sym">&gt;</span> u
		  <span class="kwa">then</span> state
	       <span class="kwa">else</span> loop <span class="sym">(</span>i <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> f <span class="sym">(</span>i<span class="sym">,</span> state<span class="sym">))</span>
	 <span class="kwa">in</span>
	    loop <span class="sym">(</span>l<span class="sym">,</span> state<span class="sym">)</span>
	 <span class="kwa">end</span>

      <span class="com">(* Check if entries in a[lo ... hi] are sorted. *)</span>
      <span class="kwa">fun</span> 'a isSorted <span class="sym">(</span>a<span class="sym">:</span> 'a array<span class="sym">,</span>
		       lo<span class="sym">:</span> <span class="kwb">int</span><span class="sym">,</span>
		       hi<span class="sym">:</span> <span class="kwb">int</span><span class="sym">,</span>
		       <span class="kwa">op</span> <span class="sym">&lt;= :</span> 'a <span class="sym">*</span> 'a <span class="sym">-&gt;</span> <span class="kwb">bool</span><span class="sym">) =</span>
	 <span class="kwa">let</span>
	    <span class="kwa">fun</span> loop <span class="sym">(</span>i<span class="sym">,</span> x<span class="sym">) =</span>
	       i <span class="sym">&gt;</span> hi
	       <span class="kwa">orelse let</span>
			 <span class="kwa">val</span> y <span class="sym">=</span> sub <span class="sym">(</span>a<span class="sym">,</span> i<span class="sym">)</span>
		      <span class="kwa">in</span>
			 x <span class="sym">&lt;=</span> y <span class="kwa">andalso</span> loop <span class="sym">(</span>i <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> y<span class="sym">)</span>
		      <span class="kwa">end</span>
	 <span class="kwa">in</span>
	    lo <span class="sym">&gt;=</span> hi <span class="kwa">orelse</span> loop <span class="sym">(</span>lo <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> sub <span class="sym">(</span>a<span class="sym">,</span> lo<span class="sym">))</span>
	 <span class="kwa">end</span>

      <span class="com">(* From page 284 of Numerical Recipes in C. *)</span>
      <span class="kwa">local</span>
	 <span class="kwa">open Word</span>
	 <span class="kwa">val</span> seed <span class="sym">=</span> ref <span class="num">0</span>w13
      <span class="kwa">in</span>
	 <span class="kwa">fun</span> rand <span class="sym">() =</span>
	    <span class="kwa">let</span>
	       <span class="kwa">val</span> res <span class="sym">=</span> <span class="num">0</span>w1664525 <span class="sym">* !</span>seed <span class="sym">+</span> <span class="num">0</span>w1013904223
	       <span class="kwa">val</span> _ <span class="sym">=</span> seed <span class="sym">:=</span> res
	    <span class="kwa">in</span>
	       toIntX res
	    <span class="kwa">end</span>
      <span class="kwa">end</span>

      <span class="kwa">fun</span> randInt <span class="sym">(</span>lo<span class="sym">,</span> hi<span class="sym">) =</span> lo <span class="sym">+</span> <span class="kwa">Int</span>.mod <span class="sym">(</span>rand<span class="sym">(),</span> hi <span class="sym">-</span> lo <span class="sym">+</span> <span class="num">1</span><span class="sym">)</span>

      <span class="com">(* insertion sort based on page 108 of Programming Pearls, by Bentley. *)</span>
      <span class="kwa">fun</span> insertionSort <span class="sym">(</span>a<span class="sym">:</span> 'a array<span class="sym">,</span> <span class="kwa">op</span> <span class="sym">&lt;= :</span> 'a <span class="sym">*</span> 'a <span class="sym">-&gt;</span> <span class="kwb">bool</span><span class="sym">):</span> unit <span class="sym">=</span>
	 <span class="kwa">let</span>
	    <span class="kwa">fun</span> x i <span class="sym">=</span> sub <span class="sym">(</span>a<span class="sym">,</span> i<span class="sym">)</span>
	 <span class="kwa">in</span>
	    for <span class="sym">(</span><span class="num">1</span><span class="sym">,</span> Array.length a<span class="sym">,</span> <span class="kwa">fn</span> i <span class="sym">=&gt;</span>
		 <span class="kwa">let</span>
		    <span class="kwa">val</span> _ <span class="sym">=</span>
		       assert <span class="sym">(</span><span class="str">&quot;insertionSort1&quot;</span><span class="sym">,</span> <span class="kwa">fn</span> <span class="sym">() =&gt;</span>
			       isSorted <span class="sym">(</span>a<span class="sym">,</span> <span class="num">0</span><span class="sym">,</span> i <span class="sym">-</span> <span class="num">1</span><span class="sym">,</span> <span class="kwa">op</span> <span class="sym">&lt;=))</span>
		    <span class="kwa">val</span> t <span class="sym">=</span> x i
		    <span class="kwa">fun</span> sift <span class="sym">(</span>j<span class="sym">:</span> <span class="kwb">int</span><span class="sym">) =</span>
		       <span class="sym">(</span>assert <span class="sym">(</span><span class="str">&quot;insertionSort2&quot;</span><span class="sym">,</span> <span class="kwa">fn</span> <span class="sym">() =&gt;</span>
				isSorted <span class="sym">(</span>a<span class="sym">,</span> <span class="num">0</span><span class="sym">,</span> j <span class="sym">-</span> <span class="num">1</span><span class="sym">,</span> <span class="kwa">op</span> <span class="sym">&lt;=)</span>
				<span class="kwa">andalso</span> isSorted <span class="sym">(</span>a<span class="sym">,</span> j <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> i<span class="sym">,</span> <span class="kwa">op</span> <span class="sym">&lt;=)</span>
				<span class="kwa">andalso</span> forall <span class="sym">(</span>j <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> i<span class="sym">,</span> <span class="kwa">fn</span> k <span class="sym">=&gt;</span> t <span class="sym">&lt;=</span> x k<span class="sym">))</span>
			<span class="sym">;</span> <span class="kwa">if</span> j <span class="sym">&gt;</span> <span class="num">0</span>
			     <span class="kwa">then</span>
				<span class="kwa">let</span>
				   <span class="kwa">val</span> j' <span class="sym">=</span> j <span class="sym">-</span> <span class="num">1</span>
				   <span class="kwa">val</span> z <span class="sym">=</span> x j'
				<span class="kwa">in if</span> t <span class="sym">&lt;=</span> z
				      <span class="kwa">then</span> <span class="sym">(</span>update <span class="sym">(</span>a<span class="sym">,</span> j<span class="sym">,</span> z<span class="sym">);</span>
					    sift j'<span class="sym">)</span>
				   <span class="kwa">else</span> j
				<span class="kwa">end</span>
			  <span class="kwa">else</span> j<span class="sym">)</span>
		    <span class="kwa">val</span> _ <span class="sym">=</span> update <span class="sym">(</span>a<span class="sym">,</span> sift i<span class="sym">,</span> t<span class="sym">)</span>
		 <span class="kwa">in</span> <span class="sym">()</span>
		 <span class="kwa">end</span><span class="sym">)</span>
	 <span class="kwa">end</span>

      <span class="com">(* quicksort based on page 112 of Programming Pearls, by Bentley. *)</span>
      <span class="kwa">fun</span> 'a quicksort <span class="sym">(</span>a<span class="sym">:</span> 'a array<span class="sym">,</span> <span class="kwa">op</span> <span class="sym">&lt;= :</span> 'a <span class="sym">*</span> 'a <span class="sym">-&gt;</span> <span class="kwb">bool</span><span class="sym">):</span> unit <span class="sym">=</span>
	 <span class="kwa">let</span>
	    <span class="kwa">fun</span> x i <span class="sym">=</span> Array.sub <span class="sym">(</span>a<span class="sym">,</span> i<span class="sym">)</span>
	    <span class="kwa">fun</span> swap <span class="sym">(</span>i<span class="sym">,</span> j<span class="sym">) =</span>
	       <span class="kwa">let</span>
		  <span class="kwa">val</span> t <span class="sym">=</span> x i
		  <span class="kwa">val</span> _ <span class="sym">=</span> update <span class="sym">(</span>a<span class="sym">,</span> i<span class="sym">,</span> x j<span class="sym">)</span>
		  <span class="kwa">val</span> _ <span class="sym">=</span> update <span class="sym">(</span>a<span class="sym">,</span> j<span class="sym">,</span> t<span class="sym">)</span>
	       <span class="kwa">in</span> <span class="sym">()</span>
	       <span class="kwa">end</span>
	    <span class="kwa">val</span> cutoff <span class="sym">=</span> <span class="num">20</span>
	    <span class="kwa">fun</span> qsort <span class="sym">(</span>l<span class="sym">:</span> <span class="kwb">int</span><span class="sym">,</span> u<span class="sym">:</span> <span class="kwb">int</span><span class="sym">):</span> unit <span class="sym">=</span>
	       <span class="kwa">if</span> u <span class="sym">-</span> l <span class="sym">&gt;</span> cutoff
		  <span class="kwa">then</span>
		     <span class="kwa">let</span>
			<span class="kwa">val</span> _ <span class="sym">=</span> swap <span class="sym">(</span>l<span class="sym">,</span> randInt <span class="sym">(</span>l<span class="sym">,</span> u<span class="sym">))</span>
			<span class="kwa">val</span> t <span class="sym">=</span> x l
			<span class="kwa">val</span> m <span class="sym">=</span>
			   fold
			   <span class="sym">(</span>l <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> u<span class="sym">,</span> l<span class="sym">,</span> <span class="kwa">fn</span> <span class="sym">(</span>i<span class="sym">,</span> m<span class="sym">) =&gt;</span>
			    <span class="sym">(</span>assert
			     <span class="sym">(</span><span class="str">&quot;qsort&quot;</span><span class="sym">,</span> <span class="kwa">fn</span> <span class="sym">() =&gt;</span>
			      forall <span class="sym">(</span>l <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> m<span class="sym">,</span> <span class="kwa">fn</span> k <span class="sym">=&gt;</span> x k <span class="sym">&lt;=</span> t<span class="sym">)</span>
			      <span class="kwa">andalso</span> forall <span class="sym">(</span>m <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> i <span class="sym">-</span> <span class="num">1</span><span class="sym">,</span> <span class="kwa">fn</span> k <span class="sym">=&gt;</span> not <span class="sym">(</span>x k <span class="sym">&lt;=</span> t<span class="sym">)))</span>
			     <span class="sym">;</span> <span class="kwa">if</span> x i <span class="sym">&lt;=</span> t
				  <span class="kwa">then</span> <span class="sym">(</span>swap <span class="sym">(</span>m <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> i<span class="sym">)</span>
					<span class="sym">;</span> m <span class="sym">+</span> <span class="num">1</span><span class="sym">)</span>
			       <span class="kwa">else</span> m<span class="sym">))</span>
			<span class="kwa">val</span> _ <span class="sym">=</span> swap <span class="sym">(</span>l<span class="sym">,</span> m<span class="sym">)</span>
			<span class="kwa">val</span> _ <span class="sym">=</span> qsort <span class="sym">(</span>l<span class="sym">,</span> m <span class="sym">-</span> <span class="num">1</span><span class="sym">)</span>
			<span class="kwa">val</span> _ <span class="sym">=</span> qsort <span class="sym">(</span>m <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> u<span class="sym">)</span>
		     <span class="kwa">in</span> <span class="sym">()</span>
		     <span class="kwa">end</span>
	       <span class="kwa">else</span> <span class="sym">()</span>
	    <span class="kwa">val</span> max <span class="sym">=</span> Array.length a <span class="sym">-</span> <span class="num">1</span>
	    <span class="kwa">val</span> _ <span class="sym">=</span> qsort <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> max<span class="sym">)</span>
	    <span class="kwa">val</span> _ <span class="sym">=</span> insertionSort <span class="sym">(</span>a<span class="sym">,</span> <span class="kwa">op</span> <span class="sym">&lt;=)</span>
	 <span class="kwa">in</span>
	    <span class="sym">()</span>
	 <span class="kwa">end</span>
   <span class="kwa">end</span>

<span class="kwa">structure</span> Test <span class="sym">:</span> <span class="kwa">sig</span>
    <span class="kwa">val</span> main <span class="sym">: (</span><span class="kwb">string</span> <span class="sym">*</span> <span class="kwb">string</span> list<span class="sym">) -&gt;</span> OS.Process.status
<span class="kwa">end</span> <span class="sym">=</span> <span class="kwa">struct</span>

<span class="com">(* This hash function is taken from pages 56-57 of</span>
<span class="com"> * The Practice of Programming by Kernighan and Pike.</span>
<span class="com"> *)</span>
<span class="kwa">fun</span> hash <span class="sym">(</span>s<span class="sym">:</span> <span class="kwb">string</span><span class="sym">):</span> <span class="kwb">word</span> <span class="sym">=</span>
   <span class="kwa">let</span>
      <span class="kwa">val</span> n <span class="sym">=</span> <span class="kwa">String</span>.size s
      <span class="kwa">fun</span> loop <span class="sym">(</span>i<span class="sym">,</span> w<span class="sym">) =</span>
	 <span class="kwa">if</span> i <span class="sym">=</span> n
	    <span class="kwa">then</span> w
	 <span class="kwa">else Word</span>.fromInt <span class="sym">(</span><span class="kwa">Char</span>.ord <span class="sym">(</span><span class="kwa">String</span>.sub <span class="sym">(</span>s<span class="sym">,</span> i<span class="sym">))) +</span> <span class="kwa">Word</span>.<span class="sym">* (</span>w<span class="sym">,</span> <span class="num">0</span>w31<span class="sym">)</span>
   <span class="kwa">in</span>
      loop <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> <span class="num">0</span>w0<span class="sym">)</span>
   <span class="kwa">end</span>

<span class="kwa">fun</span> hash <span class="sym">(</span>s<span class="sym">:</span> <span class="kwb">string</span><span class="sym">):</span> <span class="kwb">word</span> <span class="sym">=</span>
   <span class="kwa">let</span>
      <span class="kwa">val</span> n <span class="sym">=</span> <span class="kwa">String</span>.size s
      <span class="kwa">fun</span> loop <span class="sym">(</span>i<span class="sym">,</span> w<span class="sym">) =</span>
	 <span class="kwa">if</span> i <span class="sym">=</span> n
	    <span class="kwa">then</span> w
	 <span class="kwa">else</span> loop <span class="sym">(</span>i <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span>
		    <span class="kwa">Word</span>.fromInt <span class="sym">(</span><span class="kwa">Char</span>.ord <span class="sym">(</span><span class="kwa">String</span>.sub <span class="sym">(</span>s<span class="sym">,</span> i<span class="sym">)))</span>
		       <span class="sym">+</span> <span class="kwa">Word</span>.<span class="sym">* (</span>w<span class="sym">,</span> <span class="num">0</span>w31<span class="sym">))</span>
   <span class="kwa">in</span>
      loop <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> <span class="num">0</span>w0<span class="sym">)</span>
   <span class="kwa">end</span>

<span class="com">(* Based on wordfreq.ocaml. *)</span>

<span class="kwa">val</span> max <span class="sym">=</span> <span class="num">4096</span>
<span class="kwa">val</span> buf <span class="sym">=</span> Word8Array.array <span class="sym">(</span>max<span class="sym">,</span> <span class="num">0</span>w0<span class="sym">)</span>
<span class="kwa">val</span> count<span class="sym">: {</span>hash<span class="sym">:</span> <span class="kwb">word</span><span class="sym">,</span>
	    <span class="kwb">word</span><span class="sym">:</span> <span class="kwb">string</span><span class="sym">,</span>
	    count<span class="sym">:</span> <span class="kwb">int</span> ref<span class="sym">}</span> HashSet.t <span class="sym">=</span> HashSet.new <span class="sym">{</span>hash <span class="sym">=</span> #hash<span class="sym">}</span>
<span class="kwa">val</span> wbuf <span class="sym">=</span> Buffer.new <span class="num">64</span>

<span class="kwa">val</span> c2b <span class="sym">=</span> Byte.charToByte
<span class="kwa">fun</span> scan_words <span class="sym">(</span>i<span class="sym">,</span> n<span class="sym">,</span> inword<span class="sym">) =</span>
  <span class="kwa">if</span> i <span class="sym">&lt;</span> n
     <span class="kwa">then</span>
	<span class="kwa">let</span>
	   <span class="kwa">val</span> c <span class="sym">=</span> Word8Array.sub <span class="sym">(</span>buf<span class="sym">,</span> i<span class="sym">)</span>
	<span class="kwa">in</span>
	   <span class="kwa">if</span> c2b #<span class="str">&quot;a&quot;</span> <span class="sym">&lt;=</span> c <span class="kwa">andalso</span> c <span class="sym">&lt;=</span> c2b #<span class="str">&quot;z&quot;</span>
	      <span class="kwa">then</span> <span class="sym">(</span>Buffer.add <span class="sym">(</span>wbuf<span class="sym">,</span> c<span class="sym">);</span>
		    scan_words <span class="sym">(</span>i <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> n<span class="sym">,</span> <span class="kwa">true</span><span class="sym">))</span>
	   <span class="kwa">else</span>
	      <span class="kwa">if</span> c2b #<span class="str">&quot;A&quot;</span> <span class="sym">&lt;=</span> c <span class="kwa">andalso</span> c <span class="sym">&lt;=</span> c2b #<span class="str">&quot;Z&quot;</span>
		 <span class="kwa">then</span>
		    <span class="sym">(</span>Buffer.add <span class="sym">(</span>wbuf<span class="sym">,</span> c <span class="sym">+</span> <span class="num">0</span>w32<span class="sym">);</span>
		     scan_words <span class="sym">(</span>i <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> n<span class="sym">,</span> <span class="kwa">true</span><span class="sym">))</span>
	      <span class="kwa">else</span>
		 <span class="kwa">if</span> inword
		    <span class="kwa">then</span>
		       <span class="kwa">let</span>
			  <span class="kwa">val</span> w <span class="sym">=</span> Buffer.contents wbuf
			  <span class="kwa">val</span> h <span class="sym">=</span> hash w
		       <span class="kwa">in</span>
			  incr <span class="sym">(</span>#count
				<span class="sym">(</span>HashSet.lookupOrInsert
				 <span class="sym">(</span>count<span class="sym">,</span> h<span class="sym">,</span>
				  <span class="kwa">fn</span> <span class="sym">{</span>hash<span class="sym">,</span> <span class="kwb">word</span><span class="sym">,</span> ...<span class="sym">} =&gt;</span>
				  hash <span class="sym">=</span> h <span class="kwa">andalso</span> <span class="kwb">word</span> <span class="sym">=</span> w<span class="sym">,</span>
				  <span class="kwa">fn</span> <span class="sym">() =&gt; {</span>hash <span class="sym">=</span> h<span class="sym">,</span> <span class="kwb">word</span> <span class="sym">=</span> w<span class="sym">,</span> count <span class="sym">=</span> ref <span class="num">0</span><span class="sym">})));</span>
			  Buffer.clear wbuf<span class="sym">;</span>
			  scan_words <span class="sym">(</span>i <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> n<span class="sym">,</span> <span class="kwa">false</span><span class="sym">)</span>
		       <span class="kwa">end</span>
		 <span class="kwa">else</span> scan_words <span class="sym">(</span>i <span class="sym">+</span> <span class="num">1</span><span class="sym">,</span> n<span class="sym">,</span> <span class="kwa">false</span><span class="sym">)</span>
	<span class="kwa">end</span>
  <span class="kwa">else</span>
     <span class="kwa">let</span>
	<span class="kwa">val</span> nread <span class="sym">=</span>
	   Posix.IO.readArr <span class="sym">(</span>Posix.FileSys.stdin<span class="sym">,</span> Word8ArraySlice.full buf<span class="sym">)</span>
     <span class="kwa">in</span>
	<span class="kwa">if</span> nread <span class="sym">=</span> <span class="num">0</span>
	   <span class="kwa">then</span> <span class="sym">()</span>
	<span class="kwa">else</span> scan_words <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> nread<span class="sym">,</span> inword<span class="sym">)</span>
     <span class="kwa">end</span>

<span class="kwa">fun</span> printl <span class="sym">[] =</span> print <span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span> <span class="sym">|</span> printl<span class="sym">(</span>h<span class="sym">::</span>t<span class="sym">) = (</span> print h <span class="sym">;</span> printl t <span class="sym">)</span>

<span class="kwa">fun</span> rightJustify <span class="sym">(</span>s<span class="sym">:</span> <span class="kwb">string</span><span class="sym">,</span> width<span class="sym">:</span> <span class="kwb">int</span><span class="sym">) =</span>
   <span class="kwa">let</span>
      <span class="kwa">val</span> n <span class="sym">=</span> <span class="kwa">String</span>.size s
   <span class="kwa">in</span> concat <span class="sym">[</span>CharVector.tabulate <span class="sym">(</span>width <span class="sym">-</span> n<span class="sym">,</span> <span class="kwa">fn</span> _ <span class="sym">=&gt;</span> #<span class="str">&quot; &quot;</span><span class="sym">),</span> s<span class="sym">]</span>
   <span class="kwa">end</span>

<span class="kwa">fun</span> main <span class="sym">(</span>name<span class="sym">,</span> args<span class="sym">) =</span>
   <span class="kwa">let</span>
	<span class="kwa">val</span> _ <span class="sym">=</span> scan_words <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> <span class="num">0</span><span class="sym">,</span> <span class="kwa">false</span><span class="sym">)</span>
	<span class="kwa">val</span> a <span class="sym">=</span> Array.array <span class="sym">(</span>HashSet.size count<span class="sym">, (</span><span class="num">0</span><span class="sym">,</span> <span class="str">&quot;&quot;</span><span class="sym">))</span>
	<span class="kwa">val</span> i <span class="sym">=</span> ref <span class="num">0</span>
	<span class="kwa">val</span> _ <span class="sym">=</span> HashSet.foreach <span class="sym">(</span>count<span class="sym">,</span> <span class="kwa">fn</span> <span class="sym">{</span><span class="kwb">word</span><span class="sym">,</span> count<span class="sym">,</span> ...<span class="sym">} =&gt;</span>
			 <span class="sym">(</span>Array.update <span class="sym">(</span>a<span class="sym">, !</span>i<span class="sym">, (!</span>count<span class="sym">,</span> <span class="kwb">word</span><span class="sym">));</span> incr i<span class="sym">))</span>
	<span class="kwa">val</span> _ <span class="sym">=</span> Quicksort.quicksort <span class="sym">(</span>a<span class="sym">,</span> <span class="kwa">fn</span> <span class="sym">((</span>c<span class="sym">,</span> w<span class="sym">), (</span>c'<span class="sym">,</span> w'<span class="sym">)) =&gt;</span>
			     c <span class="sym">&gt;</span> c' <span class="kwa">orelse</span> c <span class="sym">=</span> c' <span class="kwa">andalso</span> w <span class="sym">&gt;=</span> w'<span class="sym">)</span>
	<span class="kwa">val</span> _ <span class="sym">=</span> Array.app <span class="sym">(</span><span class="kwa">fn</span> <span class="sym">(</span>c<span class="sym">,</span> w<span class="sym">) =&gt;</span>
		   printl <span class="sym">[</span>rightJustify <span class="sym">(</span><span class="kwa">Int</span>.toString c<span class="sym">,</span> <span class="num">7</span><span class="sym">),</span> <span class="str">&quot; &quot;</span><span class="sym">,</span> w<span class="sym">])</span> a
   <span class="kwa">in</span>
      OS.Process.success
   <span class="kwa">end</span>
<span class="kwa">end</span>

<span class="kwa">val</span> _ <span class="sym">=</span> Test.main<span class="sym">(</span> CommandLine.name<span class="sym">(),</span> CommandLine.arguments<span class="sym">() )</span>
