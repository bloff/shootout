<span class="dir">#!/bin/env groovy
</span><span class="com">/*
	$Id: knucleotide-groovy.code,v 1.1 2005-09-21 05:17:34 bfulgham Exp $

	The Great Computer Language Shootout
	http://shootout.alioth.debian.org/

	contributed by Jochen Hinrichsen
	modified by

    Each program should

        * read line-by-line a redirected FASTA format file from stdin
        * extract DNA sequence THREE
        * define a procedure/function to update a hashtable of k-nucleotide keys and count values, for a particular reading-frame â&Agrave;” even though we'll combine k-nucleotide counts for all reading-frames (grow the hashtable from a small default size)
        * write the code and percentage frequency, for all the 1-nucleotide and 2-nucleotide sequences, sorted by descending frequency and then ascending k-nucleotide key
        * count all the 3- 4- 6- 12- and 18-nucleotide sequences, and write the count and code for specific sequences

    We use FASTA files generated by the fasta benchmark as input for this benchmark. Note: the file may include both lowercase and uppercase codes.

    Correct output for this 100KB input file (generated with the fasta program N = 10000), is

    A 30.284
    T 29.796
    C 20.312
    G 19.608

    AA 9.212
    AT 8.950
    TT 8.948
    TA 8.936
    CA 6.166
    CT 6.100
    AC 6.086
    TC 6.042
    AG 6.036
    GA 5.968
    TG 5.868
    GT 5.798
    CC 4.140
    GC 4.044
    CG 3.906
    GG 3.798

    562     GGT
    152     GGTA
    15      GGTATT
    0       GGTATTTTAATT
    0       GGTATTTTAATTTATAGT


    In practice, less brute-force would be used to calculate k-nucleotide frequencies, for example Virus Classification using k-nucleotide Frequencies and A Fast Algorithm for the Exhaustive Analysis of 12-Nucleotide-Long DNA Sequences. Applications to Human Genomics (105KB pdf).
*/</span>

def sequence <span class="sym">=</span> readSequence<span class="sym">(</span>System<span class="sym">.</span>in<span class="sym">,</span> <span class="str">&quot;&gt;THREE&quot;</span><span class="sym">).</span>toUpperCase<span class="sym">()
</span>assert sequence<span class="sym">.</span>size<span class="sym">() &gt;</span> <span class="num">1000

</span><span class="sym">[</span><span class="num">1</span><span class="sym">,</span> <span class="num">2</span><span class="sym">].</span>each<span class="sym">() {
</span>    writeFrequency<span class="sym">(</span>sequence<span class="sym">,</span> it<span class="sym">)
}

[</span> <span class="str">&quot;GGT&quot;</span><span class="sym">,</span> <span class="str">&quot;GGTA&quot;</span><span class="sym">,</span> <span class="str">&quot;GGTATT&quot;</span><span class="sym">,</span> <span class="str">&quot;GGTATTTTAATT&quot;</span><span class="sym">,</span> <span class="str">&quot;GGTATTTTAATTTATAGT&quot;</span> <span class="sym">].</span>each<span class="sym">() {
</span>        println <span class="str">&quot;${sequence.count(it)}</span><span class="esc">\t</span><span class="str">${it}&quot;</span>
<span class="sym">}

</span>def readSequence<span class="sym">(</span>streamin<span class="sym">,</span> id<span class="sym">) {
</span>    def sequence <span class="sym">=</span> <span class="str">&quot;&quot;</span>
    def record <span class="sym">=</span> <span class="kwa">false
</span>    streamin<span class="sym">.</span>eachLine<span class="sym">() {</span> line <span class="sym">-&gt;
</span>        <span class="kwa">switch</span> <span class="sym">(</span>line<span class="sym">) {
</span>            <span class="kwa">case</span> <span class="sym">~</span><span class="str">&quot;^$id.*&quot;</span><span class="sym">:
</span>                record <span class="sym">=</span> <span class="kwa">true
                break

            case</span> <span class="sym">[~</span><span class="str">&quot;^&gt;.*&quot;</span><span class="sym">, ~</span><span class="str">&quot;^;.*&quot;</span><span class="sym">]:
</span>                record <span class="sym">=</span> <span class="kwa">false
                break

            default</span><span class="sym">:
</span>                <span class="kwa">if</span> <span class="sym">(</span>record<span class="sym">) {
</span>                    sequence <span class="sym">+=</span> line
                <span class="sym">}
        }
    }
</span>    sequence
<span class="sym">}

</span>def writeFrequency<span class="sym">(</span>sequence<span class="sym">,</span> f<span class="sym">) {
</span>    def count <span class="sym">= [:]
</span>    def formater <span class="sym">=</span> <span class="kwa">new</span> java<span class="sym">.</span>text<span class="sym">.</span>DecimalFormat<span class="sym">(</span><span class="str">&quot;#0.000&quot;</span><span class="sym">)
</span>    <span class="kwa">for</span> <span class="sym">(</span>offset in <span class="num">0</span><span class="sym">..&lt;</span>f<span class="sym">)</span> frequency<span class="sym">(</span>sequence<span class="sym">,</span> f<span class="sym">,</span> offset<span class="sym">,</span> count<span class="sym">)

</span>    <span class="slc">// default sort() is smallest first
</span>    <span class="slc">// sort for multiple properties: [ it.value, it.key ]
</span>    count<span class="sym">.</span>values<span class="sym">().</span>sort<span class="sym">({</span> l<span class="sym">,</span> r <span class="sym">-&gt;</span> r <span class="sym">&lt;=&gt;</span> l<span class="sym">}).</span>each<span class="sym">() {</span> value <span class="sym">-&gt;
</span>        def entry <span class="sym">=</span> count<span class="sym">.</span>find<span class="sym">() {</span> entry <span class="sym">-&gt;
</span>            entry<span class="sym">.</span>getValue<span class="sym">() ==</span> value
        <span class="sym">}

</span>        println <span class="str">&quot;${entry.key} ${formater.format(100.0*value/sequence.size())}&quot;</span>
    <span class="sym">}

</span>    println <span class="str">&quot;&quot;</span>
<span class="sym">}

</span>def frequency<span class="sym">(</span>sequence<span class="sym">,</span> f<span class="sym">,</span> offset<span class="sym">,</span> count<span class="sym">) {
</span>    def n <span class="sym">=</span> sequence<span class="sym">.</span>size<span class="sym">()
</span>    def last <span class="sym">=</span> n <span class="sym">-</span> f <span class="sym">+</span> <span class="num">1

</span>    <span class="sym">(</span>offset<span class="sym">..&lt;</span>last<span class="sym">).</span>step<span class="sym">(</span>f<span class="sym">) {</span> i <span class="sym">-&gt;
</span>        def key <span class="sym">=</span> sequence<span class="sym">[</span>i<span class="sym">..&lt;</span>i<span class="sym">+</span>f<span class="sym">]
</span>        <span class="slc">// No automatic defaulting
</span>        <span class="kwa">if</span> <span class="sym">(</span>count<span class="sym">[</span>key<span class="sym">] ==</span> null<span class="sym">)</span> count<span class="sym">[</span>key<span class="sym">] =</span> <span class="num">1
</span>        <span class="slc">// ++ results in error
</span>        <span class="kwa">else</span> count<span class="sym">[</span>key<span class="sym">] +=</span> <span class="num">1
</span>    <span class="sym">}
}

</span><span class="slc">// EOF
</span>
