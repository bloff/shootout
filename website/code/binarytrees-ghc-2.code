<span class="com">{-# OPTIONS_GHC -fglasgow-exts -O2 -optc-O3 -funbox-strict-fields #-}</span>
<span class="slc">-- The Great Computer Language Shootout</span>
<span class="slc">-- http://shootout.alioth.debian.org/</span>
<span class="slc">-- Simon Marlow</span>
<span class="slc">-- Shortened by Don Stewart</span>
<span class="slc">-- De-optimized by Isaac Gouy</span>

<span class="kwa">import</span> System<span class="sym">;</span> <span class="kwa">import</span> Text.Printf<span class="sym">;</span> <span class="kwa">import</span> Monad

<span class="kwa">data</span> Tree <span class="sym">=</span> Nil <span class="sym">|</span> Node <span class="sym">!</span><span class="kwb">Int</span> Tree Tree

min<span class="str">' = 4 :: Int</span>
<span class="str"></span>
<span class="str">main = do max'</span> <span class="sym">&lt;-</span> getArgs <span class="sym">&gt;&gt;=</span> return . max <span class="sym">(</span>min<span class="str">'+2) . read . head</span>
<span class="str">          printf &quot;stretch tree of depth %d\t check: %d\n&quot; (max'</span><span class="sym">+</span><span class="num">1</span><span class="sym">) (</span>itemCheck $ make <span class="num">0</span> <span class="sym">(</span>max<span class="str">'+1))</span>
<span class="str">          depthLoop min'</span> max<span class="str">'</span>
<span class="str">          printf &quot;long lived tree of depth %d\t check: %d\n&quot; max'</span> <span class="sym">(</span>itemCheck $ make <span class="num">0</span> max<span class="str">')</span>
<span class="str"></span>
<span class="str">depthLoop d m = when (d &lt;= m) $ do</span>
<span class="str">    printf &quot;%d\t trees of depth %d\t check: %d\n&quot; (2*n) d (sumLoop n d 0)</span>
<span class="str">    depthLoop (d+2) m</span>
<span class="str">    where n = 2^(m - d + min'</span><span class="sym">)</span>

sumLoop <span class="num">0</span> d acc <span class="sym">=</span> acc
sumLoop k d acc <span class="sym">=</span> c `seq` sumLoop <span class="sym">(</span>k<span class="sym">-</span><span class="num">1</span><span class="sym">)</span> d <span class="sym">(</span>acc <span class="sym">+</span> c <span class="sym">+</span> c<span class="str">')</span>
<span class="str">    where (c,c'</span><span class="sym">)  = (</span>itemCheck <span class="sym">(</span>make k d<span class="sym">),</span> itemCheck <span class="sym">(</span>make <span class="sym">(-</span><span class="num">1</span><span class="sym">*</span>k<span class="sym">)</span> d<span class="sym">))</span>

<span class="slc">-- make i (0::Int) = i `seq` Nil</span>
make i <span class="sym">(</span><span class="num">0</span><span class="sym">::</span><span class="kwb">Int</span><span class="sym">) =</span> Node i Nil Nil
make i  d       <span class="sym">=</span> Node i <span class="sym">(</span>make <span class="sym">((</span><span class="num">2</span><span class="sym">*</span>i<span class="sym">)-</span><span class="num">1</span><span class="sym">) (</span>d<span class="sym">-</span><span class="num">1</span><span class="sym">)) (</span>make <span class="sym">(</span><span class="num">2</span><span class="sym">*</span>i<span class="sym">) (</span>d<span class="sym">-</span><span class="num">1</span><span class="sym">))</span>

itemCheck Nil <span class="sym">=</span> <span class="num">0</span>
itemCheck <span class="sym">(</span>Node x l r<span class="sym">) =</span> x <span class="sym">+</span> itemCheck l <span class="sym">-</span> itemCheck r
