<span class="str">&quot;  The Great Computer Language Shootout
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy

   To run: gst -QI /usr/share/gnu-smalltalk/gst.im pidigits.st -a 100
&quot;</span>

Object subclass<span class="sym">:</span> <span class="slc">#Transformation
</span>instanceVariableNames<span class="sym">:</span> <span class="str">'q r s t k'</span>
classVariableNames<span class="sym">:</span> <span class="str">''</span>
poolDictionaries<span class="sym">:</span> <span class="str">''</span>
category<span class="sym">:</span> nil <span class="sym">!

!</span>Transformation class methodsFor<span class="sym">:</span> <span class="str">'instance creation'</span><span class="sym">!

</span>new
   ^super new initialize <span class="sym">!

</span>q<span class="sym">:</span> anInteger1 r<span class="sym">:</span> anInteger2 s<span class="sym">:</span> anInteger3 t<span class="sym">:</span> anInteger4
   ^<span class="sym">(</span>super new<span class="sym">)</span> q<span class="sym">:</span> anInteger1 r<span class="sym">:</span> anInteger2 s<span class="sym">:</span> anInteger3 t<span class="sym">:</span> anInteger4 <span class="sym">!

</span>unity
   ^self q<span class="sym">:</span> <span class="num">1</span> r<span class="sym">:</span> <span class="num">0</span> s<span class="sym">:</span> <span class="num">0</span> t<span class="sym">:</span> <span class="num">1</span> <span class="sym">! !


!</span>Transformation methodsFor<span class="sym">:</span> <span class="str">'initialize-release'</span><span class="sym">!

</span>initialize
   q <span class="sym">:=</span> <span class="num">0</span>.
   r <span class="sym">:=</span> <span class="num">0</span>.
   s <span class="sym">:=</span> <span class="num">0</span>.
   t <span class="sym">:=</span> <span class="num">0</span>.
   k <span class="sym">:=</span> <span class="num">0</span>. <span class="sym">! !

!</span>Transformation methodsFor<span class="sym">:</span> <span class="str">'accessing'</span><span class="sym">!

*</span> aTransformation
   ^self species
      q<span class="sym">:</span> q <span class="sym">*</span> aTransformation q
      r<span class="sym">:</span> q <span class="sym">*</span> aTransformation r <span class="sym">+ (</span>r <span class="sym">*</span> aTransformation t<span class="sym">)
</span>      s<span class="sym">:</span> s <span class="sym">*</span> aTransformation q <span class="sym">+ (</span>t <span class="sym">*</span> aTransformation s<span class="sym">)
</span>      t<span class="sym">:</span> s <span class="sym">*</span> aTransformation r <span class="sym">+ (</span>t <span class="sym">*</span> aTransformation t<span class="sym">) !

</span>extract<span class="sym">:</span> anInteger
   ^<span class="sym">(</span>q <span class="sym">*</span> anInteger <span class="sym">+</span> r<span class="sym">) / (</span>s <span class="sym">*</span> anInteger <span class="sym">+</span> t<span class="sym">) !

</span><span class="kwa">next
</span>   k <span class="sym">:=</span> k <span class="sym">+</span><span class="num">1</span>.
   q <span class="sym">:=</span> k.
   r <span class="sym">:=</span> <span class="num">4</span> <span class="sym">*</span> k <span class="sym">+</span> <span class="num">2</span>.
   s <span class="sym">:=</span> <span class="num">0</span>.
   t <span class="sym">:=</span> <span class="num">2</span> <span class="sym">*</span> k <span class="sym">+</span> <span class="num">1</span>. <span class="sym">!

</span>q
   ^q <span class="sym">!

</span>r
   ^r <span class="sym">!

</span>s
   ^s <span class="sym">!

</span>t
   ^t <span class="sym">!

</span>q<span class="sym">:</span> anInteger1 r<span class="sym">:</span> anInteger2 s<span class="sym">:</span> anInteger3 t<span class="sym">:</span> anInteger4
   q <span class="sym">:=</span> anInteger1.
   r <span class="sym">:=</span> anInteger2.
   s <span class="sym">:=</span> anInteger3.
   t <span class="sym">:=</span> anInteger4.
   k <span class="sym">:=</span> <span class="num">0</span>. <span class="sym">! !



</span>Object subclass<span class="sym">:</span> <span class="slc">#PiDigitSpigot
</span>instanceVariableNames<span class="sym">:</span> <span class="str">'z x inverse'</span>
classVariableNames<span class="sym">:</span> <span class="str">''</span>
poolDictionaries<span class="sym">:</span> <span class="str">''</span>
category<span class="sym">:</span> nil <span class="sym">!


!</span>PiDigitSpigot class methodsFor<span class="sym">:</span> <span class="str">'instance creation'</span><span class="sym">!

</span>new
   ^super new initialize <span class="sym">! !


!</span>PiDigitSpigot methodsFor<span class="sym">:</span> <span class="str">'initialize-release'</span><span class="sym">!

</span>initialize
   z <span class="sym">:=</span> Transformation unity.
   x <span class="sym">:=</span> Transformation new.
   inverse <span class="sym">:=</span> Transformation new. <span class="sym">! !

!</span>PiDigitSpigot methodsFor<span class="sym">:</span> <span class="str">'accessing'</span><span class="sym">!

</span><span class="kwa">next
</span>   <span class="sym">|</span> y <span class="sym">|
</span>   ^<span class="sym">(</span>self isSafe<span class="sym">: (</span>y <span class="sym">:=</span> self digit<span class="sym">))
</span>      ifTrue<span class="sym">: [</span>z <span class="sym">:=</span> self produce<span class="sym">:</span> y. y<span class="sym">]
</span>      ifFalse<span class="sym">: [</span>z <span class="sym">:=</span> self consume<span class="sym">:</span> x <span class="kwa">next</span>. self <span class="kwa">next</span><span class="sym">] ! !


!</span>PiDigitSpigot methodsFor<span class="sym">:</span> <span class="str">'private'</span><span class="sym">!

</span>consume<span class="sym">:</span> aTransformation
   ^z <span class="sym">*</span> aTransformation <span class="sym">!

</span>digit
   ^<span class="sym">(</span>z extract<span class="sym">:</span> <span class="num">3</span><span class="sym">)</span> floor <span class="sym">!

</span>isSafe<span class="sym">:</span> aDigit
   ^aDigit <span class="sym">= (</span>z extract<span class="sym">:</span> <span class="num">4</span><span class="sym">)</span> floor <span class="sym">!

</span>produce<span class="sym">:</span> anInteger
   inverse q<span class="sym">:</span> <span class="num">10</span> r<span class="sym">: -</span><span class="num">10</span> <span class="sym">*</span> anInteger s<span class="sym">:</span> <span class="num">0</span> t<span class="sym">:</span> <span class="num">1</span>.
   ^inverse <span class="sym">*</span> z <span class="sym">! !



|</span> i length n pidigits stream <span class="sym">|
</span>n <span class="sym">:=</span> Smalltalk arguments first asInteger.
i <span class="sym">:=</span> <span class="num">0</span>.
length <span class="sym">:=</span> <span class="num">10</span>.
pidigits <span class="sym">:=</span> PiDigitSpigot new.

stream <span class="sym">:=</span> ReadWriteStream on<span class="sym">: (</span>String new<span class="sym">:</span> <span class="num">30</span><span class="sym">)</span>.

<span class="sym">[</span>n <span class="sym">&gt;</span> <span class="num">0</span><span class="sym">]</span> whileTrue<span class="sym">: [

   (</span>n <span class="sym">&lt;</span> length<span class="sym">)
</span>      ifTrue<span class="sym">: [
</span>         n timesRepeat<span class="sym">: [
</span>            stream nextPut<span class="sym">: (</span>Character digitValue<span class="sym">:</span> pidigits <span class="kwa">next</span><span class="sym">)
            ]</span>.

         n to<span class="sym">:</span> length <span class="kwa">do</span><span class="sym">: [:</span>each<span class="sym">|</span> stream space<span class="sym">]</span>.
         i <span class="sym">:=</span> i <span class="sym">+</span> n.
         <span class="sym">]

</span>      ifFalse<span class="sym">: [
</span>         length timesRepeat<span class="sym">: [
</span>            stream nextPut<span class="sym">: (</span>Character digitValue<span class="sym">:</span> pidigits <span class="kwa">next</span><span class="sym">)
            ]</span>.

         i <span class="sym">:=</span> i <span class="sym">+</span> length.
         <span class="sym">]</span>.

   stream tab nextPut<span class="sym">:</span> <span class="kwb">$</span><span class="sym">:</span>.
   i printOn<span class="sym">:</span> stream.
   stream nl.

   Transcript nextPutAll<span class="sym">: (</span>stream contents<span class="sym">)</span>.
   stream reset.
   n <span class="sym">:=</span> n <span class="sym">-</span> length.
<span class="sym">] !</span>
