<span class="str">&quot;* The Computer Language Shootout</span>
<span class="str">    http://shootout.alioth.debian.org/</span>
<span class="str">    contributed by Isaac Gouy</span>
<span class="str">    modified by Eliot Miranda *&quot;</span><span class="sym">!</span>

Object subclass<span class="sym">:</span> <span class="slc">#PiDigitSpigot   instanceVariableNames: 'z x inverse'   classVariableNames: ''   poolDictionaries: ''   category: 'Shootout'!</span>

Object subclass<span class="sym">:</span> <span class="slc">#Transformation   instanceVariableNames: 'q r s t k'   classVariableNames: ''   poolDictionaries: ''   category: 'Shootout'!!PiDigitSpigot methodsFor: 'private'!consume: aTransformation   ^z * aTransformation! !!PiDigitSpigot methodsFor: 'private'!digit   ^(z extract: 3) floor! !!PiDigitSpigot methodsFor: 'private'!isSafe: aDigit   ^aDigit = (z extract: 4) floor! !!PiDigitSpigot methodsFor: 'private'!produce: anInteger   inverse q: 10 r: -10 * anInteger s: 0 t: 1.   ^inverse * z! !!PiDigitSpigot methodsFor: 'accessing'!next   | y |   ^(self isSafe: (y := self digit))      ifTrue: [z := self produce: y. y]      ifFalse: [z := self consume: x next. self next]! !!PiDigitSpigot methodsFor: 'initialize-release'!initialize   z := Transformation unity.   x := Transformation new.   inverse := Transformation new.! !!PiDigitSpigot class methodsFor: 'instance creation'!new   ^super new initialize! !!Tests class methodsFor: 'benchmarking'!pidigitsTo: v width: width to: output   | n i pidigits |   n := v.   i := 0.   pidigits := PiDigitSpigot new.   [n &gt; 0] whileTrue:      [n &lt; width         ifTrue:            [n timesRepeat: [output nextPut: (Character digitValue: pidigits next)].            n to: width do: [:each | output space].            i := i + n]         ifFalse:            [width timesRepeat: [output nextPut: (Character digitValue: pidigits next)].            i := i + width].</span>
      output tab<span class="sym">;</span> nextPut<span class="sym">: $:;</span> print<span class="sym">:</span> i<span class="sym">;</span> nl.
      n <span class="sym">:=</span> n <span class="sym">-</span> width<span class="sym">]! !!</span>Tests class methodsFor<span class="sym">:</span> <span class="str">'benchmark scripts'</span><span class="sym">!</span>pidigits   self pidigitsTo<span class="sym">:</span> self arg width<span class="sym">:</span> <span class="num">10</span> to<span class="sym">:</span> self stdout.   ^<span class="str">''</span><span class="sym">! !!</span>Transformation methodsFor<span class="sym">:</span> <span class="str">'accessing'</span><span class="sym">!*</span> aTransformation   ^self species       q<span class="sym">:</span> q <span class="sym">*</span> aTransformation q      r<span class="sym">:</span> q <span class="sym">*</span> aTransformation r <span class="sym">+ (</span>r <span class="sym">*</span> aTransformation t<span class="sym">)</span>      s<span class="sym">:</span> s <span class="sym">*</span> aTransformation q <span class="sym">+ (</span>t <span class="sym">*</span> aTransformation s<span class="sym">)</span>      t<span class="sym">:</span> s <span class="sym">*</span> aTransformation r <span class="sym">+ (</span>t <span class="sym">*</span> aTransformation t<span class="sym">)! !!</span>Transformation methodsFor<span class="sym">:</span> <span class="str">'accessing'</span><span class="sym">!</span>extract<span class="sym">:</span> anInteger   ^<span class="sym">(</span>q <span class="sym">*</span> anInteger <span class="sym">+</span> r<span class="sym">) // (</span>s <span class="sym">*</span> anInteger <span class="sym">+</span> t<span class="sym">)! !!</span>Transformation methodsFor<span class="sym">:</span> <span class="str">'accessing'</span><span class="sym">!</span><span class="kwa">next</span>   k <span class="sym">:=</span> k <span class="sym">+</span><span class="num">1</span>.   q <span class="sym">:=</span> k.   r <span class="sym">:=</span> <span class="num">4</span> <span class="sym">*</span> k <span class="sym">+</span> <span class="num">2</span>.   s <span class="sym">:=</span> <span class="num">0</span>.   t <span class="sym">:=</span> <span class="num">2</span> <span class="sym">*</span> k <span class="sym">+</span> <span class="num">1</span>.<span class="sym">! !!</span>Transformation methodsFor<span class="sym">:</span> <span class="str">'accessing'</span><span class="sym">!</span>q   ^q<span class="sym">! !!</span>Transformation methodsFor<span class="sym">:</span> <span class="str">'accessing'</span><span class="sym">!</span>q<span class="sym">:</span> anInteger1 r<span class="sym">:</span> anInteger2 s<span class="sym">:</span> anInteger3 t<span class="sym">:</span> anInteger4   q <span class="sym">:=</span> anInteger1.   r <span class="sym">:=</span> anInteger2.   s <span class="sym">:=</span> anInteger3.   t <span class="sym">:=</span> anInteger4.   k <span class="sym">:=</span> <span class="num">0</span>.<span class="sym">! !!</span>Transformation methodsFor<span class="sym">:</span> <span class="str">'accessing'</span><span class="sym">!</span>r   ^r<span class="sym">! !!</span>Transformation methodsFor<span class="sym">:</span> <span class="str">'accessing'</span><span class="sym">!</span>s   ^s<span class="sym">! !!</span>Transformation methodsFor<span class="sym">:</span> <span class="str">'accessing'</span><span class="sym">!</span>t   ^t<span class="sym">! !!</span>Transformation methodsFor<span class="sym">:</span> <span class="str">'initialize-release'</span><span class="sym">!</span>initialize   q <span class="sym">:=</span> <span class="num">0</span>.   r <span class="sym">:=</span> <span class="num">0</span>.   s <span class="sym">:=</span> <span class="num">0</span>.   t <span class="sym">:=</span> <span class="num">0</span>.   k <span class="sym">:=</span> <span class="num">0</span>.<span class="sym">! !!</span>Transformation class methodsFor<span class="sym">:</span> <span class="str">'instance creation'</span><span class="sym">!</span>new   ^super new initialize<span class="sym">! !!</span>Transformation class methodsFor<span class="sym">:</span> <span class="str">'instance creation'</span><span class="sym">!</span>q<span class="sym">:</span> anInteger1 r<span class="sym">:</span> anInteger2 s<span class="sym">:</span> anInteger3 t<span class="sym">:</span> anInteger4   ^<span class="sym">(</span>super new<span class="sym">)</span> q<span class="sym">:</span> anInteger1 r<span class="sym">:</span> anInteger2 s<span class="sym">:</span> anInteger3 t<span class="sym">:</span> anInteger4<span class="sym">! !!</span>Transformation class methodsFor<span class="sym">:</span> <span class="str">'instance creation'</span><span class="sym">!</span>unity   ^self q<span class="sym">:</span> <span class="num">1</span> r<span class="sym">:</span> <span class="num">0</span> s<span class="sym">:</span> <span class="num">0</span> t<span class="sym">:</span> <span class="num">1</span><span class="sym">! !</span>

Tests pidigits<span class="sym">!</span>
