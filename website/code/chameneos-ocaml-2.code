<span class="com">(*</span>
<span class="com"> * The Computer Language Shootout</span>
<span class="com"> * http://shootout.alioth.debian.org/</span>
<span class="com"> *</span>
<span class="com"> * Contributed by Ewan Mellor.</span>
<span class="com"> *</span>
<span class="com"> * To compile use</span>
<span class="com"> *</span>
<span class="com"> * ocamlopt -thread -noassert -unsafe -ccopt -O3 unix.cmxa threads.cmxa chameneos.ml</span>
<span class="com"> *)</span>


<span class="kwa">let</span> empty  <span class="sym">= -</span><span class="num">1</span>
<span class="kwa">let</span> red    <span class="sym">=</span> <span class="num">0</span>
<span class="kwa">let</span> yellow <span class="sym">=</span> <span class="num">1</span>
<span class="kwa">let</span> blue   <span class="sym">=</span> <span class="num">2</span>
<span class="kwa">let</span> faded  <span class="sym">=</span> <span class="num">3</span>


<span class="kwa">let</span> complement c1 c2 <span class="sym">=</span>
  <span class="kwa">if</span> c1 <span class="sym">=</span> c2 <span class="kwa">then</span>
    c1
  <span class="kwa">else</span>
    <span class="num">3</span> <span class="sym">-</span> c1 <span class="sym">-</span> c2


<span class="kwa">let</span> required <span class="sym">=</span>
  <span class="kwa">if</span> Array.length Sys.argv <span class="sym">&lt;=</span> <span class="num">1</span> <span class="kwa">then</span>
    <span class="num">100000</span>
  <span class="kwa">else</span>
    int_of_string Sys.argv.<span class="sym">(</span><span class="num">1</span><span class="sym">)</span>


<span class="com">(* Access to total, place1, place2, and condition is allowed only under the</span>
<span class="com">   protection of mutex.  The first thread to rendevous places its colour in</span>
<span class="com">   place1, and the second thread places the _new_ colour in place2.  If both</span>
<span class="com">   places are full, then an exchange is occurring.  The condition is used to</span>
<span class="com">   signal the first thread once the second has arrived and written the new</span>
<span class="com">   colour.  *)</span>

<span class="kwa">let</span> total <span class="sym">=</span> ref <span class="num">0</span>
<span class="kwa">let</span> place1 <span class="sym">=</span> ref empty
<span class="kwa">let</span> place2 <span class="sym">=</span> ref empty
<span class="kwa">let</span> condition <span class="sym">=</span> Condition.create<span class="sym">()</span>
<span class="kwa">let</span> mutex <span class="sym">=</span> Mutex.create<span class="sym">()</span>


<span class="com">(* The top-level loop for each thread. *)</span>
<span class="kwa">let</span> animal_loop colour' result' <span class="sym">=</span>
  <span class="kwa">let rec</span> loop colour result <span class="sym">=</span>
    Mutex.lock mutex<span class="sym">;</span>
    <span class="kwa">let</span> new_colour<span class="sym">,</span> new_result <span class="sym">=</span>
      <span class="kwa">if</span> <span class="sym">!</span>total <span class="sym">=</span> required <span class="kwa">then</span>
        <span class="com">(* Done. *)</span>
        faded<span class="sym">,</span> result
      <span class="kwa">else if</span> <span class="sym">!</span>place1 <span class="sym">=</span> empty <span class="kwa">then</span>
        <span class="kwa">begin</span>
          <span class="com">(* No-one is waiting here. *)</span>

          place1 <span class="sym">:=</span> colour<span class="sym">;</span>
          Condition.wait condition mutex<span class="sym">;</span>

          <span class="com">(* We have met with someone -- the new colour is in place2, and we must clear both places</span>
<span class="com">             when we are done. *)</span>
          <span class="kwa">let</span> nc <span class="sym">= !</span>place2 <span class="kwa">in</span>
          total <span class="sym">:= !</span>total <span class="sym">+</span> <span class="num">1</span><span class="sym">;</span>
          place1 <span class="sym">:=</span> empty<span class="sym">;</span>
          place2 <span class="sym">:=</span> empty<span class="sym">;</span>
          nc<span class="sym">,</span> result <span class="sym">+</span> <span class="num">1</span>
        <span class="kwa">end</span>
      <span class="kwa">else if</span> <span class="sym">!</span>place2 <span class="sym">=</span> empty <span class="kwa">then</span>
        <span class="kwa">begin</span>
          <span class="com">(* Someone is waiting, and I am the one to meet with them. *)</span>

          <span class="kwa">let</span> other_colour <span class="sym">= !</span>place1 <span class="kwa">in</span>
          <span class="kwa">let</span> nc <span class="sym">=</span> complement colour other_colour <span class="kwa">in</span>
          place2 <span class="sym">:=</span> nc<span class="sym">;</span>
          Condition.signal condition<span class="sym">;</span>
          nc<span class="sym">,</span> result <span class="sym">+</span> <span class="num">1</span>
        <span class="kwa">end</span>
      <span class="kwa">else</span>
        <span class="kwa">begin</span>
          <span class="com">(* Two people are here -- I must release the lock so that they can complete. *)</span>
          colour<span class="sym">,</span> result
        <span class="kwa">end</span>
    <span class="kwa">in</span>

    Mutex.unlock mutex<span class="sym">;</span>

    <span class="kwa">if</span> new_colour <span class="sym">=</span> faded <span class="kwa">then</span>
      new_result
    <span class="kwa">else</span>
      loop new_colour new_result
  <span class="kwa">in</span>
  result' <span class="sym">:=</span> loop colour' <span class="num">0</span>


<span class="kwa">let</span> animal colour <span class="sym">=</span>
  <span class="kwa">let</span> result <span class="sym">=</span> ref <span class="num">0</span> <span class="kwa">in</span>
  <span class="sym">(</span>result<span class="sym">,</span> Thread.create <span class="sym">(</span>animal_loop colour<span class="sym">)</span> result<span class="sym">)</span>


<span class="kwa">let</span> animals <span class="sym">=</span> List.map animal <span class="sym">[</span>blue<span class="sym">;</span> red<span class="sym">;</span> yellow<span class="sym">;</span> blue<span class="sym">]</span>


<span class="kwa">let</span> _ <span class="sym">=</span>
  List.iter <span class="sym">(</span><span class="kwa">fun</span> <span class="sym">(</span>_<span class="sym">,</span> thread<span class="sym">) -&gt;</span> Thread.join thread<span class="sym">)</span> animals<span class="sym">;</span>
  Printf.printf <span class="str">&quot;%d</span><span class="esc">\n</span><span class="str">&quot;</span> <span class="sym">(</span>List.fold_left <span class="sym">(</span><span class="kwa">fun</span> x <span class="sym">(</span>result<span class="sym">,</span> _<span class="sym">) -&gt;</span> x <span class="sym">+ !</span>result<span class="sym">)</span> <span class="num">0</span> animals<span class="sym">)</span>
