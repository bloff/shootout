<span class="slc">-- contributed by Jeff Newbern</span>
<span class="slc">-- compile with: ghc -O3 fannkuch.hs -o fannkuch</span>

<span class="slc">-- This is an attempt to improve over generate-and-test by instead searching the space</span>
<span class="slc">-- of permutations backward from the final state while tracking the depth of each</span>
<span class="slc">-- intermediate solution.  We use a special &quot;Any&quot; value to signify that any unassigned</span>
<span class="slc">-- value can occupy a slot, and we search only prior states that could actually lead to</span>
<span class="slc">-- this state through a flip of assigned values, or a flip requiring the assignment</span>
<span class="slc">-- of an unassigned value to slot 1.</span>

<span class="slc">-- This code uses lists to implement the permutation data, etc., which imposes O(n)</span>
<span class="slc">-- algorithms for indexing and deletion.  Replacing the lists with IOUArrays would</span>
<span class="slc">-- allow O(1) access, but make the code messier.  As it is, this code is 6-8 times</span>
<span class="slc">-- faster than the generate-and-test approach on the inputs I tried.</span>

<span class="kwa">import</span> System<span class="sym">(</span>getArgs<span class="sym">)</span>
<span class="kwa">import</span> Data.List<span class="sym">(</span>delete<span class="sym">)</span>

<span class="kwa">data</span> Val <span class="sym">=</span> Num <span class="kwb">Int</span> <span class="sym">|</span> Any <span class="kwa">deriving</span> Eq
<span class="kwa">data</span> State <span class="sym">=</span> ST { depth <span class="sym">::</span> <span class="kwb">Int</span><span class="sym">,</span> permutation <span class="sym">:: [</span>Val<span class="sym">],</span> unassigned <span class="sym">:: [</span><span class="kwb">Int</span><span class="sym">],</span> assigned <span class="sym">:: [</span><span class="kwb">Int</span><span class="sym">]</span> }

<span class="slc">-- generate a list of the deepest initial states that can reach a goal state</span>
<span class="slc">-- through flips and assignments.</span>
traceBackFrom <span class="sym">::</span> State <span class="sym">-&gt; [</span>State<span class="sym">]</span>
traceBackFrom s&#64;<span class="sym">(</span>ST _ vs us <span class="kwa">as</span><span class="sym">) =</span>
  <span class="kwa">let</span> flipped            <span class="sym">=</span> filter <span class="sym">(</span>isSame vs<span class="sym">)</span> <span class="kwa">as</span>
      assignedAndFlipped <span class="sym">=</span> filter <span class="sym">(</span>isAny vs<span class="sym">)</span>  us
  <span class="kwa">in</span> if <span class="sym">(</span>null flipped<span class="sym">) &amp;&amp; (</span>null assignedAndFlipped<span class="sym">)</span>
       <span class="kwa">then</span> <span class="sym">[</span>s<span class="sym">]</span>
       <span class="kwa">else</span> <span class="sym">(</span>concatMap traceBackFrom <span class="sym">(</span>map <span class="sym">(</span>unflip s<span class="sym">)</span> flipped<span class="sym">)) ++</span>
            <span class="sym">(</span>concatMap traceBackFrom <span class="sym">(</span>map <span class="sym">(</span>unflipAndAssign s<span class="sym">)</span> assignedAndFlipped<span class="sym">))</span>
  <span class="kwa">where</span> isAny  vs n <span class="sym">=</span> vs<span class="sym">!!(</span>n<span class="sym">-</span><span class="num">1</span><span class="sym">) ==</span> Any
        isSame vs n <span class="sym">=</span> vs<span class="sym">!!(</span>n<span class="sym">-</span><span class="num">1</span><span class="sym">) == (</span>Num n<span class="sym">)</span>
        unflip <span class="sym">(</span>ST d vs us <span class="kwa">as</span><span class="sym">)</span> n <span class="sym">=</span> <span class="kwa">let</span> <span class="sym">(</span>start<span class="sym">,</span>rest<span class="sym">) =</span> splitAt n vs
                                       start<span class="str">' = (Num n):(tail (reverse start))</span>
<span class="str">                                   in ST (d+1) (start'</span> <span class="sym">++</span> rest<span class="sym">)</span> us <span class="kwa">as</span>
        unflipAndAssign <span class="sym">(</span>ST d vs us <span class="kwa">as</span><span class="sym">)</span> n <span class="sym">=</span> <span class="kwa">let</span> <span class="sym">(</span>start<span class="sym">,</span>rest<span class="sym">) =</span> splitAt n vs
                                                start<span class="str">' = (Num n):(tail (reverse start))</span>
<span class="str">                                            in ST (d+1) (start'</span> <span class="sym">++</span> rest<span class="sym">) (</span>delete n us<span class="sym">) (</span>n<span class="sym">:</span><span class="kwa">as</span><span class="sym">)</span>

main <span class="sym">=</span> <span class="kwa">do</span> n <span class="sym">&lt;-</span> getArgs <span class="sym">&gt;&gt;=</span> readIO.head
          <span class="kwa">let</span> goalState <span class="sym">=</span> ST <span class="num">0</span> <span class="sym">((</span>Num <span class="num">1</span><span class="sym">):(</span>replicate <span class="sym">(</span>n<span class="sym">-</span><span class="num">1</span><span class="sym">)</span> Any<span class="sym">)) [</span><span class="num">2</span>..n<span class="sym">] []</span>
          <span class="kwa">let</span> deepestInitialStates <span class="sym">=</span> traceBackFrom goalState
          <span class="kwa">let</span> m <span class="sym">=</span> maximum <span class="sym">(</span>map depth deepestInitialStates<span class="sym">)</span>
          putStrLn $ <span class="str">&quot;Pfannkuchen(&quot;</span> <span class="sym">++ (</span>show n<span class="sym">) ++</span> <span class="str">&quot;) = &quot;</span> <span class="sym">++ (</span>show m<span class="sym">)</span>
