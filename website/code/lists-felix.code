<table width="100%" border="0" cellpadding="5" cellspacing="0"><tr><td bgcolor="#FFFFFF"><pre>
<I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Contributed by John Skaller
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I>include <B><FONT COLOR="#BC8F8F">&quot;std&quot;</FONT></B>;
n := atoi(System::argv 1);
<I><FONT COLOR="#B22222">// Adapted from C solution
</FONT></I>
header <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B><B><FONT COLOR="#BC8F8F">&quot;
// a simple Double Linked List
// the head node is special, it's val is length of list
struct DLL {
    int val;
    struct DLL *next;        /* points to next or head (if at tail) */
    struct DLL *prev;        /* points to prev or tail (if at head) */
};
&quot;</FONT></B><B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>;

body <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B><B><FONT COLOR="#BC8F8F">&quot;
inline int len(DLL *head) { return(head-&gt;val); }
inline int empty(DLL *head) { return(len(head) == 0); }
inline DLL *first(DLL *head) { return(head-&gt;next); }
inline DLL *last(DLL *head) { return(head-&gt;prev); }

void push_tail(DLL *head, DLL *item) {
    DLL *tail = head-&gt;prev;
    tail-&gt;next = item;
    item-&gt;next = head;
    head-&gt;prev = item;
    item-&gt;prev = tail;
    head-&gt;val++;
}

DLL *pop_tail(DLL *head) {
    DLL *prev, *tail;
    if (empty(head)) return(NULL);
    tail = head-&gt;prev;
    prev = tail-&gt;prev;
    prev-&gt;next = head;
    head-&gt;prev = prev;
    head-&gt;val--;
    return(tail);
}

void push_head(DLL *head, DLL *item) {
    DLL *next = head-&gt;next;
    head-&gt;next = item;
    next-&gt;prev = item;
    item-&gt;next = next;
    item-&gt;prev = head;
    head-&gt;val++;
}

DLL *pop_head(DLL *head) {
    DLL *next;
    if (empty(head)) return(NULL);
    next = head-&gt;next;
    head-&gt;next = next-&gt;next;
    next-&gt;next-&gt;prev = head;
    head-&gt;val--;
    return(next);
}

int list_equal(DLL *x, DLL *y) {
    DLL *xp, *yp;
    // first val's checked will be list lengths
    for (xp=x, yp=y; xp-&gt;next != x; xp=xp-&gt;next, yp=yp-&gt;next) {
        if (xp-&gt;val != yp-&gt;val) return(0);
    }
    if (xp-&gt;val != yp-&gt;val) return(0);
    return(yp-&gt;next == y);
}

DLL *list_new() {
    DLL *l = (DLL *)malloc(sizeof(DLL));
    l-&gt;next = l;
    l-&gt;prev = l;
    l-&gt;val = 0;
    return(l);
}

/* inclusive sequence 'from' &lt;-&gt; 'to' */
DLL *list_sequence(int from, int to) {
    int size, tmp, i, j;
    DLL *l;
    if (from &gt; to) {
        tmp = from; from = to; to = tmp;
    }
    size = to - from + 1;
    l = (DLL *)malloc((size+1) * sizeof(DLL));
    from--;
    for (i=0, j=1; i&lt;size; ++i, ++j) {
        l[i].next = &amp;l[i+1];
        l[j].prev = &amp;l[j-1];
        l[i].val = from++;
    }
    l[0].prev = &amp;l[size];
    l[size].next = &amp;l[0];
    l[size].prev = &amp;l[size-1];
    l[size].val = from;
    l[0].val = size;
    return(l);
}

DLL *copy(DLL *x) {
    int i, j, size = len(x);
    DLL *xp, *l = (DLL *)malloc((size+1) * sizeof(DLL));
    for (i=0, j=1, xp=x; i&lt;size; i++, j++, xp=xp-&gt;next) {
        l[i].next = &amp;l[j];
        l[j].prev = &amp;l[i];
        l[i].val = xp-&gt;val;
    }
    l[0].prev = &amp;l[size];
    l[size].next = &amp;l[0];
    l[size].val = last(x)-&gt;val;
    return(l);
}

void rev (DLL *head) {
    DLL *tmp, *p = head;
    do {
        tmp = p-&gt;next;
        p-&gt;next = p-&gt;prev;
        p-&gt;prev = tmp;
        p = tmp;
    } while (p != head);
}
&quot;</FONT></B><B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>;

type DLL_head = <B><FONT COLOR="#BC8F8F">&quot;DLL*&quot;</FONT></B>;
type DLL_item = <B><FONT COLOR="#BC8F8F">&quot;DLL*&quot;</FONT></B>;

fun get: DLL_item -&gt; <B><FONT COLOR="#228B22">int</FONT></B> = <B><FONT COLOR="#BC8F8F">&quot;$1-&gt;val&quot;</FONT></B>;

fun len: DLL_head -&gt; <B><FONT COLOR="#228B22">int</FONT></B>;
fun empty: DLL_head -&gt; bool;

fun <B><FONT COLOR="#0000FF">non_empty</FONT></B>(x:DLL_head)=&gt; not (empty x);

fun first: DLL_head -&gt; DLL_item;
fun last: DLL_head -&gt; DLL_item;

proc push_tail: DLL_head * DLL_item;
fun pop_tail: DLL_head -&gt; DLL_item;
proc push_head: DLL_head * DLL_item;

fun pop_head: DLL_head -&gt; DLL_item;
fun eq: DLL_head * DLL_head -&gt; bool = <B><FONT COLOR="#BC8F8F">&quot;list_equal($1,$2)&quot;</FONT></B>;
fun <B><FONT COLOR="#0000FF">ne</FONT></B> (x:DLL_head,y:DLL_head) =&gt; not (x == y);

fun list_new: unit -&gt; DLL_head;

<I><FONT COLOR="#B22222">/* inclusive sequence 'from' &lt;-&gt; 'to' */</FONT></I>
fun list_sequence: <B><FONT COLOR="#228B22">int</FONT></B> * <B><FONT COLOR="#228B22">int</FONT></B> -&gt; DLL_head;
fun copy: DLL_head -&gt; DLL_head;

proc rev: DLL_head;
proc free: DLL_head = <B><FONT COLOR="#BC8F8F">&quot;std::free($1);&quot;</FONT></B>;

proc <B><FONT COLOR="#0000FF">check</FONT></B>(cond:bool) (msg:string) {
  open System;
  open Text_file;
  <B><FONT COLOR="#A020F0">if</FONT></B> cond <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">endoff</FONT></B>;
  writeln (stderr,msg);
  exit 1;
<B><FONT COLOR="#5F9EA0">endoff</FONT></B>:&gt;
}

<B><FONT COLOR="#5F9EA0">SIZE</FONT></B>:=10000;


var result: <B><FONT COLOR="#228B22">int</FONT></B>;
proc <B><FONT COLOR="#0000FF">test_lists</FONT></B>() {
    var li1 = list_sequence(1, SIZE);
    var li2 = copy(li1);
    var x : DLL_item;
    check (li2 == li1) <B><FONT COLOR="#BC8F8F">&quot;li2 and li1 are not equal&quot;</FONT></B>;

    <I><FONT COLOR="#B22222">// remove each individual item from left side of li2 and
</FONT></I>    <I><FONT COLOR="#B22222">// append to right side of li3 (preserving order)
</FONT></I>    var li3 = list_new();
    whilst non_empty li2 <B><FONT COLOR="#A020F0">do</FONT></B>
        x = pop_head li2;
        push_tail(li3, x);
    done;

    check (empty li2) <B><FONT COLOR="#BC8F8F">&quot;li2 should be empty now&quot;</FONT></B>;

    <I><FONT COLOR="#B22222">// remove each individual item from right side of li3 and
</FONT></I>    <I><FONT COLOR="#B22222">// append to right side of li2 (reversing list)
</FONT></I>    whilst non_empty li3 <B><FONT COLOR="#A020F0">do</FONT></B>
        x = pop_tail li3;
        push_tail(li2, x);
    done;

    check (empty li3) <B><FONT COLOR="#BC8F8F">&quot;li3 should be empty now&quot;</FONT></B>;

    <I><FONT COLOR="#B22222">// reverse li1 in place
</FONT></I>    rev li1;

    check (get (first li1) == SIZE) <B><FONT COLOR="#BC8F8F">&quot;li1 first value wrong&quot;</FONT></B>;
    check (get (last li1) == 1) <B><FONT COLOR="#BC8F8F">&quot;last value wrong&quot;</FONT></B>;

    check (get (first li2) == SIZE) <B><FONT COLOR="#BC8F8F">&quot;li2 first value wrong&quot;</FONT></B>;
    check (get (last li2) == 1) <B><FONT COLOR="#BC8F8F">&quot;li2 last value wrong&quot;</FONT></B>;
    check (len li1 == SIZE) <B><FONT COLOR="#BC8F8F">&quot;li1 size wrong&quot;</FONT></B>;

    <I><FONT COLOR="#B22222">// compare li1 and li2 for equality
</FONT></I>    check (li1 == li2) <B><FONT COLOR="#BC8F8F">&quot;li1 and li2 are not equal&quot;</FONT></B>;

    result = len li1;
    free li1;
    free li2;
    free li3;
}

var i = n;
until i == 0 <B><FONT COLOR="#A020F0">do</FONT></B> test_lists; --i; done;
print result; endl;
</pre></td></tr></table>
