<span class="slc">;;; lists.scm
</span><span class="slc">;;;
</span><span class="slc">;;; Contributed by Felix Winkelmann
</span><span class="slc">;;; -Ob
</span>
<span class="sym">(</span>declare <span class="sym">(</span>fixnum<span class="sym">) (</span>disable<span class="sym">-</span>interrupts<span class="sym">) (</span>uses srfi<span class="num">-1</span><span class="sym">))

(</span>define SIZE <span class="num">10000</span><span class="sym">)

(</span>define <span class="sym">(</span>sequence start stop<span class="sym">)
  (</span><span class="kwa">if</span> <span class="sym">(&gt;</span> start stop<span class="sym">)
</span>      <span class="str">'()
      (cons start (sequence (+ start 1) stop))))

(define (head-to-tail! headlist taillist)
  (when (null? taillist)
    (set! taillist (list (car headlist)))
    (set! headlist (cdr headlist)))
  (letrec ((htt-helper (lambda (dest)
			 (when (not (null? headlist))
			   (let ((headlink headlist))
			     (set-cdr! dest headlink)
			     (set! headlist (cdr headlist))
			     (htt-helper headlink))))))
    (htt-helper taillist)
    (values headlist taillist)))

(define (test-lists)
  (let* ([L1 (sequence 1 SIZE)]
	 [L2 (append L1 '</span><span class="sym">())]
	 [</span>L3 <span class="str">'()])
    (set!-values (L2 L3) (head-to-tail! L2 L3))
    (set!-values (L3 L2) (head-to-tail! (reverse! L3) L2))
    (set! L1 (reverse! L1))
    (cond ((not (= SIZE (car L1))) 0)
	  ((not (equal? L1 L2))	   0)
	  (else           (length L1)))))

(define (main args)
  (let ((result #f))
    (let loop ((counter (if (null? args)
			    1
			    (string-&gt;number (car args)))))
      (when (&gt; counter 0)
	(set! result (test-lists))
	(loop (- counter 1))))
    (print result)))

(main (command-line-arguments))</span>
