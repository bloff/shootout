<span class="com">(* The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 * contributed by Jon Harrop, 2005
 * substantially stylistically modified by sweeks&#64;sweeks.com, with no
 *   major speed change, only a slight speedup, probably due to using a vector
 *   instead of a list for &quot;group&quot; scenes.
 *)</span>

<span class="kwa">fun</span> <span class="kwb">real</span> n <span class="sym">=</span> <span class="kwa">Real</span>.fromInt n
<span class="kwa">fun</span> for <span class="sym">(</span>s<span class="sym">,</span> e<span class="sym">,</span> f<span class="sym">) =</span> <span class="kwa">if</span> s<span class="sym">=</span>e <span class="kwa">then</span> <span class="sym">()</span> <span class="kwa">else</span> <span class="sym">(</span>f <span class="sym">(</span><span class="kwb">real</span> s<span class="sym">);</span> for <span class="sym">(</span>s<span class="sym">+</span><span class="num">1</span><span class="sym">,</span> e<span class="sym">,</span> f<span class="sym">))

</span><span class="kwa">val</span> delta <span class="sym">=</span> <span class="num">0.00000001
</span><span class="kwa">val</span> infinity <span class="sym">=</span> <span class="kwa">Real</span>.posInf

<span class="kwa">structure</span> Vec <span class="sym">=
</span>   <span class="kwa">struct
      datatype</span> t <span class="sym">=</span> T <span class="kwa">of</span> <span class="kwb">real</span> <span class="sym">*</span> <span class="kwb">real</span> <span class="sym">*</span> <span class="kwb">real

</span>      <span class="kwa">val</span> origin <span class="sym">=</span> T <span class="sym">(</span><span class="num">0.0</span><span class="sym">,</span> <span class="num">0.0</span><span class="sym">,</span> <span class="num">0.0</span><span class="sym">)

</span>      <span class="kwa">fun</span> scale <span class="sym">(</span>T <span class="sym">(</span>x<span class="sym">,</span> y<span class="sym">,</span> z<span class="sym">),</span> s<span class="sym">) =</span> T <span class="sym">(</span>s <span class="sym">*</span> x<span class="sym">,</span> s <span class="sym">*</span> y<span class="sym">,</span> s <span class="sym">*</span> z<span class="sym">)

</span>      <span class="kwa">fun</span> dot <span class="sym">(</span>T <span class="sym">(</span>x1<span class="sym">,</span> y1<span class="sym">,</span> z1<span class="sym">),</span> T <span class="sym">(</span>x2<span class="sym">,</span> y2<span class="sym">,</span> z2<span class="sym">)) =</span> x1 <span class="sym">*</span> x2 <span class="sym">+</span> y1 <span class="sym">*</span> y2 <span class="sym">+</span> z1 <span class="sym">*</span> z2

      <span class="kwa">fun</span> unitise v <span class="sym">=</span> scale <span class="sym">(</span>v<span class="sym">,</span> <span class="num">1.0</span> <span class="sym">/</span> <span class="kwa">Real</span>.Math.sqrt <span class="sym">(</span>dot <span class="sym">(</span>v<span class="sym">,</span> v<span class="sym">)))

</span>      <span class="kwa">local
	 fun</span> make f <span class="sym">(</span>T <span class="sym">(</span>x1<span class="sym">,</span> y1<span class="sym">,</span> z1<span class="sym">),</span> T <span class="sym">(</span>x2<span class="sym">,</span> y2<span class="sym">,</span> z2<span class="sym">)) =
</span>	    T <span class="sym">(</span>f <span class="sym">(</span>x1<span class="sym">,</span> x2<span class="sym">),</span> f <span class="sym">(</span>y1<span class="sym">,</span> y2<span class="sym">),</span> f <span class="sym">(</span>z1<span class="sym">,</span> z2<span class="sym">))
</span>      <span class="kwa">in
	 val op</span> <span class="sym">+ =</span> make <span class="sym">(</span><span class="kwa">op</span> <span class="sym">+)
</span>	 <span class="kwa">val op</span> <span class="sym">- =</span> make <span class="sym">(</span><span class="kwa">op</span> <span class="sym">-)
</span>      <span class="kwa">end
   end

structure</span> Ray <span class="sym">=
</span>   <span class="kwa">struct
      datatype</span> t <span class="sym">=</span> T <span class="kwa">of</span> <span class="sym">{</span>dir<span class="sym">:</span> Vec.t<span class="sym">,</span> orig<span class="sym">:</span> Vec.t<span class="sym">}

</span>      <span class="kwa">fun</span> hitSphere <span class="sym">(</span>T <span class="sym">{</span>dir<span class="sym">,</span> orig<span class="sym">},</span> center<span class="sym">,</span> radius<span class="sym">) =
</span>	 <span class="kwa">let
	    val</span> v <span class="sym">=</span> Vec.<span class="sym">- (</span>center<span class="sym">,</span> orig<span class="sym">)
</span>	    <span class="kwa">val</span> b <span class="sym">=</span> Vec.dot <span class="sym">(</span>v<span class="sym">,</span> dir<span class="sym">)
</span>	    <span class="kwa">val</span> disc <span class="sym">=</span> b <span class="sym">*</span> b <span class="sym">-</span> Vec.dot <span class="sym">(</span>v<span class="sym">,</span> v<span class="sym">) +</span> radius <span class="sym">*</span> radius
	 <span class="kwa">in
	    if</span> disc <span class="sym">&lt;</span> <span class="num">0.0</span> <span class="kwa">then</span> infinity
	    <span class="kwa">else
	       let
		  val</span> disc <span class="sym">=</span> <span class="kwa">Real</span>.Math.sqrt disc
	       <span class="kwa">in
		  let
		     val</span> t2 <span class="sym">=</span> b <span class="sym">+</span> disc
		  <span class="kwa">in
		     if</span> t2 <span class="sym">&lt;</span> <span class="num">0.0</span> <span class="kwa">then</span> infinity
		     <span class="kwa">else
			let
			   val</span> t1 <span class="sym">=</span> b <span class="sym">-</span> disc
			<span class="kwa">in
			   if</span> t1 <span class="sym">&gt;</span> <span class="num">0.0</span> <span class="kwa">then</span> t1 <span class="kwa">else</span> t2
			<span class="kwa">end
		  end
	       end
	 end
   end

structure</span> Scene <span class="sym">=
</span>   <span class="kwa">struct
      datatype</span> t <span class="sym">=
</span>	 Group <span class="kwa">of</span> <span class="sym">{</span>center<span class="sym">:</span> Vec.t<span class="sym">,
</span>		   radius<span class="sym">:</span> <span class="kwb">real</span><span class="sym">,
</span>		   scenes<span class="sym">:</span> t vector<span class="sym">}
       |</span> Sphere <span class="kwa">of</span> <span class="sym">{</span>center<span class="sym">:</span> Vec.t<span class="sym">,
</span>		    radius<span class="sym">:</span> <span class="kwb">real</span><span class="sym">}

</span>      <span class="kwa">val</span> intersect<span class="sym">:</span> t <span class="sym">*</span> Ray.t <span class="sym">-&gt;</span> <span class="kwb">real</span> <span class="sym">*</span> Vec.t <span class="sym">=
</span>	 <span class="kwa">fn</span> <span class="sym">(</span>scene<span class="sym">,</span> r <span class="kwa">as</span> Ray.T <span class="sym">{</span>orig<span class="sym">,</span> dir<span class="sym">}) =&gt;
</span>	 <span class="kwa">let
	    fun</span> ofScene <span class="sym">(</span>scene<span class="sym">, (</span>l<span class="sym">,</span> n<span class="sym">)) =
</span>	       <span class="kwa">case</span> scene <span class="kwa">of
</span>		  Group <span class="sym">{</span>center<span class="sym">,</span> radius<span class="sym">,</span> scenes<span class="sym">} =&gt;
</span>		     <span class="kwa">let
			val</span> l' <span class="sym">=</span> Ray.hitSphere <span class="sym">(</span>r<span class="sym">,</span> center<span class="sym">,</span> radius<span class="sym">)
</span>		     <span class="kwa">in
			if</span> l' <span class="sym">&gt;=</span> l <span class="kwa">then</span> <span class="sym">(</span>l<span class="sym">,</span> n<span class="sym">)
</span>			<span class="kwa">else Vector</span>.foldl ofScene <span class="sym">(</span>l<span class="sym">,</span> n<span class="sym">)</span> scenes
		     <span class="kwa">end
</span>		<span class="sym">|</span> Sphere <span class="sym">{</span>center<span class="sym">,</span> radius<span class="sym">} =&gt;
</span>		     <span class="kwa">let
			val</span> l' <span class="sym">=</span> Ray.hitSphere <span class="sym">(</span>r<span class="sym">,</span> center<span class="sym">,</span> radius<span class="sym">)
</span>			<span class="kwa">open</span> Vec
		     <span class="kwa">in
			if</span> l' <span class="sym">&gt;=</span> l <span class="kwa">then</span> <span class="sym">(</span>l<span class="sym">,</span> n<span class="sym">)
</span>			<span class="kwa">else</span> <span class="sym">(</span>l'<span class="sym">,</span> unitise <span class="sym">(</span>orig <span class="sym">+</span> scale <span class="sym">(</span>dir<span class="sym">,</span> l'<span class="sym">) -</span> center<span class="sym">))
</span>		     <span class="kwa">end
	 in
</span>	    ofScene <span class="sym">(</span>scene<span class="sym">, (</span>infinity<span class="sym">,</span> Vec.origin<span class="sym">))
</span>	 <span class="kwa">end

      fun</span> rayTrace <span class="sym">(</span>scene<span class="sym">,</span> light<span class="sym">,</span> ray <span class="kwa">as</span> Ray.T <span class="sym">{</span>dir<span class="sym">,</span> orig<span class="sym">}) =
</span>	 <span class="kwa">let
	    val</span> <span class="sym">(</span>lambda<span class="sym">,</span> n<span class="sym">) =</span> intersect <span class="sym">(</span>scene<span class="sym">,</span> ray<span class="sym">)
</span>	 <span class="kwa">in
	    if</span> lambda <span class="sym">&gt;=</span> infinity <span class="kwa">then</span> <span class="num">0.0
</span>	    <span class="kwa">else
	       let
		  val</span> g <span class="sym">=</span> <span class="num">0.0</span> <span class="sym">-</span> Vec.dot <span class="sym">(</span>n<span class="sym">,</span> light<span class="sym">)
</span>	       <span class="kwa">in
		  if</span> g <span class="sym">&lt;=</span> <span class="num">0.0</span> <span class="kwa">then</span> <span class="num">0.0
</span>		  <span class="kwa">else
		     let
			open</span> Vec
			<span class="kwa">val</span> <span class="sym">(</span>l<span class="sym">,</span> _<span class="sym">) =
</span>			   intersect
			   <span class="sym">(</span>scene<span class="sym">,</span> Ray.T <span class="sym">{</span>dir <span class="sym">=</span> origin <span class="sym">-</span> light<span class="sym">,
</span>					  orig <span class="sym">= (</span>orig <span class="sym">+</span> scale <span class="sym">(</span>dir<span class="sym">,</span> lambda<span class="sym">)
						  +</span> scale <span class="sym">(</span>n<span class="sym">,</span> delta<span class="sym">))})
</span>		     <span class="kwa">in
			if</span> l <span class="sym">&gt;=</span> infinity <span class="kwa">then</span> g <span class="kwa">else</span> <span class="num">0.0
</span>		     <span class="kwa">end
	       end
	 end

      fun</span> create <span class="sym">(</span>level<span class="sym">,</span> r<span class="sym">,</span> v <span class="kwa">as</span> Vec.T <span class="sym">(</span>x<span class="sym">,</span> y<span class="sym">,</span> z<span class="sym">)):</span> t <span class="sym">=
</span>	 <span class="kwa">let
	    val</span> obj <span class="sym">=</span> Sphere <span class="sym">{</span>center <span class="sym">=</span> v<span class="sym">,</span> radius <span class="sym">=</span> r<span class="sym">}
</span>	 <span class="kwa">in
	    if</span> level <span class="sym">=</span> <span class="num">1</span> <span class="kwa">then</span> obj
	    <span class="kwa">else
	       let
		  val</span> r' <span class="sym">=</span> <span class="num">3.0</span> <span class="sym">*</span> r <span class="sym">/</span> <span class="kwa">Real</span>.Math.sqrt <span class="num">12.0
</span>		  <span class="kwa">fun</span> aux <span class="sym">(</span>x'<span class="sym">,</span> z'<span class="sym">) =
</span>		     create <span class="sym">(</span>level <span class="num">- 1</span><span class="sym">,</span> <span class="num">0.5</span> <span class="sym">*</span> r<span class="sym">,</span> Vec.<span class="sym">+ (</span>v<span class="sym">,</span> Vec.T <span class="sym">(</span>~x'<span class="sym">,</span> r'<span class="sym">,</span> z'<span class="sym">)))
</span>	       <span class="kwa">in
</span>		  Group <span class="sym">{</span>center <span class="sym">=</span> v<span class="sym">,
</span>			 radius <span class="sym">=</span> <span class="num">3.0</span> <span class="sym">*</span> r<span class="sym">,
</span>			 scenes <span class="sym">= (</span><span class="kwa">Vector</span>.fromList
				   <span class="sym">[</span>aux <span class="sym">(</span>r'<span class="sym">,</span> r'<span class="sym">),</span> aux <span class="sym">(</span>~r'<span class="sym">,</span> r'<span class="sym">),
</span>				    aux <span class="sym">(</span>r'<span class="sym">,</span> ~r'<span class="sym">),</span> aux <span class="sym">(</span>~r'<span class="sym">,</span> ~r'<span class="sym">),</span> obj<span class="sym">])}
</span>	       <span class="kwa">end
	 end
   end

val</span> <span class="sym">() =
</span>   <span class="kwa">let
      val</span> level <span class="sym">=</span> <span class="num">6
</span>      <span class="kwa">val</span> ss <span class="sym">=</span> <span class="num">4
</span>      <span class="kwa">val</span> n <span class="sym">= (</span>valOf <span class="sym">(</span><span class="kwa">Int</span>.fromString <span class="sym">(</span>hd <span class="sym">(</span>CommandLine.arguments <span class="sym">())))
</span>	       <span class="kwa">handle</span> _ <span class="sym">=&gt;</span> <span class="num">256</span><span class="sym">)
</span>      <span class="kwa">val</span> scene <span class="sym">=</span> Scene.create <span class="sym">(</span>level<span class="sym">,</span> <span class="num">1.0</span><span class="sym">,</span> Vec.T <span class="sym">(</span><span class="num">0.0</span><span class="sym">,</span> ~<span class="num">1.0</span><span class="sym">,</span> <span class="num">0.0</span><span class="sym">))
</span>      <span class="kwa">val</span> s <span class="sym">=</span> <span class="kwa">Int</span>.toString n<span class="sym">;
</span>      <span class="kwa">val</span> <span class="sym">() =</span> print <span class="sym">(</span>concat <span class="sym">[</span><span class="str">&quot;P5</span><span class="esc">\n</span><span class="str">&quot;</span><span class="sym">,</span> s<span class="sym">,</span> <span class="str">&quot; &quot;</span><span class="sym">,</span> s<span class="sym">,</span> <span class="str">&quot;</span><span class="esc">\n</span><span class="str">255</span><span class="esc">\n</span><span class="str">&quot;</span><span class="sym">])
</span>   <span class="kwa">in
</span>      for
      <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> n<span class="sym">,</span> <span class="kwa">fn</span> y <span class="sym">=&gt;
</span>       for <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> n<span class="sym">,</span> <span class="kwa">fn</span> x <span class="sym">=&gt;
</span>	    <span class="kwa">let
	       val</span> g <span class="sym">=</span> ref <span class="num">0.0
</span>	       <span class="kwa">val</span> <span class="sym">() =
</span>		  for <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> ss<span class="sym">,</span> <span class="kwa">fn</span> dx <span class="sym">=&gt;
</span>		       for <span class="sym">(</span><span class="num">0</span><span class="sym">,</span> ss<span class="sym">,</span> <span class="kwa">fn</span> dy <span class="sym">=&gt;
</span>			    <span class="kwa">let
			       val</span> n <span class="sym">=</span> <span class="kwb">real</span> n
			       <span class="kwa">val</span> x <span class="sym">=</span> x <span class="sym">+</span> dx <span class="sym">/</span> <span class="kwb">real</span> ss <span class="sym">-</span> n <span class="sym">/</span> <span class="num">2.0
</span>			       <span class="kwa">val</span> y <span class="sym">=</span> n <span class="num">- 1.0</span> <span class="sym">-</span> y <span class="sym">+</span> dy <span class="sym">/</span> <span class="kwb">real</span> ss <span class="sym">-</span> n <span class="sym">/</span> <span class="num">2.0
</span>			       <span class="kwa">val</span> eye <span class="sym">=</span> Vec.unitise <span class="sym">(</span>Vec.T <span class="sym">(</span>~<span class="num">1.0</span><span class="sym">,</span> ~<span class="num">3.0</span><span class="sym">,</span> <span class="num">2.0</span><span class="sym">))
</span>			       <span class="kwa">val</span> ray <span class="sym">=
</span>				  Ray.T <span class="sym">{</span>dir <span class="sym">=</span> Vec.unitise <span class="sym">(</span>Vec.T <span class="sym">(</span>x<span class="sym">,</span> y<span class="sym">,</span> n<span class="sym">)),
</span>					 orig <span class="sym">=</span> Vec.T <span class="sym">(</span><span class="num">0.0</span><span class="sym">,</span> <span class="num">0.0</span><span class="sym">,</span> ~<span class="num">4.0</span><span class="sym">)}
</span>			    <span class="kwa">in
</span>			       g <span class="sym">:= !</span>g <span class="sym">+</span> Scene.rayTrace <span class="sym">(</span>scene<span class="sym">,</span> eye<span class="sym">,</span> ray<span class="sym">)
</span>			    <span class="kwa">end</span><span class="sym">))
</span>	       <span class="kwa">val</span> g <span class="sym">=</span> <span class="num">0.5</span> <span class="sym">+</span> <span class="num">255.0</span> <span class="sym">* !</span>g <span class="sym">/</span> <span class="kwb">real</span> <span class="sym">(</span>ss<span class="sym">*</span>ss<span class="sym">)
</span>	    <span class="kwa">in
</span>	       print <span class="sym">(</span>str <span class="sym">(</span>chr <span class="sym">(</span><span class="kwa">Real</span>.trunc g<span class="sym">)))
</span>	    <span class="kwa">end</span><span class="sym">))
</span>   <span class="kwa">end</span>
