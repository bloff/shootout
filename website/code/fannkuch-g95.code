<span class="slc">! Fannkuch access function implementation
</span><span class="slc">! Simon Geard, 1/12/04
</span><span class="slc">!
</span><span class="slc">! Building info.
</span><span class="slc">! ==============
</span><span class="slc">!
</span><span class="slc">! Linux  - using the Intel Fortran90 compiler:
</span><span class="slc">!
</span><span class="slc">!          ifort fannkuch.f90 -O3 -static-libcxa -o fannkuch
</span><span class="slc">!
</span><span class="slc">! WinXP  - Compaq Visual Fortran 6.6c
</span><span class="slc">!
</span><span class="slc">!          f90 fannkuch.f90 /link /libpath:&quot;d:\Program Files\Microsoft Visual Studio\df98\lib&quot;
</span><span class="slc">!
</span><span class="slc">! Cygwin - g95 compiler
</span><span class="slc">!
</span><span class="slc">!          g95 fannkuch.f90 -O3 -o fannkuch.exe
</span><span class="slc">!
</span><span class="slc">!!$&quot;Take a permutation of {1,...,n}, for example: {4,2,1,5,3}. Take the first element, here 4, and reverse the order of the first 4 elements: {5,1,2,4,3}. Repeat this until the first element is a 1, so flipping won't change anything more: {3,4,2,1,5}, {2,4,3,1,5}, {4,2,3,1,5}, {1,3,2,4,5}. Count the number of flips, here 5. Do this for all n! permutations, and record the maximum number of flips needed for any permutation. The conjecture is that this maximum count is approximated by n*log(n) when n goes to infinity.
</span><span class="slc">!!$
</span><span class="slc">!!$FANNKUCH is an abbreviation for the German word Pfannkuchen, or pancakes, in analogy to flipping pancakes.&quot;
</span><span class="slc">!!$
</span><span class="slc">!!$Correct output N = 7 is:
</span><span class="slc">!!$
</span><span class="slc">!!$Pfannkuchen(7) = 16
</span><span class="slc">!!$
</span><span class="slc">!!$
</span><span class="slc">!!$Correct output N = 8 is:
</span><span class="slc">!!$
</span><span class="slc">!!$Pfannkuchen(8) = 22
</span><span class="slc">!!$
</span><span class="slc">!!$
</span><span class="slc">!!$Correct output N = 9 is:
</span><span class="slc">!!$
</span><span class="slc">!!$Pfannkuchen(9) = 30
</span><span class="slc">!!$
</span><span class="slc">!!$
</span><span class="slc">!!$Correct output N = 10 is:
</span><span class="slc">!!$
</span><span class="slc">!!$Pfannkuchen(10) = 38
</span>
program fannkuch
  implicit none
  integer count<span class="sym">,</span> i<span class="sym">,</span> num
  character<span class="sym">(</span>len<span class="sym">=</span><span class="num">8</span><span class="sym">)</span> argv
  integer<span class="sym">,</span> dimension<span class="sym">(:),</span> allocatable <span class="sym">::</span> data
  intrinsic max

  call getarg<span class="sym">(</span><span class="num">1</span><span class="sym">,</span>argv<span class="sym">)
</span>  read<span class="sym">(</span>argv<span class="sym">,*)</span> num
  allocate<span class="sym">(</span>data<span class="sym">(</span>num<span class="sym">))

</span>  count <span class="sym">=</span> <span class="num">0
</span>  data <span class="sym">= (/ (</span>i<span class="sym">,</span>i<span class="sym">=</span><span class="num">1</span><span class="sym">,</span>num<span class="sym">) /)</span> <span class="slc">! Must start with the smallest number
</span>  do i<span class="sym">=</span><span class="num">1</span><span class="sym">,</span>factorial<span class="sym">(</span>num<span class="sym">)
</span>     count <span class="sym">=</span> max<span class="sym">(</span>count<span class="sym">,</span>countFlips<span class="sym">(</span>data<span class="sym">))
</span>     call getNextPerm<span class="sym">(</span>data<span class="sym">)
</span>  end do

    deallocate<span class="sym">(</span>data<span class="sym">)

  </span>  write<span class="sym">(*,</span><span class="str">'(2(a,i0))'</span><span class="sym">)</span> <span class="str">'Pfannkuchen('</span><span class="sym">,</span>num<span class="sym">,</span><span class="str">') = '</span><span class="sym">,</span>count

contains

  recursive integer function factorial<span class="sym">(</span>n<span class="sym">)</span> result<span class="sym">(</span>if<span class="sym">)
</span>    integer<span class="sym">,</span> intent<span class="sym">(</span>in<span class="sym">) ::</span> n
    if <span class="sym">(</span>n <span class="sym">==</span> <span class="num">1</span><span class="sym">)</span> then
       if <span class="sym">=</span> <span class="num">1
</span>    else
       if <span class="sym">=</span> n<span class="sym">*</span>factorial<span class="sym">(</span>n<span class="num">-1</span><span class="sym">)
</span>    end if
  end function factorial

  <span class="slc">! Reverse an array
</span>  subroutine reverse<span class="sym">(</span>data<span class="sym">)
</span>    integer<span class="sym">,</span> dimension<span class="sym">(:),</span> intent<span class="sym">(</span>inout<span class="sym">) ::</span> data
    integer<span class="sym">,</span> dimension<span class="sym">(</span>size<span class="sym">(</span>data<span class="sym">)) ::</span> work
    integer i
   <span class="slc">! print *,'reversing ',data
</span>    forall <span class="sym">(</span>i<span class="sym">=</span><span class="num">1</span><span class="sym">:</span>size<span class="sym">(</span>data<span class="sym">))
</span>       work<span class="sym">(</span>i<span class="sym">) =</span> data<span class="sym">(</span>size<span class="sym">(</span>data<span class="sym">)-</span>i<span class="sym">+</span><span class="num">1</span><span class="sym">)
</span>    end forall
    data <span class="sym">=</span> work
  end subroutine reverse

  <span class="slc">! Count the number of flips in a permutation
</span>  integer function countFlips<span class="sym">(</span>data<span class="sym">)
</span>    integer<span class="sym">,</span> dimension<span class="sym">(:),</span> intent<span class="sym">(</span>in<span class="sym">) ::</span> data
    integer<span class="sym">,</span> dimension<span class="sym">(</span>size<span class="sym">(</span>data<span class="sym">)) ::</span> work
    work <span class="sym">=</span> data
    countFlips <span class="sym">=</span> <span class="num">0
</span>    do
       if <span class="sym">(</span>work<span class="sym">(</span><span class="num">1</span><span class="sym">) &lt;=</span> <span class="num">1</span><span class="sym">)</span> exit
       call reverse<span class="sym">(</span>work<span class="sym">(</span><span class="num">1</span><span class="sym">:</span>work<span class="sym">(</span><span class="num">1</span><span class="sym">)))
</span>       countFlips <span class="sym">=</span> countFlips <span class="sym">+</span> <span class="num">1
</span>    end do
  end function countFlips

  <span class="slc">! Get next permutation
</span>  subroutine getNextPerm<span class="sym">(</span>data<span class="sym">)
</span>    integer<span class="sym">,</span> dimension<span class="sym">(:),</span> intent<span class="sym">(</span>inout<span class="sym">) ::</span> data
    integer <span class="sym">::</span> i<span class="sym">,</span> kx<span class="sym">,</span> e<span class="sym">,</span> ci<span class="sym">,</span> ce<span class="sym">,</span> tmp<span class="sym">,</span> N

    <span class="slc">! Find largest k s.t. data(k) &lt; data(k+1)
</span>    N <span class="sym">=</span> size<span class="sym">(</span>data<span class="sym">)
</span>    kx <span class="sym">=</span> <span class="num">0
</span>    do i<span class="sym">=</span><span class="num">1</span><span class="sym">,</span>N<span class="num">-1
</span>       if <span class="sym">(</span>data<span class="sym">(</span>i<span class="sym">) &lt;</span> data<span class="sym">(</span>i<span class="sym">+</span><span class="num">1</span><span class="sym">))</span> then
          kx <span class="sym">=</span> i
       end if
    end do

    <span class="slc">! Find smallest data(k+j) &gt; data(k)
</span>    e <span class="sym">=</span> data<span class="sym">(</span>kx<span class="sym">)
</span>    ci <span class="sym">=</span> kx
    do i<span class="sym">=</span>kx<span class="sym">+</span><span class="num">1</span><span class="sym">,</span>N
       if <span class="sym">(</span>data<span class="sym">(</span>i<span class="sym">) &gt;</span> e .and. <span class="sym">(</span>ci <span class="sym">==</span> kx .or. data<span class="sym">(</span>i<span class="sym">) &lt;</span> ce<span class="sym">))</span> then
          ci <span class="sym">=</span> i
          ce <span class="sym">=</span> data<span class="sym">(</span>i<span class="sym">)
</span>       end if
    end do

    <span class="slc">! Swap data(k) and data(k+j)
</span>    tmp <span class="sym">=</span> data<span class="sym">(</span>kx<span class="sym">)
</span>    data<span class="sym">(</span>kx<span class="sym">) =</span> data<span class="sym">(</span>ci<span class="sym">)
</span>    data<span class="sym">(</span>ci<span class="sym">) =</span> tmp

    <span class="slc">! Reverse data(k+1) ... data(N)
</span>    call reverse<span class="sym">(</span>data<span class="sym">(</span>kx<span class="sym">+</span><span class="num">1</span><span class="sym">:</span>N<span class="sym">))

    </span>  end subroutine getNextPerm

end program fannkuch
