<table width="100%" border="0" cellpadding="5" cellspacing="0"><tr><td bgcolor="#FFFFFF"><pre>
<I><FONT COLOR="#B22222">/* -*- mode: c -*-
 * $Id: lists1-gcc.code,v 1.2 2004-11-08 08:15:15 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */</FONT></I>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;stdio.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;stdlib.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;unistd.h&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">SIZE</FONT> 10000

<I><FONT COLOR="#B22222">// a simple Single Linked List
</FONT></I><I><FONT COLOR="#B22222">// the head node is special, it's val is length of list
</FONT></I><B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> LL {
    <B><FONT COLOR="#228B22">int</FONT></B> val;
    <B><FONT COLOR="#228B22">struct</FONT></B> LL *next;	<I><FONT COLOR="#B22222">/* points to next or head (if at tail) */</FONT></I>
} LL;

inline <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">list_length</FONT></B>(LL *head) { <B><FONT COLOR="#A020F0">return</FONT></B>(head-&gt;val); }
inline <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">list_empty</FONT></B>(LL *head)  { <B><FONT COLOR="#A020F0">return</FONT></B>(list_length(head) == 0); }
inline LL* <B><FONT COLOR="#0000FF">list_first</FONT></B>(LL *head)  { <B><FONT COLOR="#A020F0">return</FONT></B>(head-&gt;next); }

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">list_push_head</FONT></B>(LL *head, LL *item) {
    LL *next = head-&gt;next;
    head-&gt;next = item;
    item-&gt;next = next;
    head-&gt;val++;
}

LL *<B><FONT COLOR="#0000FF">list_pop_head</FONT></B>(LL *head) {
    LL *next;
    <B><FONT COLOR="#A020F0">if</FONT></B> (list_empty(head)) <B><FONT COLOR="#A020F0">return</FONT></B>(NULL);
    next = head-&gt;next;
    head-&gt;next = next-&gt;next;
    head-&gt;val--;
    <B><FONT COLOR="#A020F0">return</FONT></B>(next);
}

LL *<B><FONT COLOR="#0000FF">list_new_item</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> v) {
    LL *l = (LL *)malloc(<B><FONT COLOR="#A020F0">sizeof</FONT></B>(LL));
    l-&gt;next = NULL;
    l-&gt;val = v;
    <B><FONT COLOR="#A020F0">return</FONT></B>(l);
}

inline LL* <B><FONT COLOR="#0000FF">list_create</FONT></B>()  { <B><FONT COLOR="#A020F0">return</FONT></B>(list_new_item(0)); }

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">list_free</FONT></B> (LL* head) {
    LL *p, *tmp = head;
    <B><FONT COLOR="#A020F0">if</FONT></B> (head == NULL) <B><FONT COLOR="#A020F0">return</FONT></B>;
    <B><FONT COLOR="#A020F0">if</FONT></B> (head-&gt;next != NULL) {
	<B><FONT COLOR="#A020F0">for</FONT></B> (p=head-&gt;next; p-&gt;next != NULL; p=p-&gt;next) {
	    free(tmp);
	    tmp = p;
	}
    }
    free(tmp);
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">list_append</FONT></B> (LL* head_1, LL* head_2) {
    LL *p;
    <B><FONT COLOR="#A020F0">for</FONT></B> (p=head_1; p-&gt;next != NULL; p=p-&gt;next) ;
    p-&gt;next = head_2-&gt;next;
    head_2-&gt;next = NULL;
    head_1-&gt;val += head_2-&gt;val;
    head_2-&gt;val = 0;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">list_member</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> item, LL* head) {
    LL* p = head-&gt;next;
    <B><FONT COLOR="#A020F0">for</FONT></B> (p=head; p != NULL; p=p-&gt;next) {
	<B><FONT COLOR="#A020F0">if</FONT></B> (p-&gt;val == item) <B><FONT COLOR="#A020F0">return</FONT></B>(1);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B>(0);
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">list_reverse</FONT></B> (LL *head) {
    LL *prev, *p, *tmp, *first = list_first(head);
    <B><FONT COLOR="#A020F0">if</FONT></B> (first != NULL) {
	prev = NULL;
	p = first;
	<B><FONT COLOR="#A020F0">while</FONT></B> ((tmp = p-&gt;next) != NULL) {
	    p-&gt;next = prev;
	    prev = p;
	    p = tmp;
	}
	p-&gt;next = prev;
	head-&gt;next = p;
    }
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">list_last</FONT></B>(LL *head) {
    LL* p;
    <B><FONT COLOR="#A020F0">if</FONT></B> (head == NULL) <B><FONT COLOR="#A020F0">return</FONT></B>(0);
    <B><FONT COLOR="#A020F0">for</FONT></B> (p=head; p-&gt;next != NULL; p=p-&gt;next) ;
    <B><FONT COLOR="#A020F0">return</FONT></B>(p-&gt;val);
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> argc, <B><FONT COLOR="#228B22">char</FONT></B> *argv[]) {
    <B><FONT COLOR="#228B22">int</FONT></B> i, mid, sum = 0, n = ((argc == 2) ? atoi(argv[1]) : 1);
    LL *p, *tmp, *A, *B;

    <I><FONT COLOR="#B22222">// create list (A) of integers from 1 through N
</FONT></I>    A = list_create();
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=n; i&gt;0; i--) list_push_head(A, list_new_item(i));

    <I><FONT COLOR="#B22222">// create empty list B
</FONT></I>    B = list_create();

    <I><FONT COLOR="#B22222">// move each individual item from A to B, in a loop, reversing order
</FONT></I>    <B><FONT COLOR="#A020F0">while</FONT></B> (!list_empty(A)) list_push_head(B, list_pop_head(A));

    <I><FONT COLOR="#B22222">// print first 2 items in B
</FONT></I>    printf(<B><FONT COLOR="#BC8F8F">&quot;%d %d\n&quot;</FONT></B>, B-&gt;next-&gt;val, B-&gt;next-&gt;next-&gt;val);

    <I><FONT COLOR="#B22222">// reverse B (can be done in place)
</FONT></I>    list_reverse(B);

    <I><FONT COLOR="#B22222">// is 0 a member of B?
</FONT></I>    printf(<B><FONT COLOR="#BC8F8F">&quot;%s\n&quot;</FONT></B>, list_member(0, B) ? <B><FONT COLOR="#BC8F8F">&quot;true&quot;</FONT></B> : <B><FONT COLOR="#BC8F8F">&quot;false&quot;</FONT></B> );

    <I><FONT COLOR="#B22222">// is N a member of B?
</FONT></I>    printf(<B><FONT COLOR="#BC8F8F">&quot;%s\n&quot;</FONT></B>, list_member(n, B) ? <B><FONT COLOR="#BC8F8F">&quot;true&quot;</FONT></B> : <B><FONT COLOR="#BC8F8F">&quot;false&quot;</FONT></B> );

    <I><FONT COLOR="#B22222">// filter values from B to A that are less than N/2, preserving order
</FONT></I>    mid = n/2;
    tmp = A; <I><FONT COLOR="#B22222">// tmp points to last item in list A
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (p=list_first(B); p!=NULL; p=p-&gt;next) {
	<B><FONT COLOR="#A020F0">if</FONT></B> (p-&gt;val &lt; mid) {
	    tmp-&gt;next = list_new_item(p-&gt;val); <I><FONT COLOR="#B22222">// copy item
</FONT></I>	    tmp = tmp-&gt;next;
	    A-&gt;val++;
	}
    }

    <I><FONT COLOR="#B22222">// print first ten items of A
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0, p=list_first(A); p != NULL &amp;&amp; i&lt;10; i++, p=p-&gt;next)
	printf(<B><FONT COLOR="#BC8F8F">&quot;%d%s&quot;</FONT></B>, p-&gt;val, (i&lt;9) ? <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> : <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);

    <I><FONT COLOR="#B22222">// print sum of items in A that are less than 1000
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (p=list_first(A); p!=NULL; p=p-&gt;next)
	<B><FONT COLOR="#A020F0">if</FONT></B> ((i = p-&gt;val) &lt; 1000) sum += i;
    printf(<B><FONT COLOR="#BC8F8F">&quot;%d\n&quot;</FONT></B>, sum);

    <I><FONT COLOR="#B22222">// append B to end of A (can be done destructively)
</FONT></I>    list_append(A, B);

    <I><FONT COLOR="#B22222">// print length and last element of A
</FONT></I>    printf(<B><FONT COLOR="#BC8F8F">&quot;%d %d\n&quot;</FONT></B>, list_length(A), list_last(A));

    list_free(A);
    list_free(B);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}</pre></td></tr></table>
