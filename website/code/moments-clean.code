<span class="sym">/*</span> The Great Computer Language Shootout
    contributed by John van Groningen <span class="sym">(</span>Clean Guru<span class="sym">!)

</span>   http<span class="sym">://</span>shootout.alioth.debian.org<span class="sym">/

</span>To compile<span class="sym">:
	</span>   cleanIDE.exe <span class="slc">--batch-force-build &quot;e:\shoot\contrib\clean\moments.prj&quot;
</span>
To run<span class="sym">:
</span>   moments.exe <span class="sym">-</span>con <span class="sym">&lt;</span> input.txt <span class="sym">&gt;</span> output.txt
<span class="sym">*/


</span><span class="kwa">module</span> moments
<span class="kwa">import</span> StdEnv<span class="sym">,</span> StdOverloadedList<span class="sym">,</span> LanguageShootout<span class="sym">,</span> Heapsort

Start world
     # <span class="sym">(</span>console<span class="sym">,</span> world<span class="sym">) =</span> stdio world
   # <span class="sym">(</span>a<span class="sym">,</span>suma<span class="sym">) =</span> sumNumbers console <span class="num">0.0</span> <span class="sym">[</span>#<span class="sym">!]
</span>   # <span class="sym">(</span>median<span class="sym">,</span>n<span class="sym">,</span>a<span class="sym">) =</span> median a
      # mean <span class="sym">=</span> suma <span class="sym">/</span> toReal n
         # <span class="sym">(</span>adev<span class="sym">,</span>var<span class="sym">,</span>skew<span class="sym">,</span>kurt<span class="sym">) =</span> loop a mean <span class="num">0.0 0.0 0.0 0.0</span> <span class="sym">(</span>n<span class="num">-1</span><span class="sym">)
   =</span> resultstring <span class="sym">(</span>toReal n<span class="sym">)</span> mean median adev var skew kurt

       <span class="kwa">where
         </span>   sumNumbers <span class="sym">:: !*</span>File <span class="sym">!</span>Real .<span class="sym">[</span>#Real<span class="sym">!] -&gt; *(*</span>{#Real}<span class="sym">,</span>Real<span class="sym">)
   </span>   sumNumbers f suma a
      #<span class="sym">! (</span>ok<span class="sym">,</span>r<span class="sym">,</span>f<span class="sym">) =</span> freadr f
      <span class="sym">|</span> not ok <span class="sym">= (</span>toArray a<span class="sym">,</span> suma<span class="sym">)
      =</span> sumNumbers f <span class="sym">(</span>suma<span class="sym">+</span>r<span class="sym">) [</span># r<span class="sym">:</span>a <span class="sym">!]

      </span>   toArray <span class="sym">:: [</span>#Real<span class="sym">!] -&gt; *</span>{#Real}
   toArray a <span class="sym">=</span> {x \\ x <span class="sym">&lt;|-</span> a}

                                                      <span class="sym">//</span> Use modified Quicksort rather than Wirth<span class="str">'s k select
          median a
      # a = find_medians a
        # (n,a) = usize a
      # m = middle a ((n/2)-1) (n/2) n
      = (m,n,a)

            where
       middle a=:{[m0]=am0,[m]=am} m0 m n
         | isOdd n = am
                   = (am0 + am) / 2.0

                      loop :: !.{#Real} !Real Real Real Real Real Int -&gt; . (!Real,!Real,!Real,!Real)
    loop a mean adev var skew kurt i
      | i&lt;0
          = (adev,var,skew,kurt)
	  #! ai=a.[i]
	  # dev = ai - mean
	  # dev2 = dev*dev
	  # dev3 = dev2*dev
	  = loop a mean (adev + abs dev)(var + dev2)(skew + dev3)(kurt + dev3*dev)(i-1)

                            find_medians :: *{#Real} -&gt; .{#Real}
find_medians a0
    # (n_elements,a) = usize a0
    # k = (n_elements&gt;&gt;1) + (n_elements bitand 1)
    = quick_sort1 0 (n_elements-1) k a
    where
        quick_sort0 :: !Int !Int !Int !*{#Real} -&gt; *{#Real}
        quick_sort0 b e k a
            | k&gt;=b &amp;&amp; k&lt;=e+1
                = quick_sort1 b e k a
                = a

        quick_sort1 b e k a
            | b&gt;=e
                = a
        quick_sort1 b e k a=:{[b]=ab}
            # m=(b+e)&gt;&gt;1
            # (am,a) = a![m]
            = find_large am (b+1) e e b k {a &amp; [m]=ab}
        where
            find_large am l e r b k a
                | l&lt;=e &amp;&amp; a.[l]&lt;=am
                    = find_large am (l+1) e r b k a
                    = find_small_or_equal am r b l e k a

                       find_small_or_equal am r b l e k a
                | r&gt;b &amp;&amp; a.[r]&gt;am
                    = find_small_or_equal am (r-1) b l e k a
                | l&lt;r
                    # (al,a)=a![l]
                      (ar,a)=a![r]
                    = find_large am (l+1) e (r-1) b k {a &amp; [l]=ar,[r]=al}
           	| b==r
                    = quick_sort2 (r-1) (r+1) b e k {a &amp; [b]=am}
                    # (ar,a)=a![r]
                    = quick_sort2 (r-1) (r+1) b e k {a &amp; [r]=am,[b]=ar}

            quick_sort2 l r b e k a
                | l-b&gt;=e-r
                    = quick_sort0 b l k (quick_sort0 r e k a)
                    = quick_sort0 r e k (quick_sort0 b l k a)
   
   resultstring n mean median ad v s k =
       &quot;n:                  &quot; +++ (toString n) +++ &quot;\n&quot; +++
       &quot;median:             &quot; +++ (toStringWith 6 median) +++ &quot;\n&quot; +++
       &quot;mean:               &quot; +++ (toStringWith 6 mean) +++ &quot;\n&quot; +++
                  &quot;average_deviation:  &quot; +++ (toStringWith 6 adev) +++ &quot;\n&quot; +++
       &quot;standard_deviation: &quot; +++ (toStringWith 6 sdev) +++ &quot;\n&quot; +++
       &quot;variance:           &quot; +++ (toStringWith 6 var) +++ &quot;\n&quot; +++
       &quot;skew:               &quot; +++ (toStringWith 6 skew) +++ &quot;\n&quot; +++
       &quot;kurtosis:           &quot; +++ (toStringWith 6 kurt) +++ &quot;\n&quot;
     
            where
                                                       adev = ad / n
            var = v / (n-1.0)
      sdev = sqrt var
      skew = s / (n*var*sdev)
      kurt = k / (n*var*var)-3.0</span>                                                 
