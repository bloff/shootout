<span class="slc">;;; The Great Computer Language Shootout
</span><span class="slc">;;; http://shootout.alioth.debian.org/
</span><span class="slc">;;; contributed by Sven Hartrumpf
</span>
<span class="sym">(</span>declare <span class="sym">(</span>disable<span class="sym">-</span>interrupts<span class="sym">) (</span>fixnum<span class="sym">))

(</span>define make <span class="sym">(</span><span class="kwa">lambda</span> <span class="sym">(</span>item d<span class="sym">)
  (</span><span class="kwa">if</span> <span class="sym">(=</span> d <span class="num">0</span><span class="sym">)
    (</span><span class="kwa">list</span> <span class="str">'empty item)
    (let ((item2 (* item 2))
          (d2 (- d 1)))
      (list '</span>node <span class="sym">(</span>make <span class="sym">(-</span> item2 <span class="num">1</span><span class="sym">)</span> d2<span class="sym">)</span> item <span class="sym">(</span>make item2 d2<span class="sym">))))))

(</span>define check <span class="sym">(</span><span class="kwa">lambda</span> <span class="sym">(</span>t<span class="sym">)
  (</span><span class="kwa">if</span> <span class="sym">(</span><span class="kwa">eq</span>? <span class="sym">(</span><span class="kwa">car</span> t<span class="sym">)</span> <span class="str">'empty)
    (cadr t)
    (+ (caddr t) (- (check (cadr t)) (check (cadddr t)))))))

(define main (lambda (argv)
  (let* ((min-depth 4)
         (max-depth (max (+ min-depth 2) (if (pair? argv) (string-&gt;number (car argv)) 10))))
    (let ((stretch-depth (+ max-depth 1)))
      (display &quot;stretch tree of depth &quot;) (display stretch-depth) (write-char #</span><span class="esc">\t</span><span class="str">ab) (display &quot; check: &quot;) (display (check (make 0 stretch-depth))) (newline))
    (let ((long-lived-tree (make 0 max-depth)))
      (do ((d 4 (+ d 2))
           (c 0 0))
        ((&gt; d max-depth))
        (let ((iterations (arithmetic-shift 1 (+ (- max-depth d) min-depth)))) ; chicken-specific: arithmetic-shift
          (do ((i 0 (+ i 1)))
            ((&gt;= i iterations))
            (set! c (+ c (check (make i d)) (check (make (- i) d)))))
          (display (* 2 iterations)) (write-char #</span><span class="esc">\t</span><span class="str">ab) (display &quot; trees of depth &quot;) (display d) (write-char #</span><span class="esc">\t</span><span class="str">ab) (display &quot; check: &quot;) (display c) (newline)))
      (display &quot;long lived tree of depth &quot;) (display max-depth) (write-char #</span><span class="esc">\t</span><span class="str">ab) (display &quot; check: &quot;) (display (check long-lived-tree)) (newline)))))

(main (command-line-arguments))</span>
