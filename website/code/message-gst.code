<span class="str">&quot;* The Computer Language Shootout</span>
<span class="str">    http://shootout.alioth.debian.org/</span>
<span class="str">    contributed by Paolo Bonzini *&quot;</span><span class="sym">!</span>

Object subclass<span class="sym">:</span> <span class="slc">#Consumer   instanceVariableNames: 'semaphore msg'   classVariableNames: ''   poolDictionaries: ''   category: 'Shootout'!</span>

Consumer subclass<span class="sym">:</span> <span class="slc">#ProducerConsumer   instanceVariableNames: 'consumer'   classVariableNames: ''   poolDictionaries: ''   category: 'Shootout'!</span>

<span class="sym">!</span>Consumer methodsFor<span class="sym">:</span> <span class="str">'accessing'</span><span class="sym">!</span>msg    semaphore wait.    ^msg<span class="sym">! !!</span>Consumer methodsFor<span class="sym">:</span> <span class="str">'accessing'</span><span class="sym">!</span>msg<span class="sym">:</span> data    msg <span class="sym">:=</span> data.    semaphore signal<span class="sym">! !!</span>Consumer methodsFor<span class="sym">:</span> <span class="str">'accessing'</span><span class="sym">!</span>semaphore<span class="sym">:</span> aSemaphore    semaphore <span class="sym">:=</span> aSemaphore<span class="sym">! !!</span>Consumer class methodsFor<span class="sym">:</span> <span class="str">'instance creation'</span><span class="sym">!</span>new    <span class="sym">|</span> var <span class="sym">|</span>    var <span class="sym">:=</span> self basicNew.    var semaphore<span class="sym">:</span> Semaphore new.    ^var<span class="sym">! !!</span>ProducerConsumer methodsFor<span class="sym">:</span> <span class="str">'accessing'</span><span class="sym">!</span>consumer<span class="sym">:</span> aProcess    consumer <span class="sym">:=</span> aProcess<span class="sym">! !!</span>ProducerConsumer methodsFor<span class="sym">:</span> <span class="str">'accessing'</span><span class="sym">!</span>fork    <span class="sym">[</span> self run <span class="sym">]</span> fork<span class="sym">! !!</span>ProducerConsumer methodsFor<span class="sym">:</span> <span class="str">'accessing'</span><span class="sym">!</span>run    <span class="sym">[</span> consumer msg<span class="sym">:</span> self msg <span class="sym">+</span> <span class="num">1</span> <span class="sym">]</span> repeat<span class="sym">! !!</span>ProducerConsumer class methodsFor<span class="sym">:</span> <span class="str">'instance creation'</span><span class="sym">!</span>fork<span class="sym">:</span> consumer    <span class="sym">|</span> proc <span class="sym">|</span>    proc <span class="sym">:=</span> self new.    proc consumer<span class="sym">:</span> consumer.    proc fork.    ^proc<span class="sym">! !!</span>Tests class methodsFor<span class="sym">:</span> <span class="str">'benchmarking'</span><span class="sym">!</span>message<span class="sym">:</span> n   <span class="sym">|</span> tail head sum <span class="sym">|</span>   head <span class="sym">:=</span> tail <span class="sym">:=</span> Consumer new.   <span class="num">500</span> timesRepeat<span class="sym">: [</span>head <span class="sym">:=</span> ProducerConsumer fork<span class="sym">:</span> head<span class="sym">]</span>.   sum <span class="sym">:=</span> <span class="num">0</span>.   n timesRepeat<span class="sym">:      [</span>head msg<span class="sym">:</span> <span class="num">0</span>.      sum <span class="sym">:=</span> sum <span class="sym">+</span> tail msg<span class="sym">]</span>.   ^sum <span class="sym">! !!</span>Tests class methodsFor<span class="sym">:</span> <span class="str">'benchmark scripts'</span><span class="sym">!</span>message   self stdout print<span class="sym">: (</span>self message<span class="sym">:</span> self arg<span class="sym">);</span> nl.   ^<span class="str">''</span><span class="sym">! !</span>

Tests message<span class="sym">!</span>
