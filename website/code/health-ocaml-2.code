<span class="com">(* health.ml
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Troestler Christophe
 *)</span>

<span class="com">(* Adjust GC behavior *)</span>
<span class="kwa">let</span> <span class="sym">() =</span> Gc.set <span class="sym">{ (</span>Gc.get<span class="sym">())</span> <span class="kwa">with</span> Gc.minor_heap_size <span class="sym">=</span> <span class="num">1024</span> <span class="sym">*</span> <span class="num">1024</span> <span class="sym">}


</span><span class="com">(* Mutable data structure for bags (aka multisets) of patients.
   Useful interface only. *)</span>
<span class="com">(* module type Lsig =
sig
  type 'a t
  val make : unit -&gt; 'a t
  val add : 'a -&gt; 'a t -&gt; unit
  val iter : ('a -&gt; unit) -&gt; 'a t -&gt; unit
  val fold : ('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b t -&gt; 'a
  val keep : ('a -&gt; bool) -&gt; 'a t -&gt; unit
  val export : 'a t -&gt; 'a t
end *)</span>
<span class="kwa">module</span> L <span class="sym">=
</span><span class="kwa">struct
  type</span> <span class="str">'a t = '</span>a list ref
  <span class="kwa">and</span> <span class="str">'a list = '</span>a node option
  <span class="kwa">and</span> <span class="str">'a node = { data : '</span>a<span class="sym">;</span> <span class="kwa">mutable</span> next <span class="sym">:</span> <span class="str">'a list }

  let make () = ref None

  let add e l = l := Some { data = e; next = !l }

  let rec iter_node f = function
    | None -&gt; () | Some node -&gt; let () = f node.data in iter_node f node.next
  let iter f l = iter_node f !l

  let rec fold_node f a = function
    | None -&gt; a | Some node -&gt; fold_node f (f a node.data) node.next
  let fold f a l = fold_node f a !l

  let rec keep_node f node0 = function
    | None -&gt; ()
    | Some node -&gt;
	if f node.data then keep_node f node node.next (* Keep the node *)
	else (node0.next &lt;- node.next; keep_node f node0 node.next)

  let rec keep f l = match !l with
    | None -&gt; ()
    | Some node -&gt; if f node.data then keep_node f node node.next
                   else (l := node.next; keep f l) (* Remove 1st node *)

  let export l = let node = !l in l := None; ref node
end



type patient = {
  mutable remaining_time : int;
  mutable hospital_time : int;
  mutable hospital_visits : int;
}

let patient_stay p s =
  p.remaining_time &lt;- s;  p.hospital_time &lt;- p.hospital_time + s

type totals = int * int * int (* patients, hospital time, hospital visits *)

let add_patient (n, t, v) p =
  (n + 1, t + p.hospital_time, v + p.hospital_visits)

let ( ++ ) (n0, t0, v0) (n1, t1, v1) = (n0 + n1, t0 + t1, v0 + v1)


module Hospital =
struct
  type t = {
    triage : patient L.t;
    examination : patient L.t;
    treatement : patient L.t;
    mutable discharged : totals;

    mutable available_staff : int;
    mutable seed : int;
    has_no_regional_hospital : bool; (* i.e. &quot;top&quot; one *)
    transfers : patient L.t;
  }

  (* Shootout random generator, but with hospital seed *)
  let im = 139968 and ia = 3877 and ic = 29573
  let inv_im = 1. /. float im

  let random h max =
    h.seed &lt;- (h.seed * ia + ic) mod im;
    max *. float h.seed *. inv_im

  let make has_no_regional_hospital level seed =
    { triage = L.make();  examination = L.make();  treatement = L.make();
      discharged = (0,0,0);  available_staff = 1 lsl (level - 1);
      seed = seed;  has_no_regional_hospital = has_no_regional_hospital;
      transfers = L.make(); }

  let totals h =
    let tot = L.fold add_patient (0,0,0) h.triage in
    let tot = L.fold add_patient tot h.examination in
    let tot = L.fold add_patient tot h.treatement in
    tot ++ h.discharged

  let new_arrival h p =
    p.hospital_visits &lt;- p.hospital_visits + 1;
    if h.available_staff &gt; 0 then (
      h.available_staff &lt;- h.available_staff - 1;
      L.add p h.examination;
      patient_stay p 3
    )
    else L.add p h.triage

  let discharge_patients h =
    let treat p =
      p.remaining_time &lt;- p.remaining_time - 1;
      if p.remaining_time &gt; 0 then true else (
	h.available_staff &lt;- h.available_staff + 1;
	h.discharged &lt;- add_patient h.discharged p;
	false
      ) in
    L.keep treat h.treatement

  let treat_or_transfer_patients h =
    let examine p =
      p.remaining_time &lt;- p.remaining_time - 1;
      if p.remaining_time &gt; 0 then true else (
	if random h 1.0 &gt; 0.1 || h.has_no_regional_hospital then (
	  (* Treat patient -- no transfer *)
	  L.add p h.treatement;
	  patient_stay p 10;
	)
	else (
	  (* Transfer to regional hospital *)
	  h.available_staff &lt;- h.available_staff + 1;
	  L.add p h.transfers;
	);
	false
      ) in
    L.keep examine h.examination

  let triage_patients h =
    let triage p =
      if h.available_staff &gt; 0 then (
	h.available_staff &lt;- h.available_staff - 1;
	L.add p h.examination;
	patient_stay p 3;
	false
      )
      else (p.hospital_time &lt;- p.hospital_time + 1;  true) in
    L.keep triage h.triage

  let triage_examination_treatment h =
    discharge_patients h;
    treat_or_transfer_patients h;
    triage_patients h;
    if random h 1.0 &gt; 0.7 then new_arrival h {
      remaining_time = 0; hospital_time = 0; hospital_visits = 0 }
end


(* Hierarchical health care: a region consisting of a hospital and
   (possibly) some districts. *)
type health_care = Region of Hospital.t * (health_care array)

let levels = 5
let districts = 4

let rec create_health_care level seed1 seed2 =
  let create i = create_health_care (level - 1) (4 * seed1 + i + 1) seed2 in
  Region(Hospital.make (level = levels) level (seed1 * seed2),
	 Array.init (if level &lt;= 1 then 0 else districts) create)

let rec transfer_patients (Region(h, districts)) =
  let transfer d =
    L.iter (fun p -&gt; Hospital.new_arrival h p) (transfer_patients d) in
  Array.iter transfer districts;
  Hospital.triage_examination_treatment h;
  (* Return the transfer queue -- leaving the one of [h] empty. *)
  L.export h.Hospital.transfers

let rec accumulate_totals (Region(h, districts)) =
  Array.fold_left (fun tot d -&gt; tot ++ accumulate_totals d) (0,0,0) districts
  ++ Hospital.totals h

let () =
  let n = try int_of_string(Array.get Sys.argv 1) with _ -&gt; 100 in
  let hc = create_health_care levels 0 42 in
  for i = 1 to n do ignore(transfer_patients hc) done;
  let (pat, time, visits) = accumulate_totals hc in
  Printf.printf &quot;Patients: %i</span><span class="esc">\n</span><span class="str">Time:     %i</span><span class="esc">\n</span><span class="str">Visits:   %i</span><span class="esc">\n</span><span class="str">&quot; pat time visits</span>
