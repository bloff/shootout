<span class="sym">!</span> Matrix function implementation
<span class="sym">!</span> Simon Geard<span class="sym">,</span> <span class="num">3</span><span class="sym">/</span><span class="num">12</span><span class="sym">/</span><span class="num">04
</span><span class="sym">!
!</span> Building info<span class="sym">.
! ==============
!
!</span> Linux  <span class="sym">-</span> <span class="kwa">using</span> the Intel Fortran90 compiler<span class="sym">:
!
!</span>          ifort matrix<span class="sym">.</span>f90 <span class="sym">-</span>O3 <span class="sym">-</span><span class="kwb">static</span><span class="sym">-</span>libcxa <span class="sym">-</span>o matrix
<span class="sym">!
!</span> WinXP  <span class="sym">-</span> Compaq Visual Fortran <span class="num">6.6c
</span><span class="sym">!
!</span>          f90 matrix<span class="sym">.</span>f90 <span class="sym">/</span>link <span class="sym">/</span>libpath<span class="sym">:</span><span class="str">&quot;d:</span><span class="esc">\P</span><span class="str">rogram Files</span><span class="esc">\M</span><span class="str">icrosoft Visual Studio</span><span class="esc">\d</span><span class="str">f98</span><span class="esc">\l</span><span class="str">ib&quot;</span>
<span class="sym">!
!</span> Cygwin <span class="sym">-</span> g95 compiler
<span class="sym">!
!</span>          g95 matrix<span class="sym">.</span>f90 <span class="sym">-</span>o matrix<span class="sym">.</span>exe
<span class="sym">!
</span>program heapsort
  implicit none
  integer<span class="sym">,</span> parameter <span class="sym">::</span> IM <span class="sym">=</span> <span class="num">139968
</span>  integer<span class="sym">,</span> parameter <span class="sym">::</span> IA <span class="sym">=</span> <span class="num">3877
</span>  integer<span class="sym">,</span> parameter <span class="sym">::</span> IC <span class="sym">=</span> <span class="num">29573
</span>  integer<span class="sym">,</span> parameter <span class="sym">::</span> msize <span class="sym">=</span> <span class="num">30
</span>  real<span class="sym">*</span><span class="num">8</span><span class="sym">,</span> dimension<span class="sym">(:),</span> allocatable <span class="sym">::</span> ary
  integer <span class="sym">::</span> i<span class="sym">,</span> k<span class="sym">,</span> num
  character<span class="sym">(</span>len<span class="sym">=</span><span class="num">8</span><span class="sym">)</span> argv
  intrinsic matmul

  call getarg<span class="sym">(</span><span class="num">1</span><span class="sym">,</span>argv<span class="sym">)
</span>  read<span class="sym">(</span>argv<span class="sym">,*)</span> num
  <span class="kwa">if</span> <span class="sym">(</span>num <span class="sym">==</span> <span class="num">0</span><span class="sym">)</span> num <span class="sym">=</span> <span class="num">1


</span>  <span class="sym">!</span> create an array of N random doubles
  allocate<span class="sym">(</span>ary<span class="sym">(</span>num<span class="sym">))
</span>  ary <span class="sym">= (/(</span>getRandom<span class="sym">(</span><span class="num">1.0d0</span><span class="sym">),</span>i<span class="sym">=</span><span class="num">1</span><span class="sym">,</span>num<span class="sym">)/)

  !</span> heap sort
  call hsort<span class="sym">(</span>num<span class="sym">,</span> ary<span class="sym">)

</span>  print <span class="sym">*,</span> ary<span class="sym">(</span>num<span class="sym">)

</span>  deallocate<span class="sym">(</span>ary<span class="sym">)

</span>contains
  real<span class="sym">*</span><span class="num">8</span> function getRandom<span class="sym">(</span>mval<span class="sym">)
</span>    real<span class="sym">*</span><span class="num">8</span><span class="sym">,</span> intent<span class="sym">(</span>in<span class="sym">) ::</span> mval
    integer<span class="sym">,</span> save <span class="sym">::</span> last <span class="sym">=</span> <span class="num">42
</span>    last <span class="sym">=</span> mod<span class="sym">(</span>last <span class="sym">*</span> IA <span class="sym">+</span> IC <span class="sym">,</span> IM<span class="sym">)
</span>    getRandom <span class="sym">=</span> mval <span class="sym">*</span> last <span class="sym">/</span> IM
  end function getRandom

  subroutine hsort<span class="sym">(</span>n<span class="sym">,</span> ra<span class="sym">)
</span>    integer<span class="sym">,</span> intent<span class="sym">(</span>in<span class="sym">) ::</span> n
    real<span class="sym">*</span><span class="num">8</span><span class="sym">,</span> dimension<span class="sym">(:),</span> intent<span class="sym">(</span>inout<span class="sym">) ::</span> ra
    integer <span class="sym">::</span> i<span class="sym">,</span> j<span class="sym">,</span> ir<span class="sym">,</span> l
    real<span class="sym">*</span><span class="num">8</span> rra
    intrinsic ishft

    l <span class="sym">=</span> ishft<span class="sym">(</span>n<span class="sym">,-</span><span class="num">1</span><span class="sym">)
</span>    ir <span class="sym">=</span> n
    <span class="kwa">do
       if</span> <span class="sym">(</span>l <span class="sym">&gt;</span> <span class="num">1</span><span class="sym">)</span> then
          l <span class="sym">=</span> l<span class="num">-1
</span>          rra <span class="sym">=</span> ra<span class="sym">(</span>l<span class="sym">)
</span>       <span class="kwa">else
</span>          rra <span class="sym">=</span> ra<span class="sym">(</span>ir<span class="sym">)
</span>          ra<span class="sym">(</span>ir<span class="sym">) =</span> ra<span class="sym">(</span><span class="num">1</span><span class="sym">)
</span>          ir <span class="sym">=</span> ir<span class="num">-1
</span>          <span class="kwa">if</span> <span class="sym">(</span>ir <span class="sym">==</span> <span class="num">1</span><span class="sym">)</span> then
             ra<span class="sym">(</span><span class="num">1</span><span class="sym">) =</span> rra
             <span class="kwa">return
</span>          end <span class="kwa">if
</span>       end <span class="kwa">if
</span>       i <span class="sym">=</span> l
       j <span class="sym">=</span> ishft<span class="sym">(</span>l<span class="sym">,</span><span class="num">1</span><span class="sym">)
</span>       <span class="kwa">do
          if</span> <span class="sym">(</span>j <span class="sym">&gt;</span> ir<span class="sym">)</span> exit
          <span class="kwa">if</span> <span class="sym">(</span>j <span class="sym">&lt;</span> ir <span class="sym">.</span><span class="kwa">and</span><span class="sym">.</span> ra<span class="sym">(</span>j<span class="sym">) &lt;</span> ra<span class="sym">(</span>j<span class="sym">+</span><span class="num">1</span><span class="sym">))</span> then
             j <span class="sym">=</span> j<span class="sym">+</span><span class="num">1
</span>          end <span class="kwa">if
          if</span> <span class="sym">(</span>rra <span class="sym">&lt;</span> ra<span class="sym">(</span>j<span class="sym">))</span> then
             ra<span class="sym">(</span>i<span class="sym">) =</span> ra<span class="sym">(</span>j<span class="sym">)
</span>             i <span class="sym">=</span> j
             j <span class="sym">=</span> j<span class="sym">+</span>i
          <span class="kwa">else
</span>             j <span class="sym">=</span> ir <span class="sym">+</span> <span class="num">1
</span>          end <span class="kwa">if
</span>       end <span class="kwa">do
</span>       ra<span class="sym">(</span>i<span class="sym">) =</span> rra
 end <span class="kwa">do

</span>end subroutine hsort

end program heapsort
<span class="sym">!</span> vim<span class="sym">:</span> ts<span class="sym">=</span><span class="num">4</span> ft<span class="sym">=</span>fortran
