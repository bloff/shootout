<span class="com">/* The Computer Language Shootout Benchmarks
   http://shootout.alioth.debian.org/

   contributed by Dave Fladebo
   compile: dmd -O -inline -release binarytrees.d
*/</span>

import std<span class="sym">.</span>c<span class="sym">.</span>stdlib<span class="sym">,</span> std<span class="sym">.</span>stdio<span class="sym">;

</span><span class="kwb">int</span> main<span class="sym">(</span><span class="kwb">char</span><span class="sym">[][]</span> args<span class="sym">)
{
</span>    TreeNode<span class="sym">*</span>   stretchTree<span class="sym">,</span> longLivedTree<span class="sym">,</span> tempTree<span class="sym">;
</span>    <span class="kwb">int</span>         depth<span class="sym">,</span> minDepth<span class="sym">,</span> maxDepth<span class="sym">,</span> stretchDepth<span class="sym">,</span> N <span class="sym">=</span> args<span class="sym">.</span>length <span class="sym">&gt;</span> <span class="num">1</span> ? atoi<span class="sym">(</span>args<span class="sym">[</span><span class="num">1</span><span class="sym">]) :</span> <span class="num">1</span><span class="sym">;

</span>    minDepth <span class="sym">=</span> <span class="num">4</span><span class="sym">;
</span>    maxDepth <span class="sym">= (</span>minDepth <span class="sym">+</span> <span class="num">2</span><span class="sym">) &gt;</span> N ? minDepth <span class="sym">+</span> <span class="num">2</span> <span class="sym">:</span> N<span class="sym">;
</span>    stretchDepth <span class="sym">=</span> maxDepth <span class="sym">+</span> <span class="num">1</span><span class="sym">;

</span>    stretchTree <span class="sym">=</span> TreeNode<span class="sym">.</span>BottomUpTree<span class="sym">(</span><span class="num">0</span><span class="sym">,</span> stretchDepth<span class="sym">);
</span>    writefln<span class="sym">(</span><span class="str">&quot;stretch tree of depth &quot;</span><span class="sym">,</span>stretchDepth<span class="sym">,</span><span class="str">&quot;</span><span class="esc">\t </span> <span class="str">check: &quot;</span><span class="sym">,</span>stretchTree<span class="sym">.</span>ItemCheck<span class="sym">);
</span>    TreeNode<span class="sym">.</span>DeleteTree<span class="sym">(</span>stretchTree<span class="sym">);

</span>    longLivedTree <span class="sym">=</span> TreeNode<span class="sym">.</span>BottomUpTree<span class="sym">(</span><span class="num">0</span><span class="sym">,</span> maxDepth<span class="sym">);

</span>    <span class="kwa">for</span><span class="sym">(</span>depth <span class="sym">=</span> minDepth<span class="sym">;</span> depth <span class="sym">&lt;=</span> maxDepth<span class="sym">;</span> depth <span class="sym">+=</span> <span class="num">2</span><span class="sym">)
    {
</span>        <span class="kwb">int</span> check<span class="sym">,</span> iterations <span class="sym">=</span> <span class="num">1</span> <span class="sym">&lt;&lt; (</span>maxDepth <span class="sym">-</span> depth <span class="sym">+</span> minDepth<span class="sym">);

</span>        <span class="kwa">for</span><span class="sym">(</span><span class="kwb">int</span> i <span class="sym">=</span> <span class="num">0</span><span class="sym">;</span> i <span class="sym">&lt;</span> iterations<span class="sym">;</span> i<span class="sym">++)
        {
</span>            tempTree <span class="sym">=</span> TreeNode<span class="sym">.</span>BottomUpTree<span class="sym">(</span>i<span class="sym">,</span> depth<span class="sym">);
</span>            check <span class="sym">+=</span> tempTree<span class="sym">.</span>ItemCheck<span class="sym">;
</span>            TreeNode<span class="sym">.</span>DeleteTree<span class="sym">(</span>tempTree<span class="sym">);

</span>            tempTree <span class="sym">=</span> TreeNode<span class="sym">.</span>BottomUpTree<span class="sym">(-</span>i<span class="sym">,</span> depth<span class="sym">);
</span>            check <span class="sym">+=</span> tempTree<span class="sym">.</span>ItemCheck<span class="sym">;
</span>            TreeNode<span class="sym">.</span>DeleteTree<span class="sym">(</span>tempTree<span class="sym">);
        }

</span>        writefln<span class="sym">(</span>iterations <span class="sym">*</span> <span class="num">2</span><span class="sym">,</span><span class="str">&quot;</span><span class="esc">\t </span> <span class="str">trees of depth &quot;</span><span class="sym">,</span>depth<span class="sym">,</span><span class="str">&quot;</span><span class="esc">\t </span> <span class="str">check: &quot;</span><span class="sym">,</span>check<span class="sym">);
    }

</span>    writefln<span class="sym">(</span><span class="str">&quot;long lived tree of depth &quot;</span><span class="sym">,</span>maxDepth<span class="sym">,</span><span class="str">&quot;</span><span class="esc">\t </span> <span class="str">check: &quot;</span><span class="sym">,</span>longLivedTree<span class="sym">.</span>ItemCheck<span class="sym">);

</span>    <span class="kwa">return</span> <span class="num">0</span><span class="sym">;
}

</span><span class="kwb">struct</span> TreeNode
<span class="sym">{
</span><span class="kwc">public</span><span class="sym">:
</span>    <span class="kwb">static</span> TreeNode<span class="sym">*</span> BottomUpTree<span class="sym">(</span><span class="kwb">int</span> item<span class="sym">,</span> <span class="kwb">int</span> depth<span class="sym">)
    {
</span>        <span class="kwa">if</span> <span class="sym">(</span>depth <span class="sym">&gt;</span> <span class="num">0</span><span class="sym">)
</span>            <span class="kwa">return</span> TreeNode<span class="sym">(</span>BottomUpTree<span class="sym">(</span><span class="num">2</span> <span class="sym">*</span> item <span class="num">- 1</span><span class="sym">,</span> depth <span class="num">- 1</span><span class="sym">)
                           ,</span>BottomUpTree<span class="sym">(</span><span class="num">2</span> <span class="sym">*</span> item<span class="sym">,</span> depth <span class="num">- 1</span><span class="sym">)
                           ,</span>item<span class="sym">);
</span>        <span class="kwa">else
</span>        <span class="sym">{
</span>            <span class="kwa">return</span> TreeNode<span class="sym">(</span>item<span class="sym">);
        }
    }

</span>    <span class="kwb">int</span> ItemCheck<span class="sym">()
    {
</span>        <span class="kwa">if</span><span class="sym">(!</span>left<span class="sym">)
</span>            <span class="kwa">return</span> item<span class="sym">;
</span>        <span class="kwa">else
            return</span> item <span class="sym">+</span> left<span class="sym">.</span>ItemCheck<span class="sym">() -</span> right<span class="sym">.</span>ItemCheck<span class="sym">();
    }

</span>    <span class="kwb">static void</span> DeleteTree<span class="sym">(</span>TreeNode<span class="sym">*</span> tree<span class="sym">)
    {
</span>        <span class="kwa">if</span><span class="sym">(</span>tree<span class="sym">.</span>left<span class="sym">)
        {
</span>            DeleteTree<span class="sym">(</span>tree<span class="sym">.</span>left<span class="sym">);
</span>            DeleteTree<span class="sym">(</span>tree<span class="sym">.</span>right<span class="sym">);
        }

</span>        <span class="kwa">delete</span> tree<span class="sym">;
    }

</span><span class="kwc">private</span><span class="sym">:
</span>    TreeNode<span class="sym">*</span>           left<span class="sym">,</span> right<span class="sym">;
</span>    <span class="kwb">int</span>                 item<span class="sym">;

</span>    <span class="kwb">static</span> TreeNode<span class="sym">*</span> opCall<span class="sym">(</span><span class="kwb">int</span> item<span class="sym">)
    {
</span>        TreeNode<span class="sym">*</span> t <span class="sym">=</span> <span class="kwa">new</span> TreeNode<span class="sym">;
</span>        t<span class="sym">.</span>item <span class="sym">=</span> item<span class="sym">;
</span>        <span class="kwa">return</span> t<span class="sym">;
    }

</span>    <span class="kwb">static</span> TreeNode<span class="sym">*</span> opCall<span class="sym">(</span>TreeNode<span class="sym">*</span> left<span class="sym">,</span> TreeNode<span class="sym">*</span> right<span class="sym">,</span> <span class="kwb">int</span> item<span class="sym">)
    {
</span>        TreeNode<span class="sym">*</span> t <span class="sym">=</span> <span class="kwa">new</span> TreeNode<span class="sym">;
</span>        t<span class="sym">.</span>left <span class="sym">=</span> left<span class="sym">;
</span>        t<span class="sym">.</span>right <span class="sym">=</span> right<span class="sym">;
</span>        t<span class="sym">.</span>item <span class="sym">=</span> item<span class="sym">;
</span>        <span class="kwa">return</span> t<span class="sym">;
    }

</span>    <span class="kwa">new</span><span class="sym">(</span>uint sz<span class="sym">)
    {
</span>        TreeNode<span class="sym">*</span> tn <span class="sym">=</span> cast<span class="sym">(</span>TreeNode<span class="sym">*)</span>malloc<span class="sym">(</span>sz<span class="sym">);
</span>        tn<span class="sym">.</span>left <span class="sym">=</span> <span class="kwa">typeof</span><span class="sym">(</span>left<span class="sym">).</span>init<span class="sym">;
</span>        tn<span class="sym">.</span>right <span class="sym">=</span> <span class="kwa">typeof</span><span class="sym">(</span>right<span class="sym">).</span>init<span class="sym">;
</span>        tn<span class="sym">.</span>item <span class="sym">=</span> <span class="kwa">typeof</span><span class="sym">(</span>item<span class="sym">).</span>init<span class="sym">;
</span>        <span class="kwa">return</span> tn<span class="sym">;
    }

</span>    <span class="kwa">delete</span><span class="sym">(</span><span class="kwb">void</span><span class="sym">*</span> p<span class="sym">)
    {
</span>        free<span class="sym">(</span>p<span class="sym">);
    }
}</span>
