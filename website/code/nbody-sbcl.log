BUILD COMMANDS FOR: nbody.sbcl

Mon Jun 20 21:14:13 PDT 2005

SBCL built with: /usr/bin/sbcl --userinit /dev/null --sysinit /dev/null -batch -eval '(load "nbody.sbcl_compile")'
### START nbody.sbcl_compile
(proclaim '(optimize (speed 3) (safety 0) (debug 0) (compilation-speed 0) (space 0)))
(handler-bind ((sb-ext:defconstant-uneql      (lambda (c) (abort c))))      (load (compile-file "nbody.sbcl" ))) (save-lisp-and-die "sbcl.core" :purify t)
### END nbody.sbcl_compile


; compiling file "/opt/shootout/shootout/bench/nbody/tmp/nbody.cmucl" (written 20 JUN 2005 09:14:13 PM):
; compiling (DEFCONSTANT +DAYS-PER-YEAR+ ...)
; compiling (DEFCONSTANT +SOLAR-MASS+ ...)
; compiling (DEFSTRUCT BODY ...)
; compiling (DEFUN MAKE-BODY1 ...)
; compiling (DEFPARAMETER *JUPITER* ...)
; compiling (DEFPARAMETER *SATURN* ...)
; compiling (DEFPARAMETER *URANUS* ...)
; compiling (DEFPARAMETER *NEPTUNE* ...)
; compiling (DEFPARAMETER *SUN* ...)
; compiling (DEFUN APPLYFORCES ...)
; compiling (DEFUN MOVE ...)
; compiling (DEFUN ADVANCE ...)
; file: /opt/shootout/shootout/bench/nbody/tmp/nbody.cmucl
; in: DEFUN ADVANCE
;     (LENGTH SYSTEM)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (LOOP FOR I ACROSS SYSTEM DO (MOVE I DT))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY SETQ THE 
; ==>
;   (LENGTH #:LOOP-ACROSS-VECTOR-231)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR NULL VECTOR), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR NULL VECTOR), not a VECTOR.

; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 
; --> AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

;     (LENGTH SYSTEM)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (AREF SYSTEM I)
; --> LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

;     (AREF SYSTEM J)
; --> LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

; compiling (DEFUN ENERGY ...)
; file: /opt/shootout/shootout/bench/nbody/tmp/nbody.cmucl
; in: DEFUN ENERGY
;     (ARRAY-DIMENSION SYSTEM 0)
; 
; note: unable to
;   optimize
; because:
;   The array dimensions are unknown; must call ARRAY-DIMENSION at runtime.

;     (AREF SYSTEM I)
; --> LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

;     (* 0.5d0 (BODY-MASS B) (LOOP FOR V ACROSS (BODY-VEL B) SUM (* V V)))
; ==>
;   (* (* 0.5d0 (BODY-MASS B)) (LOOP FOR V ACROSS (BODY-VEL B) SUM (* V V)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (+ E (* 0.5d0 (BODY-MASS B) (LOOP FOR V ACROSS (BODY-VEL B) SUM (* V V))))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (ARRAY-DIMENSION SYSTEM 0)
; 
; note: unable to optimize because: can't tell whether array is simple

;     (AREF SYSTEM J)
; --> LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

;     (SQRT
;    (LOOP FOR
;          B
;          ACROSS
;          (BODY-POS B)
;          AND
;          B2
;          ACROSS
;          (BODY-POS B2)
;          SUM
;          (* (- B B2) (- B B2))))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The result is a (VALUES
;                    (OR (MEMBER 0.0 0.0d0)
;                        (DOUBLE-FLOAT (0.0d0))
;                        (SINGLE-FLOAT (0.0))
;                        (COMPLEX SINGLE-FLOAT)
;                        (COMPLEX DOUBLE-FLOAT))
;                    &OPTIONAL), not a (VALUES FLOAT &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The result is a (VALUES
;                    (OR (MEMBER 0.0 0.0d0)
;                        (DOUBLE-FLOAT (0.0d0))
;                        (SINGLE-FLOAT (0.0))
;                        (COMPLEX SINGLE-FLOAT)
;                        (COMPLEX DOUBLE-FLOAT))
;                    &OPTIONAL), not a (VALUES FLOAT &REST T).

;     (/ (* (BODY-MASS B) (BODY-MASS B2)) DIST)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a (OR (MEMBER 0.0 0.0d0)
;                                (DOUBLE-FLOAT (0.0d0))
;                                (SINGLE-FLOAT (0.0))
;                                (COMPLEX SINGLE-FLOAT)
;                                (COMPLEX DOUBLE-FLOAT)), not a SINGLE-FLOAT.

;     (- E (/ (* (BODY-MASS B) (BODY-MASS B2)) DIST))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a (OR (COMPLEX DOUBLE-FLOAT)
;                                DOUBLE-FLOAT), not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a (OR (COMPLEX DOUBLE-FLOAT)
;                                DOUBLE-FLOAT), not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a (OR (COMPLEX DOUBLE-FLOAT) DOUBLE-FLOAT), not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a (OR (COMPLEX DOUBLE-FLOAT)
;                                DOUBLE-FLOAT), not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a (OR (COMPLEX DOUBLE-FLOAT) DOUBLE-FLOAT), not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a (OR (COMPLEX DOUBLE-FLOAT)
;                                DOUBLE-FLOAT), not a (COMPLEX DOUBLE-FLOAT).

;     (LOOP FOR
;         B
;         ACROSS
;         (BODY-POS B)
;         AND
;         B2
;         ACROSS
;         (BODY-POS B2)
;         SUM
;         (* (- B B2) (- B B2)))
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY SETQ THE 
; ==>
;   (+ #:LOOP-SUM-249 (* (- B B2) (- B B2)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (LOOP FOR V ACROSS (BODY-VEL B) SUM (* V V))
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY SETQ THE 
; ==>
;   (+ #:LOOP-SUM-241 (* V V))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).

;     (* 0.5d0 (BODY-MASS B) (LOOP FOR V ACROSS (BODY-VEL B) SUM (* V V)))
; ==>
;   (* (* 0.5d0 (BODY-MASS B)) (LOOP FOR V ACROSS (BODY-VEL B) SUM (* V V)))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 3) because:
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).

;     (+ E (* 0.5d0 (BODY-MASS B) (LOOP FOR V ACROSS (BODY-VEL B) SUM (* V V))))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (LOOP FOR
;         B
;         ACROSS
;         (BODY-POS B)
;         AND
;         B2
;         ACROSS
;         (BODY-POS B2)
;         SUM
;         (* (- B B2) (- B B2)))
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY SETQ THE 
; ==>
;   (+ #:LOOP-SUM-249 (* (- B B2) (- B B2)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).

;     (/ (* (BODY-MASS B) (BODY-MASS B2)) DIST)
; 
; note: forced to do static-fun Two-arg-/ (cost 53)
;       unable to do inline float arithmetic (cost 12) because:
;       The second argument is a (OR (MEMBER 0.0 0.0d0)
;                                    (DOUBLE-FLOAT (0.0d0))
;                                    (SINGLE-FLOAT (0.0))
;                                    (COMPLEX SINGLE-FLOAT)
;                                    (COMPLEX DOUBLE-FLOAT)), not a DOUBLE-FLOAT.
;       The result is a (VALUES (OR (COMPLEX DOUBLE-FLOAT) DOUBLE-FLOAT)
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).

;     (- E (/ (* (BODY-MASS B) (BODY-MASS B2)) DIST))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a (OR (COMPLEX DOUBLE-FLOAT)
;                                    DOUBLE-FLOAT), not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).

;     (LOOP FOR V ACROSS (BODY-VEL B) SUM (* V V))
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ 
; ==>
;   (SETQ V (AREF #:LOOP-ACROSS-VECTOR-238 #:LOOP-ACROSS-INDEX-239))
; 
; note: doing float to pointer coercion (cost 13) to V

; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY SETQ THE 
; ==>
;   (+ #:LOOP-SUM-241 (* V V))
; 
; note: doing float to pointer coercion (cost 13), for:
;       the second argument of GENERIC-+

;     (* 0.5d0 (BODY-MASS B) (LOOP FOR V ACROSS (BODY-VEL B) SUM (* V V)))
; ==>
;   (* (* 0.5d0 (BODY-MASS B)) (LOOP FOR V ACROSS (BODY-VEL B) SUM (* V V)))
; 
; note: doing float to pointer coercion (cost 13), for:
;       the first argument of GENERIC-*

;     (LOOP FOR
;         B
;         ACROSS
;         (BODY-POS B)
;         AND
;         B2
;         ACROSS
;         (BODY-POS B2)
;         SUM
;         (* (- B B2) (- B B2)))
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> THE PROG1 LET SB-LOOP::LOOP-REALLY-DESETQ 
; ==>
;   (SETQ B2 (AREF #:LOOP-ACROSS-VECTOR-246 #:LOOP-ACROSS-INDEX-247))
; 
; note: doing float to pointer coercion (cost 13) to B2

; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ 
; ==>
;   (SETQ B
;           (PROG1 (AREF #:LOOP-ACROSS-VECTOR-243 #:LOOP-ACROSS-INDEX-244)
;             (SB-LOOP::LOOP-REALLY-DESETQ B2
;                                          (AREF #:LOOP-ACROSS-VECTOR-246
;                                                #:LOOP-ACROSS-INDEX-247))))
; 
; note: doing float to pointer coercion (cost 13) to B

; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY SETQ THE 
; ==>
;   (+ #:LOOP-SUM-249 (* (- B B2) (- B B2)))
; 
; note: doing float to pointer coercion (cost 13), for:
;       the second argument of GENERIC-+

;     (/ (* (BODY-MASS B) (BODY-MASS B2)) DIST)
; 
; note: doing float to pointer coercion (cost 13), for:
;       the first argument of static-fun Two-arg-/

; compiling (DEFUN OFFSET-MOMENTUM ...)
; file: /opt/shootout/shootout/bench/nbody/tmp/nbody.cmucl
; in: DEFUN OFFSET-MOMENTUM
;     (LOOP FOR
;         P
;         ACROSS
;         SYSTEM
;         DO
;         (SETF PX (+ PX (* (AREF # 0) (BODY-MASS P))))
;         (SETF PY (+ PY (* (AREF # 1) (BODY-MASS P))))
;         (SETF PZ (+ PZ (* (AREF # 2) (BODY-MASS P)))))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY SETQ THE 
; ==>
;   (LENGTH #:LOOP-ACROSS-VECTOR-263)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR NULL VECTOR), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR NULL VECTOR), not a VECTOR.

;     (AREF SYSTEM 0)
; --> LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

;     (LOOP FOR
;         P
;         ACROSS
;         SYSTEM
;         DO
;         (SETF PX (+ PX (* (AREF # 0) (BODY-MASS P))))
;         (SETF PY (+ PY (* (AREF # 1) (BODY-MASS P))))
;         (SETF PZ (+ PZ (* (AREF # 2) (BODY-MASS P)))))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 
; --> AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

;     (SETF (AREF (BODY-VEL (AREF SYSTEM 0)) 2) (/ (- PZ) +SOLAR-MASS+))
; --> SB-KERNEL:%ASET LET* SB-KERNEL:HAIRY-DATA-VECTOR-SET MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   #'(LAMBDA (&OPTIONAL (ARRAY) (SB-INT:INDEX) &REST #:G292)
;       (DECLARE (IGNORE #:G292))
;       (DECLARE (TYPE (SIMPLE-ARRAY DOUBLE-FLOAT 1) ARRAY)
;                (TYPE DOUBLE-FLOAT SB-C::NEW-VALUE))
;       (SB-KERNEL:DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE))
; 
; note: doing float to pointer coercion (cost 13) to "<return value>"

; compiling (DEFUN NBODY ...)
; file: /opt/shootout/shootout/bench/nbody/tmp/nbody.cmucl
; in: DEFUN NBODY
;     (LOOP FOR I FROM 1 UPTO N DO (ADVANCE SYSTEM 0.01d0))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN COND IF 
; ==>
;   (> I #:LOOP-LIMIT-295)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 
; --> 1+ 
; ==>
;   (+ I 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2)
;                               &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2)
;                               &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN MAIN ...); 
; compilation unit finished
;   printed 75 notes


; /opt/shootout/shootout/bench/nbody/tmp/nbody.fasl written
; compilation finished in 0:00:01
[doing purification: roots handlers stack bindings static cleanup done]
[undoing binding stack and other enclosing state... done]
[saving current Lisp image into /opt/shootout/shootout/bench/nbody/tmp/sbcl.core:
writing 18399944 bytes from the read-only space at 0x01000000
writing 6443608 bytes from the static space at 0x05000000
writing 4096 bytes from the dynamic space at 0x09000000
done]
### START nbody.sbcl_run
(proclaim '(optimize (speed 3) (safety 0) (debug 0) (compilation-speed 0) (space 0)))
(main) (quit)
### END nbody.sbcl_run


=================================================================
COMMAND LINE (%A is single numeric argument):

 /usr/bin/sbcl --noinform --core sbcl.core --userinit /dev/null --sysinit /dev/null --load nbody.sbcl_run %A


PROGRAM OUTPUT
==============
-0.169075164
-0.169086185
