<span class="kwa">Program</span> hash<span class="sym">;
</span><span class="com">{$MODE objfpc}</span>
<span class="kwa">uses</span> SysUtils<span class="sym">,</span> Classes<span class="sym">;


</span><span class="kwa">type
</span>   THashEntryPtr <span class="sym">=</span> ^THashEntryRec<span class="sym">;
</span>   THashEntryRec <span class="sym">=</span> <span class="kwa">record
</span>	  name <span class="sym">:</span> <span class="kwa">string</span><span class="sym">;
</span>	  number <span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;
</span>	  next <span class="sym">:</span> THashEntryPtr<span class="sym">;
</span>   <span class="kwa">end</span><span class="sym">;

</span><span class="kwa">const
</span>   TABLE_SIZE <span class="sym">=</span> <span class="num">100000</span><span class="sym">;

</span><span class="kwa">type</span> THash <span class="sym">=</span> <span class="kwa">class
	private
</span>		hashtable <span class="sym">:</span> <span class="kwa">array</span><span class="sym">[</span><span class="num">0</span>..TABLE_SIZE <span class="num">- 1</span><span class="sym">]</span> <span class="kwa">of</span> THashEntryRec<span class="sym">;
</span>		<span class="kwa">function</span> hash<span class="sym">(</span>s <span class="sym">:</span> <span class="kwa">string</span><span class="sym">) :</span> <span class="kwb">longint</span><span class="sym">;
</span>	<span class="kwa">public
		constructor</span> Create<span class="sym">;
</span>		<span class="kwa">function</span> store<span class="sym">(</span>name <span class="sym">:</span> <span class="kwa">string</span><span class="sym">;</span> number <span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;</span> <span class="kwa">var</span> error <span class="sym">:</span> <span class="kwb">longint</span><span class="sym">) :</span> <span class="kwb">boolean</span><span class="sym">;
</span>		<span class="kwa">function</span> fetch<span class="sym">(</span>name <span class="sym">:</span> <span class="kwa">string</span><span class="sym">;</span> <span class="kwa">var</span> number <span class="sym">:</span> <span class="kwb">longint</span><span class="sym">) :</span> <span class="kwb">boolean</span><span class="sym">;
</span>		<span class="kwa">function</span> exists<span class="sym">(</span>name <span class="sym">:</span> <span class="kwa">string</span><span class="sym">) :</span> <span class="kwb">boolean</span><span class="sym">;
</span><span class="kwa">end</span><span class="sym">;

</span><span class="kwa">constructor</span> THash.Create<span class="sym">;
</span><span class="kwa">var
</span>   i <span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;
</span><span class="kwa">begin
   for</span> i <span class="sym">:=</span> <span class="num">0</span> <span class="kwa">to</span> TABLE_SIZE <span class="num">- 1</span> <span class="kwa">do
</span>      hashtable<span class="sym">[</span>i<span class="sym">]</span>.next <span class="sym">:=</span> <span class="kwa">nil</span><span class="sym">;
</span><span class="kwa">end</span><span class="sym">;


</span><span class="kwa">function</span> THash.hash<span class="sym">(</span>s <span class="sym">:</span> <span class="kwa">string</span><span class="sym">) :</span> <span class="kwb">longint</span><span class="sym">;
</span><span class="kwa">var
</span>   i<span class="sym">,</span> j <span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;
</span><span class="kwa">begin
	if</span> length<span class="sym">(</span>s<span class="sym">) =</span> <span class="num">0</span> <span class="kwa">then</span> Result <span class="sym">:=</span> <span class="num">0
</span>	<span class="kwa">else
	begin
</span>		j <span class="sym">:=</span> ord<span class="sym">(</span>s<span class="sym">[</span><span class="num">1</span><span class="sym">])</span> <span class="kwa">mod</span> TABLE_SIZE<span class="sym">;
</span>		<span class="kwa">for</span> i <span class="sym">:=</span> <span class="num">2</span> <span class="kwa">to</span> length<span class="sym">(</span>s<span class="sym">)</span> <span class="kwa">do
</span>			j <span class="sym">:= (</span>j <span class="kwa">shl</span> <span class="num">8</span> <span class="sym">+</span> ord<span class="sym">(</span>s<span class="sym">[</span>i<span class="sym">]))</span> <span class="kwa">mod</span> TABLE_SIZE<span class="sym">;
</span>		Result <span class="sym">:=</span> j<span class="sym">;
</span>	<span class="kwa">end</span><span class="sym">;
</span><span class="kwa">end</span><span class="sym">;

</span><span class="kwa">function</span> THash.store<span class="sym">(</span>name <span class="sym">:</span> <span class="kwa">string</span><span class="sym">;</span> number <span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;</span> <span class="kwa">var</span> error <span class="sym">:</span> <span class="kwb">longint</span><span class="sym">) :</span> <span class="kwb">boolean</span><span class="sym">;
</span><span class="kwa">var
</span>   node<span class="sym">,</span> prev <span class="sym">:</span> THashEntryPtr<span class="sym">;
</span><span class="kwa">begin
</span>   error <span class="sym">:=</span> <span class="num">0</span><span class="sym">;

</span>   prev <span class="sym">:= &#64;</span>hashtable<span class="sym">[</span>hash<span class="sym">(</span>name<span class="sym">)];
</span>   node <span class="sym">:=</span> prev^.next<span class="sym">;

</span>   <span class="kwa">while</span> <span class="sym">(</span>node <span class="sym">&lt;&gt;</span> <span class="kwa">nil</span><span class="sym">)</span> <span class="kwa">and</span> <span class="sym">(</span>node^.name <span class="sym">&lt;&gt;</span> name<span class="sym">)</span> <span class="kwa">do
   begin
</span>      prev <span class="sym">:=</span> node<span class="sym">;
</span>      node <span class="sym">:=</span> node^.next<span class="sym">;
</span>   <span class="kwa">end</span><span class="sym">;

</span>   <span class="kwa">if</span> node <span class="sym">&lt;&gt;</span> <span class="kwa">nil then</span> error <span class="sym">:=</span> <span class="num">1
</span>   <span class="kwa">else begin
</span>      new<span class="sym">(</span>prev^.next<span class="sym">);
</span>      node <span class="sym">:=</span> prev^.next<span class="sym">;
</span>      <span class="kwa">if</span> node <span class="sym">=</span> <span class="kwa">nil then</span> error <span class="sym">:= -</span><span class="num">1
</span>      <span class="kwa">else begin
</span>         node^.name <span class="sym">:=</span> name<span class="sym">;
</span>	 node^.number <span class="sym">:=</span> number<span class="sym">;
</span>	 node^.next <span class="sym">:=</span> <span class="kwa">nil</span><span class="sym">;
</span>      <span class="kwa">end</span><span class="sym">;
</span>   <span class="kwa">end</span><span class="sym">;

</span>   Result <span class="sym">:=</span> error <span class="sym">=</span> <span class="num">0</span><span class="sym">;
</span><span class="kwa">end</span><span class="sym">;

</span><span class="kwa">function</span> THash.fetch<span class="sym">(</span>name <span class="sym">:</span> <span class="kwa">string</span><span class="sym">;</span> <span class="kwa">var</span> number <span class="sym">:</span> <span class="kwb">longint</span><span class="sym">) :</span> <span class="kwb">boolean</span><span class="sym">;
</span><span class="kwa">var
</span>   node <span class="sym">:</span> THashEntryPtr<span class="sym">;
</span><span class="kwa">begin
</span>   node <span class="sym">:=</span> hashtable<span class="sym">[</span>hash<span class="sym">(</span>name<span class="sym">)]</span>.next<span class="sym">;
</span>   <span class="kwa">while</span> <span class="sym">(</span>node <span class="sym">&lt;&gt;</span> <span class="kwa">nil</span><span class="sym">)</span> <span class="kwa">and</span> <span class="sym">(</span>node^.name <span class="sym">&lt;&gt;</span> name<span class="sym">)</span> <span class="kwa">do
</span>      node <span class="sym">:=</span> node^.next<span class="sym">;
</span>   <span class="kwa">if</span> node <span class="sym">&lt;&gt;</span> <span class="kwa">nil then</span> number <span class="sym">:=</span> node^.number<span class="sym">;
</span>   Result <span class="sym">:=</span> node <span class="sym">&lt;&gt;</span> <span class="kwa">nil</span><span class="sym">;
</span><span class="kwa">end</span><span class="sym">;

</span><span class="kwa">function</span> THash.exists<span class="sym">(</span>name <span class="sym">:</span> <span class="kwa">string</span><span class="sym">) :</span> <span class="kwb">boolean</span><span class="sym">;
</span><span class="kwa">var
</span>   node <span class="sym">:</span> THashEntryPtr<span class="sym">;
</span><span class="kwa">begin
</span>   node <span class="sym">:=</span> hashtable<span class="sym">[</span>hash<span class="sym">(</span>name<span class="sym">)]</span>.next<span class="sym">;
</span>   <span class="kwa">while</span> <span class="sym">(</span>node <span class="sym">&lt;&gt;</span> <span class="kwa">nil</span><span class="sym">)</span> <span class="kwa">and</span> <span class="sym">(</span>node^.name <span class="sym">&lt;&gt;</span> name<span class="sym">)</span> <span class="kwa">do
</span>      node <span class="sym">:=</span> node^.next<span class="sym">;
</span>   Result <span class="sym">:=</span> node <span class="sym">&lt;&gt;</span> <span class="kwa">nil</span><span class="sym">;
</span><span class="kwa">end</span><span class="sym">;


</span><span class="kwa">var
</span>	n<span class="sym">,</span> i<span class="sym">,</span> c<span class="sym">,</span> err <span class="sym">:</span> <span class="kwb">longint</span><span class="sym">;
</span>	X <span class="sym">:</span> THash<span class="sym">;
</span><span class="kwa">begin
	if</span> ParamCount <span class="sym">=</span> <span class="num">0</span> <span class="kwa">then
</span>		n <span class="sym">:=</span> <span class="num">1
</span>	<span class="kwa">else
</span>		n <span class="sym">:=</span> StrToInt<span class="sym">(</span>ParamStr<span class="sym">(</span><span class="num">1</span><span class="sym">));

</span>	<span class="kwa">if</span> n <span class="sym">&lt;</span> <span class="num">1</span> <span class="kwa">then</span> n <span class="sym">:=</span> <span class="num">1</span><span class="sym">;

</span>	X <span class="sym">:=</span> THash.Create<span class="sym">();

</span>	<span class="kwa">For</span> i <span class="sym">:=</span> <span class="num">1</span> <span class="kwa">To</span> n <span class="kwa">do
</span>		X.store<span class="sym">(</span> Format<span class="sym">(</span><span class="str">'%x'</span><span class="sym">, [</span>i<span class="sym">]),</span> i<span class="sym">,</span> err <span class="sym">);

</span>	c <span class="sym">:=</span> <span class="num">0</span><span class="sym">;
</span>	<span class="kwa">For</span> i<span class="sym">:=</span> n <span class="kwa">downto</span> <span class="num">1</span> <span class="kwa">do
	begin
		if</span> X.exists<span class="sym">(</span> IntToStr<span class="sym">(</span>i<span class="sym">) )</span> <span class="kwa">Then</span> Inc<span class="sym">(</span>c<span class="sym">);
</span>	<span class="kwa">end</span><span class="sym">;

</span>	Writeln <span class="sym">(</span>IntToStr<span class="sym">(</span>c<span class="sym">));
</span><span class="kwa">end</span>.
