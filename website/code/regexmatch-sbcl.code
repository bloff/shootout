<table width="100%" border="0" cellpadding="5" cellspacing="0"><tr><td bgcolor="#FFFFFF"><pre>
<I><FONT COLOR="#B22222">;;; -*- mode: lisp -*-;
</FONT></I><I><FONT COLOR="#B22222">;;; $Id: regexmatch-sbcl.code,v 1.2 2004-11-08 08:15:19 bfulgham Exp $
</FONT></I><I><FONT COLOR="#B22222">;;; http://shootout.alioth.debian.org/
</FONT></I><I><FONT COLOR="#B22222">;;; from Jochen Schmidt
</FONT></I><I><FONT COLOR="#B22222">;;; Multi-lisp modifications by Brent Fulgham
</FONT></I><I><FONT COLOR="#B22222">;;; Enhanced by Juho Snellman
</FONT></I>
<I><FONT COLOR="#B22222">;;; Further modified (optimized &amp; cleaned up a little) by Markus Ziegler
</FONT></I>(proclaim '(optimize (speed 3) (safety 0) (space 0) (debug 0) (compilation-speed 0)))
#+cmucl (setf ext:*bytes-consed-between-gcs* 5000000)
(declaim (inline typep digit-charp non-digit-charp))

(eval-when (:compile-toplevel <B><FONT COLOR="#5F9EA0">:load-toplevel</FONT></B> <B><FONT COLOR="#5F9EA0">:execute</FONT></B>)
  (use-package <B><FONT COLOR="#5F9EA0">:meta</FONT></B>)
  (meta:enable-meta-syntax)

  (defun digit-charp (char)
    (declare (type base-char char))
    (char&lt;= #\0 char #\9))
  (defun non-digit-charp (char)
    (declare (type base-char char))
    (not (<B><FONT COLOR="#A020F0">or</FONT></B> (char= char #\() (char= char #\)) (digit-charp char))))

  (deftype digit () '(satisfies digit-charp))
  (deftype non-digit () '(satisfies non-digit-charp)))

(defvar area-code     (make-array 3 <B><FONT COLOR="#5F9EA0">:element-type</FONT></B> 'base-char))
(defvar exchange      (make-array 3 <B><FONT COLOR="#5F9EA0">:element-type</FONT></B> 'base-char))
(defvar last-4-digits (make-array 4 <B><FONT COLOR="#5F9EA0">:element-type</FONT></B> 'base-char))

(defun parse-tel (input)
  (declare (type simple-base-string area-code exchange last-4-digits))
  (meta:with-string-meta (buffer input)
    (labels ((skip-non-digits (&amp;aux (d #\0))
	       (meta:match $[@(non-digit d)]))
	     (digit-triplet (result &amp;aux (old-index index) (d #\0)) 
	       (declare (type simple-base-string result))
	       (<B><FONT COLOR="#A020F0">or</FONT></B> (meta:match [ @(digit d) !(setf (schar result 0) d)
				 @(digit d) !(setf (schar result 1) d)
				 @(digit d) !(setf (schar result 2) d) ])
		   (progn (setq index old-index) nil)))
	     (digit-4tuple (result &amp;aux (old-index index) (d #\0))
	       (declare (type simple-base-string result))
	       (<B><FONT COLOR="#A020F0">or</FONT></B> (meta:match [ @(digit d) !(setf (schar result 0) d)
				 @(digit d) !(setf (schar result 1) d)
				 @(digit d) !(setf (schar result 2) d)
				 @(digit d) !(setf (schar result 3) d) ])
		   (progn (setq index old-index) nil)))
	     (telephone-nr (&amp;aux (d #\0))
	       (meta:match [ !(skip-non-digits)
				  { [ #\( !(digit-triplet area-code) #\) ] !(digit-triplet area-code) }
				  #\space !(digit-triplet exchange) { #\space #\- }
				  !(digit-4tuple last-4-digits)
				  { @(non-digit d) !(= index end) } ])))
      (telephone-nr))))

(defun main ()
  (<B><FONT COLOR="#A020F0">let</FONT></B> ((n (parse-integer (<B><FONT COLOR="#A020F0">or</FONT></B> (car (last #+sbcl sb-ext:*posix-argv*
                                         #+cmu  extensions:*command-line-strings*)) <B><FONT COLOR="#BC8F8F">&quot;1&quot;</FONT></B>)))
        (input (loop for line = (read-line *standard-input* nil 'eof)
		  until (eq line 'eof) collect line)))
     (loop for i of-type fixnum from 1 below n <B><FONT COLOR="#A020F0">do</FONT></B>
	 (loop for line of-type simple-base-string in input
	    <B><FONT COLOR="#A020F0">do</FONT></B> (parse-tel line)))
    (loop with i of-type fixnum = 0
       for line of-type string in input
       <B><FONT COLOR="#A020F0">do</FONT></B> (when (parse-tel line)
	    (format t <B><FONT COLOR="#BC8F8F">&quot;~A: (~A) ~A-~A~%&quot;</FONT></B> (incf i) area-code exchange last-4-digits)))))</pre></td></tr></table>
