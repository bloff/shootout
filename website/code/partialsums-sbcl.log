BUILD COMMANDS FOR: partialsums.sbcl

Tue May 30 23:14:04 PDT 2006

SBCL built with: /usr/bin/sbcl --userinit /dev/null --sysinit /dev/null -batch -eval '(load "partialsums.sbcl_compile")'
### START partialsums.sbcl_compile
(proclaim '(optimize (speed 3) (safety 0) (debug 0) (compilation-speed 0) (space 0)))
(handler-bind ((sb-ext:defconstant-uneql      (lambda (c) (abort c))))      (load (compile-file "partialsums.sbcl" ))) (save-lisp-and-die "sbcl.core" :purify t)
### END partialsums.sbcl_compile

; compiling file "/opt/shootout/shootout/bench/partialsums/tmp/partialsums.sbcl" (written 30 MAY 2006 11:14:04 PM):
; compiling (DEFMACRO PSUM ...)
; compiling (DEFUN MAIN ...)
; file: /opt/shootout/shootout/bench/partialsums/tmp/partialsums.sbcl
; in: DEFUN MAIN
;     (SIN K)
; 
; note: unable to avoid inline argument range check
; because the argument range ((DOUBLE-FLOAT 1.0d0)) was not within 2^64

;     (COS K)
; 
; note: unable to avoid inline argument range check
; because the argument range ((DOUBLE-FLOAT 1.0d0)) was not within 2^64

; in: DEFMACRO PSUM
;     (> K N)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; because:
;   The RATIONAL value isn't known at compile time.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; because:
;   The RATIONAL value isn't known at compile time.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; because:
;   The RATIONAL value isn't known at compile time.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; because:
;   The RATIONAL value isn't known at compile time.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; because:
;   The RATIONAL value isn't known at compile time.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; because:
;   The RATIONAL value isn't known at compile time.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; because:
;   The RATIONAL value isn't known at compile time.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; because:
;   The RATIONAL value isn't known at compile time.

; in: DEFUN MAIN
;     (- A)
; ==>
;   (SB-KERNEL:%NEGATE A)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (/ A K)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (PSUM "Alternating Harmonic" (PROGN (SETF A (- A)) (/ A K)))
; --> FORMAT DO BLOCK LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SUM (PROGN (SETF A (- A)) (/ A K)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

; in: DEFMACRO PSUM
;     (> K N)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; because:
;   The RATIONAL value isn't known at compile time.

; in: DEFUN MAIN
;     (- A)
; ==>
;   (SB-KERNEL:%NEGATE A)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (/ A (1- (* 2.0d0 K)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (PSUM "Gregory" (PROGN (SETF A (- A)) (/ A (1- (* 2.0d0 K)))))
; --> FORMAT DO BLOCK LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SUM (PROGN (SETF A (- A)) (/ A (1- (* 2.0d0 K)))))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (- A)
; ==>
;   (SB-KERNEL:%NEGATE A)
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (/ A (1- (* 2.0d0 K)))
; 
; note: forced to do static-fun Two-arg-/ (cost 53)
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).

;     (PSUM "Gregory" (PROGN (SETF A (- A)) (/ A (1- (* 2.0d0 K)))))
; --> FORMAT DO BLOCK LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SUM (PROGN (SETF A (- A)) (/ A (1- (* 2.0d0 K)))))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (- A)
; ==>
;   (SB-KERNEL:%NEGATE A)
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (/ A K)
; 
; note: forced to do static-fun Two-arg-/ (cost 53)
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).

;     (PSUM "Alternating Harmonic" (PROGN (SETF A (- A)) (/ A K)))
; --> FORMAT DO BLOCK LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SUM (PROGN (SETF A (- A)) (/ A K)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; in: DEFMACRO PSUM
;     (> K N)
; 
; note: doing float to pointer coercion (cost 13) from K, for:
;       the first argument of GENERIC->

; in: DEFUN MAIN
;     (PSUM "(2/3)^k" (EXPT (/ 2.0d0 3.0d0) (- K 1.0d0)))
; --> FORMAT FORMAT FORMATTER FUNCTION BLOCK LET 
; ==>
;   (SB-FORMAT::FORMAT-FIXED STREAM
;                            #:FORMAT-ARG-49
;                            #:G682
;                            #:G683
;                            #:G684
;                            #:G685
;                            #:G686
;                            NIL)
; 
; note: doing float to pointer coercion (cost 13) from SUM

; in: DEFMACRO PSUM
;     (> K N)
; 
; note: doing float to pointer coercion (cost 13) from K, for:
;       the first argument of GENERIC->

; in: DEFUN MAIN
;     (PSUM "k^-0.5" (/ 1.0d0 (SQRT K)))
; --> FORMAT FORMAT FORMATTER FUNCTION BLOCK LET 
; ==>
;   (SB-FORMAT::FORMAT-FIXED STREAM
;                            #:FORMAT-ARG-70
;                            #:G682
;                            #:G683
;                            #:G684
;                            #:G685
;                            #:G686
;                            NIL)
; 
; note: doing float to pointer coercion (cost 13) from SUM

; in: DEFMACRO PSUM
;     (> K N)
; 
; note: doing float to pointer coercion (cost 13) from K, for:
;       the first argument of GENERIC->

; in: DEFUN MAIN
;     (PSUM "1/k(k+1)" (/ 1.0d0 (* K (+ 1.0d0 K))))
; --> FORMAT FORMAT FORMATTER FUNCTION BLOCK LET 
; ==>
;   (SB-FORMAT::FORMAT-FIXED STREAM
;                            #:FORMAT-ARG-91
;                            #:G682
;                            #:G683
;                            #:G684
;                            #:G685
;                            #:G686
;                            NIL)
; 
; note: doing float to pointer coercion (cost 13) from SUM

; in: DEFMACRO PSUM
;     (> K N)
; 
; note: doing float to pointer coercion (cost 13) from K, for:
;       the first argument of GENERIC->

; in: DEFUN MAIN
;     (PSUM "Flint Hills"
;         (LET ((S (SIN K)))
;           (/ 1.0d0 (* (* K K K) (* S S)))))
; --> FORMAT FORMAT FORMATTER FUNCTION BLOCK LET 
; ==>
;   (SB-FORMAT::FORMAT-FIXED STREAM
;                            #:FORMAT-ARG-112
;                            #:G682
;                            #:G683
;                            #:G684
;                            #:G685
;                            #:G686
;                            NIL)
; 
; note: doing float to pointer coercion (cost 13) from SUM

; in: DEFMACRO PSUM
;     (> K N)
; 
; note: doing float to pointer coercion (cost 13) from K, for:
;       the first argument of GENERIC->

; in: DEFUN MAIN
;     (PSUM "Cookson Hills"
;         (LET ((C (COS K)))
;           (/ 1.0d0 (* (* K K K) (* C C)))))
; --> FORMAT FORMAT FORMATTER FUNCTION BLOCK LET 
; ==>
;   (SB-FORMAT::FORMAT-FIXED STREAM
;                            #:FORMAT-ARG-133
;                            #:G682
;                            #:G683
;                            #:G684
;                            #:G685
;                            #:G686
;                            NIL)
; 
; note: doing float to pointer coercion (cost 13) from SUM

; in: DEFMACRO PSUM
;     (> K N)
; 
; note: doing float to pointer coercion (cost 13) from K, for:
;       the first argument of GENERIC->

; in: DEFUN MAIN
;     (PSUM "Harmonic" (/ 1.0d0 K))
; --> FORMAT FORMAT FORMATTER FUNCTION BLOCK LET 
; ==>
;   (SB-FORMAT::FORMAT-FIXED STREAM
;                            #:FORMAT-ARG-154
;                            #:G682
;                            #:G683
;                            #:G684
;                            #:G685
;                            #:G686
;                            NIL)
; 
; note: doing float to pointer coercion (cost 13) from SUM

; in: DEFMACRO PSUM
;     (> K N)
; 
; note: doing float to pointer coercion (cost 13) from K, for:
;       the first argument of GENERIC->

; in: DEFUN MAIN
;     (PSUM "Riemann Zeta" (/ 1.0d0 (* K K)))
; --> FORMAT FORMAT FORMATTER FUNCTION BLOCK LET 
; ==>
;   (SB-FORMAT::FORMAT-FIXED STREAM
;                            #:FORMAT-ARG-175
;                            #:G682
;                            #:G683
;                            #:G684
;                            #:G685
;                            #:G686
;                            NIL)
; 
; note: doing float to pointer coercion (cost 13) from SUM

;     (PSUM "Alternating Harmonic" (PROGN (SETF A (- A)) (/ A K)))
; --> FORMAT DO BLOCK LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET PROGN 
; ==>
;   (SETQ K #:G35)
; 
; note: doing float to pointer coercion (cost 13) to K

;     (/ A (1- (* 2.0d0 K)))
; 
; note: doing float to pointer coercion (cost 13), for:
;       the second argument of static-fun Two-arg-/

; in: DEFMACRO PSUM
;     (> K N)
; 
; note: doing float to pointer coercion (cost 13) from K, for:
;       the first argument of GENERIC->
; 
; compilation unit finished
;   printed 66 notes


; /opt/shootout/shootout/bench/partialsums/tmp/partialsums.fasl written
; compilation finished in 0:00:01
[doing purification: roots handlers stack bindings static cleanup done]
[undoing binding stack and other enclosing state... done]
[saving current Lisp image into /opt/shootout/shootout/bench/partialsums/tmp/sbcl.core:
writing 19667096 bytes from the read-only space at 0x01000000
writing 4576104 bytes from the static space at 0x05000000
writing 4096 bytes from the dynamic space at 0x09000000
done]
### START partialsums.sbcl_run
(proclaim '(optimize (speed 3) (safety 0) (debug 0) (compilation-speed 0) (space 0)))
(main) (quit)
### END partialsums.sbcl_run


=================================================================
COMMAND LINE (%A is single numeric argument):

 /usr/bin/sbcl --noinform --core sbcl.core --userinit /dev/null --sysinit /dev/null --load partialsums.sbcl_run %A


PROGRAM OUTPUT
==============
3.000000000	(2/3)^k
3160.817621887	k^-0.5
0.999999600	1/k(k+1)
30.314541510	Flint Hills
42.995233998	Cookson Hills
15.309017155	Harmonic
1.644933667	Riemann Zeta
0.693146981	Alternating Harmonic
0.785398063	Gregory
