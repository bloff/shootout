<span class="slc">-- The Computer Language Shootout</span>
<span class="slc">-- http://shootout.alioth.debian.org/</span>
<span class="slc">-- contributed by Branimir Maksimovic</span>

<span class="com">{- original Haskell implementation from spigot.pdf document</span>
<span class="com"> - I've just added printPi and main, also replaced floor and / with div</span>
<span class="com"> - because for some reason div is much faster</span>
<span class="com"> -}</span>

<span class="kwa">module</span> Main <span class="kwa">where</span>
<span class="kwa">import</span> System
main <span class="sym">=</span> <span class="kwa">do</span> <span class="sym">[</span>n<span class="sym">] &lt;-</span> getArgs
          printPi $ take <span class="sym">(</span>read n<span class="sym">)</span> Main.pi

printPi digits <span class="sym">=</span> printPi<span class="str">' digits 10 0</span>
<span class="str">  where printPi'</span> <span class="sym">[]</span> ndigs sum<span class="str">' = do mapM_ (\_ -&gt; putChar '</span> <span class="str">') [1..ndigs]</span>
<span class="str">                                    putStr $ &quot;\t:&quot; ++ show sum'</span> <span class="sym">++</span> <span class="str">&quot;\n&quot;</span>
        printPi<span class="str">' xxs 0 sum'</span> <span class="sym">=</span> <span class="kwa">do</span> putStr $ <span class="str">&quot;\t:&quot;</span> <span class="sym">++</span> show sum<span class="str">' ++ &quot;\n&quot;</span>
<span class="str">                                 printPi'</span> xxs <span class="num">10</span> sum<span class="str">'</span>
<span class="str">        printPi'</span> <span class="sym">(</span>x<span class="sym">:</span>xs<span class="sym">)</span> ndigs sum<span class="str">' = do putStr $ show x</span>
<span class="str">                                        printPi'</span> xs <span class="sym">(</span>ndigs<span class="sym">-</span><span class="num">1</span><span class="sym">) (</span>sum<span class="str">'+1)</span>
<span class="str"></span>
<span class="str">stream :: (b-&gt;c) -&gt; (b-&gt;c-&gt;Bool) -&gt; (b-&gt;c-&gt;b) -&gt; (b-&gt;a-&gt;b) -&gt; b -&gt; [a] -&gt; [c]</span>
<span class="str">stream next safe prod cons z (x:xs)</span>
<span class="str">  = if safe z y</span>
<span class="str">       then y : stream next safe prod cons (prod z y) (x:xs)</span>
<span class="str">       else stream next safe prod cons (cons z x) xs</span>
<span class="str">  where y = next z</span>
<span class="str"></span>
<span class="str">type LFT = (Integer, Integer, Integer, Integer)</span>
<span class="str">floorExtr :: LFT -&gt; Integer -&gt; Integer</span>
<span class="str">floorExtr (q,r,s,t) x = ((fromInteger q) * fromInteger x + (fromInteger r)) `div`</span>
<span class="str">                        ((fromInteger s) * fromInteger x + (fromInteger t))</span>
<span class="str">unit :: LFT</span>
<span class="str">unit = (1,0,0,1)</span>
<span class="str">comp :: LFT -&gt; LFT -&gt; LFT</span>
<span class="str">comp (q,r,s,t) (u,v,w,x) = (q*u+r*w,q*v+r*x,s*u+t*w,s*v+t*x)</span>
<span class="str"></span>
<span class="str">pi = stream next safe prod cons init lfts</span>
<span class="str">  where</span>
<span class="str">        init = unit</span>
<span class="str">        lfts = [(k, 4*k+2, 0, 2*k+1) | k&lt;-[1..]]</span>
<span class="str">        next z = floorExtr z 3</span>
<span class="str">        safe z n = (n == floorExtr z 4)</span>
<span class="str">        prod z n = comp (10, -10*n, 0, 1) z</span>
<span class="str">        cons z z'</span>  <span class="sym">=</span> comp z z<span class="str">'</span>
<span class="str"></span>
