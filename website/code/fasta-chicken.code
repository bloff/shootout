<span class="slc">; The Great Computer Language Shootout
</span><span class="slc">; http://shootout.alioth.debian.org/
</span><span class="slc">;
</span><span class="slc">; fasta - benchmark
</span><span class="slc">;
</span><span class="slc">; Contributed by Brent Fulgham (based on Felix Winkelmann's
</span><span class="slc">;      Random implementation)
</span><span class="sym">(</span>declare <span class="sym">(</span>disable<span class="sym">-</span>interrupts<span class="sym">) (</span>uses format<span class="sym">) (</span>uses srfi<span class="num">-1</span><span class="sym">))

</span><span class="slc">; The usual pseudo-random number generator
</span><span class="sym">(</span>define IM <span class="num">139968</span><span class="sym">)
(</span>define IA <span class="num">3877</span><span class="sym">)
(</span>define IC <span class="num">29573</span><span class="sym">)
(</span>define LAST <span class="num">42</span><span class="sym">)

(</span>define <span class="sym">(</span>gen<span class="sym">-</span>random maximum<span class="sym">)
	(</span><span class="kwa">set</span><span class="sym">!</span> LAST <span class="sym">(</span>modulo <span class="sym">(+ (*</span> LAST IA<span class="sym">)</span> IC<span class="sym">)</span> IM<span class="sym">))
	(/ (*</span> maximum LAST<span class="sym">)</span> IM<span class="sym">))

</span><span class="slc">;;; Weighted selection from alphabet
</span><span class="sym">(</span>define <span class="sym">(</span>mkCumulativeInt orig total new<span class="sym">)
    (</span><span class="kwa">if</span> <span class="sym">(</span><span class="kwa">null</span>? orig<span class="sym">) (</span><span class="kwa">reverse</span> new<span class="sym">)
        (</span>let <span class="sym">((</span>val <span class="sym">(+</span> total <span class="sym">(</span>cadar orig<span class="sym">))))
	  (</span>mkCumulativeInt <span class="sym">(</span><span class="kwa">cdr</span> orig<span class="sym">)</span> val
	        <span class="sym">(</span><span class="kwa">cons</span> <span class="sym">(</span><span class="kwa">list</span> <span class="sym">(</span><span class="kwa">caar</span> orig<span class="sym">)</span> val<span class="sym">)</span> new<span class="sym">)))))

(</span>define <span class="sym">(</span>mkCumulative aslst<span class="sym">)
    (</span>mkCumulativeInt aslst <span class="num">0.0</span> <span class="str">'()))

(define (selectRandomInternal lst r)
    ;(format #t &quot;lst: ~A r=~A~%&quot; lst r)
    (if (null? lst) &quot;error&quot;
        (let ((curr (car lst)))
	    (if (&lt; r (cadr curr))
                (car curr)
                (selectRandomInternal (cdr lst) r)))))

(define (selectRandom alphabet)
    (selectRandomInternal alphabet (gen-random 1)))

;;; Generate and write FASTA format
(define (writeFasta todo alphabet len)
   (let ((end (if (&lt; todo len) todo len)))
     (when (&gt; todo 0)
         (do ((x 0 (+ x 1))) ((= x end))
	   (format #t &quot;~A&quot; (selectRandom alphabet)))
         (newline)
         (writeFasta (- todo len) alphabet len))))

(define (mkFastaFragment id description alphabet num)
    (let ((todo num)
          (len 60))
        (format #t &quot;&gt;~A ~A~%&quot; id description)
	(writeFasta todo alphabet len)))

;;; Define alphabets
(define dna1
    '</span><span class="sym">((</span><span class="str">&quot;a&quot;</span> <span class="num">0.3029549426680</span><span class="sym">)
      (</span><span class="str">&quot;c&quot;</span> <span class="num">0.1979883004921</span><span class="sym">)
      (</span><span class="str">&quot;g&quot;</span> <span class="num">0.1975473066391</span><span class="sym">)
      (</span><span class="str">&quot;t&quot;</span> <span class="num">0.3015094502008</span><span class="sym">)))

(</span>define dna2
    <span class="str">'((&quot;a&quot; 0.250)
      (&quot;c&quot; 0.125)
      (&quot;g&quot; 0.125)
      (&quot;t&quot; 0.250)

      (&quot;U&quot; 0.019230769231)
      (&quot;R&quot; 0.019230769231)
      (&quot;Y&quot; 0.019230769231)
      (&quot;K&quot; 0.019230769231)
      (&quot;M&quot; 0.019230769231)
      (&quot;S&quot; 0.019230769231)
      (&quot;W&quot; 0.019230769231)
      (&quot;B&quot; 0.019230769231)
      (&quot;D&quot; 0.019230769231)
      (&quot;H&quot; 0.019230769231)
      (&quot;V&quot; 0.019230769231)
      (&quot;N&quot; 0.019230769231)
      (&quot;-&quot; 0.019230769231)))

(define (main args)
    (let ((n (or (and (= (length args) 2) (string-&gt;number (cadr args))) 1))
          (ldna1 (mkCumulative dna1))
	  (ldna2 (mkCumulative dna2)))
      (mkFastaFragment &quot;TestOne&quot; &quot;test fragment&quot; ldna2 (* n 1))
      (mkFastaFragment &quot;TestTwo&quot; &quot;test fragment&quot; ldna1 (* n 2))
      (mkFastaFragment &quot;TestThree&quot; &quot;test fragment&quot; ldna2 (* n 3))
      (mkFastaFragment &quot;TestFour&quot; &quot;test fragment&quot; ldna1 (* n 4))
      (mkFastaFragment &quot;TestFive&quot; &quot;test fragment&quot; ldna2 (* n 5))))

(main (argv))
</span>
