<source>
<def></def><com>/* The Computer Language Benchmarks Game</com><br />
<com> * http://shootout.alioth.debian.org/</com><br />
<com> *</com><br />
<com> * contributed by Calum Grant</com><br />
<com> */</com><def></def><br />
<br />
<dir>#include &lt;iostream&gt;</dir><br />
<def></def><dir>#include &lt;memory&gt;</dir><br />
<def></def><br />
<kwc>template</kwc><def></def><sym>&lt;</sym><def>typename Item</def><sym>,</sym> <def>typename Left</def><sym>,</sym> <def>typename Right</def><sym>&gt;</sym> <def></def><kwb>struct</kwb> <def>node</def><br />
<sym>{</sym><br />
<def></def>   <kwc>template</kwc><def></def><sym>&lt;</sym><def>typename I</def><sym>,</sym> <def>typename L</def><sym>,</sym> <def>typename R</def><sym>&gt;</sym><br />
<def></def>      <kwd>node</kwd><def></def><sym>(</sym><def>I i</def><sym>,</sym> <def>L l</def><sym>,</sym> <def>R r</def><sym>) :</sym> <def></def><kwd>item</kwd><def></def><sym>(</sym><def>i</def><sym>),</sym> <def></def><kwd>left</kwd><def></def><sym>(</sym><def>l</def><sym>),</sym> <def></def><kwd>right</kwd><def></def><sym>(</sym><def>r</def><sym>) { }</sym><br />
<def></def>   <kwb>const</kwb> <def>Item item</def><sym>;</sym><br />
<def></def>   <kwb>const</kwb> <def>Left left</def><sym>;</sym><br />
<def></def>   <kwb>const</kwb> <def>Right right</def><sym>;</sym><br />
<def></def><sym>};</sym><br />
<def></def><br />
<kwc>template</kwc><def></def><sym>&lt;</sym><def>typename Item</def><sym>&gt;</sym> <def></def><kwb>struct</kwb> <def>leaf_node</def><br />
<sym>{</sym><br />
<def></def>   <kwc>template</kwc><def></def><sym>&lt;</sym><def>typename I</def><sym>&gt;</sym> <def></def><kwd>leaf_node</kwd><def></def><sym>(</sym><def>I i</def><sym>) :</sym> <def></def><kwd>item</kwd><def></def><sym>(</sym><def>i</def><sym>) { }</sym><br />
<def></def>   <kwb>const</kwb> <def>Item item</def><sym>;</sym><br />
<def></def><sym>};</sym><br />
<def></def><br />
<kwc>template</kwc><def></def><sym>&lt;</sym><def>typename Item</def><sym>&gt;</sym> <def></def><kwb>int</kwb> <def></def><kwd>check</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>leaf_node</def><sym>&lt;</sym><def>Item</def><sym>&gt; &amp;</sym> <def>node</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <kwa>return</kwa> <def>node</def><sym>.</sym><def>item</def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwc>template</kwc><def></def><sym>&lt;</sym><def>typename Item</def><sym>,</sym> <def>typename Left</def><sym>,</sym> <def>typename Right</def><sym>&gt;</sym><br />
<def></def>   <kwb>int</kwb> <def></def><kwd>check</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>node</def><sym>&lt;</sym><def>Item</def><sym>,</sym><def>Left</def><sym>,</sym><def>Right</def><sym>&gt; &amp;</sym> <def>node</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <kwa>return</kwa> <def>node</def><sym>.</sym><def>item</def> <sym>+</sym> <def></def><kwd>check</kwd><def></def><sym>(</sym><def>node</def><sym>.</sym><def>left</def><sym>) -</sym> <def></def><kwd>check</kwd><def></def><sym>(</sym><def>node</def><sym>.</sym><def>right</def><sym>);</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwc>template</kwc><def></def><sym>&lt;</sym><def></def><kwb>int</kwb> <def>Depth</def><sym>&gt;</sym> <def></def><kwb>struct</kwb> <def>make</def> <sym>:</sym> <def></def><kwc>public</kwc> <def>node</def><sym>&lt;</sym><def></def><kwb>int</kwb><def></def><sym>,</sym> <def>make</def><sym>&lt;</sym><def>Depth</def><sym>-</sym><def></def><num>1</num><def></def><sym>&gt;,</sym> <def>make</def><sym>&lt;</sym><def>Depth</def><sym>-</sym><def></def><num>1</num><def></def><sym>&gt; &gt;</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <kwd>make</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i</def><sym>) :</sym> <def>node</def><sym>&lt;</sym> <def></def><kwb>int</kwb><def></def><sym>,</sym> <def>make</def><sym>&lt;</sym><def>Depth</def><sym>-</sym><def></def><num>1</num><def></def><sym>&gt;,</sym> <def>make</def><sym>&lt;</sym><def>Depth</def><sym>-</sym><def></def><num>1</num><def></def><sym>&gt; &gt;(</sym><def>i</def><sym>,</sym> <def></def><num>2</num><def></def><sym>*</sym><def>i</def><sym>-</sym><def></def><num>1</num><def></def><sym>,</sym> <def></def><num>2</num><def></def><sym>*</sym><def>i</def><sym>) { }</sym><br />
<def></def><sym>};</sym><br />
<def></def><br />
<kwc>template</kwc><def></def><sym>&lt;&gt;</sym> <def></def><kwb>struct</kwb> <def>make</def><sym>&lt;</sym><def></def><num>0</num><def></def><sym>&gt; :</sym> <def></def><kwc>public</kwc> <def>leaf_node</def><sym>&lt;</sym><def></def><kwb>int</kwb><def></def><sym>&gt;</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <kwd>make</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i</def><sym>) :</sym> <def>leaf_node</def><sym>&lt;</sym><def></def><kwb>int</kwb><def></def><sym>&gt;(</sym><def>i</def><sym>) { }</sym><br />
<def></def><sym>};</sym><br />
<def></def><br />
<kwc>template</kwc><def></def><sym>&lt;</sym><def></def><kwb>int</kwb> <def>Depth</def><sym>&gt;</sym> <def>std</def><sym>::</sym><def>auto_ptr</def><sym>&lt;</sym><def>make</def><sym>&lt;</sym><def>Depth</def><sym>&gt; &gt;</sym> <def></def><kwd>make_tree</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <kwa>return</kwa> <def>std</def><sym>::</sym><def>auto_ptr</def><sym>&lt;</sym> <def>make</def><sym>&lt;</sym><def>Depth</def><sym>&gt; &gt;(</sym><def></def><kwa>new</kwa> <def>make</def><sym>&lt;</sym><def>Depth</def><sym>&gt;(</sym><def>i</def><sym>));</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwc>template</kwc><def></def><sym>&lt;</sym><def></def><kwb>int</kwb> <def>MinDepth</def><sym>,</sym> <def></def><kwb>int</kwb> <def>MaxDepth</def><sym>=</sym><def></def><num>24</num><def></def><sym>&gt;</sym> <def></def><kwb>struct</kwb> <def>test</def><br />
<sym>{</sym><br />
<def></def>   <kwc>template</kwc><def></def><sym>&lt;</sym><def></def><kwb>int</kwb> <def>D</def><sym>=</sym><def>MinDepth</def><sym>,</sym> <def></def><kwb>bool</kwb><def></def><sym>=</sym><def>D</def><sym>&lt;=</sym><def>MaxDepth</def><sym>&gt;</sym> <def></def><kwb>struct</kwb> <def>loop</def><br />
   <sym>{</sym><br />
<def></def>      <kwd>loop</kwd><def></def><sym>()</sym><br />
<def></def>      <sym>{</sym><br />
<def></def>         <kwb>const int</kwb> <def>iterations</def> <sym>=</sym> <def></def><num>1</num> <def></def><sym>&lt;&lt; (</sym><def>MaxDepth</def> <sym>-</sym> <def>D</def> <sym>+</sym> <def>MinDepth</def><sym>);</sym><br />
<def></def>         <kwb>int</kwb> <def>c</def><sym>=</sym><def></def><num>0</num><def></def><sym>;</sym><br />
<def></def><br />
         <kwa>for</kwa><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i</def><sym>=</sym><def></def><num>1</num><def></def><sym>;</sym> <def>i</def><sym>&lt;=</sym><def>iterations</def><sym>; ++</sym><def>i</def><sym>)</sym><br />
<def></def>         <sym>{</sym><br />
<def>            c</def> <sym>+=</sym> <def></def><kwd>check</kwd><def></def><sym>(*</sym><def>make_tree</def><sym>&lt;</sym><def>D</def><sym>&gt;(</sym><def>i</def><sym>)) +</sym> <def></def><kwd>check</kwd><def></def><sym>(*</sym><def>make_tree</def><sym>&lt;</sym><def>D</def><sym>&gt;(-</sym><def>i</def><sym>));</sym><br />
<def></def>         <sym>}</sym><br />
<def><br />
         std</def><sym>::</sym><def>cout</def> <sym>&lt;&lt; (</sym><def></def><num>2</num><def></def><sym>*</sym><def>iterations</def><sym>) &lt;&lt;</sym> <def></def><str>&quot;</str><esc>\t</esc> <str>trees of depth &quot;</str><def></def> <sym>&lt;&lt;</sym> <def>D</def> <sym>&lt;&lt;</sym> <def></def><str>&quot;</str><esc>\t</esc> <str>&quot;</str><def></def><br />
            <sym>&lt;&lt;</sym> <def></def><str>&quot;check: &quot;</str><def></def> <sym>&lt;&lt;</sym> <def>c</def> <sym>&lt;&lt;</sym> <def>std</def><sym>::</sym><def>endl</def><sym>;</sym><br />
<def><br />
         loop</def><sym>&lt;</sym><def>D</def><sym>+</sym><def></def><num>2</num><def></def><sym>&gt;();</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>};</sym><br />
<def></def><br />
   <kwc>template</kwc><def></def><sym>&lt;</sym><def></def><kwb>int</kwb> <def>D</def><sym>&gt;</sym> <def></def><kwb>struct</kwb> <def>loop</def><sym>&lt;</sym><def>D</def><sym>,</sym> <def></def><kwa>false</kwa><def></def><sym>&gt; { };</sym><br />
<def></def><br />
   <kwb>static void</kwb> <def></def><kwd>run</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>max_depth</def><sym>)</sym><br />
<def></def>   <sym>{</sym><br />
<def></def>      <kwa>if</kwa><def></def><sym>(</sym><def>max_depth</def> <sym>&lt;</sym> <def>MaxDepth</def><sym>)</sym><br />
<def></def>      <sym>{</sym><br />
<def>         test</def><sym>&lt;</sym><def>MinDepth</def><sym>,</sym> <def>MaxDepth</def><sym>-</sym><def></def><num>1</num><def></def><sym>&gt;::</sym><def></def><kwd>run</kwd><def></def><sym>(</sym><def>max_depth</def><sym>);</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>      <kwa>else</kwa><br />
<def></def>      <sym>{</sym><br />
<def></def>         <kwb>const int</kwb> <def>stretch_depth</def> <sym>=</sym> <def>MaxDepth</def><sym>+</sym><def></def><num>1</num><def></def><sym>;</sym><br />
<def>          std</def><sym>::</sym><def>cout</def> <sym>&lt;&lt;</sym> <def></def><str>&quot;stretch tree of depth &quot;</str><def></def> <sym>&lt;&lt;</sym> <def>stretch_depth</def> <sym>&lt;&lt;</sym> <def></def><str>&quot;</str><esc>\t</esc> <str>&quot;</str><def></def><br />
            <sym>&lt;&lt;</sym> <def></def><str>&quot;check: &quot;</str><def></def> <sym>&lt;&lt;</sym> <def></def><kwd>check</kwd><def></def><sym>(*</sym><def>make_tree</def><sym>&lt;</sym><def>stretch_depth</def><sym>&gt;(</sym><def></def><num>0</num><def></def><sym>)) &lt;&lt;</sym> <def>std</def><sym>::</sym><def>endl</def><sym>;</sym><br />
<def><br />
         std</def><sym>::</sym><def>auto_ptr</def><sym>&lt;</sym> <def>make</def><sym>&lt;</sym><def>MaxDepth</def><sym>&gt; &gt;</sym> <def>long_lived_tree</def> <sym>=</sym> <def>make_tree</def><sym>&lt;</sym><def>MaxDepth</def><sym>&gt;(</sym><def></def><num>0</num><def></def><sym>);</sym><br />
<def><br />
         loop</def><sym>&lt;&gt;();</sym><br />
<def><br />
         std</def><sym>::</sym><def>cout</def> <sym>&lt;&lt;</sym> <def></def><str>&quot;long lived tree of depth &quot;</str><def></def> <sym>&lt;&lt;</sym> <def>MaxDepth</def> <sym>&lt;&lt;</sym> <def></def><str>&quot;</str><esc>\t</esc> <str>&quot;</str><def></def><br />
            <sym>&lt;&lt;</sym> <def></def><str>&quot;check: &quot;</str><def></def> <sym>&lt;&lt;</sym> <def></def><kwd>check</kwd><def></def><sym>(*</sym><def>long_lived_tree</def><sym>) &lt;&lt;</sym> <def></def><str>&quot;</str><esc>\n</esc><str>&quot;</str><def></def><sym>;</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><sym>};</sym><br />
<def></def><br />
<kwc>template</kwc><def></def><sym>&lt;</sym><def></def><kwb>int</kwb> <def>MinDepth</def><sym>&gt;</sym> <def></def><kwb>struct</kwb> <def>test</def><sym>&lt;</sym><def>MinDepth</def><sym>,</sym> <def></def><num>0</num><def></def><sym>&gt;</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <kwb>static void</kwb> <def></def><kwd>run</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb><def></def><sym>) { }</sym><br />
<def></def><sym>};</sym><br />
<def></def><br />
<kwb>int</kwb> <def></def><kwd>main</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>argc</def><sym>,</sym> <def></def><kwb>char</kwb> <def></def><sym>*</sym><def>argv</def><sym>[])</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <kwb>const int</kwb> <def>min_depth</def><sym>=</sym><def></def><num>4</num><def></def><sym>;</sym><br />
<def></def>    <kwb>int</kwb> <def>max_depth</def> <sym>=</sym> <def>std</def><sym>::</sym><def></def><kwd>max</kwd><def></def><sym>(</sym><def>min_depth</def><sym>+</sym><def></def><num>2</num><def></def><sym>, (</sym><def>argc</def> <sym>==</sym> <def></def><num>2</num> <def>?</def> <kwd>atoi</kwd><def></def><sym>(</sym><def>argv</def><sym>[</sym><def></def><num>1</num><def></def><sym>]) :</sym> <def></def><num>10</num><def></def><sym>));</sym><br />
<def>   test</def><sym>&lt;</sym><def>min_depth</def><sym>&gt;::</sym><def></def><kwd>run</kwd><def></def><sym>(</sym><def>max_depth</def><sym>);</sym><br />
<def></def>   <kwa>return</kwa> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def><sym>}</sym><def></def><br />
</source>
