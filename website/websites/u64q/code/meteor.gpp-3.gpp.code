<source>
<def></def><slc>// The Computer Language Shootout</slc><br />
<def></def><slc>// http://shootout.alioth.debian.org/</slc><br />
<def></def><slc>// contributed by Ben St. John (jbstjohn@gmx.net)</slc><br />
<def></def><slc>// some ideas taken from Kevin Barnes' implementation</slc><br />
<def></def><dir>#include &lt;iostream&gt;</dir><br />
<def></def><dir>#include &lt;vector&gt;</dir><br />
<def></def><dir>#include &lt;string&gt;</dir><br />
<def></def><br />
<kwa>using namespace</kwa> <def>std</def><sym>;</sym><br />
<def></def><br />
<dir>#define getMask(iPos) (1 &lt;&lt; iPos)</dir><br />
<def></def><br />
<kwb>enum</kwb> <def></def><sym>{</sym><def>X</def><sym>,</sym> <def>Y</def><sym>,</sym> <def>N_DIM</def><sym>};</sym><br />
<def></def><kwb>enum</kwb> <def></def><sym>{</sym><def>EVEN</def><sym>,</sym> <def>ODD</def><sym>,</sym> <def>N_PARITY</def><sym>};</sym><br />
<def></def><br />
<kwc>typedef</kwc> <def></def><kwb>unsigned int</kwb> <def>TUInt32</def><sym>;</sym><br />
<def></def><kwc>typedef</kwc> <def></def><kwb>unsigned long long</kwb> <def>TUInt64</def><sym>;</sym><br />
<def></def><kwc>typedef</kwc> <def></def><kwb>signed char</kwb> <def>TInt8</def><sym>;</sym><br />
<def></def><kwc>typedef</kwc> <def>TUInt32 BitVec</def><sym>;</sym><br />
<def></def><br />
<kwb>static const int</kwb> <def>N_COL</def> <sym>=</sym> <def></def><num>5</num><def></def><sym>;</sym><br />
<def></def><kwb>static const int</kwb> <def>N_ROW</def> <sym>=</sym> <def></def><num>10</num><def></def><sym>;</sym><br />
<def></def><kwb>static const int</kwb> <def>N_CELL</def> <sym>=</sym> <def>N_COL</def> <sym>*</sym> <def>N_ROW</def><sym>;</sym><br />
<def></def><kwb>static const int</kwb> <def>N_PIECE_TYPE</def> <sym>=</sym> <def></def><num>10</num><def></def><sym>;</sym><br />
<def></def><br />
<kwc>class</kwc> <def>Piece</def><sym>;</sym><br />
<def></def><kwb>struct</kwb> <def>Solution</def><br />
<sym>{</sym><br />
<def></def>   <kwb>static const int</kwb> <def>NO_PIECE</def> <sym>= -</sym><def></def><num>1</num><def></def><sym>;</sym><br />
<def></def><br />
   <kwb>void</kwb> <def></def><kwd>setCells</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>);</sym><br />
<def></def>   <kwb>bool</kwb> <def></def><kwd>lessThan</kwd><def></def><sym>(</sym><def>Solution</def> <sym>&amp;</sym> <def>r</def><sym>);</sym><br />
<def>   string</def> <kwd>toString</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>)</sym> <def></def><kwb>const</kwb><def></def><sym>;</sym><br />
<def></def>   <kwb>void</kwb> <def></def><kwd>fill</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>val</def><sym>);</sym><br />
<def></def>   <kwb>void</kwb> <def></def><kwd>spin</kwd><def></def><sym>(</sym><def>Solution</def> <sym>&amp;</sym> <def>spun</def><sym>);</sym><br />
<def></def><br />
   <kwb>bool</kwb> <def></def><kwd>isEmpty</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>) {</sym><def></def><kwa>return</kwa> <def></def><sym>(</sym><def>m_nPiece</def> <sym>==</sym> <def></def><num>0</num><def></def><sym>);}</sym><br />
<def></def>   <kwb>void</kwb> <def></def><kwd>removeLastPiece</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>) {</sym><def>m_nPiece</def><sym>--;</sym> <def>m_synched</def> <sym>=</sym> <def></def><kwa>false</kwa><def></def><sym>;}</sym><br />
<def></def>   <kwb>void</kwb> <def></def><kwd>addPiece</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>BitVec</def> <sym>&amp;</sym> <def>vec</def><sym>,</sym> <def></def><kwb>int</kwb> <def>iPiece</def><sym>,</sym> <def></def><kwb>int</kwb> <def>row</def><sym>) {</sym><br />
<def>      SPiece</def> <sym>&amp;</sym> <def>p</def> <sym>=</sym> <def>m_pieces</def><sym>[</sym><def>m_nPiece</def><sym>++];</sym><br />
<def>      p</def><sym>.</sym><def>vec</def> <sym>=</sym> <def>vec</def><sym>;</sym><br />
<def>      p</def><sym>.</sym><def>iPiece</def> <sym>= (</sym><def></def><kwb>short</kwb><def></def><sym>)</sym><def>iPiece</def><sym>;</sym><br />
<def>      p</def><sym>.</sym><def>row</def> <sym>= (</sym><def></def><kwb>short</kwb><def></def><sym>)</sym><def>row</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwd>Solution</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>fillVal</def><sym>);</sym><br />
<def></def>   <kwd>Solution</kwd><def></def><sym>() :</sym> <def></def><kwd>m_synched</kwd><def></def><sym>(</sym><def></def><kwa>false</kwa><def></def><sym>),</sym> <def></def><kwd>m_nPiece</kwd><def></def><sym>(</sym><def></def><num>0</num><def></def><sym>) {}</sym><br />
<def></def><br />
   <kwb>struct</kwb> <def>SPiece</def> <sym>{</sym><br />
<def>      BitVec vec</def><sym>;</sym><br />
<def></def>      <kwb>short</kwb> <def>iPiece</def><sym>;</sym><br />
<def></def>      <kwb>short</kwb> <def>row</def><sym>;</sym><br />
<def></def>      <kwd>SPiece</kwd><def></def><sym>() {}</sym><br />
<def></def>      <kwd>SPiece</kwd><def></def><sym>(</sym><def>BitVec avec</def><sym>,</sym> <def>TUInt32 apiece</def><sym>,</sym> <def>TUInt32 arow</def><sym>) :</sym><br />
<def></def>      <kwd>vec</kwd><def></def><sym>(</sym><def>avec</def><sym>),</sym> <def></def><kwd>iPiece</kwd><def></def><sym>(</sym><def></def><kwb>short</kwb><def></def><sym>(</sym><def>apiece</def><sym>)),</sym> <def></def><kwd>row</kwd><def></def><sym>(</sym><def></def><kwb>short</kwb><def></def><sym>(</sym><def>arow</def><sym>))</sym><br />
<def></def>      <sym>{}</sym><br />
<def></def>   <sym>};</sym><br />
<def>   SPiece m_pieces</def><sym>[</sym><def>N_PIECE_TYPE</def><sym>];</sym><br />
<def>   TUInt32 m_nPiece</def><sym>;</sym><br />
<def>   TInt8 m_cells</def><sym>[</sym><def>N_ROW</def><sym>][</sym><def>N_COL</def><sym>];</sym><br />
<def></def>   <kwb>bool</kwb> <def>m_synched</def><sym>;</sym><br />
<def></def><sym>};</sym><br />
<def></def><br />
<slc>//------------------------------------</slc><br />
<def></def><kwb>struct</kwb> <def>Board</def><br />
<sym>{</sym><br />
<def></def>   <kwb>static const</kwb> <def>BitVec L_EDGE_MASK</def> <sym>=</sym><br />
<def></def>      <sym>(</sym><def></def><num>1L</num><def>L</def> <sym>&lt;&lt;</sym>  <def></def><num>0</num><def></def><sym>) | (</sym><def></def><num>1L</num><def>L</def> <sym>&lt;&lt;</sym>  <def></def><num>5</num><def></def><sym>) | (</sym><def></def><num>1L</num><def>L</def> <sym>&lt;&lt;</sym> <def></def><num>10</num><def></def><sym>) | (</sym><def></def><num>1L</num><def>L</def> <sym>&lt;&lt;</sym> <def></def><num>15</num><def></def><sym>) |</sym><br />
<def></def>      <sym>(</sym><def></def><num>1L</num><def>L</def> <sym>&lt;&lt;</sym> <def></def><num>20</num><def></def><sym>) | (</sym><def></def><num>1L</num><def>L</def> <sym>&lt;&lt;</sym> <def></def><num>25</num><def></def><sym>) | (</sym><def></def><num>1L</num><def>L</def> <sym>&lt;&lt;</sym> <def></def><num>30</num><def></def><sym>);</sym><br />
<def></def>   <kwb>static const</kwb> <def>BitVec R_EDGE_MASK</def> <sym>=</sym> <def>L_EDGE_MASK</def> <sym>&lt;&lt;</sym> <def></def><num>4</num><def></def><sym>;</sym><br />
<def></def>   <kwb>static const</kwb> <def>BitVec TOP_ROW</def> <sym>= (</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def>N_COL</def><sym>) -</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>   <kwb>static const</kwb> <def>BitVec ROW_0_MASK</def> <sym>=</sym><br />
<def>      TOP_ROW</def>        <sym>| (</sym><def>TOP_ROW</def> <sym>&lt;&lt;</sym> <def></def><num>10</num><def></def><sym>) | (</sym><def>TOP_ROW</def> <sym>&lt;&lt;</sym> <def></def><num>20</num><def></def><sym>) | (</sym><def>TOP_ROW</def> <sym>&lt;&lt;</sym> <def></def><num>30</num><def></def><sym>);</sym><br />
<def></def>   <kwb>static const</kwb> <def>BitVec ROW_1_MASK</def> <sym>=</sym> <def>ROW_0_MASK</def> <sym>&lt;&lt;</sym> <def></def><num>5</num><def></def><sym>;</sym><br />
<def></def>   <kwb>static const</kwb> <def>BitVec BOARD_MASK</def> <sym>= (</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def></def><num>30</num><def></def><sym>) -</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def><br />
   <kwd>Board</kwd><def></def><sym>();</sym><br />
<def></def><br />
   <kwb>static</kwb> <def>TUInt32</def> <kwd>getIndex</kwd><def></def><sym>(</sym><def>TUInt32 x</def><sym>,</sym> <def>TUInt32 y</def><sym>) {</sym> <def></def><kwa>return</kwa> <def>y</def> <sym>*</sym> <def>N_COL</def> <sym>+</sym> <def>x</def><sym>;    }</sym><br />
<def></def>   <kwb>static bool</kwb> <def></def><kwd>hasBadFirstRegion</kwd><def></def><sym>(</sym><def>BitVec</def> <sym>&amp;</sym> <def>toFill</def><sym>,</sym> <def>BitVec rNew</def><sym>);</sym><br />
<def></def>   <kwb>static bool</kwb> <def></def><kwd>hasBadIslands</kwd><def></def><sym>(</sym><def>BitVec boardVec</def><sym>,</sym> <def></def><kwb>int</kwb> <def>row</def><sym>);</sym><br />
<def></def>   <kwb>static bool</kwb> <def></def><kwd>calcBadIslands</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>BitVec boardVec</def><sym>,</sym> <def></def><kwb>int</kwb> <def>row</def><sym>);</sym><br />
<def></def>   <kwb>static bool</kwb> <def></def><kwd>hasBadIslandsSingle</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>BitVec</def> <sym>&amp;</sym> <def>boardVec</def><sym>,</sym> <def></def><kwb>int</kwb> <def>row</def><sym>);</sym><br />
<def></def><br />
   <kwb>void</kwb> <def></def><kwd>genAllSolutions</kwd><def></def><sym>(</sym><def>BitVec boardVec</def><sym>,</sym> <def>TUInt32 placedPieces</def><sym>,</sym> <def>TUInt32 iNextFill</def><sym>);</sym><br />
<def></def>   <kwb>void</kwb> <def></def><kwd>recordSolution</kwd><def></def><sym>(</sym><def>Solution</def> <sym>&amp;</sym> <def>s</def><sym>);</sym><br />
<def><br />
   Solution m_curSolution</def><sym>;</sym><br />
<def>   Solution m_minSolution</def><sym>;</sym><br />
<def>   Solution m_maxSolution</def><sym>;</sym><br />
<def>   TUInt32 m_nSolutionFound</def><sym>;</sym><br />
<def></def><sym>};</sym><br />
<def></def><br />
<slc>//------------------------------------</slc><br />
<def></def><br />
<kwc>class</kwc> <def>Piece</def><br />
<sym>{</sym><br />
<def></def><kwc>public</kwc><def></def><sym>:</sym><br />
<def></def>   <kwb>struct</kwb> <def>Instance</def> <sym>{</sym><br />
<def>      TUInt64 m_allowed</def><sym>;</sym><br />
<def>      BitVec m_vec</def><sym>;</sym><br />
<def></def>      <kwb>int</kwb> <def>m_offset</def><sym>;</sym><br />
<def></def>      <kwb>int</kwb> <def>m_w</def><sym>;</sym><br />
<def></def>      <kwb>int</kwb> <def>m_h</def><sym>;</sym><br />
<def></def>   <sym>};</sym><br />
<def></def><br />
   <kwb>static const int</kwb> <def>N_ELEM</def> <sym>=</sym> <def></def><num>5</num><def></def><sym>;</sym><br />
<def></def>   <kwb>static const int</kwb> <def>N_ORIENT</def> <sym>=</sym> <def></def><num>12</num><def></def><sym>;</sym><br />
<def></def>   <kwb>static const int</kwb> <def>ALL_PIECE_MASK</def> <sym>= (</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def>N_PIECE_TYPE</def><sym>) -</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>   <kwb>static const</kwb> <def>TUInt32 SKIP_PIECE</def> <sym>=</sym> <def></def><num>5</num><def></def><sym>;</sym> <def></def><slc>// it's magic!</slc><br />
<def></def><br />
   <kwc>typedef</kwc> <def></def><kwb>int</kwb> <def>TCoordList</def><sym>[</sym><def>N_ELEM</def><sym>][</sym><def>N_DIM</def><sym>];</sym><br />
<def></def><br />
   <kwb>static const</kwb> <def>BitVec BaseDefinitions</def><sym>[</sym><def>N_PIECE_TYPE</def><sym>];</sym><br />
<def></def>   <kwb>static</kwb> <def>Piece s_basePiece</def><sym>[</sym><def>N_PIECE_TYPE</def><sym>][</sym><def>N_ORIENT</def><sym>];</sym><br />
<def></def><br />
   <kwb>static const</kwb> <def>Instance</def> <sym>&amp;</sym> <def></def><kwd>getPiece</kwd><def></def><sym>(</sym><def>TUInt32 iPiece</def><sym>,</sym> <def>TUInt32 iOrient</def><sym>,</sym> <def>TUInt32 iParity</def><sym>);</sym><br />
<def></def>   <kwb>static bool</kwb> <def></def><kwd>checkBaseDefinitions</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>);</sym><br />
<def></def>   <kwb>static</kwb> <def>BitVec</def> <kwd>toBitVector</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>TCoordList</def> <sym>&amp;</sym> <def>coords</def><sym>);</sym><br />
<def></def>   <kwb>static void</kwb> <def></def><kwd>genOrientation</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>BitVec</def> <sym>&amp;</sym> <def>vec</def><sym>,</sym> <def>TUInt32 iOrient</def><sym>,</sym> <def>Piece</def> <sym>&amp;</sym> <def>target</def><sym>);</sym><br />
<def></def>   <kwb>static void</kwb> <def></def><kwd>setCoordList</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>BitVec</def> <sym>&amp;</sym> <def>vec</def><sym>,</sym> <def>TCoordList</def> <sym>&amp;</sym> <def>coords</def><sym>);</sym><br />
<def></def>   <kwb>static void</kwb> <def></def><kwd>shiftUpLines</kwd><def></def><sym>(</sym><def>TCoordList</def> <sym>&amp;</sym> <def>coords</def><sym>,</sym> <def></def><kwb>int</kwb> <def>shift</def><sym>);</sym><br />
<def></def>   <kwb>static void</kwb> <def></def><kwd>shiftToX0</kwd><def></def><sym>(</sym><def>TCoordList</def> <sym>&amp;</sym> <def>coords</def><sym>,</sym> <def>Instance</def> <sym>&amp;</sym> <def>instance</def><sym>,</sym> <def></def><kwb>int</kwb> <def>offsetRow</def><sym>);</sym><br />
<def></def>   <kwb>void</kwb> <def></def><kwd>setAllowedPositions</kwd><def></def><sym>(</sym><def>TUInt32 isOdd</def><sym>);</sym><br />
<def></def>   <kwb>static void</kwb> <def></def><kwd>genAllOrientations</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>);</sym><br />
<def><br />
   Instance m_instance</def><sym>[</sym><def>N_PARITY</def><sym>];</sym><br />
<def></def><sym>};</sym><br />
<def></def><br />
<kwb>struct</kwb> <def>AllowedPieces</def> <sym>{</sym><br />
<def></def>   <kwb>signed char</kwb> <def>nPieces</def><sym>[</sym><def>N_PIECE_TYPE</def><sym>];</sym><br />
<def></def>   <slc>// DEVNOTE: could be done more efficiently (space-wise)</slc><br />
<def>   TUInt32 pieceVec</def><sym>[</sym><def>N_PIECE_TYPE</def><sym>][</sym><def>Piece</def><sym>::</sym><def>N_ORIENT</def><sym>];</sym><br />
<def></def><sym>};</sym><br />
<def><br />
AllowedPieces g_allowedPieces</def><sym>[</sym><def>N_ROW</def><sym>][</sym><def>N_COL</def><sym>] = {{</sym><def></def><num>0</num><def></def><sym>}};</sym><br />
<def></def><br />
<slc>// should be moved in Board, but I'm lazy</slc><br />
<def></def><kwb>enum</kwb> <def></def><sym>{</sym><def>CLOSED</def><sym>,</sym> <def>OPEN</def><sym>,</sym> <def>N_FIXED</def><sym>};</sym><br />
<def></def><dir>#define MAX_ISLAND_OFFSET 1024</dir><br />
<def></def><kwb>struct</kwb> <def>IslandInfo</def> <sym>{</sym><br />
<def>   TUInt32 hasBadIslands</def><sym>[</sym><def>N_FIXED</def><sym>][</sym><def>N_PARITY</def><sym>];</sym><br />
<def>   TUInt32 isKnown</def><sym>[</sym><def>N_FIXED</def><sym>][</sym><def>N_PARITY</def><sym>];</sym><br />
<def></def><sym>};</sym><br />
<def><br />
IslandInfo g_islandInfo</def><sym>[</sym><def>MAX_ISLAND_OFFSET</def><sym>] = {</sym><def></def><num>0</num><def></def><sym>};</sym><br />
<def></def><kwb>int</kwb> <def>g_nIslandInfo</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def><br />
<slc>//------------------------------------</slc><br />
<def>Solution</def><sym>::</sym><def></def><kwd>Solution</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>fillVal</def><sym>) :</sym><br />
<def></def><kwd>m_nPiece</kwd><def></def><sym>(</sym><def></def><num>0</num><def></def><sym>) {</sym><br />
<def></def>   <kwd>fill</kwd><def></def><sym>(</sym><def>fillVal</def><sym>);</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Solution</def><sym>::</sym><def></def><kwd>fill</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>val</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def>   m_synched</def> <sym>=</sym> <def></def><kwa>false</kwa><def></def><sym>;</sym><br />
<def></def>   <kwd>memset</kwd><def></def><sym>(&amp;</sym><def>m_cells</def><sym>[</sym><def></def><num>0</num><def></def><sym>][</sym><def></def><num>0</num><def></def><sym>],</sym> <def>val</def><sym>,</sym> <def>N_CELL</def><sym>);</sym><br />
<def></def><sym>}</sym><br />
<def><br />
string Solution</def><sym>::</sym><def></def><kwd>toString</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>)</sym> <def></def><kwb>const</kwb><br />
<def></def><sym>{</sym><br />
<def>   string result</def><sym>;</sym><br />
<def>   result</def><sym>.</sym><def></def><kwd>reserve</kwd><def></def><sym>(</sym><def>N_CELL</def> <sym>*</sym> <def></def><num>2</num><def></def><sym>);</sym><br />
<def></def><br />
   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>y</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>y</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>y</def><sym>++) {</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>x</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>x</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>x</def><sym>++) {</sym><br />
<def></def>         <kwb>int</kwb> <def>val</def> <sym>=</sym> <def>m_cells</def><sym>[</sym><def>y</def><sym>][</sym><def>x</def><sym>];</sym><br />
<def>         result</def> <sym>+= ((</sym><def>val</def> <sym>==</sym> <def>NO_PIECE</def><sym>)</sym> <def>?</def> <str>'.'</str><def></def> <sym>:</sym> <def></def><kwb>char</kwb><def></def><sym>(</sym><def></def><str>'0'</str><def></def> <sym>+</sym> <def>val</def><sym>));</sym><br />
<def>         result</def> <sym>+=</sym> <def></def><str>' '</str><def></def><sym>;</sym><br />
<def></def>      <sym>}</sym><br />
<def>      result</def> <sym>+=</sym> <def></def><str>'</str><esc>\n</esc><str>'</str><def></def><sym>;</sym><br />
<def></def><br />
      <slc>// indent every second line</slc><br />
<def></def>      <kwa>if</kwa> <def></def><sym>(</sym><def>y</def> <sym>%</sym> <def></def><num>2</num> <def></def><sym>==</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def>         result</def> <sym>+=</sym> <def></def><str>&quot; &quot;</str><def></def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>return</kwa> <def>result</def><sym>;</sym> <def></def><slc>// copies result. Oh well</slc><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Solution</def><sym>::</sym><def></def><kwd>setCells</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>m_synched</def><sym>)</sym><br />
<def></def>      <kwa>return</kwa><def></def><sym>;</sym><br />
<def></def><br />
   <kwd>fill</kwd><def></def><sym>(</sym><def>NO_PIECE</def><sym>);</sym><br />
<def></def><br />
   <slc>// could be more efficient</slc><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def>TUInt32 iPiece</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iPiece</def> <sym>&lt;</sym> <def>m_nPiece</def><sym>;</sym> <def>iPiece</def><sym>++) {</sym><br />
<def></def>      <kwb>const</kwb> <def>SPiece</def> <sym>&amp;</sym> <def>p</def> <sym>=</sym> <def>m_pieces</def><sym>[</sym><def>iPiece</def><sym>];</sym><br />
<def>      BitVec vec</def> <sym>=</sym> <def>p</def><sym>.</sym><def>vec</def><sym>;</sym><br />
<def>      TInt8 pID</def> <sym>= (</sym><def>TInt8</def><sym>)</sym><def>p</def><sym>.</sym><def>iPiece</def><sym>;</sym><br />
<def></def>      <kwb>int</kwb> <def>rowOffset</def> <sym>=</sym> <def>p</def><sym>.</sym><def>row</def><sym>;</sym><br />
<def></def><br />
      <kwb>int</kwb> <def>nNewCells</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>y</def> <sym>=</sym> <def>rowOffset</def><sym>;</sym> <def>y</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>y</def><sym>++) {</sym><br />
<def></def>         <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>x</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>x</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>x</def><sym>++) {</sym><br />
<def></def>            <kwa>if</kwa> <def></def><sym>(</sym><def>vec</def> <sym>&amp;</sym> <def></def><num>1</num><def></def><sym>) {</sym><br />
<def>               m_cells</def><sym>[</sym><def>y</def><sym>][</sym><def>x</def><sym>] =</sym> <def>pID</def><sym>;</sym><br />
<def>               nNewCells</def><sym>++;</sym><br />
<def></def>            <sym>}</sym><br />
<def>            vec</def> <sym>&gt;&gt;=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>         <sym>}</sym><br />
<def></def>         <kwa>if</kwa> <def></def><sym>(</sym><def>nNewCells</def> <sym>==</sym> <def>Piece</def><sym>::</sym><def>N_ELEM</def><sym>)</sym><br />
<def></def>            <kwa>break</kwa><def></def><sym>;</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def><br />
<br />
   m_synched</def> <sym>=</sym> <def></def><kwa>true</kwa><def></def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>bool</kwb> <def>Solution</def><sym>::</sym><def></def><kwd>lessThan</kwd><def></def><sym>(</sym><def>Solution</def> <sym>&amp;</sym> <def>r</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>m_pieces</def><sym>[</sym><def></def><num>0</num><def></def><sym>].</sym><def>iPiece</def> <sym>!=</sym> <def>r</def><sym>.</sym><def>m_pieces</def><sym>[</sym><def></def><num>0</num><def></def><sym>].</sym><def>iPiece</def><sym>) {</sym><br />
<def></def>      <kwa>return</kwa> <def>m_pieces</def><sym>[</sym><def></def><num>0</num><def></def><sym>].</sym><def>iPiece</def> <sym>&lt;</sym> <def>r</def><sym>.</sym><def>m_pieces</def><sym>[</sym><def></def><num>0</num><def></def><sym>].</sym><def>iPiece</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwd>setCells</kwd><def></def><sym>();</sym><br />
<def>   r</def><sym>.</sym><def></def><kwd>setCells</kwd><def></def><sym>();</sym><br />
<def></def><br />
   <kwb>int</kwb> <def>y</def><sym>;</sym><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def>y</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>y</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>y</def><sym>++) {</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>x</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>x</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>x</def><sym>++) {</sym><br />
<def></def>         <kwb>int</kwb> <def>lval</def> <sym>=</sym> <def>m_cells</def><sym>[</sym><def>y</def><sym>][</sym><def>x</def><sym>];</sym><br />
<def></def>         <kwb>int</kwb> <def>rval</def> <sym>=</sym> <def>r</def><sym>.</sym><def>m_cells</def><sym>[</sym><def>y</def><sym>][</sym><def>x</def><sym>];</sym><br />
<def></def><br />
         <kwa>if</kwa> <def></def><sym>(</sym><def>lval</def> <sym>!=</sym> <def>rval</def><sym>)</sym><br />
<def></def>            <kwa>return</kwa> <def></def><sym>(</sym><def>lval</def> <sym>&lt;</sym> <def>rval</def><sym>);</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>return false</kwa><def></def><sym>;</sym> <def></def><slc>// solutions are equal</slc><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Solution</def><sym>::</sym><def></def><kwd>spin</kwd><def></def><sym>(</sym><def>Solution</def> <sym>&amp;</sym> <def>spun</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <kwd>setCells</kwd><def></def><sym>();</sym><br />
<def></def><br />
   <slc>// swap cells</slc><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>y</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>y</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>y</def><sym>++) {</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>x</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>x</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>x</def><sym>++) {</sym><br />
<def>         TInt8 flipped</def> <sym>=</sym> <def>m_cells</def><sym>[</sym><def>N_ROW</def> <sym>-</sym> <def>y</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>][</sym><def>N_COL</def> <sym>-</sym> <def>x</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>];</sym><br />
<def>         spun</def><sym>.</sym><def>m_cells</def><sym>[</sym><def>y</def><sym>][</sym><def>x</def><sym>] =</sym> <def>flipped</def><sym>;</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <slc>// swap first and last pieces (the rest aren't used)</slc><br />
<def>   spun</def><sym>.</sym><def>m_pieces</def><sym>[</sym><def></def><num>0</num><def></def><sym>].</sym><def>iPiece</def> <sym>=</sym> <def>m_pieces</def><sym>[</sym><def>N_PIECE_TYPE</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>].</sym><def>iPiece</def><sym>;</sym><br />
<def>   spun</def><sym>.</sym><def>m_synched</def> <sym>=</sym> <def></def><kwa>true</kwa><def></def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<slc>//------------------------------------</slc><br />
<def><br />
Piece Piece</def><sym>::</sym><def>s_basePiece</def><sym>[</sym><def>N_PIECE_TYPE</def><sym>][</sym><def>N_ORIENT</def><sym>];</sym><br />
<def></def><br />
<kwb>const</kwb> <def>BitVec Piece</def><sym>::</sym><def>BaseDefinitions</def><sym>[] = {</sym><br />
<def></def>   <num>0x010f</num><def></def><sym>,</sym>   <def></def><num>0x00cb</num><def></def><sym>,</sym> <def></def><num>0x1087</num><def></def><sym>,</sym> <def></def><num>0x0427</num><def></def><sym>,</sym> <def></def><num>0x0465</num><def></def><sym>,</sym><br />
<def></def>   <num>0x00c7</num><def></def><sym>,</sym> <def></def><num>0x08423</num><def></def><sym>,</sym> <def></def><num>0x00a7</num><def></def><sym>,</sym> <def></def><num>0x0187</num><def></def><sym>,</sym> <def></def><num>0x008f</num><br />
<def></def><sym>};</sym><br />
<def></def><br />
<kwb>int</kwb> <def></def><kwd>floor</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>top</def><sym>,</sym> <def></def><kwb>int</kwb> <def>bot</def><sym>) {</sym><br />
<def></def>   <kwb>int</kwb> <def>toZero</def> <sym>=</sym> <def>top</def> <sym>/</sym> <def>bot</def><sym>;</sym><br />
<def></def>   <slc>// negative numbers should be rounded down, not towards zero</slc><br />
<def></def>   <kwa>if</kwa> <def></def><sym>((</sym><def>toZero</def> <sym>*</sym> <def>bot</def> <sym>!=</sym> <def>top</def><sym>) &amp;&amp; ((</sym><def>top</def> <sym>&lt;</sym> <def></def><num>0</num><def></def><sym>) != (</sym><def>bot</def> <sym>&lt;=</sym> <def></def><num>0</num><def></def><sym>)))</sym><br />
<def>      toZero</def><sym>--;</sym><br />
<def></def><br />
   <kwa>return</kwa> <def>toZero</def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>static const</kwb> <def>TUInt32 s_firstOne</def><sym>[</sym><def></def><num>32</num><def></def><sym>] =   {</sym><br />
<def></def>   <num>0</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym><br />
<def></def>   <num>2</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym><br />
<def></def>   <num>3</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym><br />
<def></def>   <num>2</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym><br />
<def></def><br />
   <num>4</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym><br />
<def></def>   <num>2</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym><br />
<def></def>   <num>3</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym><br />
<def></def>   <num>2</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym><br />
<def></def><sym>};</sym><br />
<def><br />
TUInt32</def> <kwd>getFirstOne</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>BitVec</def> <sym>&amp;</sym> <def>v</def><sym>,</sym> <def>TUInt32 startPos</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>) {</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>v</def> <sym>== (</sym><def>BitVec</def><sym>)</sym><def></def><num>0</num><def></def><sym>)</sym><br />
<def></def>      <kwa>return</kwa> <def></def><num>0</num><def></def><sym>;</sym><br />
<def><br />
   TUInt32 iPos</def> <sym>=</sym> <def>startPos</def><sym>;</sym><br />
<def>   BitVec mask</def> <sym>=</sym> <def></def><num>0xff</num> <def></def><sym>&lt;&lt;</sym> <def>startPos</def><sym>;</sym><br />
<def></def>   <kwa>while</kwa> <def></def><sym>((</sym><def>mask</def> <sym>&amp;</sym> <def>v</def><sym>) ==</sym> <def></def><num>0</num><def></def><sym>) {</sym><br />
<def>      mask</def> <sym>&lt;&lt;=</sym> <def></def><num>8</num><def></def><sym>;</sym><br />
<def>      iPos</def> <sym>+=</sym> <def></def><num>8</num><def></def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def>   TUInt32 result</def> <sym>=</sym> <def></def><kwd>TUInt32</kwd><def></def><sym>((</sym><def>mask</def> <sym>&amp;</sym> <def>v</def><sym>) &gt;&gt;</sym> <def>iPos</def><sym>);</sym><br />
<def>   TUInt32 resultLow</def> <sym>=</sym> <def>result</def> <sym>&amp;</sym> <def></def><num>0x0f</num><def></def><sym>;</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>resultLow</def> <sym>!=</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def>      iPos</def> <sym>+=</sym> <def>s_firstOne</def><sym>[</sym><def>resultLow</def><sym>];</sym><br />
<def></def>   <kwa>else</kwa><br />
<def>      iPos</def> <sym>+=</sym> <def></def><num>4</num> <def></def><sym>+</sym> <def>s_firstOne</def><sym>[</sym><def>result</def> <sym>&gt;&gt;</sym> <def></def><num>4</num><def></def><sym>];</sym><br />
<def></def><br />
   <kwa>return</kwa> <def>iPos</def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def><br />
TUInt32</def> <kwd>countOnes</kwd><def></def><sym>(</sym><def>BitVec v</def><sym>) {</sym><br />
<def>   TUInt32 n</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>   <kwa>while</kwa> <def></def><sym>(</sym><def>v</def><sym>) {</sym><br />
<def>      n</def><sym>++;</sym><br />
<def>      v</def> <sym>=</sym> <def>v</def> <sym>&amp; (</sym><def>v</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>return</kwa> <def>n</def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Piece</def><sym>::</sym><def></def><kwd>setCoordList</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>BitVec</def> <sym>&amp;</sym> <def>vec</def><sym>,</sym> <def>TCoordList</def> <sym>&amp;</sym> <def>coords</def><sym>) {</sym><br />
<def></def>   <kwb>int</kwb> <def>iCoord</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def>   BitVec mask</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>y</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>y</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>y</def><sym>++) {</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>x</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>x</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>x</def><sym>++) {</sym><br />
<def></def>         <kwa>if</kwa> <def></def><sym>(</sym><def>mask</def> <sym>&amp;</sym> <def>vec</def><sym>) {</sym><br />
<def>            coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>X</def><sym>] =</sym> <def>x</def><sym>;</sym><br />
<def>            coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>Y</def><sym>] =</sym> <def>y</def><sym>;</sym><br />
<def><br />
            iCoord</def><sym>++;</sym><br />
<def></def>         <sym>}</sym><br />
<def>         mask</def> <sym>&lt;&lt;=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><sym>}</sym><br />
<def><br />
BitVec Piece</def><sym>::</sym><def></def><kwd>toBitVector</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>TCoordList</def> <sym>&amp;</sym> <def>coords</def><sym>) {</sym><br />
<def></def>   <kwb>int</kwb> <def>y</def><sym>,</sym> <def>x</def><sym>;</sym><br />
<def>   BitVec result</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iCoord</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iCoord</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iCoord</def><sym>++) {</sym><br />
<def>      x</def> <sym>=</sym> <def>coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>X</def><sym>];</sym><br />
<def>      y</def> <sym>=</sym> <def>coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def><br />
      <kwb>int</kwb> <def>pos</def> <sym>=</sym> <def>Board</def><sym>::</sym><def></def><kwd>getIndex</kwd><def></def><sym>(</sym><def>x</def><sym>,</sym> <def>y</def><sym>);</sym><br />
<def>      result</def> <sym>|= (</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def>pos</def><sym>);</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>return</kwa> <def>result</def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Piece</def><sym>::</sym><def></def><kwd>shiftUpLines</kwd><def></def><sym>(</sym><def>TCoordList</def> <sym>&amp;</sym> <def>coords</def><sym>,</sym> <def></def><kwb>int</kwb> <def>shift</def><sym>) {</sym><br />
<def></def>   <slc>// shifts are not so simple in the vertical direction</slc><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iCoord</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iCoord</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iCoord</def><sym>++) {</sym><br />
<def></def>      <kwb>int</kwb> <def></def><sym>&amp;</sym> <def>rx</def> <sym>=</sym> <def>coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>X</def><sym>];</sym><br />
<def></def>      <kwb>int</kwb> <def></def><sym>&amp;</sym> <def>ry</def> <sym>=</sym> <def>coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def><br />
      <kwa>if</kwa> <def></def><sym>(</sym><def>ry</def> <sym>&amp;</sym> <def>shift</def> <sym>&amp;</sym> <def></def><num>0x1</num><def></def><sym>)</sym><br />
<def>         rx</def><sym>++;</sym><br />
<def>      ry</def> <sym>-=</sym> <def>shift</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Piece</def><sym>::</sym><def></def><kwd>shiftToX0</kwd><def></def><sym>(</sym><def>TCoordList</def> <sym>&amp;</sym> <def>coords</def><sym>,</sym> <def>Piece</def><sym>::</sym><def>Instance</def> <sym>&amp;</sym> <def>instance</def><sym>,</sym> <def></def><kwb>int</kwb> <def>offsetRow</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <slc>// .. determine shift</slc><br />
<def></def>   <kwb>int</kwb> <def>x</def><sym>,</sym> <def>y</def><sym>;</sym><br />
<def></def>   <kwb>int</kwb> <def>xMin</def> <sym>=</sym> <def>coords</def><sym>[</sym><def></def><num>0</num><def></def><sym>][</sym><def>X</def><sym>];</sym><br />
<def></def>   <kwb>int</kwb> <def>xMax</def> <sym>=</sym> <def>xMin</def><sym>;</sym><br />
<def></def>   <kwb>int</kwb> <def>iCoord</def><sym>;</sym><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def>iCoord</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym> <def>iCoord</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iCoord</def><sym>++) {</sym><br />
<def>      x</def> <sym>=</sym> <def>coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>X</def><sym>];</sym><br />
<def>      y</def> <sym>=</sym> <def>coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def><br />
      <kwa>if</kwa> <def></def><sym>(</sym><def>x</def> <sym>&lt;</sym> <def>xMin</def><sym>)</sym><br />
<def>         xMin</def> <sym>=</sym> <def>x</def><sym>;</sym><br />
<def></def>      <kwa>else if</kwa> <def></def><sym>(</sym><def>x</def> <sym>&gt;</sym> <def>xMax</def><sym>)</sym><br />
<def>         xMax</def> <sym>=</sym> <def>x</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <slc>// I'm dying for a 'foreach' here</slc><br />
<def></def>   <kwb>int</kwb> <def>offset</def> <sym>=</sym> <def>N_ELEM</def><sym>;</sym><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def>iCoord</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iCoord</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iCoord</def><sym>++) {</sym><br />
<def></def>      <kwb>int</kwb> <def></def><sym>&amp;</sym> <def>rx</def> <sym>=</sym> <def>coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>X</def><sym>];</sym><br />
<def></def>      <kwb>int</kwb> <def></def><sym>&amp;</sym> <def>ry</def> <sym>=</sym> <def>coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def><br />
      rx</def> <sym>-=</sym> <def>xMin</def><sym>;</sym><br />
<def></def><br />
      <slc>// check offset -- leftmost cell on top line</slc><br />
<def></def>      <kwa>if</kwa> <def></def><sym>((</sym><def>ry</def> <sym>==</sym> <def>offsetRow</def><sym>) &amp;&amp; (</sym><def>rx</def> <sym>&lt;</sym> <def>offset</def><sym>))</sym><br />
<def>         offset</def> <sym>=</sym> <def>rx</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def><br />
   instance</def><sym>.</sym><def>m_w</def> <sym>=</sym> <def>xMax</def> <sym>-</sym> <def>xMin</def><sym>;</sym><br />
<def>   instance</def><sym>.</sym><def>m_offset</def> <sym>=</sym> <def>offset</def><sym>;</sym><br />
<def>   instance</def><sym>.</sym><def>m_vec</def> <sym>=</sym> <def></def><kwd>toBitVector</kwd><def></def><sym>(</sym><def>coords</def><sym>);</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Piece</def><sym>::</sym><def></def><kwd>setAllowedPositions</kwd><def></def><sym>(</sym><def>TUInt32 isOdd</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def>   Piece</def><sym>::</sym><def>Instance</def> <sym>&amp;</sym> <def>p</def> <sym>=</sym> <def>m_instance</def><sym>[</sym><def>isOdd</def><sym>];</sym><br />
<def>   TUInt64</def> <sym>&amp;</sym> <def>allowed</def> <sym>=</sym> <def>p</def><sym>.</sym><def>m_allowed</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def>   TUInt64 posMask</def> <sym>=</sym> <def></def><num>1L</num><def>L</def> <sym>&lt;&lt; (</sym><def>isOdd</def> <sym>*</sym> <def>N_COL</def><sym>);</sym><br />
<def></def><br />
   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>y</def> <sym>=</sym> <def>isOdd</def><sym>;</sym> <def>y</def> <sym>&lt;</sym> <def>N_ROW</def> <sym>-</sym> <def>p</def><sym>.</sym><def>m_h</def><sym>;</sym> <def>y</def><sym>+=</sym><def></def><num>2</num><def></def><sym>,</sym> <def>posMask</def> <sym>&lt;&lt;=</sym> <def>N_COL</def><sym>) {</sym><br />
<def></def>      <kwa>if</kwa> <def></def><sym>(</sym><def>p</def><sym>.</sym><def>m_offset</def><sym>)</sym><br />
<def>         posMask</def> <sym>&lt;&lt;=</sym> <def>p</def><sym>.</sym><def>m_offset</def><sym>;</sym><br />
<def></def><br />
      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>xPos</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>xPos</def> <sym>&lt;</sym> <def>N_COL</def> <sym>-</sym> <def>p</def><sym>.</sym><def>m_offset</def><sym>;</sym> <def>xPos</def><sym>++,</sym> <def>posMask</def> <sym>&lt;&lt;=</sym> <def></def><num>1</num><def></def><sym>){</sym><br />
<def></def>         <slc>// check if the new position is on the board</slc><br />
<def></def>         <kwa>if</kwa> <def></def><sym>(</sym><def>xPos</def> <sym>&gt;=</sym> <def>N_COL</def> <sym>-</sym> <def>p</def><sym>.</sym><def>m_w</def><sym>)</sym><br />
<def></def>            <kwa>continue</kwa><def></def><sym>;</sym><br />
<def></def><br />
         <slc>// move it to the desired location</slc><br />
<def>         BitVec pieceVec</def> <sym>=</sym> <def>p</def><sym>.</sym><def>m_vec</def> <sym>&lt;&lt;</sym> <def>xPos</def><sym>;</sym><br />
<def></def><br />
         <kwa>if</kwa> <def></def><sym>(</sym><def>Board</def><sym>::</sym><def></def><kwd>hasBadIslandsSingle</kwd><def></def><sym>(</sym><def>pieceVec</def><sym>,</sym> <def>y</def><sym>))</sym><br />
<def></def>            <kwa>continue</kwa><def></def><sym>;</sym><br />
<def></def><br />
         <slc>// position is allowed</slc><br />
<def>         allowed</def> <sym>|=</sym> <def>posMask</def><sym>;</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Piece</def><sym>::</sym><def></def><kwd>genOrientation</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>BitVec</def> <sym>&amp;</sym> <def>vec</def><sym>,</sym> <def>TUInt32 iOrient</def><sym>,</sym> <def>Piece</def> <sym>&amp;</sym> <def>target</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <slc>// get (x,y) coordinates</slc><br />
<def>   TCoordList coords</def><sym>;</sym><br />
<def></def>   <kwd>setCoordList</kwd><def></def><sym>(</sym><def>vec</def><sym>,</sym> <def>coords</def><sym>);</sym><br />
<def></def><br />
   <kwb>int</kwb> <def>y</def><sym>,</sym> <def>x</def><sym>;</sym><br />
<def></def>   <kwb>int</kwb> <def>iCoord</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>   <kwb>int</kwb> <def>rot</def> <sym>=</sym> <def>iOrient</def> <sym>%</sym> <def></def><num>6</num><def></def><sym>;</sym><br />
<def></def>   <kwb>int</kwb> <def>flip</def> <sym>=</sym> <def>iOrient</def> <sym>&gt;=</sym> <def></def><num>6</num><def></def><sym>;</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>flip</def><sym>) {</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def>iCoord</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iCoord</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iCoord</def><sym>++)</sym><br />
<def>         coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>Y</def><sym>] = -</sym><def>coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <slc>// rotate (if necessary)</slc><br />
<def></def>   <kwa>while</kwa> <def></def><sym>(</sym><def>rot</def><sym>--) {</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def>iCoord</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iCoord</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iCoord</def><sym>++) {</sym><br />
<def>         x</def> <sym>=</sym> <def>coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>X</def><sym>];</sym><br />
<def>         y</def> <sym>=</sym> <def>coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def><br />
         <slc>// I just worked this out by hand. Took a while.</slc><br />
<def></def>         <kwb>int</kwb> <def>xNew</def> <sym>=</sym> <def></def><kwd>floor</kwd><def></def><sym>((</sym><def></def><num>2</num> <def></def><sym>*</sym> <def>x</def> <sym>-</sym> <def></def><num>3</num> <def></def><sym>*</sym> <def>y</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>),</sym> <def></def><num>4</num><def></def><sym>);</sym><br />
<def></def>         <kwb>int</kwb> <def>yNew</def> <sym>=</sym> <def></def><kwd>floor</kwd><def></def><sym>((</sym><def></def><num>2</num> <def></def><sym>*</sym> <def>x</def> <sym>+</sym> <def>y</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>),</sym> <def></def><num>2</num><def></def><sym>);</sym><br />
<def>         coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>X</def><sym>] =</sym> <def>xNew</def><sym>;</sym><br />
<def>         coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>Y</def><sym>] =</sym> <def>yNew</def><sym>;</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <slc>// shift vertically</slc><br />
<def></def>   <slc>// .. determine shift</slc><br />
<def></def>   <kwb>int</kwb> <def>yMin</def> <sym>=</sym> <def>coords</def><sym>[</sym><def></def><num>0</num><def></def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def>   <kwb>int</kwb> <def>yMax</def> <sym>=</sym> <def>yMin</def><sym>;</sym><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def>iCoord</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym> <def>iCoord</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iCoord</def><sym>++) {</sym><br />
<def>      y</def> <sym>=</sym> <def>coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def><br />
      <kwa>if</kwa> <def></def><sym>(</sym><def>y</def> <sym>&lt;</sym> <def>yMin</def><sym>)</sym><br />
<def>         yMin</def> <sym>=</sym> <def>y</def><sym>;</sym><br />
<def></def>      <kwa>else if</kwa> <def></def><sym>(</sym><def>y</def> <sym>&gt;</sym> <def>yMax</def><sym>)</sym><br />
<def>         yMax</def> <sym>=</sym> <def>y</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def>   TUInt32 h</def> <sym>=</sym> <def>yMax</def> <sym>-</sym> <def>yMin</def><sym>;</sym><br />
<def>   Instance</def> <sym>&amp;</sym> <def>even</def> <sym>=</sym> <def>target</def><sym>.</sym><def>m_instance</def><sym>[</sym><def>EVEN</def><sym>];</sym><br />
<def>   Instance</def> <sym>&amp;</sym> <def>odd</def> <sym>=</sym> <def>target</def><sym>.</sym><def>m_instance</def><sym>[</sym><def>ODD</def><sym>];</sym><br />
<def>   even</def><sym>.</sym><def>m_h</def> <sym>=</sym> <def>h</def><sym>;</sym><br />
<def>   odd</def><sym>.</sym><def>m_h</def> <sym>=</sym> <def>h</def><sym>;</sym><br />
<def></def><br />
   <kwd>shiftUpLines</kwd><def></def><sym>(</sym><def>coords</def><sym>,</sym> <def>yMin</def><sym>);</sym><br />
<def></def>   <kwd>shiftToX0</kwd><def></def><sym>(</sym><def>coords</def><sym>,</sym> <def>even</def><sym>,</sym> <def></def><num>0</num><def></def><sym>);</sym><br />
<def>   target</def><sym>.</sym><def></def><kwd>setAllowedPositions</kwd><def></def><sym>(</sym><def>EVEN</def><sym>);</sym><br />
<def>   even</def><sym>.</sym><def>m_vec</def> <sym>&gt;&gt;=</sym> <def>even</def><sym>.</sym><def>m_offset</def><sym>;</sym><br />
<def></def><br />
   <slc>// shift down one line</slc><br />
<def></def>   <kwd>shiftUpLines</kwd><def></def><sym>(</sym><def>coords</def><sym>, -</sym><def></def><num>1</num><def></def><sym>);</sym><br />
<def></def>   <kwd>shiftToX0</kwd><def></def><sym>(</sym><def>coords</def><sym>,</sym> <def>odd</def><sym>,</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def></def>   <slc>// shift the bitmask back one line</slc><br />
<def>   odd</def><sym>.</sym><def>m_vec</def> <sym>&gt;&gt;=</sym> <def>N_COL</def><sym>;</sym><br />
<def>   target</def><sym>.</sym><def></def><kwd>setAllowedPositions</kwd><def></def><sym>(</sym><def>ODD</def><sym>);</sym><br />
<def>   odd</def><sym>.</sym><def>m_vec</def> <sym>&gt;&gt;=</sym> <def>odd</def><sym>.</sym><def>m_offset</def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Piece</def><sym>::</sym><def></def><kwd>genAllOrientations</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>) {</sym><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iPiece</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iPiece</def> <sym>&lt;</sym> <def>N_PIECE_TYPE</def><sym>;</sym> <def>iPiece</def><sym>++) {</sym><br />
<def></def>      <kwb>const</kwb> <def>BitVec</def> <sym>&amp;</sym> <def>refPiece</def> <sym>=</sym> <def>BaseDefinitions</def><sym>[</sym><def>iPiece</def><sym>];</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iOrient</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iOrient</def> <sym>&lt;</sym> <def>N_ORIENT</def><sym>;</sym> <def>iOrient</def><sym>++) {</sym><br />
<def>         Piece</def> <sym>&amp;</sym> <def>p</def> <sym>=</sym> <def>s_basePiece</def><sym>[</sym><def>iPiece</def><sym>][</sym><def>iOrient</def><sym>];</sym><br />
<def></def>         <kwd>genOrientation</kwd><def></def><sym>(</sym><def>refPiece</def><sym>,</sym> <def>iOrient</def><sym>,</sym> <def>p</def><sym>);</sym><br />
<def></def>         <kwa>if</kwa> <def></def><sym>((</sym><def>iPiece</def> <sym>==</sym> <def>SKIP_PIECE</def><sym>) &amp;&amp; ((</sym><def>iOrient</def> <sym>/</sym> <def></def><num>3</num><def></def><sym>) &amp;</sym> <def></def><num>1</num><def></def><sym>))</sym><br />
<def>            p</def><sym>.</sym><def>m_instance</def><sym>[</sym><def></def><num>0</num><def></def><sym>].</sym><def>m_allowed</def> <sym>=</sym> <def>p</def><sym>.</sym><def>m_instance</def><sym>[</sym><def></def><num>1</num><def></def><sym>].</sym><def>m_allowed</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iPiece</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iPiece</def> <sym>&lt;</sym> <def>N_PIECE_TYPE</def><sym>;</sym> <def>iPiece</def><sym>++) {</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iOrient</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iOrient</def> <sym>&lt;</sym> <def>N_ORIENT</def><sym>;</sym> <def>iOrient</def><sym>++) {</sym><br />
<def>         TUInt64 mask</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>         <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iRow</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iRow</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>iRow</def><sym>++) {</sym><br />
<def></def>            <kwb>const</kwb> <def>Piece</def><sym>::</sym><def>Instance</def> <sym>&amp;</sym> <def>p</def> <sym>=</sym> <def></def><kwd>getPiece</kwd><def></def><sym>(</sym><def>iPiece</def><sym>,</sym> <def>iOrient</def><sym>, (</sym><def>iRow</def> <sym>&amp;</sym> <def></def><num>1</num><def></def><sym>));</sym><br />
<def></def>            <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iCol</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iCol</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>iCol</def><sym>++) {</sym><br />
<def>               AllowedPieces</def> <sym>&amp;</sym> <def>allowed</def> <sym>=</sym> <def>g_allowedPieces</def><sym>[</sym><def>iRow</def><sym>][</sym><def>iCol</def><sym>];</sym><br />
<def></def>               <kwa>if</kwa> <def></def><sym>(</sym><def>p</def><sym>.</sym><def>m_allowed</def> <sym>&amp;</sym> <def>mask</def><sym>) {</sym><br />
<def></def>                  <kwb>signed char</kwb> <def></def><sym>&amp;</sym> <def>nPiece</def> <sym>=</sym> <def>allowed</def><sym>.</sym><def>nPieces</def><sym>[</sym><def>iPiece</def><sym>];</sym><br />
<def>                  allowed</def><sym>.</sym><def>pieceVec</def><sym>[</sym><def>iPiece</def><sym>][</sym><def>nPiece</def><sym>] =</sym> <def>p</def><sym>.</sym><def>m_vec</def> <sym>&lt;&lt;</sym> <def>iCol</def><sym>;</sym><br />
<def>                  nPiece</def><sym>++;</sym><br />
<def></def>               <sym>}</sym><br />
<def><br />
               mask</def> <sym>&lt;&lt;=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>            <sym>}</sym><br />
<def></def>         <sym>}</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<br />
<kwb>const</kwb> <def>Piece</def><sym>::</sym><def>Instance</def> <sym>&amp;</sym> <def>Piece</def><sym>::</sym><def></def><kwd>getPiece</kwd><def></def><sym>(</sym><def>TUInt32 iPiece</def><sym>,</sym> <def>TUInt32 iOrient</def><sym>,</sym> <def>TUInt32 iParity</def><sym>) {</sym><br />
<def></def>   <kwa>return</kwa> <def>s_basePiece</def><sym>[</sym><def>iPiece</def><sym>][</sym><def>iOrient</def><sym>].</sym><def>m_instance</def><sym>[</sym><def>iParity</def><sym>];</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<slc>// ------------------------------------</slc><br />
<def><br />
Board</def><sym>::</sym><def></def><kwd>Board</kwd><def></def><sym>() :</sym><br />
<def></def><kwd>m_curSolution</kwd><def></def><sym>(</sym><def>Solution</def><sym>::</sym><def>NO_PIECE</def><sym>),</sym> <def></def><kwd>m_minSolution</kwd><def></def><sym>(</sym><def>N_PIECE_TYPE</def><sym>),</sym><br />
<def></def><kwd>m_maxSolution</kwd><def></def><sym>(</sym><def>Solution</def><sym>::</sym><def>NO_PIECE</def><sym>),</sym> <def></def><kwd>m_nSolutionFound</kwd><def></def><sym>(</sym><def></def><num>0</num><def></def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>bool</kwb> <def>Board</def><sym>::</sym><def></def><kwd>hasBadFirstRegion</kwd><def></def><sym>(</sym><def>BitVec</def> <sym>&amp;</sym> <def>toFill</def><sym>,</sym> <def>BitVec rNew</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <slc>// grow empty region, until it doesn't change any more</slc><br />
<def>   BitVec region</def><sym>;</sym><br />
<def></def>   <kwa>do</kwa> <def></def><sym>{</sym><br />
<def>      region</def> <sym>=</sym> <def>rNew</def><sym>;</sym><br />
<def></def><br />
      <slc>// grow right/left</slc><br />
<def>      rNew</def> <sym>|= (</sym><def>region</def> <sym>&amp; ~</sym><def>L_EDGE_MASK</def><sym>) &gt;&gt;</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def>      rNew</def> <sym>|= (</sym><def>region</def> <sym>&amp; ~</sym><def>R_EDGE_MASK</def><sym>) &lt;&lt;</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def><br />
      <slc>// simple grow up/down</slc><br />
<def>      rNew</def> <sym>|= (</sym><def>region</def> <sym>&gt;&gt;</sym> <def>N_COL</def><sym>);</sym><br />
<def>      rNew</def> <sym>|= (</sym><def>region</def> <sym>&lt;&lt;</sym> <def>N_COL</def><sym>);</sym><br />
<def></def><br />
      <slc>// tricky growth</slc><br />
<def>      BitVec evenRegion</def> <sym>=</sym> <def>region</def> <sym>&amp; (</sym><def>ROW_0_MASK</def> <sym>&amp; ~</sym><def>L_EDGE_MASK</def><sym>);</sym><br />
<def>      rNew</def> <sym>|=</sym> <def>evenRegion</def> <sym>&gt;&gt; (</sym><def>N_COL</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def>      rNew</def> <sym>|=</sym> <def>evenRegion</def> <sym>&lt;&lt; (</sym><def>N_COL</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def><br />
      BitVec oddRegion</def> <sym>=</sym> <def>region</def> <sym>&amp; (</sym><def>ROW_1_MASK</def> <sym>&amp; ~</sym><def>R_EDGE_MASK</def><sym>);</sym><br />
<def>      rNew</def> <sym>|=</sym> <def>oddRegion</def> <sym>&gt;&gt; (</sym><def>N_COL</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def>      rNew</def> <sym>|=</sym> <def>oddRegion</def> <sym>&lt;&lt; (</sym><def>N_COL</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def></def><br />
      <slc>// clamp against existing pieces</slc><br />
<def>      rNew</def> <sym>&amp;=</sym> <def>toFill</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def>   <kwa>while</kwa> <def></def><sym>((</sym><def>rNew</def> <sym>!=</sym> <def>toFill</def><sym>) &amp;&amp; (</sym><def>rNew</def> <sym>!=</sym> <def>region</def><sym>));</sym><br />
<def></def><br />
   <slc>// subtract empty region from board</slc><br />
<def>   toFill ^</def><sym>=</sym> <def>rNew</def><sym>;</sym><br />
<def><br />
   TUInt32 nEmptyCells</def> <sym>=</sym> <def></def><kwd>countOnes</kwd><def></def><sym>(</sym><def>toFill</def><sym>);</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>nEmptyCells</def> <sym>%</sym> <def>Piece</def><sym>::</sym><def>N_ELEM</def> <sym>!=</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def></def>      <kwa>return true</kwa><def></def><sym>;</sym><br />
<def></def><br />
   <kwa>return false</kwa><def></def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>bool</kwb> <def>Board</def><sym>::</sym><def></def><kwd>hasBadIslands</kwd><def></def><sym>(</sym><def>BitVec boardVec</def><sym>,</sym> <def></def><kwb>int</kwb> <def>row</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <slc>// skip over any filled rows</slc><br />
<def></def>   <kwa>while</kwa> <def></def><sym>((</sym><def>boardVec</def> <sym>&amp;</sym> <def>TOP_ROW</def><sym>) ==</sym> <def>TOP_ROW</def><sym>) {</sym><br />
<def>      boardVec</def> <sym>&gt;&gt;=</sym> <def>N_COL</def><sym>;</sym><br />
<def>      row</def><sym>++;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>if</kwa> <def></def><sym>(</sym><def>boardVec</def> <sym>==</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def></def>      <kwa>return false</kwa><def></def><sym>;</sym><br />
<def></def><br />
   <kwa>if</kwa> <def></def><sym>(</sym><def>boardVec</def> <sym>&amp; (</sym><def>TOP_ROW</def> <sym>&lt;&lt;</sym> <def>N_COL</def> <sym>*</sym> <def></def><num>3</num><def></def><sym>))</sym><br />
<def></def>      <kwa>return</kwa> <def></def><kwd>calcBadIslands</kwd><def></def><sym>(</sym><def>boardVec</def><sym>,</sym> <def>row</def><sym>);</sym><br />
<def></def><br />
   <kwb>int</kwb> <def>isOdd</def> <sym>=</sym> <def>row</def> <sym>&amp;</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def>   TUInt32 iInfo</def> <sym>=</sym> <def>boardVec</def> <sym>&amp; ((</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def></def><num>2</num> <def></def><sym>*</sym> <def>N_COL</def><sym>) -</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def>   TUInt32 lastRow</def> <sym>= (</sym><def>boardVec</def> <sym>&gt;&gt; (</sym><def></def><num>2</num> <def></def><sym>*</sym> <def>N_COL</def><sym>)) &amp;</sym> <def>TOP_ROW</def><sym>;</sym><br />
<def></def>   <kwb>int</kwb> <def>isClosed</def> <sym>=</sym> <def>row</def> <sym>&gt;</sym> <def></def><num>6</num><def></def><sym>;</sym><br />
<def><br />
   IslandInfo</def> <sym>&amp;</sym> <def>islandInfo</def> <sym>=</sym> <def>g_islandInfo</def><sym>[</sym><def>iInfo</def><sym>];</sym><br />
<def>   TUInt32 mask</def> <sym>=</sym> <def></def><kwd>getMask</kwd><def></def><sym>(</sym><def>lastRow</def><sym>);</sym><br />
<def>   TUInt32</def> <sym>&amp;</sym> <def>isKnownVector</def> <sym>=</sym> <def>islandInfo</def><sym>.</sym><def>isKnown</def><sym>[</sym><def>isOdd</def><sym>][</sym><def>isClosed</def><sym>];</sym><br />
<def>   TUInt32</def> <sym>&amp;</sym> <def>badIsleVector</def> <sym>=</sym> <def>islandInfo</def><sym>.</sym><def>hasBadIslands</def><sym>[</sym><def>isOdd</def><sym>][</sym><def>isClosed</def><sym>];</sym><br />
<def></def><br />
   <kwa>if</kwa> <def></def><sym>(</sym><def>isKnownVector</def> <sym>&amp;</sym> <def>mask</def><sym>)</sym><br />
<def></def>      <kwa>return</kwa> <def></def><sym>((</sym><def>badIsleVector</def> <sym>&amp;</sym> <def>mask</def><sym>) !=</sym> <def></def><num>0</num><def></def><sym>);</sym><br />
<def><br />
   isKnownVector</def> <sym>|=</sym> <def>mask</def><sym>;</sym><br />
<def></def><br />
   <slc>// calc island info</slc><br />
<def></def>   <kwb>bool</kwb> <def>hasBad</def> <sym>=</sym> <def></def><kwd>calcBadIslands</kwd><def></def><sym>(</sym><def>boardVec</def><sym>,</sym> <def>row</def><sym>);</sym><br />
<def></def><br />
   <slc>// set it</slc><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>hasBad</def><sym>)</sym><br />
<def>      badIsleVector</def> <sym>|=</sym> <def>mask</def><sym>;</sym><br />
<def></def><br />
   <kwa>return</kwa> <def>hasBad</def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>bool</kwb> <def>Board</def><sym>::</sym><def></def><kwd>calcBadIslands</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>BitVec boardVec</def><sym>,</sym> <def></def><kwb>int</kwb> <def>row</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def>   BitVec toFill</def> <sym>= ~</sym><def>boardVec</def><sym>;</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>row</def> <sym>&amp;</sym> <def></def><num>1</num><def></def><sym>) {</sym><br />
<def>      row</def><sym>--;</sym><br />
<def>      toFill</def> <sym>&lt;&lt;=</sym> <def>N_COL</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def><br />
   BitVec boardMask</def> <sym>=</sym> <def>BOARD_MASK</def><sym>;</sym> <def></def><slc>// all but the first two bits</slc><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>row</def> <sym>&gt;</sym> <def></def><num>4</num><def></def><sym>) {</sym><br />
<def></def>      <kwb>int</kwb> <def>boardMaskShift</def> <sym>= (</sym><def>row</def> <sym>-</sym> <def></def><num>4</num><def></def><sym>) *</sym> <def>N_COL</def><sym>;</sym><br />
<def>      boardMask</def> <sym>&gt;&gt;=</sym> <def>boardMaskShift</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def>   toFill</def> <sym>&amp;=</sym> <def>boardMask</def><sym>;</sym><br />
<def></def><br />
   <slc>// a little pre-work to speed things up</slc><br />
<def>   BitVec bottom</def> <sym>= (</sym><def>TOP_ROW</def> <sym>&lt;&lt; (</sym><def></def><num>5</num> <def></def><sym>*</sym> <def>N_COL</def><sym>));</sym><br />
<def></def>   <kwb>bool</kwb> <def>filled</def> <sym>= ((</sym><def>bottom</def> <sym>&amp;</sym> <def>toFill</def><sym>) ==</sym> <def>bottom</def><sym>);</sym><br />
<def></def>   <kwa>while</kwa> <def></def><sym>((</sym><def>bottom</def> <sym>&amp;</sym> <def>toFill</def><sym>) ==</sym> <def>bottom</def><sym>) {</sym><br />
<def>      toFill ^</def><sym>=</sym> <def>bottom</def><sym>;</sym><br />
<def>      bottom</def> <sym>&gt;&gt;=</sym> <def>N_COL</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def><br />
   BitVec startRegion</def><sym>;</sym><br />
<def></def>   <kwb>int</kwb> <def>iPos</def><sym>;</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>filled</def> <sym>|| (</sym><def>row</def> <sym>&lt;</sym> <def></def><num>4</num><def></def><sym>))   {</sym><br />
<def>      startRegion</def> <sym>=</sym> <def>bottom</def> <sym>&amp;</sym> <def>toFill</def><sym>;</sym><br />
<def></def>   <sym>}</sym> <def></def><kwa>else</kwa> <def></def><sym>{</sym><br />
<def>      iPos</def> <sym>=</sym> <def></def><kwd>getFirstOne</kwd><def></def><sym>(</sym><def>toFill</def><sym>);</sym><br />
<def>      startRegion</def> <sym>=</sym> <def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def>iPos</def><sym>;</sym><br />
<def></def>      <slc>//      startRegion |= ((startRegion &amp; ~R_EDGE_MASK) &lt;&lt; 1) &amp; toFill;</slc><br />
<def>      startRegion</def> <sym>|= (</sym><def>startRegion</def> <sym>&lt;&lt;</sym> <def>N_COL</def><sym>) &amp;</sym> <def>toFill</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>while</kwa> <def></def><sym>(</sym><def>toFill</def><sym>)    {</sym><br />
<def></def>      <kwa>if</kwa> <def></def><sym>(</sym><def></def><kwd>hasBadFirstRegion</kwd><def></def><sym>(</sym><def>toFill</def><sym>,</sym> <def>startRegion</def><sym>))</sym><br />
<def></def>         <kwa>return true</kwa><def></def><sym>;</sym><br />
<def>      iPos</def> <sym>=</sym> <def></def><kwd>getFirstOne</kwd><def></def><sym>(</sym><def>toFill</def><sym>);</sym><br />
<def>      startRegion</def> <sym>=</sym> <def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def>iPos</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>return false</kwa><def></def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>bool</kwb> <def>Board</def><sym>::</sym><def></def><kwd>hasBadIslandsSingle</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>BitVec</def> <sym>&amp;</sym> <def>boardVec</def><sym>,</sym> <def></def><kwb>int</kwb> <def>row</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def>   BitVec toFill</def> <sym>= ~</sym><def>boardVec</def><sym>;</sym><br />
<def></def>   <kwb>bool</kwb> <def>isOdd</def> <sym>= (</sym><def>row</def> <sym>&amp;</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>isOdd</def><sym>) {</sym><br />
<def>      row</def><sym>--;</sym><br />
<def>      toFill</def> <sym>&lt;&lt;=</sym> <def>N_COL</def><sym>;</sym> <def></def><slc>// shift to even aligned</slc><br />
<def>      toFill</def> <sym>|=</sym> <def>TOP_ROW</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def><br />
   BitVec startRegion</def> <sym>=</sym> <def>TOP_ROW</def><sym>;</sym><br />
<def>   BitVec lastRow</def> <sym>=</sym> <def>TOP_ROW</def> <sym>&lt;&lt; (</sym><def></def><num>5</num> <def></def><sym>*</sym> <def>N_COL</def><sym>);</sym><br />
<def><br />
   BitVec boardMask</def> <sym>=</sym> <def>BOARD_MASK</def><sym>;</sym> <def></def><slc>// all but the first two bits</slc><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>row</def> <sym>&gt;=</sym> <def></def><num>4</num><def></def><sym>) {</sym><br />
<def></def>      <kwb>int</kwb> <def>boardMaskShift</def> <sym>= (</sym><def>row</def> <sym>-</sym> <def></def><num>4</num><def></def><sym>) *</sym> <def>N_COL</def><sym>;</sym><br />
<def>      boardMask</def> <sym>&gt;&gt;=</sym> <def>boardMaskShift</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def>   <kwa>else if</kwa> <def></def><sym>(</sym> <def>isOdd</def> <sym>|| (</sym><def>row</def> <sym>==</sym> <def></def><num>0</num><def></def><sym>)</sym> <def></def><com>/* || (boardVec &amp; lastRow) */</com><def></def><sym>) {</sym><br />
<def>      startRegion</def> <sym>=</sym> <def>lastRow</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def><br />
   toFill</def> <sym>&amp;=</sym> <def>boardMask</def><sym>;</sym><br />
<def>   startRegion</def> <sym>&amp;=</sym> <def>toFill</def><sym>;</sym><br />
<def></def><br />
   <kwa>while</kwa> <def></def><sym>(</sym><def>toFill</def><sym>)    {</sym><br />
<def></def>      <kwa>if</kwa> <def></def><sym>(</sym><def></def><kwd>hasBadFirstRegion</kwd><def></def><sym>(</sym><def>toFill</def><sym>,</sym> <def>startRegion</def><sym>))</sym><br />
<def></def>         <kwa>return true</kwa><def></def><sym>;</sym><br />
<def></def>      <kwb>int</kwb> <def>iPos</def> <sym>=</sym> <def></def><kwd>getFirstOne</kwd><def></def><sym>(</sym><def>toFill</def><sym>);</sym><br />
<def>      startRegion</def> <sym>=</sym> <def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def>iPos</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>return false</kwa><def></def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<slc>// recursive vs iterative?</slc><br />
<def></def><kwb>void</kwb> <def>Board</def><sym>::</sym><def></def><kwd>genAllSolutions</kwd><def></def><sym>(</sym><def>BitVec boardVec</def><sym>,</sym> <def>TUInt32 placedPieces</def><sym>,</sym> <def>TUInt32 row</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <kwa>while</kwa> <def></def><sym>((</sym><def>boardVec</def> <sym>&amp;</sym> <def>TOP_ROW</def><sym>) ==</sym> <def>TOP_ROW</def><sym>) {</sym><br />
<def>      boardVec</def> <sym>&gt;&gt;=</sym> <def>N_COL</def><sym>;</sym><br />
<def>      row</def><sym>++;</sym><br />
<def></def>   <sym>}</sym><br />
<def>   TUInt32 iNextFill</def> <sym>=</sym> <def>s_firstOne</def><sym>[~</sym><def>boardVec</def> <sym>&amp;</sym> <def>TOP_ROW</def><sym>];</sym><br />
<def></def><br />
   <kwb>int</kwb> <def>pieceMask</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iPiece</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iPiece</def> <sym>&lt;</sym> <def>N_PIECE_TYPE</def><sym>;</sym> <def>iPiece</def><sym>++,</sym> <def>pieceMask</def> <sym>&lt;&lt;=</sym> <def></def><num>1</num><def></def><sym>)</sym><br />
<def></def>   <sym>{</sym><br />
<def></def>      <slc>// skip if we've already used this piece</slc><br />
<def></def>      <kwa>if</kwa> <def></def><sym>(</sym><def>pieceMask</def> <sym>&amp;</sym> <def>placedPieces</def><sym>)</sym><br />
<def></def>         <kwa>continue</kwa><def></def><sym>;</sym><br />
<def></def>      <kwb>const</kwb> <def>AllowedPieces</def> <sym>&amp;</sym> <def>allowed</def> <sym>=</sym> <def>g_allowedPieces</def><sym>[</sym><def>row</def><sym>][</sym><def>iNextFill</def><sym>];</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iOrient</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iOrient</def> <sym>&lt;</sym> <def>allowed</def><sym>.</sym><def>nPieces</def><sym>[</sym><def>iPiece</def><sym>];</sym> <def>iOrient</def><sym>++)</sym><br />
<def></def>      <sym>{</sym><br />
<def>         BitVec pieceVec</def> <sym>=</sym> <def>allowed</def><sym>.</sym><def>pieceVec</def><sym>[</sym><def>iPiece</def><sym>][</sym><def>iOrient</def><sym>];</sym><br />
<def></def><br />
         <slc>// check if piece conflicts with other pieces</slc><br />
<def></def>         <kwa>if</kwa> <def></def><sym>(</sym><def>pieceVec</def> <sym>&amp;</sym> <def>boardVec</def><sym>)</sym><br />
<def></def>            <kwa>continue</kwa><def></def><sym>;</sym><br />
<def></def><br />
         <slc>// add the piece to the board</slc><br />
<def>         boardVec</def> <sym>|=</sym> <def>pieceVec</def><sym>;</sym><br />
<def></def><br />
         <kwa>if</kwa> <def></def><sym>(</sym><def></def><kwd>hasBadIslands</kwd><def></def><sym>(</sym><def>boardVec</def><sym>,</sym> <def>row</def><sym>)) {</sym><br />
<def></def>            <slc>// remove the piece from the board vector</slc><br />
<def>            boardVec ^</def><sym>=</sym> <def>pieceVec</def><sym>;</sym><br />
<def></def>            <kwa>continue</kwa><def></def><sym>;</sym><br />
<def></def>         <sym>}</sym><br />
<def></def><br />
         <slc>// mark piece as placed</slc><br />
<def>         placedPieces</def> <sym>|=</sym> <def>pieceMask</def><sym>;</sym><br />
<def>         m_curSolution</def><sym>.</sym><def></def><kwd>addPiece</kwd><def></def><sym>(</sym><def>pieceVec</def><sym>,</sym> <def>iPiece</def><sym>,</sym> <def>row</def><sym>);</sym><br />
<def></def><br />
         <slc>// recur if not done</slc><br />
<def></def>         <kwa>if</kwa> <def></def><sym>(</sym><def>placedPieces</def> <sym>!=</sym> <def>Piece</def><sym>::</sym><def>ALL_PIECE_MASK</def><sym>)</sym><br />
<def></def>            <kwd>genAllSolutions</kwd><def></def><sym>(</sym><def>boardVec</def><sym>,</sym> <def>placedPieces</def><sym>,</sym> <def>row</def><sym>);</sym><br />
<def></def>         <kwa>else</kwa><br />
<def></def>            <kwd>recordSolution</kwd><def></def><sym>(</sym><def>m_curSolution</def><sym>);</sym><br />
<def></def><br />
         <slc>// remove the piece before continuing with a new piece</slc><br />
<def>         boardVec ^</def><sym>=</sym> <def>pieceVec</def><sym>;</sym><br />
<def>         m_curSolution</def><sym>.</sym><def></def><kwd>removeLastPiece</kwd><def></def><sym>();</sym><br />
<def></def>      <sym>}</sym><br />
<def><br />
      placedPieces</def> <sym>&amp;= ~</sym><def>pieceMask</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Board</def><sym>::</sym><def></def><kwd>recordSolution</kwd><def></def><sym>(</sym><def>Solution</def> <sym>&amp;</sym> <def>s</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def>   m_nSolutionFound</def> <sym>+=</sym> <def></def><num>2</num><def></def><sym>;</sym> <def></def><slc>// we add the solution and its rotation</slc><br />
<def></def><br />
   <kwa>if</kwa> <def></def><sym>(</sym><def>m_minSolution</def><sym>.</sym><def></def><kwd>isEmpty</kwd><def></def><sym>()) {</sym><br />
<def>      m_minSolution</def> <sym>=</sym> <def>m_maxSolution</def> <sym>=</sym> <def>s</def><sym>;</sym><br />
<def></def>      <kwa>return</kwa><def></def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>if</kwa> <def></def><sym>(</sym><def>s</def><sym>.</sym><def></def><kwd>lessThan</kwd><def></def><sym>(</sym><def>m_minSolution</def><sym>))</sym><br />
<def>      m_minSolution</def> <sym>=</sym> <def>s</def><sym>;</sym><br />
<def></def>   <kwa>else if</kwa> <def></def><sym>(</sym><def>m_maxSolution</def><sym>.</sym><def></def><kwd>lessThan</kwd><def></def><sym>(</sym><def>s</def><sym>))</sym><br />
<def>      m_maxSolution</def> <sym>=</sym> <def>s</def><sym>;</sym><br />
<def><br />
   Solution spun</def><sym>;</sym><br />
<def>   s</def><sym>.</sym><def></def><kwd>spin</kwd><def></def><sym>(</sym><def>spun</def><sym>);</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>spun</def><sym>.</sym><def></def><kwd>lessThan</kwd><def></def><sym>(</sym><def>m_minSolution</def><sym>))</sym><br />
<def>      m_minSolution</def> <sym>=</sym> <def>spun</def><sym>;</sym><br />
<def></def>   <kwa>else if</kwa> <def></def><sym>(</sym><def>m_maxSolution</def><sym>.</sym><def></def><kwd>lessThan</kwd><def></def><sym>(</sym><def>spun</def><sym>))</sym><br />
<def>      m_maxSolution</def> <sym>=</sym> <def>spun</def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>int</kwb> <def></def><kwd>main</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>argc</def><sym>,</sym> <def></def><kwb>char</kwb> <def></def><sym>*[])</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <kwb>const int</kwb> <def>N_SOLUTION</def> <sym>=</sym> <def></def><num>2098</num><def></def><sym>;</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>argc</def> <sym>&gt;</sym> <def></def><num>2</num><def></def><sym>)</sym><br />
<def></def>      <kwa>return</kwa> <def></def><num>1</num><def></def><sym>;</sym> <def></def><slc>// spec says this is an error</slc><br />
<def><br />
   Board board</def><sym>;</sym><br />
<def>   Piece</def><sym>::</sym><def></def><kwd>genAllOrientations</kwd><def></def><sym>();</sym><br />
<def>   board</def><sym>.</sym><def></def><kwd>genAllSolutions</kwd><def></def><sym>(</sym><def></def><num>0</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>);</sym><br />
<def></def><br />
   <kwb>int</kwb> <def>nFound</def> <sym>=</sym> <def>board</def><sym>.</sym><def>m_nSolutionFound</def><sym>;</sym><br />
<def><br />
   cout</def> <sym>&lt;&lt;</sym> <def>nFound</def> <sym>&lt;&lt;</sym> <def></def><str>&quot; solutions found</str><esc>\n\n</esc><str>&quot;</str><def></def><sym>;</sym><br />
<def>   cout</def> <sym>&lt;&lt;</sym> <def>board</def><sym>.</sym><def>m_minSolution</def><sym>.</sym><def></def><kwd>toString</kwd><def></def><sym>() &lt;&lt;</sym> <def></def><str>'</str><esc>\n</esc><str>'</str><def></def><sym>;</sym><br />
<def>   cout</def> <sym>&lt;&lt;</sym> <def>board</def><sym>.</sym><def>m_maxSolution</def><sym>.</sym><def></def><kwd>toString</kwd><def></def><sym>() &lt;&lt;</sym> <def>endl</def><sym>;</sym><br />
<def></def><br />
   <kwa>if</kwa> <def></def><sym>(</sym><def>nFound</def> <sym>!=</sym> <def>N_SOLUTION</def><sym>)</sym><br />
<def></def>      <kwa>return</kwa> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def><br />
   <kwa>return</kwa> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def><sym>}</sym><def></def><br />
</source>
