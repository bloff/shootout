<source>
<def></def><com>/* The Computer Benchmarks Game</com><br />
<com> * http://shootout.alioth.debian.org/</com><br />
<com> *</com><br />
<com> * contributed by Isaac Gouy</com><br />
<com> * modified by Antti Lankila for generics</com><br />
<com> */</com><def></def><br />
<br />
<kwa>using</kwa> <def>System</def><sym>;</sym><br />
<def></def><kwa>using</kwa> <def>System</def><sym>.</sym><def>IO</def><sym>;</sym><br />
<def></def><kwa>using</kwa> <def>System</def><sym>.</sym><def>Collections</def><sym>.</sym><def>Generic</def><sym>;</sym><br />
<def></def><kwa>using</kwa> <def>System</def><sym>.</sym><def>Text</def><sym>;</sym><br />
<def></def><br />
<kwa>public class</kwa> <def>program</def> <sym>{</sym><br />
<def></def>    <kwa>public static</kwa> <def></def><kwb>void</kwb> <def></def><kwd>Main</kwd><def></def><sym>(</sym><def></def><kwb>string</kwb><def></def><sym>[]</sym> <def>args</def><sym>) {</sym><br />
<def></def>	<kwb>string</kwb> <def>line</def><sym>;</sym><br />
<def>	StreamReader source</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>StreamReader</kwd><def></def><sym>(</sym><def>Console</def><sym>.</sym><def></def><kwd>OpenStandardInput</kwd><def></def><sym>());</sym><br />
<def>	StringBuilder input</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>StringBuilder</kwd><def></def><sym>();</sym><br />
<def></def><br />
	<kwa>while</kwa> <def></def><sym>( (</sym><def>line</def> <sym>=</sym> <def>source</def><sym>.</sym><def></def><kwd>ReadLine</kwd><def></def><sym>() ) !=</sym> <def></def><kwa>null</kwa> <def></def><sym>) {</sym><br />
<def></def>	    <kwa>if</kwa> <def></def><sym>(</sym><def>line</def><sym>[</sym><def></def><num>0</num><def></def><sym>] ==</sym> <def></def><str>'&gt;'</str><def></def> <sym>&amp;&amp;</sym> <def>line</def><sym>.</sym><def></def><kwd>Substring</kwd><def></def><sym>(</sym><def></def><num>1</num><def></def><sym>,</sym> <def></def><num>5</num><def></def><sym>) ==</sym> <def></def><str>&quot;THREE&quot;</str><def></def><sym>)</sym><br />
<def></def>		<kwa>break</kwa><def></def><sym>;</sym><br />
<def></def>	<sym>}</sym><br />
<def></def><br />
	<kwa>while</kwa> <def></def><sym>( (</sym><def>line</def> <sym>=</sym> <def>source</def><sym>.</sym><def></def><kwd>ReadLine</kwd><def></def><sym>()) !=</sym> <def></def><kwa>null</kwa> <def></def><sym>) {</sym><br />
<def></def>            <kwb>char</kwb> <def>c</def> <sym>=</sym> <def>line</def><sym>[</sym><def></def><num>0</num><def></def><sym>];</sym><br />
<def></def>            <kwa>if</kwa> <def></def><sym>(</sym><def>c</def> <sym>==</sym> <def></def><str>'&gt;'</str><def></def><sym>)</sym><br />
<def></def>               <kwa>break</kwa><def></def><sym>;</sym><br />
<def></def>            <kwa>if</kwa> <def></def><sym>(</sym><def>c</def> <sym>!=</sym> <def></def><str>';'</str><def></def><sym>)</sym><br />
<def>               input</def><sym>.</sym><def></def><kwd>Append</kwd><def></def><sym>(</sym><def>line</def><sym>.</sym><def></def><kwd>ToUpper</kwd><def></def><sym>());</sym><br />
<def></def>	<sym>}</sym><br />
<def><br />
	KNucleotide kn</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>KNucleotide</kwd><def></def><sym>(</sym><def>input</def><sym>.</sym><def></def><kwd>ToString</kwd><def></def><sym>());</sym><br />
<def>        input</def> <sym>=</sym> <def></def><kwa>null</kwa><def></def><sym>;</sym><br />
<def>	kn</def><sym>.</sym><def></def><kwd>WriteFrequencies</kwd><def></def><sym>(</sym><def></def><num>1</num><def></def><sym>);</sym><br />
<def>	kn</def><sym>.</sym><def></def><kwd>WriteFrequencies</kwd><def></def><sym>(</sym><def></def><num>2</num><def></def><sym>);</sym><br />
<def><br />
	kn</def><sym>.</sym><def></def><kwd>WriteCount</kwd><def></def><sym>(</sym><def></def><str>&quot;GGT&quot;</str><def></def><sym>);</sym><br />
<def>	kn</def><sym>.</sym><def></def><kwd>WriteCount</kwd><def></def><sym>(</sym><def></def><str>&quot;GGTA&quot;</str><def></def><sym>);</sym><br />
<def>	kn</def><sym>.</sym><def></def><kwd>WriteCount</kwd><def></def><sym>(</sym><def></def><str>&quot;GGTATT&quot;</str><def></def><sym>);</sym><br />
<def>	kn</def><sym>.</sym><def></def><kwd>WriteCount</kwd><def></def><sym>(</sym><def></def><str>&quot;GGTATTTTAATT&quot;</str><def></def><sym>);</sym><br />
<def>	kn</def><sym>.</sym><def></def><kwd>WriteCount</kwd><def></def><sym>(</sym><def></def><str>&quot;GGTATTTTAATTTATAGT&quot;</str><def></def><sym>);</sym><br />
<def></def>    <sym>}</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwa>public class</kwa> <def>KNucleotide</def> <sym>{</sym><br />
<def></def>    <com>/* freq[foo] ++ implies a get and a set. */</com><def></def><br />
    <kwa>internal class</kwa> <def>Value</def> <sym>{</sym><br />
<def></def>	<kwa>internal</kwa> <def></def><kwb>int</kwb> <def>v</def><sym>;</sym><br />
<def></def><br />
	<kwa>internal</kwa> <def></def><kwd>Value</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>v</def><sym>)</sym><br />
<def></def>	<sym>{</sym><br />
<def></def>	    <kwa>this</kwa><def></def><sym>.</sym><def>v</def> <sym>=</sym> <def>v</def><sym>;</sym><br />
<def></def>	<sym>}</sym><br />
<def></def>    <sym>}</sym><br />
<def></def><br />
    <kwa>private</kwa> <def>Dictionary</def><sym>&lt;</sym><def></def><kwb>string</kwb><def></def><sym>,</sym> <def>Value</def><sym>&gt;</sym> <def>frequencies</def> <sym>=</sym> <def></def><kwa>new</kwa> <def>Dictionary</def><sym>&lt;</sym><def></def><kwb>string</kwb><def></def><sym>,</sym> <def>Value</def><sym>&gt;();</sym><br />
<def></def>    <kwa>private</kwa> <def></def><kwb>string</kwb> <def>sequence</def><sym>;</sym><br />
<def></def><br />
    <kwa>public</kwa> <def></def><kwd>KNucleotide</kwd><def></def><sym>(</sym><def></def><kwb>string</kwb> <def>s</def><sym>)</sym><br />
<def></def>    <sym>{</sym><br />
<def>	sequence</def> <sym>=</sym> <def>s</def><sym>;</sym><br />
<def></def>    <sym>}</sym><br />
<def></def><br />
    <kwa>public</kwa> <def></def><kwb>void</kwb> <def></def><kwd>WriteFrequencies</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>nucleotideLength</def><sym>) {</sym><br />
<def></def>	<kwd>GenerateFrequencies</kwd><def></def><sym>(</sym><def>nucleotideLength</def><sym>);</sym><br />
<def><br />
	List</def><sym>&lt;</sym><def>KeyValuePair</def><sym>&lt;</sym><def></def><kwb>string</kwb><def></def><sym>,</sym> <def>Value</def><sym>&gt;&gt;</sym> <def>items</def> <sym>=</sym> <def></def><kwa>new</kwa> <def>List</def><sym>&lt;</sym><def>KeyValuePair</def><sym>&lt;</sym><def></def><kwb>string</kwb><def></def><sym>,</sym> <def>Value</def><sym>&gt;&gt;(</sym><def>frequencies</def><sym>);</sym><br />
<def>	items</def><sym>.</sym><def></def><kwd>Sort</kwd><def></def><sym>(</sym><def>SortByFrequencyAndCode</def><sym>);</sym><br />
<def></def><br />
	<kwb>int</kwb> <def>sum</def> <sym>=</sym> <def>sequence</def><sym>.</sym><def>Length</def> <sym>-</sym> <def>nucleotideLength</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>	<kwa>foreach</kwa> <def></def><sym>(</sym><def>KeyValuePair</def><sym>&lt;</sym><def></def><kwb>string</kwb><def></def><sym>,</sym> <def>Value</def><sym>&gt;</sym> <def>each in items</def><sym>) {</sym><br />
<def></def>	    <kwb>double</kwb> <def>percent</def> <sym>=</sym> <def>each</def><sym>.</sym><def>Value</def><sym>.</sym><def>v</def> <sym>*</sym> <def></def><num>100.0</num> <def></def><sym>/</sym> <def>sum</def><sym>;</sym><br />
<def>	    Console</def><sym>.</sym><def></def><kwd>WriteLine</kwd><def></def><sym>(</sym><def></def><str>&quot;{0} {1:f3}&quot;</str><def></def><sym>,</sym> <def>each</def><sym>.</sym><def>Key</def><sym>,</sym> <def>percent</def><sym>);</sym><br />
<def></def>	<sym>}</sym><br />
<def>	Console</def><sym>.</sym><def></def><kwd>WriteLine</kwd><def></def><sym>(</sym><def></def><str>&quot;&quot;</str><def></def><sym>);</sym><br />
<def></def>    <sym>}</sym><br />
<def></def><br />
    <kwa>public</kwa> <def></def><kwb>void</kwb> <def></def><kwd>WriteCount</kwd><def></def><sym>(</sym><def></def><kwb>string</kwb> <def>nucleotideFragment</def><sym>) {</sym><br />
<def></def>	<kwd>GenerateFrequencies</kwd><def></def><sym>(</sym><def>nucleotideFragment</def><sym>.</sym><def>Length</def><sym>);</sym><br />
<def></def><br />
	<kwb>int</kwb> <def>count</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>	<kwa>if</kwa> <def></def><sym>(</sym><def>frequencies</def><sym>.</sym><def></def><kwd>ContainsKey</kwd><def></def><sym>(</sym><def>nucleotideFragment</def><sym>))</sym><br />
<def>	    count</def> <sym>=</sym> <def>frequencies</def><sym>[</sym><def>nucleotideFragment</def><sym>].</sym><def>v</def><sym>;</sym><br />
<def>	Console</def><sym>.</sym><def></def><kwd>WriteLine</kwd><def></def><sym>(</sym><def></def><str>&quot;{0}</str><esc>\t</esc><str>{1}&quot;</str><def></def><sym>,</sym> <def>count</def><sym>,</sym> <def>nucleotideFragment</def><sym>);</sym><br />
<def></def>    <sym>}</sym><br />
<def></def><br />
    <kwa>private</kwa> <def></def><kwb>void</kwb> <def></def><kwd>GenerateFrequencies</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>length</def><sym>) {</sym><br />
<def>	frequencies</def><sym>.</sym><def></def><kwd>Clear</kwd><def></def><sym>();</sym><br />
<def></def>	<kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>frame</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>frame</def> <sym>&lt;</sym> <def>length</def><sym>;</sym> <def>frame</def><sym>++)</sym><br />
<def></def>	    <kwd>KFrequency</kwd><def></def><sym>(</sym><def>frame</def><sym>,</sym> <def>length</def><sym>);</sym><br />
<def></def>    <sym>}</sym><br />
<def></def><br />
    <kwa>private</kwa> <def></def><kwb>void</kwb> <def></def><kwd>KFrequency</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>readingFrame</def><sym>,</sym> <def></def><kwb>int</kwb> <def>k</def><sym>) {</sym><br />
<def></def>	<kwb>int</kwb> <def>n</def> <sym>=</sym> <def>sequence</def><sym>.</sym><def>Length</def> <sym>-</sym> <def>k</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>	<com>/* string.Substring is a malloc monster :( */</com><def></def><br />
	<kwa>if</kwa> <def></def><sym>(</sym><def>k</def> <sym>&gt;</sym> <def></def><num>6</num><def></def><sym>) {</sym><br />
<def></def>	    <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i</def> <sym>=</sym> <def>readingFrame</def><sym>;</sym> <def>i</def> <sym>&lt;</sym> <def>n</def><sym>;</sym> <def>i</def> <sym>+=</sym> <def>k</def><sym>) {</sym><br />
<def></def>		<kwb>string</kwb> <def>knucleo</def> <sym>=</sym> <def>sequence</def><sym>.</sym><def></def><kwd>Substring</kwd><def></def><sym>(</sym><def>i</def><sym>,</sym> <def>k</def><sym>);</sym><br />
<def></def>		<kwa>if</kwa> <def></def><sym>(</sym><def>frequencies</def><sym>.</sym><def></def><kwd>ContainsKey</kwd><def></def><sym>(</sym><def>knucleo</def><sym>))</sym><br />
<def>		    frequencies</def><sym>[</sym><def>knucleo</def><sym>].</sym><def>v</def> <sym>++;</sym><br />
<def></def>		<kwa>else</kwa><br />
<def>		    frequencies</def><sym>[</sym><def>knucleo</def><sym>] =</sym> <def></def><kwa>new</kwa> <def></def><kwd>Value</kwd><def></def><sym>(</sym><def></def><num>1</num><def></def><sym>);</sym><br />
<def></def>	    <sym>}</sym><br />
<def></def>	<sym>}</sym> <def></def><kwa>else</kwa> <def></def><sym>{</sym><br />
<def></def>	    <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i</def> <sym>=</sym> <def>readingFrame</def><sym>;</sym> <def>i</def> <sym>&lt;</sym> <def>n</def><sym>;</sym> <def>i</def> <sym>+=</sym> <def>k</def><sym>) {</sym><br />
<def></def>		<kwb>string</kwb> <def>knucleo</def> <sym>=</sym> <def>sequence</def><sym>.</sym><def></def><kwd>Substring</kwd><def></def><sym>(</sym><def>i</def><sym>,</sym> <def>k</def><sym>);</sym><br />
<def></def>		<kwa>try</kwa> <def></def><sym>{</sym><br />
<def>		    frequencies</def><sym>[</sym><def>knucleo</def><sym>].</sym><def>v</def> <sym>++;</sym><br />
<def></def>		<sym>}</sym><br />
<def></def>		<kwa>catch</kwa> <def></def><sym>(</sym><def>KeyNotFoundException</def><sym>) {</sym><br />
<def>		    frequencies</def><sym>[</sym><def>knucleo</def><sym>] =</sym> <def></def><kwa>new</kwa> <def></def><kwd>Value</kwd><def></def><sym>(</sym><def></def><num>1</num><def></def><sym>);</sym><br />
<def></def>		<sym>}</sym><br />
<def></def>	    <sym>}</sym><br />
<def></def>	<sym>}</sym><br />
<def></def>    <sym>}</sym><br />
<def></def><br />
    <kwb>int</kwb> <def></def><kwd>SortByFrequencyAndCode</kwd><def></def><sym>(</sym><def>KeyValuePair</def><sym>&lt;</sym><def></def><kwb>string</kwb><def></def><sym>,</sym> <def>Value</def><sym>&gt;</sym> <def>item1</def><sym>,</sym> <def>KeyValuePair</def><sym>&lt;</sym><def></def><kwb>string</kwb><def></def><sym>,</sym> <def>Value</def><sym>&gt;</sym> <def>item2</def><sym>) {</sym><br />
<def></def>	<kwb>int</kwb> <def>comparison</def> <sym>=</sym> <def>item2</def><sym>.</sym><def>Value</def><sym>.</sym><def>v</def><sym>.</sym><def></def><kwd>CompareTo</kwd><def></def><sym>(</sym><def>item1</def><sym>.</sym><def>Value</def><sym>.</sym><def>v</def><sym>);</sym><br />
<def></def>	<kwa>if</kwa> <def></def><sym>(</sym><def>comparison</def> <sym>==</sym> <def></def><num>0</num><def></def><sym>)</sym> <def></def><kwa>return</kwa> <def>item1</def><sym>.</sym><def>Key</def><sym>.</sym><def></def><kwd>CompareTo</kwd><def></def><sym>(</sym><def>item2</def><sym>.</sym><def>Key</def><sym>);</sym><br />
<def></def>	<kwa>else return</kwa> <def>comparison</def><sym>;</sym><br />
<def></def>    <sym>}</sym><br />
<def></def><sym>}</sym><def></def><br />
</source>
