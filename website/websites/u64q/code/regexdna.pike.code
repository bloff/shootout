<source>
<def></def><slc>// ---------------------------------------------------------------------</slc><br />
<def></def><slc>// The Great Computer Language Shootout</slc><br />
<def></def><slc>// http://shootout.alioth.debian.org/</slc><br />
<def></def><slc>//</slc><br />
<def></def><slc>// Requires that the PCRE [Perl Compatible Regular Expression] library</slc><br />
<def></def><slc>// be installed [Pike needs to be rebuilt after this is installed].</slc><br />
<def></def><slc>//</slc><br />
<def></def><slc>// Also, makes use of code from:</slc><br />
<def></def><slc>//</slc><br />
<def></def><slc>//   http://buoy.riverweb.com:8080/viewrep/cvs/pike_modules/Public_Web_Wiki/module.pmod.in/module.pmod</slc><br />
<def></def><slc>//</slc><br />
<def></def><slc>// to approximate the expected [but not currently implemented] functionality</slc><br />
<def></def><slc>// of 'Regexp.split'. Many thanks to Bill Welliver for suggesting this</slc><br />
<def></def><slc>// approach.</slc><br />
<def></def><slc>//</slc><br />
<def></def><slc>// Contributed by Anthony Borla</slc><br />
<def></def><slc>// ---------------------------------------------------------------------</slc><br />
<def></def><br />
<slc>//</slc><br />
<def></def><slc>// Extracted from 'pmod' module</slc><br />
<def></def><slc>//</slc><br />
<def>class BaseRule</def><br />
<sym>{</sym><br />
<def></def>  <kwb>constant</kwb> <def>type</def> <sym>=</sym> <def></def><str>&quot;BaseRule&quot;</str><def></def><sym>;</sym><br />
<def></def>  <kwb>static object</kwb> <def>regexp</def><sym>;</sym><br />
<def></def>  <kwb>static function</kwb> <def>split_fun</def><sym>;</sym><br />
<def></def>  <kwb>int</kwb> <def>max_iterations</def> <sym>=</sym> <def></def><num>10</num><def></def><sym>;</sym><br />
<def></def><br />
  <kwb>string</kwb> <def></def><kwd>_sprintf</kwd><def></def><sym>(</sym><def></def><kwb>mixed</kwb> <def>... args</def><sym>)</sym><br />
<def></def>  <sym>{</sym><br />
<def>    return</def> <kwa>sprintf</kwa><def></def><sym>(</sym><def></def><str>&quot;%s(%s)&quot;</str><def></def><sym>,</sym> <def>type</def><sym>,</sym> <def>regexp</def><sym>-&gt;</sym><def>pattern</def><sym>);</sym><br />
<def></def>  <sym>}</sym><br />
<def></def><br />
  <kwb>void</kwb> <def></def><kwd>create</kwd><def></def><sym>(</sym><def></def><kwb>string</kwb> <def>match</def><sym>)</sym><br />
<def></def>  <sym>{</sym><br />
<def>    regexp</def> <sym>=</sym> <def></def><kwd>_Regexp_PCRE</kwd><def></def><sym>(</sym><def>match</def><sym>,</sym> <def>Regexp.PCRE.OPTION.MULTILINE</def><sym>);</sym><br />
<def>    split_fun</def> <sym>=</sym> <def>regexp</def><sym>-&gt;</sym><def>split</def><sym>;</sym><br />
<def></def>  <sym>}</sym><br />
<def></def><br />
  <kwb>array</kwb> <def></def><kwa>replace</kwa><def></def><sym>(</sym><def></def><kwb>string</kwb> <def>subject</def><sym>,</sym><def></def><kwb>string</kwb><def></def><sym>|</sym><def></def><kwb>function</kwb> <def>with</def><sym>,</sym> <def></def><kwb>mixed</kwb><def></def><sym>|</sym><def></def><kwb>void</kwb> <def>... args</def><sym>)</sym><br />
<def></def>  <sym>{</sym><br />
<def></def>    <kwb>int</kwb> <def>i</def><sym>=</sym><def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>    <kwb>array</kwb> <def>res</def> <sym>= ({});</sym><br />
<def></def><br />
    <kwd>for</kwd> <def></def><sym>(;;)</sym><br />
<def></def>    <sym>{</sym><br />
<def></def>      <kwb>array</kwb> <def>substrings</def> <sym>= ({});</sym><br />
<def></def>      <kwb>array</kwb><def></def><sym>(</sym><def></def><kwb>int</kwb><def></def><sym>)|</sym><def></def><kwb>int</kwb> <def>v</def><sym>=</sym><def>regexp</def><sym>-&gt;</sym><def></def><kwd>exec</kwd><def></def><sym>(</sym><def>subject</def><sym>,</sym><def>i</def><sym>);</sym><br />
<def></def><br />
      <kwd>if</kwd> <def></def><sym>(</sym><def></def><kwa>intp</kwa><def></def><sym>(</sym><def>v</def><sym>) &amp;&amp; !</sym><def>regexp</def><sym>-&gt;</sym><def></def><kwd>handle_exec_error</kwd><def></def><sym>([</sym><def></def><kwb>int</kwb><def></def><sym>]</sym><def>v</def><sym>))</sym> <def>break</def><sym>;</sym><br />
<def></def><br />
      <kwd>if</kwd> <def></def><sym>(</sym><def>v</def><sym>[</sym><def></def><num>0</num><def></def><sym>]&gt;</sym><def>i</def><sym>)</sym> <def>res</def><sym>+=({</sym><def>subject</def><sym>[</sym><def>i..v</def><sym>[</sym><def></def><num>0</num><def></def><sym>]-</sym><def></def><num>1</num><def></def><sym>]});</sym><br />
<def></def><br />
      <kwd>if</kwd><def></def><sym>(</sym><def></def><kwa>sizeof</kwa><def></def><sym>(</sym><def>v</def><sym>)&gt;</sym><def></def><num>2</num><def></def><sym>)</sym><br />
<def></def>      <sym>{</sym><br />
<def></def>        <kwb>int</kwb> <def>c</def> <sym>=</sym> <def></def><num>2</num><def></def><sym>;</sym><br />
<def>        do</def><br />
        <sym>{</sym><br />
<def>          substrings</def> <sym>+= ({</sym> <def>subject</def><sym>[</sym><def>v</def><sym>[</sym><def>c</def><sym>]</sym><def>..</def><sym>(</sym><def>v</def><sym>[</sym><def>c</def><sym>+</sym><def></def><num>1</num><def></def><sym>]-</sym><def></def><num>1</num><def></def><sym>)] });</sym><br />
<def>          c</def><sym>+=</sym><def></def><num>2</num><def></def><sym>;</sym><br />
<def></def>        <sym>}</sym><br />
<def></def>        <kwd>while</kwd><def></def><sym>(</sym><def>c</def><sym>&lt;= (</sym><def></def><kwa>sizeof</kwa><def></def><sym>(</sym><def>v</def><sym>)-</sym><def></def><num>2</num><def></def><sym>));</sym><br />
<def></def>      <sym>}</sym><br />
<def></def><br />
      <kwd>if</kwd> <def></def><sym>(</sym><def></def><kwa>stringp</kwa><def></def><sym>(</sym><def>with</def><sym>))</sym> <def>res</def><sym>+=({</sym><def>with</def><sym>});</sym><br />
<def>      else</def> <sym>{</sym> <def></def><kwb>array</kwb> <def>o</def> <sym>=</sym> <def></def><kwd>with</kwd><def></def><sym>(</sym><def>subject</def><sym>[</sym><def>v</def><sym>[</sym><def></def><num>0</num><def></def><sym>]</sym><def>..v</def><sym>[</sym><def></def><num>1</num><def></def><sym>]-</sym><def></def><num>1</num><def></def><sym>],</sym> <def>substrings</def><sym>,</sym> <def>@args</def><sym>);</sym> <def>res</def><sym>+=</sym><def>o</def><sym>; }</sym><br />
<def><br />
      i</def><sym>=</sym><def>v</def><sym>[</sym><def></def><num>1</num><def></def><sym>];</sym><br />
<def></def>    <sym>}</sym><br />
<def><br />
    res</def><sym>+=({</sym><def>subject</def><sym>[</sym><def>i..</def><sym>]});</sym><br />
<def>    return res</def><sym>;</sym><br />
<def></def>  <sym>}</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<slc>// --------------------------------</slc><br />
<def></def><br />
<kwb>constant</kwb> <def>VARIANTS</def> <sym>= ({</sym><br />
<def></def>  <str>&quot;agggtaaa|tttaccct&quot;</str><def></def><sym>,</sym> <def></def><str>&quot;[cgt]gggtaaa|tttaccc[acg]&quot;</str><def></def><sym>,</sym> <def></def><str>&quot;a[act]ggtaaa|tttacc[agt]t&quot;</str><def></def><sym>,</sym><br />
<def></def>  <str>&quot;ag[act]gtaaa|tttac[agt]ct&quot;</str><def></def><sym>,</sym> <def></def><str>&quot;agg[act]taaa|ttta[agt]cct&quot;</str><def></def><sym>,</sym> <def></def><str>&quot;aggg[acg]aaa|ttt[cgt]ccct&quot;</str><def></def><sym>,</sym><br />
<def></def>  <str>&quot;agggt[cgt]aa|tt[acg]accct&quot;</str><def></def><sym>,</sym> <def></def><str>&quot;agggta[cgt]a|t[acg]taccct&quot;</str><def></def><sym>,</sym> <def></def><str>&quot;agggtaa[cgt]|[acg]ttaccct&quot;</str><def></def><sym>});</sym><br />
<def></def><br />
<kwb>constant</kwb> <def>IUBS</def> <sym>= ([</sym><br />
<def></def>  <str>&quot;B&quot;</str><def></def><sym>:</sym><def></def><str>&quot;(c|g|t)&quot;</str><def></def><sym>,</sym> <def></def><str>&quot;D&quot;</str><def></def><sym>:</sym><def></def><str>&quot;(a|g|t)&quot;</str><def></def><sym>,</sym> <def></def><str>&quot;H&quot;</str><def></def><sym>:</sym><def></def><str>&quot;(a|c|t)&quot;</str><def></def><sym>,</sym> <def></def><str>&quot;K&quot;</str><def></def><sym>:</sym><def></def><str>&quot;(g|t)&quot;</str><def></def><sym>,</sym><br />
<def></def>  <str>&quot;M&quot;</str><def></def><sym>:</sym><def></def><str>&quot;(a|c)&quot;</str><def></def><sym>,</sym> <def></def><str>&quot;N&quot;</str><def></def><sym>:</sym><def></def><str>&quot;(a|c|g|t)&quot;</str><def></def><sym>,</sym> <def></def><str>&quot;R&quot;</str><def></def><sym>:</sym><def></def><str>&quot;(a|g)&quot;</str><def></def><sym>,</sym> <def></def><str>&quot;S&quot;</str><def></def><sym>:</sym><def></def><str>&quot;(c|g)&quot;</str><def></def><sym>,</sym><br />
<def></def>  <str>&quot;V&quot;</str><def></def><sym>:</sym><def></def><str>&quot;(a|c|g)&quot;</str><def></def><sym>,</sym> <def></def><str>&quot;W&quot;</str><def></def><sym>:</sym><def></def><str>&quot;(a|t)&quot;</str><def></def><sym>,</sym> <def></def><str>&quot;Y&quot;</str><def></def><sym>:</sym><def></def><str>&quot;(c|t)&quot;</str><def></def><sym>]);</sym><br />
<def></def><br />
<slc>// --------------------------------</slc><br />
<def></def><br />
<kwb>int</kwb> <def></def><kwd>main</kwd><def></def><sym>()</sym><br />
<def></def><sym>{</sym><br />
<def></def>  <slc>// Read input data into string and record its length</slc><br />
<def></def>  <kwb>string</kwb> <def>seq</def> <sym>=</sym> <def>Stdio.stdin</def><sym>-&gt;</sym><def></def><kwd>read</kwd><def></def><sym>();</sym> <def></def><kwb>int</kwb> <def>initial_length</def> <sym>=</sym> <def></def><kwa>sizeof</kwa><def></def><sym>(</sym><def>seq</def><sym>);</sym><br />
<def></def><br />
  <slc>// Remove all newline and segment divider line occurrences</slc><br />
<def>  seq</def> <sym>=</sym> <def>Regexp.</def><kwa>replace</kwa><def></def><sym>(</sym><def></def><str>&quot;(&gt;.*</str><esc>\n</esc><str>)|(</str><esc>\n</esc><str>)&quot;</str><def></def><sym>,</sym> <def>seq</def><sym>,</sym> <def></def><str>&quot;&quot;</str><def></def><sym>);</sym> <def></def><kwb>int</kwb> <def>code_length</def> <sym>=</sym> <def></def><kwa>sizeof</kwa><def></def><sym>(</sym><def>seq</def><sym>);</sym><br />
<def></def><br />
  <slc>// Perform regexp counts</slc><br />
<def></def>  <kwd>foreach</kwd><def></def><sym>(</sym><def>VARIANTS</def><sym>,</sym> <def></def><kwb>string</kwb> <def>var</def><sym>)</sym><br />
<def></def>  <sym>{</sym><br />
<def></def>    <slc>// 'Regexp.split' version would probably look like this:</slc><br />
<def></def>    <slc>//</slc><br />
<def></def>    <slc>// int number_of_matches; string pattern = &quot;(?i)&quot; + var;</slc><br />
<def></def>    <slc>//</slc><br />
<def></def>    <slc>// if (array(string) matches = Regexp.split(pattern, seq))</slc><br />
<def></def>    <slc>//   number_of_matches = sizeof(matches);</slc><br />
<def></def>    <slc>//</slc><br />
<def></def><br />
    <slc>// 'pmod' module version</slc><br />
<def></def>    <kwb>int</kwb> <def>number_of_matches</def> <sym>=</sym> <def></def><kwa>sizeof</kwa><def></def><sym>(</sym><def></def><kwd>BaseRule</kwd><def></def><sym>(</sym><def></def><str>&quot;(?i)&quot;</str><def></def> <sym>+</sym> <def>var</def><sym>)-&gt;</sym><def></def><kwa>replace</kwa><def></def><sym>(</sym><def>seq</def><sym>,</sym> <def></def><str>&quot;&quot;</str><def></def><sym>)) /</sym> <def></def><num>2</num><def></def><sym>;</sym><br />
<def></def><br />
    <kwa>write</kwa><def></def><sym>(</sym><def></def><str>&quot;%s %d</str><esc>\n</esc><str>&quot;</str><def></def><sym>,</sym> <def>var</def><sym>,</sym> <def>number_of_matches</def><sym>);</sym><br />
<def></def>  <sym>}</sym><br />
<def></def><br />
  <slc>// Perform replacements</slc><br />
<def></def>  <kwd>foreach</kwd><def></def><sym>(</sym><def></def><kwa>indices</kwa><def></def><sym>(</sym><def>IUBS</def><sym>),</sym> <def></def><kwb>string</kwb> <def>key</def><sym>)</sym><br />
<def></def>  <sym>{</sym><br />
<def>    seq</def> <sym>=</sym> <def>Regexp.</def><kwa>replace</kwa><def></def><sym>(</sym><def>key</def><sym>,</sym> <def>seq</def><sym>,</sym> <def>IUBS</def><sym>[</sym><def>key</def><sym>]);</sym><br />
<def></def>  <sym>}</sym><br />
<def></def><br />
  <slc>// Print statistics</slc><br />
<def></def>  <kwa>write</kwa><def></def><sym>(</sym><def></def><str>&quot;</str><esc>\n</esc><str>%d</str><esc>\n</esc><str>%d</str><esc>\n</esc><str>%d</str><esc>\n</esc><str>&quot;</str><def></def><sym>,</sym> <def>initial_length</def><sym>,</sym> <def>code_length</def><sym>,</sym> <def></def><kwa>sizeof</kwa><def></def><sym>(</sym><def>seq</def><sym>));</sym><br />
<def><br />
  return</def> <num>0</num><def></def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
</source>
