<source>
<def></def><com>(*</com><br />
<com>  The Computer Language Benchmarks Game</com><br />
<com>  http://shootout.alioth.debian.org</com><br />
<com></com><br />
<com>  contributed by Vitaly Trifonof</com><br />
<com>*)</com><def></def><br />
<br />
<com>{$INLINE ON}</com><def></def><br />
<com>{$CHECKPOINTER OFF}</com><def></def><br />
<com>{$RANGECHECKS OFF}</com><def></def><br />
<com>{$OVERFLOWCHECKS OFF}</com><def></def><br />
<com>{$VARSTRINGCHECKS OFF}</com><def></def><br />
<com>{$IOCHECKS OFF}</com><def></def><br />
<com>{$OPTIMIZATION TAILREC}</com><def></def><br />
<br />
<kwa>uses</kwa> <def>regexpr</def><sym>,</sym> <def>sysutils</def><sym>;</sym><br />
<def></def><br />
<br />
<kwa>var</kwa><br />
<def>  seqLen</def><sym>:</sym> <def></def><kwb>Cardinal</kwb> <def></def><sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def>  seqCleanLen</def><sym>:</sym> <def></def><kwb>Cardinal</kwb> <def></def><sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def><br />
<br />
<kwa>function</kwa> <def>getchar</def><sym>:</sym> <def></def><kwb>Char</kwb><def></def><sym>;</sym> <def></def><kwa>inline</kwa><def></def><sym>;</sym><br />
<def></def><kwa>var</kwa><br />
<def>  ch</def><sym>:</sym> <def></def><kwb>Char</kwb><def></def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def>  seqLen</def> <sym>+=</sym> <def></def><num>1</num><def></def><sym>;</sym>  <def></def><kwd>read</kwd><def></def><sym>(</sym><def>ch</def><sym>);</sym>  <def>getchar</def> <sym>:=</sym> <def>ch</def><br />
<kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><br />
<br />
<kwa>var</kwa><br />
<def>  patterns</def> <sym>:</sym> <def></def><kwa>array</kwa><def></def><sym>[</sym><def></def><num>0</num><def></def><sym>.</sym><def></def><num>.8</num><def></def><sym>]</sym> <def></def><kwa>of</kwa> <def>PChar</def> <sym>=</sym><br />
<def></def>    <sym>(</sym><br />
<def></def>      <str>'(agggtaaa)|(tttaccct)'</str><def></def><sym>,</sym><br />
<def></def>      <str>'([cgt]gggtaaa)|(tttaccc[acg])'</str><def></def><sym>,</sym><br />
<def></def>      <str>'(a[act]ggtaaa)|(tttacc[agt]t)'</str><def></def><sym>,</sym><br />
<def></def>      <str>'(ag[act]gtaaa)|(tttac[agt]ct)'</str><def></def><sym>,</sym><br />
<def></def>      <str>'(agg[act]taaa)|(ttta[agt]cct)'</str><def></def><sym>,</sym><br />
<def></def>      <str>'(aggg[acg]aaa)|(ttt[cgt]ccct)'</str><def></def><sym>,</sym><br />
<def></def>      <str>'(agggt[cgt]aa)|(tt[acg]accct)'</str><def></def><sym>,</sym><br />
<def></def>      <str>'(agggta[cgt]a)|(t[acg]taccct)'</str><def></def><sym>,</sym><br />
<def></def>      <str>'(agggtaa[cgt])|([acg]ttaccct)'</str><def></def><br />
    <sym>);</sym><br />
<def></def><br />
<br />
<kwa>function</kwa> <def></def><kwd>findExpr</kwd><def></def><sym>(</sym> <def>regexp</def><sym>,</sym> <def>seq</def><sym>:</sym> <def>PChar</def> <sym>):</sym> <def></def><kwb>Longint</kwb><def></def><sym>;</sym> <def></def><kwa>inline</kwa><def></def><sym>;</sym><br />
<def></def><kwa>var</kwa><br />
<def>  cregexp</def> <sym>:</sym> <def>TRegExprEngine</def><sym>;</sym><br />
<def>  count</def><sym>,</sym> <def>index</def><sym>,</sym> <def>tmpInt</def><sym>:</sym> <def></def><kwb>Longint</kwb><def></def><sym>;</sym><br />
<def>  tmpseq</def><sym>:</sym> <def>PChar</def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def>  count</def> <sym>:=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>tmpseq</def> <sym>:=</sym> <def>seq</def><sym>;</sym><br />
<def></def>  <kwd>GenerateRegExprEngine</kwd><def></def><sym>(</sym> <def>regexp</def><sym>, [</sym><def>ref_caseinsensitive</def><sym>],</sym> <def>cregexp</def><sym>);</sym><br />
<def></def><br />
  <kwa>while</kwa> <def></def><kwd>RegExprPos</kwd><def></def><sym>(</sym><def>cregexp</def><sym>,</sym> <def>tmpseq</def><sym>,</sym> <def>index</def><sym>,</sym> <def>tmpInt</def><sym>)</sym> <def></def><kwa>do</kwa><br />
<def></def>  <kwa>begin</kwa><br />
<def>    count</def> <sym>+=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def>    tmpseq</def> <sym>:= @(</sym><def>tmpseq</def><sym>[</sym><def>index</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>]);</sym><br />
<def></def>  <kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><br />
  <kwd>DestroyRegExprEngine</kwd><def></def><sym>(</sym> <def>cregexp</def> <sym>);</sym><br />
<def>  findExpr</def> <sym>:=</sym> <def>count</def><br />
<kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><br />
<br />
<kwa>function</kwa> <def></def><kwd>findSplitExpr</kwd> <def></def><sym>(</sym> <def>regexp</def><sym>,</sym><def>seq</def><sym>:</sym> <def>PChar</def> <sym>):</sym> <def></def><kwb>Longint</kwb><def></def><sym>;</sym> <def></def><kwa>inline</kwa><def></def><sym>;</sym><br />
<def></def><kwa>var</kwa><br />
<def>  split</def><sym>:</sym> <def>PChar</def><sym>;</sym><br />
<def>  count</def><sym>:</sym> <def></def><kwb>Longint</kwb><def></def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def>  split</def> <sym>:=</sym> <def></def><kwd>strscan</kwd><def></def><sym>(</sym><def>regexp</def><sym>,</sym> <def></def><str>'|'</str><def></def><sym>);</sym><br />
<def></def>  <kwb>Byte</kwb><def></def><sym>(</sym><def>split</def><sym>^) :=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def><br />
  count</def> <sym>:=</sym> <def></def><kwd>findExpr</kwd><def></def><sym>(</sym><def>regexp</def><sym>,</sym> <def>seq</def><sym>);</sym><br />
<def>  count</def> <sym>+=</sym> <def></def><kwd>findExpr</kwd><def></def><sym>(@</sym><def>split</def><sym>[</sym><def></def><num>1</num><def></def><sym>],</sym> <def>seq</def><sym>);</sym><br />
<def>  split</def><sym>^ :=</sym> <def></def><str>'|'</str><def></def><sym>;</sym><br />
<def>  findSplitExpr</def> <sym>:=</sym> <def>count</def><br />
<kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><br />
<com>(* calculate needed size for malloc *)</com><def></def><br />
<kwa>function</kwa> <def></def><kwd>addSize</kwd><def></def><sym>(</sym> <def>seq</def><sym>:</sym> <def>PChar</def> <sym>):</sym> <def></def><kwb>Cardinal</kwb><def></def><sym>;</sym> <def></def><kwa>inline</kwa><def></def><sym>;</sym><br />
<def></def><kwa>var</kwa><br />
<def>  count</def><sym>:</sym> <def></def><kwb>Cardinal</kwb> <def></def><sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def>  tmpseq</def><sym>:</sym> <def>PChar</def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def>  tmpseq</def> <sym>:=</sym> <def>seq</def><sym>;</sym><br />
<def></def>  <kwa>while</kwa> <def></def><kwb>Byte</kwb><def></def><sym>(</sym><def>tmpseq</def><sym>^) &lt;&gt;</sym> <def></def><num>0</num> <def></def><kwa>do</kwa><br />
<def></def>  <kwa>begin</kwa><br />
<def></def>    <kwa>case</kwa> <def>tmpseq</def><sym>^</sym> <def></def><kwa>of</kwa><br />
<def></def>      <str>'B'</str><def></def><sym>:</sym>    <def>count</def> <sym>+=</sym> <def></def><num>6</num><def></def><sym>;</sym>  <def></def><slc>//(c|g|t)</slc><br />
<def></def>      <str>'D'</str><def></def><sym>:</sym>    <def>count</def> <sym>+=</sym> <def></def><num>6</num><def></def><sym>;</sym>  <def></def><slc>//(a|g|t)</slc><br />
<def></def>      <str>'H'</str><def></def><sym>:</sym>    <def>count</def> <sym>+=</sym> <def></def><num>6</num><def></def><sym>;</sym>  <def></def><slc>//(a|c|t)</slc><br />
<def></def>      <str>'K'</str><def></def><sym>:</sym>    <def>count</def> <sym>+=</sym> <def></def><num>4</num><def></def><sym>;</sym>  <def></def><slc>//(g|t)</slc><br />
<def></def>      <str>'M'</str><def></def><sym>:</sym>    <def>count</def> <sym>+=</sym> <def></def><num>4</num><def></def><sym>;</sym>  <def></def><slc>//(a|c)</slc><br />
<def></def>      <str>'N'</str><def></def><sym>:</sym>    <def>count</def> <sym>+=</sym> <def></def><num>8</num><def></def><sym>;</sym>  <def></def><slc>//(a|c|g|t)</slc><br />
<def></def>      <str>'R'</str><def></def><sym>:</sym>    <def>count</def> <sym>+=</sym> <def></def><num>4</num><def></def><sym>;</sym>  <def></def><slc>//(a|g)</slc><br />
<def></def>      <str>'S'</str><def></def><sym>:</sym>    <def>count</def> <sym>+=</sym> <def></def><num>4</num><def></def><sym>;</sym>  <def></def><slc>//(c|t)</slc><br />
<def></def>      <str>'V'</str><def></def><sym>:</sym>    <def>count</def> <sym>+=</sym> <def></def><num>6</num><def></def><sym>;</sym>  <def></def><slc>//(a|c|g)</slc><br />
<def></def>      <str>'W'</str><def></def><sym>:</sym>    <def>count</def> <sym>+=</sym> <def></def><num>4</num><def></def><sym>;</sym>  <def></def><slc>//(a|t)</slc><br />
<def></def>      <str>'Y'</str><def></def><sym>:</sym>    <def>count</def> <sym>+=</sym> <def></def><num>4</num><def></def><sym>;</sym>  <def></def><slc>//(c|t)</slc><br />
<def></def>    <kwa>end</kwa><def></def><sym>;</sym><br />
<def>    tmpseq</def> <sym>:= @</sym><def>tmpseq</def><sym>[</sym><def></def><num>1</num><def></def><sym>]</sym><br />
<def></def>  <kwa>end</kwa><def></def><sym>;</sym><br />
<def>  addSize</def> <sym>:=</sym> <def>count</def><br />
<kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><br />
<com>(* IUB replace *)</com><def></def><br />
<kwa>procedure</kwa> <def></def><kwd>replace</kwd><def></def><sym>(</sym> <def>seq</def><sym>:</sym> <def>PChar</def><sym>;</sym> <def></def><kwa>var</kwa> <def>newSeq</def><sym>:</sym> <def>PChar</def> <sym>);</sym> <def></def><kwa>inline</kwa><def></def><sym>;</sym><br />
<def></def><kwa>var</kwa><br />
<def>  itmpseq</def><sym>,</sym> <def>otmpseq</def><sym>:</sym> <def>PChar</def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def></def>  <kwd>GetMem</kwd><def></def><sym>(</sym><def>newSeq</def><sym>,</sym> <def></def><kwd>SizeOf</kwd><def></def><sym>(</sym><def></def><kwb>Char</kwb><def></def><sym>)*(</sym><def>seqCleanLen</def> <sym>+</sym> <def></def><kwd>addSize</kwd><def></def><sym>(</sym><def>seq</def><sym>) +</sym> <def></def><num>1</num><def></def><sym>));</sym><br />
<def>  itmpseq</def> <sym>:=</sym> <def>seq</def><sym>;</sym> <def>otmpseq</def> <sym>:=</sym> <def>newSeq</def><sym>;</sym><br />
<def></def>  <kwa>while</kwa> <def></def><kwb>Byte</kwb><def></def><sym>(</sym><def>itmpseq</def><sym>^) &lt;&gt;</sym> <def></def><num>0</num> <def></def><kwa>do</kwa><br />
<def></def>  <kwa>begin</kwa><br />
<def></def>    <kwa>case</kwa> <def>itmpseq</def><sym>^</sym> <def></def><kwa>of</kwa><br />
<def></def>      <str>'B'</str><def></def><sym>:</sym>  <def>otmpseq</def> <sym>:=</sym> <def></def><kwd>strecopy</kwd><def></def><sym>(</sym><def>otmpseq</def><sym>,</sym><def></def><str>'(c|g|t)'</str><def></def><sym>);</sym><br />
<def></def>      <str>'D'</str><def></def><sym>:</sym>  <def>otmpseq</def> <sym>:=</sym> <def></def><kwd>strecopy</kwd><def></def><sym>(</sym><def>otmpseq</def><sym>,</sym><def></def><str>'(a|g|t)'</str><def></def><sym>);</sym><br />
<def></def>      <str>'H'</str><def></def><sym>:</sym>  <def>otmpseq</def> <sym>:=</sym> <def></def><kwd>strecopy</kwd><def></def><sym>(</sym><def>otmpseq</def><sym>,</sym><def></def><str>'(a|c|t)'</str><def></def><sym>);</sym><br />
<def></def>      <str>'K'</str><def></def><sym>:</sym>  <def>otmpseq</def> <sym>:=</sym> <def></def><kwd>strecopy</kwd><def></def><sym>(</sym><def>otmpseq</def><sym>,</sym><def></def><str>'(g|t)'</str><def></def><sym>);</sym><br />
<def></def>      <str>'M'</str><def></def><sym>:</sym>  <def>otmpseq</def> <sym>:=</sym> <def></def><kwd>strecopy</kwd><def></def><sym>(</sym><def>otmpseq</def><sym>,</sym><def></def><str>'(a|c)'</str><def></def><sym>);</sym><br />
<def></def>      <str>'N'</str><def></def><sym>:</sym>  <def>otmpseq</def> <sym>:=</sym> <def></def><kwd>strecopy</kwd><def></def><sym>(</sym><def>otmpseq</def><sym>,</sym><def></def><str>'(a|c|g|t)'</str><def></def><sym>);</sym><br />
<def></def>      <str>'R'</str><def></def><sym>:</sym>  <def>otmpseq</def> <sym>:=</sym> <def></def><kwd>strecopy</kwd><def></def><sym>(</sym><def>otmpseq</def><sym>,</sym><def></def><str>'(a|g)'</str><def></def><sym>);</sym><br />
<def></def>      <str>'S'</str><def></def><sym>:</sym>  <def>otmpseq</def> <sym>:=</sym> <def></def><kwd>strecopy</kwd><def></def><sym>(</sym><def>otmpseq</def><sym>,</sym><def></def><str>'(c|t)'</str><def></def><sym>);</sym><br />
<def></def>      <str>'V'</str><def></def><sym>:</sym>  <def>otmpseq</def> <sym>:=</sym> <def></def><kwd>strecopy</kwd><def></def><sym>(</sym><def>otmpseq</def><sym>,</sym><def></def><str>'(a|c|g)'</str><def></def><sym>);</sym><br />
<def></def>      <str>'W'</str><def></def><sym>:</sym>  <def>otmpseq</def> <sym>:=</sym> <def></def><kwd>strecopy</kwd><def></def><sym>(</sym><def>otmpseq</def><sym>,</sym><def></def><str>'(a|t)'</str><def></def><sym>);</sym><br />
<def></def>      <str>'Y'</str><def></def><sym>:</sym>  <def>otmpseq</def> <sym>:=</sym> <def></def><kwd>strecopy</kwd><def></def><sym>(</sym><def>otmpseq</def><sym>,</sym><def></def><str>'(c|t)'</str><def></def><sym>);</sym><br />
<def></def>    <kwa>else</kwa><br />
<def>      otmpseq</def><sym>^ :=</sym> <def>itmpseq</def><sym>^;</sym><br />
<def>      otmpseq</def> <sym>:= @</sym><def>otmpseq</def><sym>[</sym><def></def><num>1</num><def></def><sym>]</sym><br />
<def></def>    <kwa>end</kwa><def></def><sym>;</sym><br />
<def>    itmpseq</def> <sym>:= @</sym><def>itmpseq</def><sym>[</sym><def></def><num>1</num><def></def><sym>]</sym><br />
<def></def>  <kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><br />
<br />
<kwa>var</kwa><br />
<def>  seq</def><sym>,</sym> <def>newSeq</def><sym>:</sym> <def>PChar</def><sym>;</sym><br />
<def>  maxSeqLen</def><sym>:</sym> <def></def><kwb>Cardinal</kwb> <def></def><sym>=</sym> <def></def><num>6000000</num><def></def><sym>;</sym><br />
<def>  ch</def><sym>:</sym> <def></def><kwb>Char</kwb><def></def><sym>;</sym><br />
<def>  i</def><sym>:</sym> <def></def><kwb>Longint</kwb><def></def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def></def>  <kwd>GetMem</kwd><def></def><sym>(</sym><def>seq</def><sym>,</sym> <def></def><kwd>SizeOf</kwd><def></def><sym>(</sym><def></def><kwb>Char</kwb><def></def><sym>)*(</sym><def>maxSeqLen</def><sym>+</sym><def></def><num>1</num><def></def><sym>));</sym><br />
<def></def><br />
<com>(* Read FASTA format file from stdin</com><br />
<com>   Count length and remove the unwanted elements  *)</com><def></def><br />
  <kwa>while not</kwa> <def>eof</def> <kwa>do</kwa><br />
<def></def>  <kwa>begin</kwa><br />
<def>    ch</def> <sym>:=</sym> <def>getchar</def><sym>;</sym><br />
<def></def><br />
    <kwa>if</kwa> <def>ch</def> <sym>&lt;&gt;</sym> <def></def><str>'&gt;'</str><def></def> <kwa>then</kwa><br />
<def></def>    <kwa>begin</kwa><br />
<def></def>      <kwa>if</kwa> <def>seqCleanLen</def> <sym>=</sym> <def>maxSeqLen</def> <kwa>then</kwa><br />
<def></def>      <kwa>begin</kwa><br />
<def>        maxSeqLen</def> <sym>+=</sym> <def></def><num>2000000</num><def></def><sym>;</sym><br />
<def>        seq</def> <sym>:=</sym> <def></def><kwd>ReAllocMem</kwd><def></def><sym>(</sym><def>seq</def><sym>,</sym> <def></def><kwd>SizeOf</kwd><def></def><sym>(</sym><def></def><kwb>Char</kwb><def></def><sym>)*(</sym><def>maxSeqLen</def><sym>+</sym><def></def><num>2</num><def></def><sym>) );</sym><br />
<def></def>      <kwa>end</kwa><def></def><sym>;</sym><br />
<def>      seq</def><sym>[</sym><def>seqCleanLen</def><sym>] :=</sym> <def>ch</def><sym>;</sym><br />
<def>      seqCleanLen</def> <sym>+=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>      <kwa>if</kwa> <def>eoln</def> <kwa>then</kwa><br />
<def>        getchar</def><br />
    <kwa>end</kwa><br />
<def></def>    <kwa>else</kwa><br />
<def></def>    <kwa>begin</kwa><br />
<def></def>      <kwa>repeat</kwa><br />
<def>        getchar</def><br />
      <kwa>until</kwa> <def>eoln</def><sym>;</sym><br />
<def>      getchar</def><br />
    <kwa>end</kwa><br />
<def></def>  <kwa>end</kwa><def></def><sym>;</sym><br />
<def></def>  <kwb>Byte</kwb><def></def><sym>(</sym><def>seq</def><sym>[</sym><def>seqCleanLen</def><sym>]) :=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def></def><slc>//end read data</slc><br />
<def></def><br />
<com>(* Count matches *)</com><def></def><br />
<com>(* The following slow, because unit regexpr in free pascal is very slow *)</com><def></def><br />
  <kwa>for</kwa> <def>i</def> <sym>:=</sym> <def></def><num>0</num> <def></def><kwa>to</kwa> <def></def><num>8</num> <def></def><kwa>do</kwa><br />
<def></def>    <kwd>writeln</kwd><def></def><sym>(</sym><def>patterns</def><sym>[</sym><def>i</def><sym>],</sym> <def></def><kwd>findSplitExpr</kwd><def></def><sym>(</sym><def>patterns</def><sym>[</sym><def>i</def><sym>],</sym> <def>seq</def><sym>));</sym><br />
<def></def>    <slc>//writeln(patterns[i], findExpr(patterns[i], seq));</slc><br />
<def></def><br />
<com>(* do replacements *)</com><def></def><br />
  <kwd>replace</kwd><def></def><sym>(</sym><def>seq</def><sym>,</sym> <def>newSeq</def><sym>);</sym><br />
<def><br />
  writeln</def><sym>;</sym><br />
<def></def>  <kwd>writeln</kwd><def></def><sym>(</sym><def>seqLen</def><sym>);</sym><br />
<def></def>  <kwd>writeln</kwd><def></def><sym>(</sym><def>seqCleanLen</def><sym>);</sym><br />
<def></def>  <kwd>writeln</kwd><def></def><sym>(</sym><def></def><kwd>strlen</kwd><def></def><sym>(</sym><def>newSeq</def><sym>));</sym><br />
<def></def><br />
  <kwd>FreeMem</kwd><def></def><sym>(</sym><def>newSeq</def><sym>);</sym><br />
<def></def>  <kwd>FreeMem</kwd><def></def><sym>(</sym><def>seq</def><sym>)</sym><br />
<def></def><kwa>end</kwa><def></def><sym>.</sym><def></def><br />
</source>
