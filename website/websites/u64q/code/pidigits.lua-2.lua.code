<source>
<def></def><slc>-- The Computer Language Shootout</slc><br />
<def></def><slc>-- http://shootout.alioth.debian.org/</slc><br />
<def></def><slc>-- contributed by Mike Pall</slc><br />
<def></def><br />
<slc>-- Start of dynamically compiled chunk.</slc><br />
<def></def><kwa>local</kwa> <def>chunk</def> <sym>= [=[</sym><br />
<def></def><br />
<slc>-- Factory function for multi-precision number (mpn) operations.</slc><br />
<def></def><kwa>local function</kwa> <def></def><kwd>fmm</kwd><def></def><sym>(</sym><def>fa</def><sym>,</sym> <def>fb</def><sym>)</sym><br />
<def></def>  <kwa>return</kwa> <def></def><kwd>loadstring</kwd><def></def><sym>([[</sym><br />
<def></def>    <kwa>return function</kwa><def></def><sym>(</sym><def>y</def><sym>,</sym> <def>a</def><sym>,</sym> <def>ka</def><sym>,</sym> <def>b</def><sym>,</sym> <def>kb</def><sym>)</sym><br />
<def></def>      <kwa>local</kwa> <def>carry</def><sym>,</sym> <def>n</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><slc>#a ]]..(fb == 0 and &quot;&quot; or [[</slc><br />
<def></def>      <kwa>local</kwa> <def>na</def><sym>,</sym> <def>nb</def> <sym>=</sym> <def>n</def><sym>,</sym> <def></def><slc>#b -- Need to adjust lengths. 1 element suffices here.</slc><br />
<def></def>      <kwa>if</kwa> <def>na</def> <sym>&gt;</sym> <def>nb</def> <kwa>then</kwa> <def>b</def><sym>[</sym><def>na</def><sym>] =</sym> <def></def><num>0</num> <def></def><kwa>elseif</kwa> <def>na</def> <sym>&lt;</sym> <def>nb</def> <kwa>then</kwa> <def>a</def><sym>[</sym><def>nb</def><sym>] =</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>n</def> <sym>=</sym> <def>nb</def> <kwa>end</kwa><br />
<def>    ]]</def><sym>)..[[</sym><br />
<def></def>      <kwa>for</kwa> <def>i</def><sym>=</sym><def></def><num>1</num><def></def><sym>,</sym><def>n</def> <kwa>do</kwa> <def></def><slc>-- Sum up all elements and propagate carry.</slc><br />
<def></def>        <kwa>local</kwa> <def>x</def> <sym>=</sym> <def>a</def><sym>[</sym><def>i</def><sym>]</sym> <def>]]</def><sym>..(</sym><def>fa</def> <sym>==</sym> <def></def><num>2</num> <def></def><kwa>and</kwa> <def></def><str>&quot;*ka&quot;</str><def></def> <kwa>or</kwa> <def></def><str>&quot;&quot;</str><def></def><sym>)..</sym><br />
<def></def>          <sym>(</sym><def>fb</def> <sym>==</sym> <def></def><num>2</num> <def></def><kwa>and</kwa> <def></def><str>&quot;+b[i]*kb&quot;</str><def></def> <kwa>or</kwa> <def></def><sym>(</sym><def>fb</def> <sym>==</sym> <def></def><num>1</num> <def></def><kwa>and</kwa> <def></def><str>&quot;+b[i]&quot;</str><def></def> <kwa>or</kwa> <def></def><str>&quot;&quot;</str><def></def><sym>))..[[ +</sym> <def>carry</def><br />
        <kwa>if</kwa> <def>x</def> <sym>&lt;</sym> <def>RADIX</def> <kwa>and</kwa> <def>x</def> <sym>&gt;=</sym> <def></def><num>0</num> <def></def><kwa>then</kwa> <def>carry</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>y</def><sym>[</sym><def>i</def><sym>] =</sym> <def>x</def> <slc>-- Check for overflow.</slc><br />
<def></def>        <kwa>else local</kwa> <def>d</def> <sym>=</sym> <def>x</def> <sym>%</sym> <def>RADIX</def><sym>;</sym> <def>carry</def> <sym>= (</sym><def>x</def><sym>-</sym><def>d</def><sym>) /</sym> <def>RADIX</def><sym>;</sym> <def>y</def><sym>[</sym><def>i</def><sym>] =</sym> <def>d</def> <kwa>end</kwa><br />
<def></def>      <kwa>end</kwa><br />
<def>      y</def><sym>[</sym><def>n</def><sym>+</sym><def></def><num>1</num><def></def><sym>] =</sym> <def></def><kwa>nil</kwa> <def></def><slc>-- Truncate target. 1 element suffices here.</slc><br />
<def></def>      <kwa>if</kwa> <def>carry</def> <sym>==</sym> <def></def><num>0</num> <def></def><kwa>then while</kwa> <def>n</def> <sym>&gt;</sym> <def></def><num>0</num> <def></def><kwa>and</kwa> <def>y</def><sym>[</sym><def>n</def><sym>] ==</sym> <def></def><num>0</num> <def></def><kwa>do</kwa> <def>y</def><sym>[</sym><def>n</def><sym>] =</sym> <def></def><kwa>nil end</kwa><br />
<def></def>      <kwa>elseif</kwa> <def>carry</def> <sym>== -</sym><def></def><num>1</num> <def></def><kwa>then</kwa> <def>y</def><sym>[</sym><def>n</def><sym>] =</sym> <def>y</def><sym>[</sym><def>n</def><sym>] -</sym> <def>RADIX</def> <kwa>else</kwa> <def>y</def><sym>[</sym><def>n</def><sym>+</sym><def></def><num>1</num><def></def><sym>] =</sym> <def>carry</def> <kwa>end</kwa><br />
<def>    ]]</def><sym>..(</sym><def>fb</def> <sym>==</sym> <def></def><num>0</num> <def></def><kwa>and</kwa> <def></def><str>&quot;&quot;</str><def></def> <kwa>or</kwa> <def></def><sym>[[</sym> <def></def><slc>-- Undo length adjustment.</slc><br />
<def></def>      <kwa>if</kwa> <def>na</def> <sym>&gt;</sym> <def>nb</def> <kwa>then</kwa> <def>b</def><sym>[</sym><def>na</def><sym>] =</sym> <def></def><kwa>nil elseif</kwa> <def>na</def> <sym>&lt;</sym> <def>nb</def> <kwa>and</kwa> <def>y ~</def><sym>=</sym> <def>a</def> <kwa>then</kwa> <def>a</def><sym>[</sym><def>nb</def><sym>] =</sym> <def></def><kwa>nil end</kwa><br />
<def>    ]]</def><sym>)..[[</sym><br />
<def></def>      <kwa>return</kwa> <def>y</def><br />
    <kwa>end</kwa><def>]]</def><sym>)()</sym><br />
<def></def><kwa>end</kwa><br />
<def></def><br />
<slc>-- Generate needed mpn functions.</slc><br />
<def></def><kwa>local</kwa> <def>mm_kk</def><sym>,</sym> <def>mm_k1</def><sym>,</sym> <def>mm_k0</def><sym>,</sym> <def>mm_11</def> <sym>=</sym> <def></def><kwd>fmm</kwd><def></def><sym>(</sym><def></def><num>2</num><def></def><sym>,</sym> <def></def><num>2</num><def></def><sym>),</sym> <def></def><kwd>fmm</kwd><def></def><sym>(</sym><def></def><num>2</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>),</sym> <def></def><kwd>fmm</kwd><def></def><sym>(</sym><def></def><num>2</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>),</sym> <def></def><kwd>fmm</kwd><def></def><sym>(</sym><def></def><num>1</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>)</sym><br />
<def></def><br />
<slc>-- Choose the most efficient mpn function for y = a*ka + b*kb at run-time.</slc><br />
<def></def><kwa>local function</kwa> <def></def><kwd>mm</kwd><def></def><sym>(</sym><def>y</def><sym>,</sym> <def>a</def><sym>,</sym> <def>ka</def><sym>,</sym> <def>b</def><sym>,</sym> <def>kb</def><sym>)</sym><br />
<def></def>  <kwa>local</kwa> <def>f</def> <sym>=</sym> <def>mm_kk</def><br />
  <kwa>if</kwa> <def>kb</def> <sym>==</sym> <def></def><num>0</num> <def></def><kwa>or</kwa> <def></def><slc>#b == 0 then if ka == 1 then return a else f = mm_k0 end</slc><br />
<def></def>  <kwa>elseif</kwa> <def>kb</def> <sym>==</sym> <def></def><num>1</num> <def></def><kwa>then if</kwa> <def>ka</def> <sym>==</sym> <def></def><num>1</num> <def></def><kwa>then</kwa> <def>f</def> <sym>=</sym> <def>mm_11</def> <kwa>else</kwa> <def>f</def> <sym>=</sym> <def>mm_k1</def> <kwa>end end</kwa><br />
<def></def>  <kwa>return</kwa> <def></def><kwd>f</kwd><def></def><sym>(</sym><def>y</def><sym>,</sym> <def>a</def><sym>,</sym> <def>ka</def><sym>,</sym> <def>b</def><sym>,</sym> <def>kb</def><sym>)</sym><br />
<def></def><kwa>end</kwa><br />
<def></def><br />
<slc>-- Compose matrix with numbers on the right.</slc><br />
<def></def><kwa>local function</kwa> <def></def><kwd>compose_r</kwd><def></def><sym>(</sym><def>aq</def><sym>,</sym><def>ar</def><sym>,</sym><def>as</def><sym>,</sym><def>at</def><sym>,</sym> <def>bq</def><sym>,</sym><def>br</def><sym>,</sym><def>bs</def><sym>,</sym><def>bt</def><sym>)</sym><br />
<def></def>  <kwd>mm</kwd><def></def><sym>(</sym><def>ar</def><sym>,</sym> <def>ar</def><sym>,</sym><def>bq</def><sym>,</sym> <def>at</def><sym>,</sym><def>br</def><sym>)</sym> <def></def><kwd>mm</kwd><def></def><sym>(</sym><def>at</def><sym>,</sym> <def>at</def><sym>,</sym><def>bt</def><sym>,</sym> <def>ar</def><sym>,</sym><def>bs</def><sym>)</sym><br />
<def></def>  <kwd>mm</kwd><def></def><sym>(</sym><def>as</def><sym>,</sym> <def>as</def><sym>,</sym><def>bt</def><sym>,</sym> <def>aq</def><sym>,</sym><def>bs</def><sym>)</sym> <def></def><kwd>mm</kwd><def></def><sym>(</sym><def>aq</def><sym>,</sym> <def>aq</def><sym>,</sym><def>bq</def><sym>,</sym> <def></def><kwa>nil</kwa><def></def><sym>,</sym><def></def><num>0</num><def></def><sym>)</sym><br />
<def></def><kwa>end</kwa><br />
<def></def><br />
<slc>-- Compose matrix with numbers on the left.</slc><br />
<def></def><kwa>local function</kwa> <def></def><kwd>compose_l</kwd><def></def><sym>(</sym><def>aq</def><sym>,</sym><def>ar</def><sym>,</sym><def>as</def><sym>,</sym><def>at</def><sym>,</sym> <def>bq</def><sym>,</sym><def>br</def><sym>,</sym><def>bs</def><sym>,</sym><def>bt</def><sym>)</sym><br />
<def></def>  <kwd>mm</kwd><def></def><sym>(</sym><def>ar</def><sym>,</sym> <def>ar</def><sym>,</sym><def>bt</def><sym>,</sym> <def>aq</def><sym>,</sym><def>br</def><sym>)</sym> <def></def><kwd>mm</kwd><def></def><sym>(</sym><def>at</def><sym>,</sym> <def>at</def><sym>,</sym><def>bt</def><sym>,</sym> <def>as</def><sym>,</sym><def>br</def><sym>)</sym><br />
<def></def>  <kwd>mm</kwd><def></def><sym>(</sym><def>as</def><sym>,</sym> <def>as</def><sym>,</sym><def>bq</def><sym>,</sym> <def>at</def><sym>,</sym><def>bs</def><sym>)</sym> <def></def><kwd>mm</kwd><def></def><sym>(</sym><def>aq</def><sym>,</sym> <def>aq</def><sym>,</sym><def>bq</def><sym>,</sym> <def></def><kwa>nil</kwa><def></def><sym>,</sym><def></def><num>0</num><def></def><sym>)</sym><br />
<def></def><kwa>end</kwa><br />
<def></def><br />
<slc>-- Extract one digit.</slc><br />
<def></def><kwa>local</kwa> <def>u</def><sym>,</sym> <def>v</def><sym>,</sym> <def>jj</def> <sym>= {}, {},</sym> <def></def><num>0</num><br />
<def></def><kwa>local function</kwa> <def></def><kwd>extract</kwd><def></def><sym>(</sym><def>q</def><sym>,</sym><def>r</def><sym>,</sym><def>s</def><sym>,</sym><def>t</def><sym>,</sym> <def>j</def><sym>)</sym><br />
<def></def>  <kwa>local</kwa> <def>u</def> <sym>=</sym> <def>j</def> <sym>==</sym> <def>jj</def> <sym>+</sym> <def></def><num>1</num> <def></def><kwa>and</kwa> <def></def><kwd>mm</kwd><def></def><sym>(</sym><def>u</def><sym>,</sym> <def>u</def><sym>,</sym><def></def><num>1</num><def></def><sym>,</sym> <def>q</def><sym>,</sym><def></def><num>1</num><def></def><sym>)</sym> <def></def><kwa>or</kwa> <def></def><kwd>mm</kwd><def></def><sym>(</sym><def>u</def><sym>,</sym> <def>q</def><sym>,</sym><def>j</def><sym>,</sym> <def>r</def><sym>,</sym><def></def><num>1</num><def></def><sym>);</sym> <def>jj</def> <sym>=</sym> <def>j</def><br />
  <kwa>local</kwa> <def>v</def> <sym>=</sym> <def></def><kwd>mm</kwd><def></def><sym>(</sym><def>v</def><sym>,</sym> <def>t</def><sym>,</sym><def></def><num>1</num><def></def><sym>,</sym> <def>s</def><sym>,</sym><def>j</def><sym>)</sym><br />
<def></def>  <kwa>local</kwa> <def>nu</def><sym>,</sym> <def>nv</def><sym>,</sym> <def>y</def> <sym>=</sym> <def></def><slc>#u, #v</slc><br />
<def></def>  <kwa>if</kwa> <def>nu</def> <sym>==</sym> <def>nv</def> <kwa>then</kwa><br />
<def></def>    <kwa>if</kwa> <def>nu</def> <sym>==</sym> <def></def><num>1</num> <def></def><kwa>then</kwa> <def>y</def> <sym>=</sym> <def>u</def><sym>[</sym><def></def><num>1</num><def></def><sym>] /</sym> <def>v</def><sym>[</sym><def></def><num>1</num><def></def><sym>]</sym><br />
<def></def>    <kwa>else</kwa> <def>y</def> <sym>= (</sym><def>u</def><sym>[</sym><def>nu</def><sym>]*</sym><def>RADIX</def> <sym>+</sym> <def>u</def><sym>[</sym><def>nu</def><sym>-</sym><def></def><num>1</num><def></def><sym>]) / (</sym><def>v</def><sym>[</sym><def>nv</def><sym>]*</sym><def>RADIX</def> <sym>+</sym> <def>v</def><sym>[</sym><def>nv</def><sym>-</sym><def></def><num>1</num><def></def><sym>])</sym> <def></def><kwa>end</kwa><br />
<def></def>  <kwa>elseif</kwa> <def>nu</def> <sym>==</sym> <def>nv</def><sym>+</sym><def></def><num>1</num> <def></def><kwa>then</kwa> <def>y</def> <sym>= (</sym><def>u</def><sym>[</sym><def>nu</def><sym>]*</sym><def>RADIX</def> <sym>+</sym> <def>u</def><sym>[</sym><def>nv</def><sym>]) /</sym> <def>v</def><sym>[</sym><def>nv</def><sym>]</sym><br />
<def></def>  <kwa>else return</kwa> <def></def><num>0</num> <def></def><kwa>end</kwa><br />
<def></def>  <kwa>return</kwa> <def>math</def><sym>.</sym><def></def><kwb>floor</kwb><def></def><sym>(</sym><def>y</def><sym>)</sym><br />
<def></def><kwa>end</kwa><br />
<def></def><br />
<slc>-- Coroutine which yields successive digits of PI.</slc><br />
<def></def><kwa>return</kwa> <def>coroutine</def><sym>.</sym><def></def><kwd>wrap</kwd><def></def><sym>(</sym><def></def><kwa>function</kwa><def></def><sym>()</sym><br />
<def></def>  <kwa>local</kwa> <def>q</def><sym>,</sym> <def>r</def><sym>,</sym> <def>s</def><sym>,</sym> <def>t</def><sym>,</sym> <def>k</def> <sym>= {</sym><def></def><num>1</num><def></def><sym>}, {}, {}, {</sym><def></def><num>1</num><def></def><sym>},</sym> <def></def><num>1</num><br />
<def></def>  <kwa>repeat</kwa><br />
<def></def>    <kwa>local</kwa> <def>y</def> <sym>=</sym> <def></def><kwd>extract</kwd><def></def><sym>(</sym><def>q</def><sym>,</sym><def>r</def><sym>,</sym><def>s</def><sym>,</sym><def>t</def><sym>,</sym> <def></def><num>3</num><def></def><sym>)</sym><br />
<def></def>    <kwa>if</kwa> <def>y</def> <sym>==</sym> <def></def><kwd>extract</kwd><def></def><sym>(</sym><def>q</def><sym>,</sym><def>r</def><sym>,</sym><def>s</def><sym>,</sym><def>t</def><sym>,</sym> <def></def><num>4</num><def></def><sym>)</sym> <def></def><kwa>then</kwa><br />
<def>      coroutine</def><sym>.</sym><def></def><kwd>yield</kwd><def></def><sym>(</sym><def>y</def><sym>)</sym><br />
<def></def>      <kwd>compose_r</kwd><def></def><sym>(</sym><def>q</def><sym>,</sym><def>r</def><sym>,</sym><def>s</def><sym>,</sym><def>t</def><sym>,</sym>  <def></def><num>10</num><def></def><sym>, -</sym><def></def><num>10</num><def></def><sym>*</sym><def>y</def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>)</sym><br />
<def></def>    <kwa>else</kwa><br />
<def></def>      <kwd>compose_l</kwd><def></def><sym>(</sym><def>q</def><sym>,</sym><def>r</def><sym>,</sym><def>s</def><sym>,</sym><def>t</def><sym>,</sym>   <def>k</def><sym>,</sym> <def></def><num>4</num><def></def><sym>*</sym><def>k</def><sym>+</sym><def></def><num>2</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>2</num><def></def><sym>*</sym><def>k</def><sym>+</sym><def></def><num>1</num><def></def><sym>)</sym><br />
<def>      k</def> <sym>=</sym> <def>k</def> <sym>+</sym> <def></def><num>1</num><br />
<def></def>    <kwa>end</kwa><br />
<def></def>  <kwa>until false</kwa><br />
<def></def><kwa>end</kwa><def></def><sym>)</sym><br />
<def></def><br />
<sym>]=]</sym> <def></def><slc>-- End of dynamically compiled chunk.</slc><br />
<def></def><br />
<kwa>local</kwa> <def>N</def> <sym>=</sym> <def></def><kwb>tonumber</kwb><def></def><sym>(</sym><def>arg</def> <kwa>and</kwa> <def>arg</def><sym>[</sym><def></def><num>1</num><def></def><sym>])</sym> <def></def><kwa>or</kwa> <def></def><num>27</num><br />
<def></def><kwa>local</kwa> <def>RADIX</def> <sym>=</sym> <def>N</def> <sym>&lt;</sym> <def></def><num>6500</num> <def></def><kwa>and</kwa> <def></def><num>2</num><def>^</def><num>36</num> <def></def><kwa>or</kwa> <def></def><num>2</num><def>^</def><num>32</num> <def></def><slc>-- Avoid overflow.</slc><br />
<def></def><br />
<slc>-- Substitute radix and compile chunk.</slc><br />
<def></def><kwa>local</kwa> <def>pidigit</def> <sym>=</sym> <def></def><kwd>loadstring</kwd><def></def><sym>(</sym><def></def><kwb>string</kwb><def></def><sym>.</sym><def></def><kwb>gsub</kwb><def></def><sym>(</sym><def>chunk</def><sym>,</sym> <def></def><str>&quot;RADIX&quot;</str><def></def><sym>,</sym> <def></def><kwb>tostring</kwb><def></def><sym>(</sym><def>RADIX</def><sym>)))()</sym><br />
<def></def><br />
<slc>-- Print lines with 10 digits.</slc><br />
<def></def><kwa>for</kwa> <def>i</def><sym>=</sym><def></def><num>10</num><def></def><sym>,</sym><def>N</def><sym>,</sym><def></def><num>10</num> <def></def><kwa>do</kwa><br />
<def></def>  <kwa>for</kwa> <def>j</def><sym>=</sym><def></def><num>1</num><def></def><sym>,</sym><def></def><num>10</num> <def></def><kwa>do</kwa> <def>io</def><sym>.</sym><def></def><kwb>write</kwb><def></def><sym>(</sym><def></def><kwd>pidigit</kwd><def></def><sym>())</sym> <def></def><kwa>end</kwa><br />
<def>  io</def><sym>.</sym><def></def><kwb>write</kwb><def></def><sym>(</sym><def></def><str>&quot;</str><esc>\t</esc><str>:&quot;</str><def></def><sym>,</sym> <def>i</def><sym>,</sym> <def></def><str>&quot;</str><esc>\n</esc><str>&quot;</str><def></def><sym>)</sym><br />
<def></def><kwa>end</kwa><br />
<def></def><br />
<slc>-- Print remaining digits (if any).</slc><br />
<def></def><kwa>local</kwa> <def>n10</def> <sym>=</sym> <def>N</def> <sym>%</sym> <def></def><num>10</num><br />
<def></def><kwa>if</kwa> <def>n10 ~</def><sym>=</sym> <def></def><num>0</num> <def></def><kwa>then</kwa><br />
<def></def>  <kwa>for</kwa> <def>i</def><sym>=</sym><def></def><num>1</num><def></def><sym>,</sym><def>n10</def> <kwa>do</kwa> <def>io</def><sym>.</sym><def></def><kwb>write</kwb><def></def><sym>(</sym><def></def><kwd>pidigit</kwd><def></def><sym>())</sym> <def></def><kwa>end</kwa><br />
<def>  io</def><sym>.</sym><def></def><kwb>write</kwb><def></def><sym>(</sym><def></def><kwb>string</kwb><def></def><sym>.</sym><def></def><kwd>rep</kwd><def></def><sym>(</sym><def></def><str>&quot; &quot;</str><def></def><sym>,</sym> <def></def><num>10</num><def></def><sym>-</sym><def>n10</def><sym>),</sym> <def></def><str>&quot;</str><esc>\t</esc><str>:&quot;</str><def></def><sym>,</sym> <def>N</def><sym>,</sym> <def></def><str>&quot;</str><esc>\n</esc><str>&quot;</str><def></def><sym>)</sym><br />
<def></def><kwa>end</kwa><br />
<def></def><br />
</source>
