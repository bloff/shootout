<source>
<def></def><com>(* knucleotide.ml</com><br />
<com> *</com><br />
<com> * The Great Computer Language Shootout</com><br />
<com> * http://shootout.alioth.debian.org/</com><br />
<com> *</com><br />
<com> * Contributed by Troestler Christophe</com><br />
<com> * translated to MLton/SML by sweeks@sweeks.com.</com><br />
<com> *)</com><def></def><br />
<br />
<kwa>structure</kwa> <def>H</def> <sym>=</sym> <def>HashTable</def><br />
<com>(* [counts k dna] fills and return the hashtable [count] of</com><br />
<com> * k-nucleotide keys and count values for a particular reading-frame</com><br />
<com> * of length [k] of the string [dna].</com><br />
<com> *)</com><def></def><br />
<kwa>fun</kwa> <def>counts</def> <sym>(</sym><def>k</def><sym>,</sym> <def>dna</def><sym>) =</sym><br />
<def></def>   <kwa>let</kwa><br />
<def></def>      <kwa>val</kwa> <def>count</def> <sym>=</sym> <def>H.new</def> <sym>{</sym><def>equals</def> <sym>=</sym> <def></def><kwa>op</kwa> <def></def><sym>=,</sym> <def>hash</def> <sym>=</sym> <def></def><kwa>String</kwa><def>.hash</def><sym>,</sym> <def>size</def> <sym>=</sym> <def></def><num>0x40000</num><def></def><sym>}</sym><br />
<def></def>      <kwa>val</kwa> <def>n</def> <sym>=</sym> <def>size dna</def> <sym>+</sym> <def></def><num>1</num> <def></def><sym>-</sym> <def>k</def><br />
      <kwa>val</kwa> <def></def><sym>() =</sym><br />
<def>	 for</def> <sym>(</sym><def></def><num>0</num><def></def><sym>,</sym> <def>n</def><sym>,</sym> <def></def><kwa>fn</kwa> <def>i</def> <sym>=&gt;</sym><br />
<def></def>	      <kwa>Int</kwa><def>.inc</def><br />
	      <sym>(</sym><def>H.lookupOrInsert</def> <sym>(</sym><def>count</def><sym>,</sym> <def></def><kwa>String</kwa><def>.substring</def> <sym>(</sym><def>dna</def><sym>,</sym> <def>i</def><sym>,</sym> <def>k</def><sym>),</sym><br />
<def></def>				 <kwa>fn</kwa> <def></def><sym>() =&gt;</sym> <def>ref</def> <num>0</num><def></def><sym>)))</sym><br />
<def></def>   <kwa>in</kwa><br />
<def></def>      <sym>(</sym><def>n</def><sym>,</sym> <def>count</def><sym>)</sym><br />
<def></def>   <kwa>end</kwa><br />
<def></def><br />
<com>(* [write_frequencies k dna] writes the frequencies for a</com><br />
<com> * reading-frame of length [k] sorted by descending frequency and then</com><br />
<com> * ascending k-nucleotide key.</com><br />
<com> *)</com><def></def><br />
<kwa>fun</kwa> <def>compareFreq</def> <sym>((</sym><def>k1</def><sym>:</sym><def></def><kwb>string</kwb><def></def><sym>,</sym> <def>f1</def><sym>:</sym><def></def><kwb>real</kwb><def></def><sym>), (</sym><def>k2</def><sym>,</sym> <def>f2</def><sym>)) =</sym><br />
<def>   f1</def> <sym>&gt;</sym> <def>f2</def> <kwa>orelse</kwa> <def></def><sym>(</sym><def></def><kwa>Real</kwa><def>.</def><sym>== (</sym><def>f1</def><sym>,</sym> <def>f2</def><sym>)</sym> <def></def><kwa>andalso String</kwa><def>.</def><sym>&lt;= (</sym><def>k1</def><sym>,</sym> <def>k2</def><sym>))</sym><br />
<def></def><br />
<kwa>fun</kwa> <def>writeFrequencies</def> <sym>(</sym><def>k</def><sym>,</sym> <def>dna</def><sym>) =</sym><br />
<def></def>  <kwa>let</kwa><br />
<def></def>     <kwa>val</kwa> <def></def><sym>(</sym><def>n</def><sym>,</sym> <def>cnt</def><sym>) =</sym> <def>counts</def> <sym>(</sym><def>k</def><sym>,</sym> <def>dna</def><sym>)</sym><br />
<def></def>     <kwa>val</kwa> <def>tot</def> <sym>=</sym> <def></def><kwa>Real</kwa><def>.fromInt n</def><br />
     <kwa>val</kwa> <def>frq</def> <sym>=</sym><br />
<def>	Array.fromList</def> <sym>(</sym><def>H.fold</def> <sym>(</sym><def>cnt</def><sym>, [],</sym> <def></def><kwa>fn</kwa> <def></def><sym>(</sym><def>k</def><sym>,</sym> <def>r</def><sym>,</sym> <def>l</def><sym>) =&gt;</sym><br />
<def></def>				<sym>(</sym><def>k</def><sym>,</sym> <def></def><num>100.0</num> <def></def><sym>*</sym> <def></def><kwa>Real</kwa><def>.fromInt</def> <sym>(!</sym><def>r</def><sym>) /</sym> <def>tot</def><sym>) ::</sym> <def>l</def><sym>))</sym><br />
<def></def>     <kwa>val</kwa> <def>_</def> <sym>=</sym> <def>QuickSort.sortArray</def> <sym>(</sym><def>frq</def><sym>,</sym> <def>compareFreq</def><sym>)</sym><br />
<def></def>     <kwa>val</kwa> <def></def><sym>() =</sym><br />
<def>	Array.foreach</def> <sym>(</sym><def>frq</def><sym>,</sym> <def></def><kwa>fn</kwa> <def></def><sym>(</sym><def>k</def><sym>,</sym> <def>f</def><sym>) =&gt;</sym><br />
<def>		       print</def> <sym>(</sym><def>concat</def> <sym>[</sym><def>k</def><sym>,</sym> <def></def><str>&quot; &quot;</str><def></def><sym>,</sym><br />
<def></def>				      <kwa>Real</kwa><def>.fmt</def> <sym>(</sym><def></def><kwa>StringCvt</kwa><def>.FIX</def> <sym>(</sym><def>SOME</def> <num>3</num><def></def><sym>))</sym> <def>f</def><sym>,</sym><br />
<def></def>				      <str>&quot;</str><esc>\n</esc><str>&quot;</str><def></def><sym>]))</sym><br />
<def></def>  <kwa>in</kwa><br />
<def>     print</def> <str>&quot;</str><esc>\n</esc><str>&quot;</str><def></def><br />
  <kwa>end</kwa><br />
<def></def><br />
<kwa>fun</kwa> <def>writeCount</def> <sym>(</sym><def>seq</def><sym>,</sym> <def>dna</def><sym>) =</sym><br />
<def></def>  <kwa>let</kwa><br />
<def></def>     <kwa>val</kwa> <def></def><sym>(</sym><def>_</def><sym>,</sym> <def>cnt</def><sym>) =</sym> <def>counts</def> <sym>(</sym><def>size seq</def><sym>,</sym> <def>dna</def><sym>)</sym><br />
<def></def>  <kwa>in</kwa><br />
<def>     print</def> <sym>(</sym><def>concat</def> <sym>[</sym><def></def><kwa>Int</kwa><def>.toString</def> <sym>(</sym><def></def><kwa>case</kwa> <def>H.peek</def> <sym>(</sym><def>cnt</def><sym>,</sym> <def>seq</def><sym>)</sym> <def></def><kwa>of</kwa><br />
<def>				     NONE</def> <sym>=&gt;</sym> <def></def><num>0</num><br />
<def></def>				   <sym>|</sym> <def>SOME r</def> <sym>=&gt; !</sym><def>r</def><sym>),</sym><br />
<def></def>		    <str>&quot;</str><esc>\t</esc><str>&quot;</str><def></def><sym>,</sym> <def>seq</def><sym>,</sym> <def></def><str>&quot;</str><esc>\n</esc><str>&quot;</str><def></def><sym>])</sym><br />
<def></def>  <kwa>end</kwa><br />
<def></def><br />
<kwa>structure</kwa> <def>Buffer</def><sym>:</sym><br />
<def></def>   <kwa>sig</kwa><br />
<def></def>      <kwa>type</kwa> <def>t</def><br />
<br />
      <kwa>val</kwa> <def>addLine</def><sym>:</sym> <def>t</def> <sym>*</sym> <def></def><kwb>string</kwb> <def></def><sym>-&gt;</sym> <def>t</def><br />
      <kwa>val</kwa> <def>contents</def><sym>:</sym> <def>t</def> <sym>-&gt;</sym> <def>char array</def><br />
      <kwa>val</kwa> <def>empty</def><sym>:</sym> <def>t</def><br />
   <kwa>end</kwa> <def></def><sym>=</sym><br />
<def></def>   <kwa>struct</kwa><br />
<def></def>      <kwa>datatype</kwa> <def>t</def> <sym>=</sym> <def>T</def> <kwa>of</kwa> <def></def><kwb>string</kwb> <def>list</def><br />
<br />
      <kwa>val</kwa> <def>empty</def><sym>:</sym> <def>t</def> <sym>=</sym> <def>T</def> <sym>[]</sym><br />
<def></def><br />
      <kwa>fun</kwa> <def>addLine</def> <sym>(</sym><def>T xs</def><sym>,</sym> <def>x</def><sym>) =</sym> <def>T</def> <sym>(</sym><def>x</def> <sym>::</sym> <def>xs</def><sym>)</sym><br />
<def></def><br />
      <kwa>fun</kwa> <def>contents</def> <sym>(</sym><def>T lines</def><sym>) =</sym><br />
<def></def>	 <kwa>let</kwa><br />
<def></def>	    <kwa>val</kwa> <def>n</def> <sym>=</sym> <def>foldl</def> <sym>(</sym><def></def><kwa>fn</kwa> <def></def><sym>(</sym><def>s</def><sym>,</sym> <def>n</def><sym>) =&gt;</sym> <def>n</def> <sym>+</sym> <def>size s</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>)</sym> <def></def><num>0</num> <def>lines</def><br />
	    <kwa>val</kwa> <def>a</def> <sym>=</sym> <def>Array.array</def> <sym>(</sym><def>n</def><sym>,</sym> <def>#</def><str>&quot;</str><esc>\000</esc><str>&quot;</str><def></def><sym>)</sym><br />
<def></def>	    <kwa>val</kwa> <def>_</def> <sym>=</sym><br />
<def>	       foldl</def> <sym>(</sym><def></def><kwa>fn</kwa> <def></def><sym>(</sym><def>s</def><sym>,</sym> <def>i</def><sym>) =&gt;</sym><br />
<def></def>		      <kwa>let</kwa><br />
<def></def>			 <kwa>fun</kwa> <def>loop</def> <sym>(</sym><def>i</def><sym>,</sym> <def>j</def><sym>)  =</sym><br />
<def></def>			    <kwa>if</kwa> <def>j</def> <sym>&lt;</sym> <def></def><num>0</num><br />
<def></def>			       <kwa>then</kwa> <def>i</def><br />
			    <kwa>else</kwa> <def></def><sym>(</sym><def>Array.update</def> <sym>(</sym><def>a</def><sym>,</sym> <def>i</def><sym>,</sym> <def></def><kwa>String</kwa><def>.sub</def> <sym>(</sym><def>s</def><sym>,</sym> <def>j</def><sym>))</sym><br />
<def></def>				  <sym>;</sym> <def>loop</def> <sym>(</sym><def>i</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>,</sym> <def>j</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>))</sym><br />
<def></def>		      <kwa>in</kwa><br />
<def>			 loop</def> <sym>(</sym><def>i</def><sym>,</sym> <def></def><kwa>String</kwa><def>.size s</def> <sym>-</sym> <def></def><num>2</num><def></def><sym>)</sym><br />
<def></def>		      <kwa>end</kwa><def></def><sym>)</sym><br />
<def></def>	       <sym>(</sym><def>n</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>)</sym> <def>lines</def><br />
	 <kwa>in</kwa><br />
<def>	    a</def><br />
	 <kwa>end</kwa><br />
<def></def>   <kwa>end</kwa><br />
<def></def><br />
<com>(* Extract DNA sequence &quot;THREE&quot; from stdin *)</com><def></def><br />
<kwa>val</kwa> <def>dnaThree</def> <sym>=</sym><br />
<def></def>  <kwa>let</kwa><br />
<def></def>     <kwa>fun</kwa> <def>line</def> <sym>() =</sym> <def></def><kwa>TextIO</kwa><def>.inputLine</def> <kwa>TextIO</kwa><def>.stdIn</def><br />
     <kwa>fun</kwa> <def>isThree s</def> <sym>=</sym> <def></def><kwa>String</kwa><def>.substring</def> <sym>(</sym><def>s</def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>6</num><def></def><sym>) =</sym> <def></def><str>&quot;&gt;THREE&quot;</str><def></def><br />
     <kwa>val</kwa> <def></def><sym>() =</sym> <def></def><kwa>while</kwa> <def>not</def> <sym>(</sym><def>isThree</def> <sym>(</sym><def>valOf</def> <sym>(</sym><def>line</def> <sym>())))</sym> <def></def><kwa>do</kwa> <def></def><sym>()</sym><br />
<def></def>     <kwa>fun</kwa> <def>loop</def> <sym>() =</sym><br />
<def></def>	<kwa>let</kwa><br />
<def></def>	   <kwa>val</kwa> <def>l</def> <sym>=</sym> <def>valOf</def> <sym>(</sym><def>line</def> <sym>())</sym><br />
<def></def>	<kwa>in</kwa><br />
<def></def>	   <kwa>if</kwa> <def>#</def><str>&quot;;&quot;</str><def></def> <sym>=</sym> <def></def><kwa>String</kwa><def>.sub</def> <sym>(</sym><def>l</def><sym>,</sym> <def></def><num>0</num><def></def><sym>)</sym>  <def></def><com>(* Skip possible comment *)</com><def></def><br />
	      <kwa>then</kwa> <def>loop</def> <sym>()</sym><br />
<def></def>	   <kwa>else</kwa><br />
<def></def>	      <kwa>let</kwa><br />
<def></def>		 <kwa>fun</kwa> <def>loop</def> <sym>(</sym><def>b</def><sym>,</sym> <def>l</def><sym>) =</sym><br />
<def></def>		    <kwa>let</kwa><br />
<def></def>		       <kwa>val</kwa> <def>b</def> <sym>=</sym> <def>Buffer.addLine</def> <sym>(</sym><def>b</def><sym>,</sym> <def>l</def><sym>)</sym><br />
<def></def>		    <kwa>in</kwa><br />
<def></def>		       <kwa>case</kwa> <def>line</def> <sym>()</sym> <def></def><kwa>of</kwa><br />
<def>			  NONE</def> <sym>=&gt;</sym> <def>b</def><br />
			<sym>|</sym> <def>SOME l</def> <sym>=&gt;</sym><br />
<def></def>			     <kwa>if</kwa> <def>#</def><str>&quot;&lt;&quot;</str><def></def> <sym>=</sym> <def></def><kwa>String</kwa><def>.sub</def> <sym>(</sym><def>l</def><sym>,</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def></def>				<kwa>then</kwa> <def>b</def><br />
			     <kwa>else</kwa> <def>loop</def> <sym>(</sym><def>b</def><sym>,</sym> <def>l</def><sym>)</sym><br />
<def></def>		    <kwa>end</kwa><br />
<def></def>	      <kwa>in</kwa><br />
<def>		 loop</def> <sym>(</sym><def>Buffer.empty</def><sym>,</sym> <def>l</def><sym>)</sym><br />
<def></def>	      <kwa>end</kwa><br />
<def></def>	<kwa>end</kwa><br />
<def></def>     <kwa>val</kwa> <def>a</def> <sym>=</sym> <def>Buffer.contents</def> <sym>(</sym><def>loop</def> <sym>())</sym><br />
<def></def>  <kwa>in</kwa><br />
<def></def>     <kwa>String</kwa><def>.toUpper</def><br />
     <sym>(</sym><def></def><kwa>String</kwa><def>.tabulate</def> <sym>(</sym><def>Array.length a</def><sym>,</sym> <def></def><kwa>fn</kwa> <def>i</def> <sym>=&gt;</sym> <def>Array.sub</def> <sym>(</sym><def>a</def><sym>,</sym> <def>i</def><sym>)))</sym><br />
<def></def>  <kwa>end</kwa><br />
<def></def><br />
<kwa>val</kwa> <def></def><sym>() =</sym> <def>writeFrequencies</def> <sym>(</sym><def></def><num>1</num><def></def><sym>,</sym> <def>dnaThree</def><sym>)</sym><br />
<def></def><kwa>val</kwa> <def></def><sym>() =</sym> <def>writeFrequencies</def> <sym>(</sym><def></def><num>2</num><def></def><sym>,</sym> <def>dnaThree</def><sym>)</sym><br />
<def></def><kwa>val</kwa> <def></def><sym>() =</sym><br />
<def></def>   <kwa>List</kwa><def>.foreach</def><br />
   <sym>([</sym><def></def><str>&quot;GGT&quot;</str><def></def><sym>,</sym> <def></def><str>&quot;GGTA&quot;</str><def></def><sym>,</sym> <def></def><str>&quot;GGTATT&quot;</str><def></def><sym>,</sym> <def></def><str>&quot;GGTATTTTAATT&quot;</str><def></def><sym>,</sym> <def></def><str>&quot;GGTATTTTAATTTATAGT&quot;</str><def></def><sym>],</sym><br />
<def></def>    <kwa>fn</kwa> <def>k</def> <sym>=&gt;</sym> <def>writeCount</def> <sym>(</sym><def>k</def><sym>,</sym> <def>dnaThree</def><sym>))</sym><br />
<def></def><br />
<br />
</source>
