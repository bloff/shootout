<source>
<def></def><com>/**</com><br />
<com> * The Computer Language Benchmarks Game</com><br />
<com> * Based on the CAL Open Quark version</com><br />
<com> * Contributed by Magnus Byne.</com><br />
<com> */</com><def></def><br />
<kwa>module</kwa> <def>Meteor</def><sym>;</sym><br />
<def></def><br />
<kwa>import</kwa> <def>Cal</def><sym>.</sym><def>Core</def><sym>.</sym><def>Prelude</def> <kwa>using</kwa><br />
<def></def>    <kwa>typeClass</kwa> <def></def><sym>=</sym> <def>Enum</def><sym>,</sym> <def>Inputable</def><sym>,</sym> <def>IntEnum</def><sym>,</sym> <def>Outputable</def><sym>;</sym><br />
<def></def>    <kwa>typeConstructor</kwa> <def></def><sym>=</sym> <def>Boolean</def><sym>,</sym> <def>Int</def><sym>,</sym> <def>Long</def><sym>,</sym> <def>String</def><sym>;</sym><br />
<def></def>    <kwa>dataConstructor</kwa> <def></def><sym>=</sym> <def>False</def><sym>,</sym> <def>True</def><sym>;</sym><br />
<def></def>    <kwa>function</kwa> <def></def><sym>=</sym> <def>eager</def><sym>,</sym> <def>fromInt</def><sym>,</sym> <def>iff</def><sym>,</sym> <def>seq</def><sym>,</sym> <def>stringToInt</def><sym>;</sym><br />
<def></def>    <sym>;</sym><br />
<def></def><kwa>import</kwa> <def>Cal</def><sym>.</sym><def>Core</def><sym>.</sym><def>Debug</def> <kwa>using</kwa><br />
<def></def>    <kwa>typeClass</kwa> <def></def><sym>=</sym> <def>Show</def><sym>;</sym><br />
<def></def>    <kwa>function</kwa> <def></def><sym>=</sym> <def>show</def><sym>;</sym><br />
<def></def>    <sym>;</sym><br />
<def></def><kwa>import</kwa> <def>Cal</def><sym>.</sym><def>Core</def><sym>.</sym><def>Bits</def> <kwa>using</kwa><br />
<def></def>    <kwa>function</kwa> <def></def><sym>=</sym> <def>bitwiseAnd</def><sym>,</sym> <def>bitwiseOr</def><sym>,</sym> <def>shiftL</def><sym>,</sym> <def>shiftRUnsigned</def><sym>;</sym><br />
<def></def>    <sym>;</sym><br />
<def></def><kwa>import</kwa> <def>Cal</def><sym>.</sym><def>Collections</def><sym>.</sym><def>List</def> <kwa>using</kwa><br />
<def></def>    <kwa>function</kwa> <def></def><sym>=</sym> <def>foldLeftStrict</def><sym>,</sym> <def>head</def><sym>,</sym> <def>map</def><sym>;</sym><br />
<def></def>    <sym>;</sym><br />
<def></def><kwa>import</kwa> <def>Cal</def><sym>.</sym><def>Collections</def><sym>.</sym><def>Array</def> <kwa>using</kwa><br />
<def></def>    <kwa>typeConstructor</kwa> <def></def><sym>=</sym> <def>Array</def><sym>;</sym><br />
<def></def>    <sym>;</sym><br />
<def></def><kwa>import</kwa> <def>Cal</def><sym>.</sym><def>IO</def><sym>.</sym><def>Console</def> <kwa>using</kwa><br />
<def></def>    <kwa>function</kwa> <def></def><sym>=</sym> <def>printLine</def><sym>;</sym><br />
<def></def>    <sym>;</sym><br />
<def></def><br />
<br />
<kwa>data foreign unsafe import jvm</kwa> <def></def><str>&quot;long[]&quot;</str><def><br />
    JLongArray</def> <kwa>deriving</kwa> <def>Inputable</def><sym>,</sym> <def>Outputable</def><sym>,</sym> <def>Show</def><sym>;</sym><br />
<def></def><br />
<kwa>foreign unsafe import jvm</kwa> <def></def><str>&quot;newArray&quot;</str><def> longArray_new</def> <sym>::</sym> <def>Int</def> <sym>-&gt;</sym> <def>JLongArray</def><sym>;</sym><br />
<def></def><br />
<kwa>foreign unsafe import jvm</kwa> <def></def><str>&quot;lengthArray&quot;</str><def> longArray_length</def> <sym>::</sym> <def>JLongArray</def> <sym>-&gt;</sym> <def>Int</def><sym>;</sym><br />
<def></def><br />
<kwa>foreign unsafe import jvm</kwa> <def></def><str>&quot;subscriptArray&quot;</str><def><br />
    longArray_subscript</def> <sym>::</sym> <def>JLongArray</def> <sym>-&gt;</sym> <def>Int</def> <sym>-&gt;</sym> <def>Long</def><sym>;</sym><br />
<def></def><br />
<kwa>foreign unsafe import jvm</kwa> <def></def><str>&quot;updateArray&quot;</str><def><br />
    longArray_update</def> <sym>::</sym> <def>JLongArray</def> <sym>-&gt;</sym> <def>Int</def> <sym>-&gt;</sym> <def>Long</def> <sym>-&gt;</sym> <def>Long</def><sym>;</sym><br />
<def></def><br />
<com>/** build an array from a list*/</com><def><br />
jLongArrayfromList</def> <sym>:: [</sym><def>Long</def><sym>] -&gt;</sym> <def>JLongArray</def><sym>;</sym><br />
<def>jLongArrayfromList</def> <sym>!</sym><def>input</def> <sym>=</sym><br />
<def></def>    <kwa>let</kwa><br />
<def>        array</def> <sym>::</sym> <def>JLongArray</def><sym>;</sym><br />
<def>        array</def> <sym>=</sym> <def>eager $ longArray_new</def> <sym>(</sym><def>List</def><sym>.</sym><def>length input</def><sym>);</sym><br />
<def></def>    <kwa>in</kwa><br />
<def>        array</def><br />
        <sym>`</sym><def>seq</def><sym>`</sym><br />
<def>        foldLeftStrict</def><br />
            <sym>(</sym><br />
<def>                \</def><sym>!</sym><def>index</def> <sym>!</sym><def>value</def> <sym>-&gt;</sym><br />
<def>                    longArray_update array index value</def><br />
                    <sym>`</sym><def>seq</def><sym>`</sym><br />
<def></def>                    <sym>(</sym><def>index</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>)</sym><br />
<def></def>            <sym>)</sym><br />
<def></def>            <num>0</num><br />
<def>            input</def><br />
        <sym>`</sym><def>seq</def><sym>`</sym><br />
<def>        array</def><br />
    <sym>;</sym><br />
<def></def><br />
<kwa>data</kwa> <def>Direction</def> <sym>=</sym><br />
<def>    E</def> <sym>|</sym> <def>SE</def> <sym>|</sym> <def>SW</def> <sym>|</sym> <def>W</def> <sym>|</sym> <def>NW</def> <sym>|</sym> <def>NE</def><br />
    <kwa>deriving</kwa> <def>Enum</def><sym>,</sym> <def>IntEnum</def><br />
    <sym>;</sym><br />
<def></def><br />
<com>/** the puzzle pieces*/</com><def><br />
pieces</def> <sym>:: [[</sym><def>Direction</def><sym>]];</sym><br />
<def>pieces</def> <sym>=</sym><br />
<def></def>    <sym>[</sym><br />
<def></def>        <sym>[</sym><def>E</def><sym>,</sym> <def>E</def><sym>,</sym> <def>E</def><sym>,</sym> <def>SE</def><sym>],</sym><br />
<def></def>        <sym>[</sym><def>SE</def><sym>,</sym> <def>SW</def><sym>,</sym> <def>W</def><sym>,</sym> <def>SW</def><sym>],</sym><br />
<def></def>        <sym>[</sym><def>W</def><sym>,</sym> <def>W</def><sym>,</sym> <def>SW</def><sym>,</sym> <def>SE</def><sym>],</sym><br />
<def></def>        <sym>[</sym><def>E</def><sym>,</sym> <def>E</def><sym>,</sym> <def>SW</def><sym>,</sym> <def>SE</def><sym>],</sym><br />
<def></def>        <sym>[</sym><def>NW</def><sym>,</sym> <def>W</def><sym>,</sym> <def>NW</def><sym>,</sym> <def>SE</def><sym>,</sym> <def>SW</def><sym>],</sym><br />
<def></def>        <sym>[</sym><def>E</def><sym>,</sym> <def>E</def><sym>,</sym> <def>NE</def><sym>,</sym> <def>W</def><sym>],</sym><br />
<def></def>        <sym>[</sym><def>NW</def><sym>,</sym> <def>NE</def><sym>,</sym> <def>NE</def><sym>,</sym> <def>W</def><sym>],</sym><br />
<def></def>        <sym>[</sym><def>NE</def><sym>,</sym> <def>SE</def><sym>,</sym> <def>E</def><sym>,</sym> <def>NE</def><sym>],</sym><br />
<def></def>        <sym>[</sym><def>SE</def><sym>,</sym> <def>SE</def><sym>,</sym> <def>E</def><sym>,</sym> <def>SE</def><sym>],</sym><br />
<def></def>        <sym>[</sym><def>E</def><sym>,</sym> <def>NW</def><sym>,</sym> <def>NW</def><sym>,</sym> <def>NW</def><sym>]</sym><br />
<def></def>    <sym>]</sym><br />
<def></def>    <sym>;</sym><br />
<def><br />
width</def> <sym>::</sym> <def>Int</def><sym>;</sym><br />
<def>width</def> <sym>=</sym> <def></def><num>5</num><def></def><sym>;</sym><br />
<def><br />
height</def> <sym>::</sym> <def>Int</def><sym>;</sym><br />
<def>height</def> <sym>=</sym> <def></def><num>10</num><def></def><sym>;</sym><br />
<def></def><br />
<com>/** rotate a puzzle piece clockwise */</com><def><br />
rotatePiece</def> <sym>:: [</sym><def>Direction</def><sym>] -&gt; [</sym><def>Direction</def><sym>];</sym><br />
<def>rotatePiece</def> <sym>!</sym><def>piece</def> <sym>=</sym><br />
<def></def>    <kwa>let</kwa><br />
<def>        rotate</def> <sym>::</sym> <def>Direction</def> <sym>-&gt;</sym> <def>Direction</def><sym>;</sym><br />
<def>        rotate</def> <sym>!</sym><def>direction</def> <sym>=</sym><br />
<def></def>            <kwa>case</kwa> <def>direction</def> <kwa>of</kwa><br />
<def>            E</def> <sym>-&gt;</sym> <def>SE</def><sym>;</sym><br />
<def>            SE</def> <sym>-&gt;</sym> <def>SW</def><sym>;</sym><br />
<def>            SW</def> <sym>-&gt;</sym> <def>W</def><sym>;</sym><br />
<def>            W</def> <sym>-&gt;</sym> <def>NW</def><sym>;</sym><br />
<def>            NW</def> <sym>-&gt;</sym> <def>NE</def><sym>;</sym><br />
<def>            NE</def> <sym>-&gt;</sym> <def>E</def><sym>;</sym><br />
<def></def>            <sym>;</sym><br />
<def></def>    <kwa>in</kwa><br />
<def>        map rotate piece</def><br />
    <sym>;</sym><br />
<def></def><br />
<com>/** flip a piece about it's vertical axis*/</com><def><br />
flipPiece</def> <sym>:: [</sym><def>Direction</def><sym>] -&gt; [</sym><def>Direction</def><sym>];</sym><br />
<def>flipPiece</def> <sym>!</sym><def>piece</def> <sym>=</sym><br />
<def></def>    <kwa>let</kwa><br />
<def>        flip</def> <sym>::</sym> <def>Direction</def> <sym>-&gt;</sym> <def>Direction</def><sym>;</sym><br />
<def>        flip</def> <sym>!</sym><def>direction</def> <sym>=</sym><br />
<def></def>            <kwa>case</kwa> <def>direction</def> <kwa>of</kwa><br />
<def>            E</def> <sym>-&gt;</sym> <def>W</def><sym>;</sym><br />
<def>            SE</def> <sym>-&gt;</sym> <def>SW</def><sym>;</sym><br />
<def>            SW</def> <sym>-&gt;</sym> <def>SE</def><sym>;</sym><br />
<def>            W</def> <sym>-&gt;</sym> <def>E</def><sym>;</sym><br />
<def>            NW</def> <sym>-&gt;</sym> <def>NE</def><sym>;</sym><br />
<def>            NE</def> <sym>-&gt;</sym> <def>NW</def><sym>;</sym><br />
<def></def>            <sym>;</sym><br />
<def></def>    <kwa>in</kwa><br />
<def>        map flip piece</def><br />
    <sym>;</sym><br />
<def></def><br />
<com>/**</com><br />
<com> * the puzzle board is represented as a 64 long. The positions on the board,</com><br />
<com> * from the top left, row by row, to the bottom right are represented</com><br />
<com> * by bits highbit to lowbit inclusive. A set bit means the position is occupied.</com><br />
<com> * An unset bit means the bit is not occupied.</com><br />
<com> */</com><def><br />
highBit</def> <sym>::</sym> <def>Long</def><sym>;</sym><br />
<def>highBit</def> <sym>=</sym> <def></def><num>4611686018427387904</num><def></def><sym>;</sym><br />
<def><br />
lowBit</def> <sym>::</sym> <def>Long</def><sym>;</sym><br />
<def>lowBit</def> <sym>=</sym> <def></def><num>8192</num><def></def><sym>;</sym><br />
<def><br />
fullBoard</def> <sym>::</sym> <def>Long</def><sym>;</sym><br />
<def>fullBoard</def> <sym>=</sym> <def></def><num>9223372036854767616</num><def></def><sym>;</sym><br />
<def></def><br />
<com>/**</com><br />
<com> * an array with one mask for each position on the board. The set bits in the mask</com><br />
<com> * correspond to positions on the board that are adjacent.</com><br />
<com> */</com><def><br />
adjacentSquares</def> <sym>::</sym> <def>JLongArray</def><sym>;</sym><br />
<def>adjacentSquares</def> <sym>=</sym><br />
<def></def>    <kwa>let</kwa><br />
<def>        adjacent</def> <sym>:: [</sym><def>Direction</def><sym>];</sym><br />
<def></def>        <slc>//route of steps to surround the square</slc><br />
<def>        adjacent</def> <sym>= [</sym><def>E</def><sym>,</sym> <def>SW</def><sym>,</sym> <def>W</def><sym>,</sym> <def>NW</def><sym>,</sym> <def>NE</def><sym>,</sym> <def>E</def><sym>];</sym><br />
<def></def>    <kwa>in</kwa><br />
<def>        jLongArrayfromList</def><br />
            <sym>(</sym><def>List</def><sym>.</sym><def>mapIndexed</def><br />
                <sym>(</sym><br />
<def>                    \</def><sym>!</sym><def>a</def> <sym>!</sym><def>i</def> <sym>-&gt;</sym><br />
<def>                        toBits<br />
                        $ validCoords<br />
                        $ List</def><sym>.</sym><def>tail<br />
                        $ toCoords adjacent</def> <sym>(</sym><def>i</def> <sym>%</sym> <def>width</def><sym>) (</sym><def>i</def> <sym>/</sym> <def>width</def><sym>)</sym><br />
<def></def>                <sym>)</sym><br />
<def></def>                <sym>(</sym><def>List</def><sym>.</sym><def>replicate</def> <sym>(</sym><def>width</def> <sym>*</sym> <def>height</def><sym>) (</sym><def></def><num>0</num> <def></def><sym>::</sym> <def>Int</def><sym>))</sym><br />
<def></def>            <sym>)</sym><br />
<def></def>    <sym>;</sym><br />
<def></def><br />
<com>/**</com><br />
<com> * returns the board position 0 .. 49 of the first occuipied square</com><br />
<com> */</com><def><br />
getFirstSetBit</def> <sym>::</sym> <def>Long</def> <sym>-&gt;</sym> <def>Int</def><sym>;</sym><br />
<def>getFirstSetBit</def> <sym>!</sym><def>word</def> <sym>=</sym><br />
<def></def>    <kwa>let</kwa><br />
<def>        helper</def> <sym>::</sym> <def>Long</def> <sym>-&gt;</sym> <def>Long</def> <sym>-&gt;</sym> <def>Int</def> <sym>-&gt;</sym> <def>Int</def><sym>;</sym><br />
<def>        helper</def> <sym>!</sym><def>word</def> <sym>!</sym><def>bit</def> <sym>!</sym><def>i</def> <sym>=</sym><br />
<def></def>            <kwa>if</kwa> <def>bitwiseAnd word bit</def> <sym>!=</sym> <def></def><num>0</num> <def></def><kwa>then</kwa><br />
<def>                i</def><br />
            <kwa>else</kwa><br />
<def>                helper word</def> <sym>(</sym><def>shiftRUnsigned bit</def> <num>1</num><def></def><sym>) (</sym><def>i</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>)</sym><br />
<def></def>            <sym>;</sym><br />
<def></def>    <kwa>in</kwa><br />
<def>        helper word highBit</def> <num>0</num><br />
<def></def>    <sym>;</sym><br />
<def></def><br />
<com>/**</com><br />
<com> * return the number of bits that are set in a mask</com><br />
<com> */</com><def><br />
countBits</def> <sym>::</sym> <def>Long</def> <sym>-&gt;</sym> <def>Int</def><sym>;</sym><br />
<def>countBits</def> <sym>!</sym><def>word</def> <sym>=</sym><br />
<def></def>    <kwa>let</kwa><br />
<def>        helper</def> <sym>::</sym> <def>Long</def> <sym>-&gt;</sym> <def>Int</def> <sym>-&gt;</sym> <def>Int</def><sym>;</sym><br />
<def>        helper</def> <sym>!</sym><def>word</def> <sym>!</sym><def>count</def> <sym>=</sym><br />
<def></def>            <kwa>if</kwa> <def>word</def> <sym>==</sym> <def></def><num>0</num> <def></def><kwa>then</kwa><br />
<def>                count</def><br />
            <kwa>else</kwa><br />
<def>                helper</def> <sym>(</sym><def>bitwiseAnd word</def> <sym>(</sym><def>word</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>)) (</sym><def>count</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>)</sym><br />
<def></def>            <sym>;</sym><br />
<def></def>    <kwa>in</kwa><br />
<def>        eager $ helper word</def> <num>0</num><br />
<def></def>    <sym>;</sym><br />
<def></def><br />
<com>/**</com><br />
<com> * returns true if the board mask has an island of fewer than five positions -</com><br />
<com> * used to prune positions tha have 'holes' that no piece could fit into</com><br />
<com> * (as all pieces are of size 5)</com><br />
<com> */</com><def><br />
hasSmallIslands</def> <sym>::</sym> <def>Long</def> <sym>-&gt;</sym> <def>Boolean</def><sym>;</sym><br />
<def>hasSmallIslands</def> <sym>!</sym><def>board</def> <sym>=</sym><br />
<def></def>    <kwa>let</kwa><br />
<def>        fill</def> <sym>::</sym> <def>Long</def> <sym>-&gt;</sym> <def>Long</def> <sym>-&gt;</sym> <def>Long</def> <sym>-&gt;</sym> <def>Long</def><sym>;</sym><br />
<def>        fill</def> <sym>!</sym><def>board</def> <sym>!</sym><def>filled</def> <sym>!</sym><def>seeds</def> <sym>=</sym><br />
<def></def>            <kwa>if</kwa> <def>seeds</def> <sym>==</sym> <def></def><num>0</num> <def></def><kwa>then</kwa><br />
<def>                filled</def><br />
            <kwa>else</kwa><br />
<def></def>                <kwa>let</kwa><br />
<def>                    highestSeed</def> <sym>::</sym> <def>Int</def><sym>;</sym><br />
<def>                    highestSeed</def> <sym>=</sym> <def>eager $ getFirstSetBit seeds</def><sym>;</sym><br />
<def><br />
                    newSeeds</def> <sym>::</sym> <def>Long</def><sym>;</sym><br />
<def>                    newSeeds</def> <sym>=</sym><br />
<def>                        eager<br />
                        $ bitwiseAnd</def><br />
                            <sym>(</sym><def>longArray_subscript adjacentSquares highestSeed</def><sym>)</sym><br />
<def></def>                            <sym>(</sym><def>Bits</def><sym>.</sym><def>complement $ bitwiseOr filled board</def><sym>)</sym><br />
<def></def>                        <sym>;</sym><br />
<def></def>                <kwa>in</kwa><br />
<def>                    fill<br />
                        board</def><br />
                        <sym>(</sym><def>bitwiseOr filled</def> <sym>(</sym><def>bitwiseOr seeds newSeeds</def><sym>))</sym><br />
<def></def>                        <sym>(</sym><def>bitwiseAnd</def><br />
                            <sym>(</sym><def>bitwiseOr seeds newSeeds</def><sym>)</sym><br />
<def></def>                            <sym>(</sym><br />
<def>                                Bits</def><sym>.</sym><def>complement<br />
                                $ Bits</def><sym>.</sym><def>shiftR highBit</def> <sym>(</sym><def>fromInt highestSeed</def><sym>)</sym><br />
<def></def>                            <sym>)</sym><br />
<def></def>                        <sym>)</sym><br />
<def></def>            <sym>;</sym><br />
<def></def>    <kwa>in</kwa><br />
<def></def><br />
        <kwa>if</kwa> <def>bitwiseAnd board fullBoard</def> <sym>==</sym> <def>fullBoard</def> <kwa>then</kwa><br />
<def>            False</def><br />
        <kwa>else</kwa><br />
<def></def>            <kwa>let</kwa><br />
<def>                island</def> <sym>::</sym> <def>Long</def><sym>;</sym><br />
<def>                island</def> <sym>=</sym><br />
<def>                    eager<br />
                    $ fill<br />
                        board</def><br />
                        <num>0</num><br />
<def></def>                        <sym>(</sym><br />
<def>                            Bits</def><sym>.</sym><def>highestBitMask<br />
                            $ bitwiseAnd fullBoard</def> <sym>(</sym><def>Bits</def><sym>.</sym><def>complement board</def><sym>)</sym><br />
<def></def>                        <sym>)</sym><br />
<def></def>                    <sym>;</sym><br />
<def></def>            <kwa>in</kwa><br />
<def></def>                <kwa>if</kwa> <def>countBits island</def> <sym>&lt;</sym> <def></def><num>5</num> <def></def><kwa>then</kwa><br />
<def>                    True</def><br />
                <kwa>else</kwa><br />
<def>                    hasSmallIslands</def> <sym>(</sym><def>bitwiseOr board island</def><sym>)</sym><br />
<def></def>    <sym>;</sym><br />
<def></def><br />
<com>/**</com><br />
<com> * take a solution and make the reverse - a second solution that is a rotation of the first.</com><br />
<com> */</com><def><br />
makeReverseSolution</def> <sym>::</sym> <def>JLongArray</def> <sym>-&gt;</sym> <def>JLongArray</def> <sym>-&gt;</sym> <def>JLongArray</def><sym>;</sym><br />
<def>makeReverseSolution</def> <sym>!</sym><def>solution</def> <sym>!</sym><def>reversed</def> <sym>=</sym><br />
<def></def>    <kwa>let</kwa><br />
<def>        reverseMask</def> <sym>::</sym> <def>Long</def> <sym>-&gt;</sym> <def>Long</def><sym>;</sym><br />
<def>        reverseMask</def> <sym>!</sym><def>board</def> <sym>=</sym><br />
<def></def>            <kwa>let</kwa><br />
<def>                reverse</def> <sym>::</sym> <def>Long</def> <sym>-&gt;</sym> <def>Long</def> <sym>-&gt;</sym> <def>Long</def> <sym>-&gt;</sym> <def>Long</def> <sym>-&gt;</sym> <def>Long</def><sym>;</sym><br />
<def>                reverse</def> <sym>!</sym><def>board</def> <sym>!</sym><def>res</def> <sym>!</sym><def>fromBit</def> <sym>!</sym><def>toBit</def> <sym>=</sym><br />
<def></def>                    <kwa>if</kwa> <def>fromBit</def> <sym>&lt;</sym> <def>lowBit</def> <kwa>then</kwa><br />
<def>                        res</def><br />
                    <kwa>else if</kwa> <def>bitwiseAnd fromBit board</def> <sym>!=</sym> <def></def><num>0</num> <def></def><kwa>then</kwa><br />
<def>                        reverse<br />
                            board</def><br />
                            <sym>(</sym><def>bitwiseOr res toBit</def><sym>)</sym><br />
<def></def>                            <sym>(</sym><def>shiftRUnsigned fromBit</def> <num>1</num><def></def><sym>)</sym><br />
<def></def>                            <sym>(</sym><def>shiftL toBit</def> <num>1</num><def></def><sym>)</sym><br />
<def></def>                    <kwa>else</kwa><br />
<def>                        reverse<br />
                            board<br />
                            res</def><br />
                            <sym>(</sym><def>shiftRUnsigned fromBit</def> <num>1</num><def></def><sym>)</sym><br />
<def></def>                            <sym>(</sym><def>shiftL toBit</def> <num>1</num><def></def><sym>)</sym><br />
<def></def>                    <sym>;</sym><br />
<def></def>            <kwa>in</kwa><br />
<def>                reverse board</def> <sym>(</sym><def>bitwiseAnd board</def> <num>15</num><def></def><sym>)</sym> <def>highBit lowBit</def><br />
            <sym>;</sym><br />
<def><br />
        len</def> <sym>::</sym> <def>Int</def><sym>;</sym><br />
<def>        len</def> <sym>=</sym> <def>eager $ longArray_length solution</def><sym>;</sym><br />
<def><br />
        loop</def> <sym>::</sym> <def>Int</def> <sym>-&gt;</sym> <def>JLongArray</def><sym>;</sym><br />
<def>        loop</def> <sym>!</sym><def>i</def> <sym>=</sym><br />
<def></def>            <kwa>if</kwa> <def>i</def> <sym>&lt;</sym> <def>len</def> <kwa>then</kwa><br />
<def>                longArray_update<br />
                    reversed<br />
                    i</def><br />
                    <sym>(</sym><def>reverseMask $ longArray_subscript solution i</def><sym>)</sym><br />
<def></def>                <sym>`</sym><def>seq</def><sym>`</sym><br />
<def>                loop</def> <sym>(</sym><def>i</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>)</sym><br />
<def></def>            <kwa>else</kwa><br />
<def>                reversed</def><br />
            <sym>;</sym><br />
<def></def>    <kwa>in</kwa><br />
<def>        loop</def> <num>1</num><br />
<def></def>    <sym>;</sym><br />
<def></def><br />
<com>/** true if the coord is on the board*/</com><def><br />
validCoord</def> <sym>:: (</sym><def>Int</def><sym>,</sym> <def>Int</def><sym>) -&gt;</sym> <def>Boolean</def><sym>;</sym><br />
<def>validCoord</def> <sym>!</sym><def>coord</def> <sym>=</sym><br />
<def></def>    <kwa>case</kwa> <def>coord</def> <kwa>of</kwa><br />
<def></def>    <sym>(</sym><def>x</def><sym>,</sym> <def>y</def><sym>) -&gt;</sym> <def>x</def> <sym>&gt;=</sym> <def></def><num>0</num> <def></def><sym>&amp;&amp;</sym> <def>x</def> <sym>&lt;</sym> <def>width</def> <sym>&amp;&amp;</sym> <def>y</def> <sym>&gt;=</sym> <def></def><num>0</num> <def></def><sym>&amp;&amp;</sym> <def>y</def> <sym>&lt;</sym> <def>height</def><sym>;</sym><br />
<def></def>    <sym>;</sym><br />
<def></def><br />
<com>/** filter a list of corrds and return only those that fit on the board*/</com><def><br />
validCoords</def> <sym>:: [(</sym><def>Int</def><sym>,</sym> <def>Int</def><sym>)] -&gt; [(</sym><def>Int</def><sym>,</sym> <def>Int</def><sym>)];</sym><br />
<def>validCoords</def> <sym>!</sym><def>coords</def> <sym>=</sym> <def>List</def><sym>.</sym><def>filter validCoord coords</def><sym>;</sym><br />
<def></def><br />
<com>/** convert a piece to a list of coords*/</com><def><br />
toCoords</def> <sym>:: [</sym><def>Direction</def><sym>] -&gt;</sym> <def>Int</def> <sym>-&gt;</sym> <def>Int</def> <sym>-&gt; [(</sym><def>Int</def><sym>,</sym> <def>Int</def><sym>)];</sym><br />
<def>toCoords</def> <sym>!</sym><def>piece</def> <sym>!</sym><def>x</def> <sym>!</sym><def>y</def> <sym>=</sym><br />
<def></def>    <kwa>case</kwa> <def>piece</def> <kwa>of</kwa><br />
<def>    head</def> <sym>:</sym> <def>tail</def> <sym>-&gt;</sym><br />
<def></def>        <kwa>case</kwa> <def>head</def> <kwa>of</kwa><br />
<def>        E</def> <sym>-&gt; (</sym><def>x</def><sym>,</sym> <def>y</def><sym>) :</sym> <def>toCoords tail</def> <sym>(</sym><def>x</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>)</sym> <def>y</def><sym>;</sym><br />
<def>        SE</def> <sym>-&gt; (</sym><def>x</def><sym>,</sym> <def>y</def><sym>) :</sym> <def>toCoords tail</def> <sym>(</sym><def>x</def> <sym>+</sym> <def>bitwiseAnd y</def> <num>1</num><def></def><sym>) (</sym><def>y</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def>        SW</def> <sym>-&gt;</sym><br />
<def></def>            <sym>(</sym><def>x</def><sym>,</sym> <def>y</def><sym>) :</sym> <def>toCoords tail</def> <sym>(</sym><def>x</def> <sym>- (</sym><def></def><num>1</num> <def></def><sym>-</sym> <def>bitwiseAnd y</def> <num>1</num><def></def><sym>)) (</sym><def>y</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def>        W</def> <sym>-&gt; (</sym><def>x</def><sym>,</sym> <def>y</def><sym>) :</sym> <def>toCoords tail</def> <sym>(</sym><def>x</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>)</sym> <def>y</def><sym>;</sym><br />
<def>        NW</def> <sym>-&gt;</sym><br />
<def></def>            <sym>(</sym><def>x</def><sym>,</sym> <def>y</def><sym>) :</sym> <def>toCoords tail</def> <sym>(</sym><def>x</def> <sym>- (</sym><def></def><num>1</num> <def></def><sym>-</sym> <def>bitwiseAnd y</def> <num>1</num><def></def><sym>)) (</sym><def>y</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def>        NE</def> <sym>-&gt; (</sym><def>x</def><sym>,</sym> <def>y</def><sym>) :</sym> <def>toCoords tail</def> <sym>(</sym><def>x</def> <sym>+</sym> <def>bitwiseAnd y</def> <num>1</num><def></def><sym>) (</sym><def>y</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def></def>        <sym>;</sym><br />
<def></def>    <sym>[] -&gt; [(</sym><def>x</def><sym>,</sym> <def>y</def><sym>)];</sym><br />
<def></def>    <sym>;</sym><br />
<def><br />
getValueAtbit</def> <sym>::</sym> <def>JLongArray</def> <sym>-&gt;</sym> <def>Long</def> <sym>-&gt;</sym> <def>Int</def> <sym>-&gt;</sym> <def>Long</def><sym>;</sym><br />
<def>getValueAtbit</def> <sym>!</sym><def>solution</def> <sym>!</sym><def>bit</def> <sym>!</sym><def>i</def> <sym>=</sym><br />
<def></def>    <kwa>if</kwa> <def>bitwiseAnd bit</def> <sym>(</sym><def>longArray_subscript solution i</def><sym>) !=</sym> <def></def><num>0</num> <def></def><kwa>then</kwa><br />
<def>        bitwiseAnd</def> <sym>(</sym><def>longArray_subscript solution i</def><sym>)</sym> <def></def><num>15</num><br />
<def></def>    <kwa>else</kwa><br />
<def>        getValueAtbit solution bit</def> <sym>(</sym><def>i</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>)</sym><br />
<def></def>    <sym>;</sym><br />
<def><br />
copy</def> <sym>::</sym> <def>JLongArray</def> <sym>-&gt;</sym> <def>JLongArray</def> <sym>-&gt;</sym> <def>Int</def> <sym>-&gt; ();</sym><br />
<def>copy</def> <sym>!</sym><def>solution1</def> <sym>!</sym><def>solution2</def> <sym>!</sym><def>i</def> <sym>=</sym><br />
<def></def>    <kwa>if</kwa> <def>i</def> <sym>&lt;</sym> <def></def><num>11</num> <def></def><kwa>then</kwa><br />
<def>        longArray_update solution1 i</def> <sym>(</sym><def>longArray_subscript solution2 i</def><sym>)</sym><br />
<def></def>        <sym>`</sym><def>seq</def><sym>`</sym><br />
<def>        copy solution1 solution2</def> <sym>(</sym><def>i</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>)</sym><br />
<def></def>    <kwa>else</kwa><br />
<def></def>        <sym>()</sym><br />
<def></def>    <sym>;</sym><br />
<def></def><br />
<com>/**</com><br />
<com> * set solution 2 to the max of solution 2 and solution 1.</com><br />
<com> */</com><def><br />
updateMaxSolution</def> <sym>::</sym> <def>JLongArray</def> <sym>-&gt;</sym> <def>JLongArray</def> <sym>-&gt; ();</sym><br />
<def>updateMaxSolution</def> <sym>!</sym><def>solution1</def> <sym>!</sym><def>solution2</def> <sym>=</sym><br />
<def></def>    <kwa>let</kwa><br />
<def>        greaterThan</def> <sym>::</sym> <def>JLongArray</def> <sym>-&gt;</sym> <def>JLongArray</def> <sym>-&gt;</sym> <def>Long</def> <sym>-&gt;</sym> <def>Boolean</def><sym>;</sym><br />
<def>        greaterThan</def> <sym>!</sym><def>solution1</def> <sym>!</sym><def>solution2</def> <sym>!</sym><def>bit</def> <sym>=</sym><br />
<def></def>            <kwa>let</kwa><br />
<def>                v1</def> <sym>::</sym> <def>Long</def><sym>;</sym><br />
<def>                v1</def> <sym>=</sym> <def>eager $ getValueAtbit solution1 bit</def> <num>1</num><def></def><sym>;</sym><br />
<def><br />
                v2</def> <sym>::</sym> <def>Long</def><sym>;</sym><br />
<def>                v2</def> <sym>=</sym> <def>eager $ getValueAtbit solution2 bit</def> <num>1</num><def></def><sym>;</sym><br />
<def></def>            <kwa>in</kwa><br />
<def></def>                <kwa>if</kwa> <def>v1</def> <sym>==</sym> <def>v2</def> <kwa>then</kwa><br />
<def>                    greaterThan solution1 solution2</def> <sym>(</sym><def>shiftRUnsigned bit</def> <num>1</num><def></def><sym>)</sym><br />
<def></def>                <kwa>else</kwa><br />
<def>                    v1</def> <sym>&lt;</sym> <def>v2</def><br />
            <sym>;</sym><br />
<def></def>    <kwa>in</kwa><br />
<def></def><br />
        <kwa>if</kwa> <def>greaterThan solution1 solution2 highBit</def> <kwa>then</kwa><br />
<def>            copy solution1 solution2</def> <num>0</num><br />
<def></def>        <kwa>else</kwa><br />
<def></def>            <sym>()</sym><br />
<def></def>    <sym>;</sym><br />
<def></def><br />
<com>/**</com><br />
<com> * set solution 2 to the minimum of solution 2 and solution 1.</com><br />
<com> */</com><def><br />
updateMinSolution</def> <sym>::</sym> <def>JLongArray</def> <sym>-&gt;</sym> <def>JLongArray</def> <sym>-&gt; ();</sym><br />
<def>updateMinSolution</def> <sym>!</sym><def>solution1</def> <sym>!</sym><def>solution2</def> <sym>=</sym><br />
<def></def>    <kwa>let</kwa><br />
<def>        lessThan</def> <sym>::</sym> <def>JLongArray</def> <sym>-&gt;</sym> <def>JLongArray</def> <sym>-&gt;</sym> <def>Long</def> <sym>-&gt;</sym> <def>Boolean</def><sym>;</sym><br />
<def>        lessThan</def> <sym>!</sym><def>solution1</def> <sym>!</sym><def>solution2</def> <sym>!</sym><def>bit</def> <sym>=</sym><br />
<def></def>            <kwa>let</kwa><br />
<def>                v1</def> <sym>::</sym> <def>Long</def><sym>;</sym><br />
<def>                v1</def> <sym>=</sym> <def>eager $ getValueAtbit solution1 bit</def> <num>1</num><def></def><sym>;</sym><br />
<def><br />
                v2</def> <sym>::</sym> <def>Long</def><sym>;</sym><br />
<def>                v2</def> <sym>=</sym> <def>eager $ getValueAtbit solution2 bit</def> <num>1</num><def></def><sym>;</sym><br />
<def></def>            <kwa>in</kwa><br />
<def></def>                <kwa>if</kwa> <def>v1</def> <sym>==</sym> <def>v2</def> <kwa>then</kwa><br />
<def>                    lessThan solution1 solution2</def> <sym>(</sym><def>shiftRUnsigned bit</def> <num>1</num><def></def><sym>)</sym><br />
<def></def>                <kwa>else</kwa><br />
<def>                    v1</def> <sym>&gt;</sym> <def>v2</def><br />
            <sym>;</sym><br />
<def></def>    <kwa>in</kwa><br />
<def></def><br />
        <kwa>if</kwa> <def>lessThan solution1 solution2 highBit</def> <kwa>then</kwa><br />
<def>            copy solution1 solution2</def> <num>0</num><br />
<def></def>        <kwa>else</kwa><br />
<def></def>            <sym>()</sym><br />
<def></def>    <sym>;</sym><br />
<def></def><br />
<com>/** true if the list of coords all fit on the board*/</com><def><br />
fits</def> <sym>:: [(</sym><def>Int</def><sym>,</sym> <def>Int</def><sym>)] -&gt;</sym> <def>Boolean</def><sym>;</sym><br />
<def>fits</def> <sym>!</sym><def>coords</def> <sym>=</sym> <def>List</def><sym>.</sym><def>all validCoord coords</def><sym>;</sym><br />
<def></def><br />
<com>/** convert a coord to a bit mask*/</com><def><br />
toBit</def> <sym>:: (</sym><def>Int</def><sym>,</sym> <def>Int</def><sym>) -&gt;</sym> <def>Long</def><sym>;</sym><br />
<def>toBit</def> <sym>!</sym><def>coord</def> <sym>=</sym> <def>shiftRUnsigned highBit</def> <sym>(</sym><def>fromInt</def> <sym>(</sym><def>coord</def><sym>.</sym><def>#</def><num>1</num> <def></def><sym>+</sym> <def>coord</def><sym>.</sym><def>#</def><num>2</num> <def></def><sym>*</sym> <def></def><num>5</num><def></def><sym>));</sym><br />
<def></def><br />
<com>/** convert a list of coords to be bit mask*/</com><def><br />
toBits</def> <sym>:: [(</sym><def>Int</def><sym>,</sym> <def>Int</def><sym>)] -&gt;</sym> <def>Long</def><sym>;</sym><br />
<def>toBits</def> <sym>!</sym><def>coords</def> <sym>=</sym> <def>foldLeftStrict bitwiseOr</def> <num>0</num> <def></def><sym>(</sym><def>map toBit coords</def><sym>);</sym><br />
<def></def><br />
<com>/** convert a list of coords to be bit mask, with a piece id in the lower bits*/</com><def><br />
coordsToBits</def> <sym>:: [(</sym><def>Int</def><sym>,</sym> <def>Int</def><sym>)] -&gt;</sym> <def>Int</def> <sym>-&gt;</sym> <def>Long</def><sym>;</sym><br />
<def>coordsToBits</def> <sym>!</sym><def>coords</def> <sym>!</sym><def>pieceNo</def> <sym>=</sym><br />
<def></def>    <kwa>let</kwa><br />
<def>        bits</def> <sym>:: [</sym><def>Long</def><sym>];</sym><br />
<def>        bits</def> <sym>=</sym> <def>map toBit coords</def><sym>;</sym><br />
<def></def>    <kwa>in</kwa><br />
<def>        foldLeftStrict bitwiseOr</def> <sym>(</sym><def>fromInt pieceNo</def><sym>)</sym> <def>bits</def><br />
    <sym>;</sym><br />
<def></def><br />
<com>/** find the next empty square starting at square*/</com><def><br />
findNextEmptySquare</def> <sym>::</sym> <def>Long</def> <sym>-&gt;</sym> <def>Int</def> <sym>-&gt;</sym> <def>Int</def><sym>;</sym><br />
<def>findNextEmptySquare</def> <sym>!</sym><def>board</def> <sym>!</sym><def>square</def> <sym>=</sym><br />
<def></def>    <kwa>if</kwa> <def>bitwiseAnd board</def> <sym>(</sym><def>shiftRUnsigned highBit</def> <sym>(</sym><def>fromInt square</def><sym>)) ==</sym> <def></def><num>0</num> <def></def><kwa>then</kwa><br />
<def>        square</def><br />
    <kwa>else</kwa><br />
<def>        findNextEmptySquare board</def> <sym>(</sym><def>square</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>)</sym><br />
<def></def>    <sym>;</sym><br />
<def></def><br />
<com>/** convert a solution to s string in the benchmark format*/</com><def><br />
showSolution</def> <sym>::</sym> <def>JLongArray</def> <sym>-&gt;</sym> <def>String</def><sym>;</sym><br />
<def>showSolution</def> <sym>!</sym><def>solution</def> <sym>=</sym><br />
<def></def>    <kwa>let</kwa><br />
<def>        findId</def> <sym>::</sym> <def>Int</def> <sym>-&gt;</sym> <def>Long</def> <sym>-&gt;</sym> <def>String</def><sym>;</sym><br />
<def>        findId</def> <sym>!</sym><def>i</def> <sym>!</sym><def>bit</def> <sym>=</sym><br />
<def></def>            <kwa>if</kwa> <def>i</def> <sym>==</sym> <def></def><num>11</num> <def></def><kwa>then</kwa><br />
<def></def>                <str>&quot;-&quot;</str><def></def><br />
            <kwa>else if</kwa> <def>bitwiseAnd</def> <sym>(</sym><def>longArray_subscript solution i</def><sym>)</sym> <def>bit</def> <sym>&gt;</sym> <def></def><num>0</num> <def></def><kwa>then</kwa><br />
<def>                show</def> <sym>(</sym><def>i</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>)</sym><br />
<def></def>            <kwa>else</kwa><br />
<def>                findId</def> <sym>(</sym><def>i</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>)</sym> <def>bit</def><br />
            <sym>;</sym><br />
<def><br />
        drawBoard</def> <sym>::</sym> <def>Int</def> <sym>-&gt;</sym> <def>Long</def> <sym>-&gt;</sym> <def>String</def> <sym>-&gt;</sym> <def>String</def><sym>;</sym><br />
<def>        drawBoard</def> <sym>!</sym><def>i</def> <sym>!</sym><def>bit</def> <sym>!</sym><def>result</def> <sym>=</sym><br />
<def></def>            <kwa>let</kwa><br />
<def>                term1</def> <sym>::</sym> <def>String</def><sym>;</sym><br />
<def>                term1</def> <sym>=</sym><br />
<def></def>                    <kwa>if</kwa> <def>i</def> <sym>&gt;</sym> <def></def><num>0</num> <def></def><sym>&amp;&amp;</sym> <def>i</def> <sym>%</sym> <def></def><num>5</num> <def></def><sym>==</sym> <def></def><num>0</num> <def></def><kwa>then</kwa><br />
<def></def>                        <str>&quot;</str><esc>\n</esc><str>&quot;</str><def></def><br />
                    <kwa>else</kwa><br />
<def></def>                        <str>&quot;&quot;</str><def></def><br />
                    <sym>;</sym><br />
<def><br />
                term2</def> <sym>::</sym> <def>String</def><sym>;</sym><br />
<def>                term2</def> <sym>=</sym><br />
<def></def>                    <kwa>if</kwa> <def>i</def> <sym>%</sym> <def></def><num>10</num> <def></def><sym>==</sym> <def></def><num>5</num> <def></def><kwa>then</kwa><br />
<def></def>                        <str>&quot; &quot;</str><def></def><br />
                    <kwa>else</kwa><br />
<def></def>                        <str>&quot;&quot;</str><def></def><br />
                    <sym>;</sym><br />
<def></def>            <kwa>in</kwa><br />
<def></def>                <kwa>if</kwa> <def>i</def> <sym>&lt;</sym> <def></def><num>50</num> <def></def><kwa>then</kwa><br />
<def>                    drawBoard</def><br />
                        <sym>(</sym><def>i</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>)</sym><br />
<def></def>                        <sym>(</sym><def>shiftRUnsigned bit</def> <num>1</num><def></def><sym>)</sym><br />
<def></def>                        <sym>(</sym><def>result</def> <sym>++</sym> <def>term1</def> <sym>++</sym> <def>term2</def> <sym>++</sym> <def>findId</def> <num>0</num> <def>bit</def> <sym>++</sym> <def></def><str>&quot; &quot;</str><def></def><sym>)</sym><br />
<def></def>                <kwa>else</kwa><br />
<def>                    result</def><br />
            <sym>;</sym><br />
<def></def>    <kwa>in</kwa><br />
<def><br />
        drawBoard</def> <num>0</num> <def>highBit</def> <str>&quot;&quot;</str><def></def><br />
    <sym>;</sym><br />
<def></def><br />
<com>/**</com><br />
<com> * Creates an array in which for each square on the board</com><br />
<com> * there is an array of bit masks for the pieces that occupy that square as their first square</com><br />
<com> */</com><def><br />
allSortedMasks</def> <sym>:: [[</sym><def>Direction</def><sym>]] -&gt;</sym> <def>Array JLongArray</def><sym>;</sym><br />
<def>allSortedMasks</def> <sym>!</sym><def>pieces</def> <sym>=</sym><br />
<def></def>    <kwa>let</kwa><br />
<def>        masks</def> <sym>:: [</sym><def>Long</def><sym>];</sym><br />
<def>        masks</def> <sym>=</sym><br />
<def>            List</def><sym>.</sym><def>reverse<br />
            $ List</def><sym>.</sym><def>sortExternal<br />
            $ Prelude</def><sym>.</sym><def>concat<br />
            $ List</def><sym>.</sym><def>zipWith getAllMasks pieces</def> <sym>[</sym><def></def><num>1</num><def></def><sym>,</sym> <def></def><num>2</num><def></def><sym>,</sym> <def></def><num>3</num><def></def><sym>,</sym> <def></def><num>4</num><def></def><sym>,</sym> <def></def><num>5</num><def></def><sym>,</sym> <def></def><num>6</num><def></def><sym>,</sym> <def></def><num>7</num><def></def><sym>,</sym> <def></def><num>8</num><def></def><sym>,</sym> <def></def><num>9</num><def></def><sym>,</sym> <def></def><num>10</num><def></def><sym>]</sym><br />
<def></def>            <sym>;</sym><br />
<def><br />
        loop</def> <sym>::</sym> <def>Long</def> <sym>-&gt; [</sym><def>Long</def><sym>] -&gt; [[</sym><def>Long</def><sym>]] -&gt; [[</sym><def>Long</def><sym>]];</sym><br />
<def>        loop</def> <sym>!</sym><def>bit</def> <sym>!</sym><def>masks</def> <sym>!</sym><def>res</def> <sym>=</sym><br />
<def></def>            <kwa>if</kwa> <def>bit</def> <sym>&lt;</sym> <def>lowBit</def> <kwa>then</kwa><br />
<def>                res</def><br />
            <kwa>else</kwa><br />
<def>                loop</def><br />
                    <sym>(</sym><def>shiftRUnsigned bit</def> <num>1</num><def></def><sym>)</sym><br />
<def></def>                    <sym>(</sym><def>List</def><sym>.</sym><def>dropWhile</def> <sym>(</sym><def>\</def><sym>!</sym><def>a</def> <sym>-&gt;</sym> <def>a</def> <sym>&gt;</sym> <def>bit</def><sym>)</sym> <def>masks</def><sym>)</sym><br />
<def></def>                    <sym>(</sym><def>res</def> <sym>++ [</sym><def>List</def><sym>.</sym><def>takeWhile</def> <sym>(</sym><def>\</def><sym>!</sym><def>a</def> <sym>-&gt;</sym> <def>a</def> <sym>&gt;</sym> <def>bit</def><sym>)</sym> <def>masks</def><sym>])</sym><br />
<def></def>            <sym>;</sym><br />
<def></def>    <kwa>in</kwa><br />
<def><br />
        Array</def><sym>.</sym><def>fromList</def> <sym>(</sym><def>map jLongArrayfromList</def> <sym>(</sym><def>loop highBit masks</def> <sym>[]))</sym><br />
<def></def>    <sym>;</sym><br />
<def><br />
meteor</def> <sym>::</sym> <def>Int</def> <sym>-&gt; ();</sym><br />
<def>meteor</def> <sym>!</sym><def>n</def> <sym>=</sym><br />
<def></def>    <kwa>let</kwa><br />
<def>        masks</def> <sym>::</sym> <def>Array JLongArray</def><sym>;</sym><br />
<def>        masks</def> <sym>=</sym> <def>allSortedMasks pieces</def><sym>;</sym><br />
<def><br />
        minSol</def> <sym>::</sym> <def>JLongArray</def><sym>;</sym><br />
<def>        minSol</def> <sym>=</sym> <def>longArray_new</def> <num>11</num><def></def><sym>;</sym><br />
<def><br />
        maxSol</def> <sym>::</sym> <def>JLongArray</def><sym>;</sym><br />
<def>        maxSol</def> <sym>=</sym> <def>longArray_new</def> <num>11</num><def></def><sym>;</sym><br />
<def><br />
        workingSolution</def> <sym>::</sym> <def>JLongArray</def><sym>;</sym><br />
<def>        workingSolution</def> <sym>=</sym> <def>longArray_new</def> <num>11</num><def></def><sym>;</sym><br />
<def></def>    <kwa>in</kwa><br />
<def>        longArray_update maxSol</def> <num>1</num> <def>highBit</def><br />
        <sym>`</sym><def>seq</def><sym>`</sym><br />
<def>        longArray_update minSol</def> <num>1</num> <def></def><sym>(</sym><def>bitwiseOr highBit</def> <num>11</num><def></def><sym>)</sym><br />
<def></def>        <sym>`</sym><def>seq</def><sym>`</sym><br />
<def>        solve</def><br />
            <num>0</num><br />
<def>            emptyBoard<br />
            workingSolution</def><br />
            <sym>(</sym><def>longArray_new</def> <num>11</num><def></def><sym>)</sym><br />
<def>            masks</def><br />
            <sym>(</sym><def>Array</def><sym>.</sym><def>subscript masks</def> <num>0</num><def></def><sym>)</sym><br />
<def></def>            <num>0</num><br />
<def></def>            <num>0</num><br />
<def>            maxSol<br />
            minSol</def><br />
        <sym>`</sym><def>seq</def><sym>`</sym><br />
<def>        printLine</def><br />
            <sym>(</sym><br />
<def>                show</def> <sym>(</sym><def>longArray_subscript workingSolution</def> <num>0</num><def></def><sym>)</sym><br />
<def></def>                <sym>++</sym> <def></def><str>&quot; solutions found&quot;</str><def></def><br />
            <sym>)</sym><br />
<def></def>        <sym>`</sym><def>seq</def><sym>`</sym><br />
<def>        printLine</def> <str>&quot;&quot;</str><def></def><br />
        <sym>`</sym><def>seq</def><sym>`</sym><br />
<def>        printLine</def> <sym>(</sym><def>showSolution minSol</def><sym>)</sym><br />
<def></def>        <sym>`</sym><def>seq</def><sym>`</sym><br />
<def>        printLine</def> <str>&quot;&quot;</str><def></def><br />
        <sym>`</sym><def>seq</def><sym>`</sym><br />
<def>        printLine</def> <sym>(</sym><def>showSolution maxSol</def><sym>)</sym><br />
<def></def>        <sym>`</sym><def>seq</def><sym>`</sym><br />
<def>        printLine</def> <str>&quot;&quot;</str><def></def><br />
    <sym>;</sym><br />
<def><br />
solve</def> <sym>::</sym><br />
<def>    Int</def> <sym>-&gt;</sym> <def>Long</def> <sym>-&gt;</sym> <def>JLongArray</def> <sym>-&gt;</sym> <def>JLongArray</def> <sym>-&gt;</sym> <def>Array JLongArray</def> <sym>-&gt;</sym> <def>JLongArray</def><br />
    <sym>-&gt;</sym> <def>Int</def> <sym>-&gt;</sym> <def>Int</def> <sym>-&gt;</sym> <def>JLongArray</def> <sym>-&gt;</sym> <def>JLongArray</def> <sym>-&gt; ();</sym><br />
<def>solve</def> <sym>!</sym><def>i</def> <sym>!</sym><def>board</def> <sym>!</sym><def>solution</def> <sym>!</sym><def>reverseSolution</def> <sym>!</sym><def>allMasks</def> <sym>!</sym><def>masks</def> <sym>!</sym><def>numPieces</def><br />
      <sym>!</sym><def>boardSquare</def> <sym>!</sym><def>maxSolution</def> <sym>!</sym><def>minSolution</def> <sym>=</sym><br />
<def></def><br />
    <kwa>if</kwa> <def>i</def> <sym>&gt;=</sym> <def>longArray_length masks</def> <kwa>then</kwa><br />
<def></def>        <sym>()</sym><br />
<def></def>    <kwa>else</kwa><br />
<def></def>        <kwa>let</kwa><br />
<def>            pieceMask</def> <sym>::</sym> <def>Long</def><sym>;</sym><br />
<def>            pieceMask</def> <sym>=</sym> <def>eager $ longArray_subscript masks i</def><sym>;</sym><br />
<def><br />
            pieceId</def> <sym>::</sym> <def>Int</def><sym>;</sym><br />
<def>            pieceId</def> <sym>=</sym> <def>eager $ Prelude</def><sym>.</sym><def>fromLong</def> <sym>(</sym><def>bitwiseAnd pieceMask</def> <num>15</num><def></def><sym>);</sym><br />
<def></def>        <kwa>in</kwa><br />
<def></def><br />
            <slc>//if the piece is not already in use and it fits</slc><br />
<def></def>            <kwa>if</kwa><br />
<def>                longArray_subscript solution pieceId</def> <sym>==</sym> <def></def><num>0</num><br />
<def></def>                <sym>&amp;&amp;</sym> <def>bitwiseAnd board pieceMask</def> <sym>&lt;</sym> <def></def><num>16</num><br />
<def></def>            <kwa>then</kwa><br />
<def></def>                <kwa>let</kwa><br />
<def>                    newBoard</def> <sym>::</sym> <def>Long</def><sym>;</sym><br />
<def>                    newBoard</def> <sym>=</sym> <def>eager $ bitwiseOr board pieceMask</def><sym>;</sym><br />
<def><br />
                    nextSquare</def> <sym>::</sym> <def>Int</def><sym>;</sym><br />
<def>                    nextSquare</def> <sym>=</sym><br />
<def>                        eager $ findNextEmptySquare newBoard boardSquare</def><sym>;</sym><br />
<def></def>                <kwa>in</kwa><br />
<def>                    longArray_update solution pieceId pieceMask</def><br />
                    <sym>`</sym><def>seq</def><sym>`</sym><br />
<def></def>                    <sym>(</sym><br />
<def></def>                        <kwa>if</kwa> <def>numPieces</def> <sym>==</sym> <def></def><num>9</num> <def></def><kwa>then</kwa><br />
<def>                            longArray_update<br />
                                solution</def><br />
                                <num>0</num><br />
<def></def>                                <sym>(</sym><def>longArray_subscript solution</def> <num>0</num> <def></def><sym>+</sym> <def></def><num>2</num><def></def><sym>)</sym><br />
<def></def>                            <sym>`</sym><def>seq</def><sym>`</sym><br />
<def>                            makeReverseSolution solution reverseSolution</def><br />
                            <sym>`</sym><def>seq</def><sym>`</sym><br />
<def>                            updateMaxSolution maxSolution solution</def><br />
                            <sym>`</sym><def>seq</def><sym>`</sym><br />
<def>                            updateMaxSolution maxSolution reverseSolution</def><br />
                            <sym>`</sym><def>seq</def><sym>`</sym><br />
<def>                            updateMinSolution minSolution solution</def><br />
                            <sym>`</sym><def>seq</def><sym>`</sym><br />
<def>                            updateMinSolution minSolution reverseSolution</def><br />
                            <sym>`</sym><def>seq</def><sym>`</sym><br />
<def>                            longArray_update solution pieceId</def> <num>0</num><br />
<def></def>                            <sym>`</sym><def>seq</def><sym>`</sym><br />
<def></def>                            <sym>()</sym><br />
<def></def>                        <kwa>else if</kwa><br />
<def>                            nextSquare</def> <sym>&gt;</sym> <def></def><num>25</num><br />
<def></def>                            <sym>&amp;&amp;</sym> <def>longArray_subscript solution</def> <num>1</num> <def></def><sym>==</sym> <def></def><num>0</num><br />
<def></def>                        <kwa>then</kwa><br />
<def>                            longArray_update solution pieceId</def> <num>0</num><br />
<def></def>                            <sym>`</sym><def>seq</def><sym>`</sym><br />
<def>                            solve</def><br />
                                <sym>(</sym><def>i</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>)</sym><br />
<def>                                board<br />
                                solution<br />
                                reverseSolution<br />
                                allMasks<br />
                                masks<br />
                                numPieces<br />
                                boardSquare<br />
                                maxSolution<br />
                                minSolution</def><br />
                        <kwa>else</kwa><br />
<def>                            solve</def><br />
                                <num>0</num><br />
<def>                                newBoard<br />
                                solution<br />
                                reverseSolution<br />
                                allMasks</def><br />
                                <sym>(</sym><def>Array</def><sym>.</sym><def>subscript allMasks nextSquare</def><sym>)</sym><br />
<def></def>                                <sym>(</sym><def>numPieces</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>)</sym><br />
<def>                                nextSquare<br />
                                maxSolution<br />
                                minSolution</def><br />
                            <sym>`</sym><def>seq</def><sym>`</sym><br />
<def>                            longArray_update solution pieceId</def> <num>0</num><br />
<def></def>                            <sym>`</sym><def>seq</def><sym>`</sym><br />
<def>                            solve</def><br />
                                <sym>(</sym><def>i</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>)</sym><br />
<def>                                board<br />
                                solution<br />
                                reverseSolution<br />
                                allMasks<br />
                                masks<br />
                                numPieces<br />
                                boardSquare<br />
                                maxSolution<br />
                                minSolution</def><br />
                    <sym>)</sym><br />
<def></def>            <kwa>else</kwa><br />
<def>                solve</def><br />
                    <sym>(</sym><def>i</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>)</sym><br />
<def>                    board<br />
                    solution<br />
                    reverseSolution<br />
                    allMasks<br />
                    masks<br />
                    numPieces<br />
                    boardSquare<br />
                    maxSolution<br />
                    minSolution</def><br />
    <sym>;</sym><br />
<def></def><br />
<com>/**</com><br />
<com> * computes a list of all the masks for a particular piece.</com><br />
<com> * The list includes all positions, rotations and flips of the piece.</com><br />
<com> */</com><def><br />
getAllMasks</def> <sym>:: [</sym><def>Direction</def><sym>] -&gt;</sym> <def>Int</def> <sym>-&gt; [</sym><def>Long</def><sym>];</sym><br />
<def>getAllMasks</def> <sym>!</sym><def>piece</def> <sym>!</sym><def>pieceNo</def> <sym>=</sym><br />
<def></def>    <kwa>let</kwa><br />
<def></def><br />
        <slc>//this is used so we omit masks were piece 1 is in the bottom half of the board</slc><br />
<def></def>        <slc>//these positions will be covered by symmetry</slc><br />
<def>        heightp</def> <sym>::</sym> <def>Int</def><sym>;</sym><br />
<def>        heightp</def> <sym>=</sym><br />
<def>            eager<br />
            $</def><br />
            <sym>(</sym><br />
<def></def>                <kwa>if</kwa> <def>pieceNo</def> <sym>==</sym> <def></def><num>1</num> <def></def><kwa>then</kwa><br />
<def>                    height</def> <sym>/</sym> <def></def><num>2</num> <def></def><sym>-</sym> <def></def><num>1</num><br />
<def></def>                <kwa>else</kwa><br />
<def>                    height</def><br />
            <sym>)</sym><br />
<def></def>            <sym>;</sym><br />
<def><br />
        getRotationMasks</def> <sym>:: [</sym><def>Direction</def><sym>] -&gt;</sym> <def>Int</def> <sym>-&gt; [</sym><def>Long</def><sym>] -&gt; [</sym><def>Long</def><sym>];</sym><br />
<def>        getRotationMasks</def> <sym>!</sym><def>piece</def> <sym>!</sym><def>n</def> <sym>!</sym><def>masks</def> <sym>=</sym><br />
<def>            getTranslationMasks piece</def><br />
            <sym>++</sym> <def>iff</def><br />
                <sym>(</sym><def>n</def> <sym>&gt;</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def></def>                <sym>(</sym><def>getRotationMasks</def> <sym>(</sym><def>rotatePiece piece</def><sym>) (</sym><def>n</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>)</sym> <def>masks</def><sym>)</sym><br />
<def></def>                <sym>[]</sym><br />
<def></def>            <sym>;</sym><br />
<def><br />
        getTranslationMasks</def> <sym>:: [</sym><def>Direction</def><sym>] -&gt; [</sym><def>Long</def><sym>];</sym><br />
<def>        getTranslationMasks</def> <sym>!</sym><def>piece</def> <sym>=</sym><br />
<def></def>            <kwa>let</kwa><br />
<def>                loop</def> <sym>::</sym> <def>Int</def> <sym>-&gt;</sym> <def>Int</def> <sym>-&gt; [</sym><def>Long</def><sym>] -&gt; [</sym><def>Long</def><sym>];</sym><br />
<def>                loop</def> <sym>!</sym><def>x</def> <sym>!</sym><def>y</def> <sym>!</sym><def>masks</def> <sym>=</sym><br />
<def></def>                    <kwa>if</kwa> <def>x</def> <sym>&lt;</sym> <def>width</def> <kwa>then</kwa><br />
<def></def>                        <kwa>let</kwa><br />
<def>                            coords</def> <sym>:: [(</sym><def>Int</def><sym>,</sym> <def>Int</def><sym>)];</sym><br />
<def>                            coords</def> <sym>=</sym> <def>eager $ toCoords piece x y</def><sym>;</sym><br />
<def><br />
                            mask</def> <sym>::</sym> <def>Long</def><sym>;</sym><br />
<def>                            mask</def> <sym>=</sym> <def>eager $ coordsToBits coords pieceNo</def><sym>;</sym><br />
<def></def>                        <kwa>in</kwa><br />
<def></def>                            <kwa>if</kwa><br />
<def>                                fits coords</def><br />
                                <sym>&amp;&amp; (</sym><def>Prelude</def><sym>.</sym><def>not $ hasSmallIslands mask</def><sym>)</sym><br />
<def></def>                            <kwa>then</kwa><br />
<def>                                loop</def> <sym>(</sym><def>x</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>)</sym> <def>y</def> <sym>(</sym><def>mask</def> <sym>:</sym> <def>masks</def><sym>)</sym><br />
<def></def>                            <kwa>else</kwa><br />
<def></def>                                <slc>//reject the piece</slc><br />
<def>                                loop</def> <sym>(</sym><def>x</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>)</sym> <def>y masks</def><br />
                    <kwa>else if</kwa> <def>y</def> <sym>&lt;</sym> <def>heightp</def> <kwa>then</kwa><br />
<def>                        loop</def> <num>0</num> <def></def><sym>(</sym><def>y</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>)</sym> <def>masks</def><br />
                    <kwa>else</kwa><br />
<def>                        masks</def><br />
                    <sym>;</sym><br />
<def></def>            <kwa>in</kwa><br />
<def>                loop</def> <num>0 0</num> <def></def><sym>[]</sym><br />
<def></def>            <sym>;</sym><br />
<def></def>    <kwa>in</kwa><br />
<def>        getRotationMasks piece</def> <num>5</num> <def></def><sym>[]</sym><br />
<def></def>        <sym>++</sym> <def>getRotationMasks</def> <sym>(</sym><def>flipPiece piece</def><sym>)</sym> <def></def><num>5</num> <def></def><sym>[]</sym><br />
<def></def>    <sym>;</sym><br />
<def><br />
emptyBoard</def> <sym>::</sym> <def>Long</def><sym>;</sym><br />
<def>emptyBoard</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def><br />
main</def> <sym>:: [</sym><def>String</def><sym>] -&gt; ();</sym><br />
<def></def><kwa>public</kwa> <def>main</def> <sym>!</sym><def>args</def> <sym>=</sym><br />
<def></def>    <kwa>let</kwa><br />
<def>        n</def> <sym>::</sym> <def>Int</def><sym>;</sym><br />
<def>        n</def> <sym>=</sym> <def>eager $ stringToInt</def> <sym>(</sym><def>head args</def><sym>);</sym><br />
<def></def>    <kwa>in</kwa><br />
<def>        meteor n</def><br />
    <sym>;</sym><br />
<def></def><br />
</source>
