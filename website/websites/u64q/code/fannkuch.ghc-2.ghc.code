<source>
<def></def><com>{-# OPTIONS -fglasgow-exts -O2 -optc-O3 #-}</com><def></def><br />
<br />
<slc>-- The Great Computer Language Shootout</slc><br />
<def></def><slc>-- http://shootout.alioth.debian.org/</slc><br />
<def></def><slc>-- contributed by Don Stewart, translation from the C version</slc><br />
<def></def><br />
<kwa>import</kwa> <def>Control.Monad</def><br />
<kwa>import</kwa> <def>Foreign</def><br />
<kwa>import</kwa> <def>System</def><br />
<kwa>import</kwa> <def>GHC.Base</def><br />
<kwa>import</kwa> <def>GHC.Ptr</def><br />
<kwa>import</kwa> <def>GHC.IOBase<br />
<br />
main</def> <sym>=</sym> <def></def><kwa>do</kwa><br />
<def>    n</def> <sym>&lt;-</sym> <def>getArgs</def> <sym>&gt;&gt;=</sym> <def>return . read . head<br />
    k</def> <sym>&lt;-</sym> <def>if n</def> <sym>&lt;</sym> <def></def><num>1</num> <def></def><kwa>then</kwa> <def>return</def> <sym>(</sym><def></def><num>0</num><def></def><sym>::</sym><def></def><kwb>Int</kwb><def></def><sym>)</sym> <def></def><kwa>else</kwa> <def>fannkuch n<br />
    putStrLn $</def> <str>&quot;Pfannkuchen(&quot;</str><def></def> <sym>++</sym> <def>show n</def> <sym>++</sym> <def></def><str>&quot;) = &quot;</str><def></def> <sym>++</sym> <def>show</def> <sym>(</sym><def>k</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>)</sym><br />
<def><br />
fannkuch n</def><sym>@(</sym><def>I# n#</def><sym>) =</sym> <def></def><kwa>do</kwa><br />
<def>    perm</def>            <sym>&lt;-</sym> <def>mallocArray n</def>       <sym>::</sym> <def>IO</def> <sym>(</sym><def>Ptr</def> <kwb>Int</kwb><def></def><sym>)</sym><br />
<def></def>    <sym>(</sym><def>Ptr c#</def><sym>)        &lt;-</sym> <def>mallocArray n</def>       <sym>::</sym> <def>IO</def> <sym>(</sym><def>Ptr</def> <kwb>Int</kwb><def></def><sym>)</sym><br />
<def>    perm1</def><sym>@(</sym><def>Ptr p1#</def><sym>) &lt;-</sym> <def>newArray</def> <sym>[</sym><def></def><num>0</num> <def>.. n</def><sym>-</sym><def></def><num>1</num><def></def><sym>] ::</sym> <def>IO</def> <sym>(</sym><def>Ptr</def> <kwb>Int</kwb><def></def><sym>)</sym><br />
<def></def>    <sym>(</sym><def>Ptr rP</def><sym>)        &lt;-</sym> <def>newArray</def> <sym>[</sym><def>n</def><sym>]        ::</sym> <def>IO</def> <sym>(</sym><def>Ptr</def> <kwb>Int</kwb><def></def><sym>)</sym><br />
<def></def>    <sym>(</sym><def>Ptr flipsMaxP</def><sym>) &lt;-</sym> <def>newArray</def> <sym>[</sym><def></def><num>0</num><def></def><sym>]        ::</sym> <def>IO</def> <sym>(</sym><def>Ptr</def> <kwb>Int</kwb><def></def><sym>)</sym><br />
<def></def><br />
    <kwa>let</kwa> <def>go didpr</def> <sym>=</sym> <def></def><kwa>do</kwa><br />
<def>            didpr'</def> <sym>&lt;-</sym> <def>if didpr</def> <sym>&lt; (</sym><def></def><num>30</num> <def></def><sym>::</sym> <def></def><kwb>Int</kwb><def></def><sym>)</sym><br />
<def></def>                      <kwa>then</kwa> <def>ppr</def> <num>0</num> <def>n perm1</def> <sym>&gt;&gt;</sym> <def>putStr</def> <str>&quot;\n&quot;</str><def></def> <sym>&gt;&gt;</sym> <def>return</def> <sym>(</sym><def>didpr</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>)</sym><br />
<def></def>                      <kwa>else</kwa> <def>return didpr<br />
<br />
            IO $ \s</def> <sym>-&gt;</sym><br />
<def></def>                <kwa>case</kwa> <def>readIntOffAddr# rP</def> <num>0</num><def># s</def> <kwa>of</kwa><br />
<def></def>                    <sym>(</sym><def># s</def><sym>,</sym> <def>r# #</def><sym>) -&gt;</sym> <def></def><kwa>case</kwa> <def>setcount c# r# s</def> <kwa>of</kwa><br />
<def></def>                        <sym>(</sym><def># s</def><sym>,</sym> <def>_ #</def><sym>) -&gt;</sym> <def></def><kwa>case</kwa> <def>writeIntOffAddr# rP</def> <num>0</num><def>#</def> <num>1</num><def># s</def> <kwa>of</kwa><br />
<def>                            s</def> <sym>-&gt; (</sym><def># s</def><sym>, ()</sym> <def>#</def><sym>)</sym><br />
<def><br />
            t</def> <sym>&lt;-</sym> <def>IO $ \s</def> <sym>-&gt;</sym><br />
<def></def>                <kwa>case</kwa> <def>readIntOffAddr# p1#</def> <num>0</num><def># s</def> <kwa>of</kwa><br />
<def></def>                    <sym>(</sym><def># s</def><sym>,</sym> <def>p1 #</def><sym>) -&gt;</sym> <def></def><kwa>case</kwa> <def>readIntOffAddr# p1#</def> <sym>(</sym><def>n#</def> <sym>-</sym><def>#</def> <num>1</num><def>#</def><sym>)</sym> <def>s</def> <kwa>of</kwa><br />
<def></def>                        <sym>(</sym><def># s</def><sym>,</sym> <def>pn #</def><sym>) -&gt; (</sym><def># s</def><sym>,</sym> <def>not</def> <sym>(</sym><def>p1</def> <sym>==</sym><def>#</def> <num>0</num><def>#</def> <sym>||</sym> <def>pn</def> <sym>==</sym><def>#</def> <sym>(</sym><def>n#</def> <sym>-</sym><def>#</def> <num>1</num><def>#</def><sym>))</sym> <def>#</def><sym>)</sym><br />
<def><br />
            when t $ exchange n perm perm1 flipsMaxP<br />
<br />
            fm</def>   <sym>&lt;-</sym> <def>IO $ \s</def> <sym>-&gt;</sym> <def></def><kwa>case</kwa> <def>readIntOffAddr# flipsMaxP</def> <num>0</num><def># s</def> <kwa>of</kwa><br />
<def></def>                                <sym>(</sym><def># s</def><sym>,</sym> <def>x #</def><sym>) -&gt; (</sym><def># s</def><sym>,</sym> <def>I# x #</def><sym>)</sym><br />
<def>            done</def> <sym>&lt;-</sym> <def>IO $ \s</def> <sym>-&gt;</sym> <def>rot rP n# p1# c# s<br />
            if done</def> <kwa>then</kwa> <def>return fm</def> <kwa>else</kwa> <def>go didpr'<br />
    go</def> <num>0</num><br />
<def></def><br />
<slc>------------------------------------------------------------------------</slc><br />
<def><br />
exchange n p</def><sym>@(</sym><def>Ptr a</def><sym>)</sym> <def>p1</def><sym>@(</sym><def>Ptr b</def><sym>)</sym> <def>fm</def> <sym>=</sym> <def></def><kwa>do</kwa><br />
<def>    copyArray</def> <sym>(</sym><def>p `advancePtr`</def> <num>1</num><def></def><sym>) (</sym><def>p1 `advancePtr`</def> <num>1</num><def></def><sym>) (</sym><def>n</def><sym>-</sym><def></def><num>1</num><def></def><sym>)</sym><br />
<def>    IO $ \s</def> <sym>-&gt;</sym><br />
<def></def>        <kwa>case</kwa> <def>readIntOffAddr# b</def> <num>0</num><def># s</def>  <kwa>of</kwa> <def>{</def> <sym>(</sym><def># s</def><sym>,</sym> <def>k #</def><sym>) -&gt;</sym><br />
<def></def>        <kwa>case</kwa> <def>doswap k a</def> <num>0</num><def># s</def>         <kwa>of</kwa> <def>{</def> <sym>(</sym><def># s</def><sym>,</sym> <def>f #</def><sym>) -&gt;</sym><br />
<def></def>        <kwa>case</kwa> <def>readIntOffAddr# fm</def> <num>0</num><def># s</def> <kwa>of</kwa> <def>{</def> <sym>(</sym><def># s</def><sym>,</sym> <def>m #</def><sym>) -&gt;</sym><br />
<def>        if m</def> <sym>&lt;</sym><def># f</def> <kwa>then case</kwa> <def>writeIntOffAddr# fm</def> <num>0</num><def># f s</def> <kwa>of</kwa> <def>s</def> <sym>-&gt; (</sym><def># s</def><sym>, ()</sym> <def>#</def><sym>)</sym><br />
<def></def>                  <kwa>else</kwa> <def></def><sym>(</sym><def># s</def><sym>, ()</sym> <def>#</def><sym>)</sym><br />
<def>        } } }</def><br />
<com>{-# INLINE exchange #-}</com><def><br />
<br />
doswap k a f s</def> <sym>=</sym><br />
<def></def>    <kwa>case</kwa> <def>swap</def> <num>1</num><def>#</def> <sym>(</sym><def>k</def> <sym>-</sym><def>#</def> <num>1</num><def>#</def><sym>)</sym> <def>a s</def>    <kwa>of</kwa> <def>{</def> <sym>(</sym><def># s</def><sym>,</sym> <def>_ #</def><sym>) -&gt;</sym><br />
<def></def>    <kwa>case</kwa> <def>readIntOffAddr# a k s</def>    <kwa>of</kwa> <def>{</def> <sym>(</sym><def># s</def><sym>,</sym> <def>j #</def><sym>) -&gt;</sym><br />
<def></def>    <kwa>case</kwa> <def>writeIntOffAddr# a k k s</def> <kwa>of</kwa> <def>{ s</def>          <sym>-&gt;</sym><br />
<def>    if k</def> <sym>/=</sym><def>#</def> <num>0</num><def>#</def> <kwa>then</kwa> <def>doswap j a</def> <sym>(</sym><def>f</def> <sym>+</sym><def>#</def> <num>1</num><def>#</def><sym>)</sym> <def>s</def> <kwa>else</kwa> <def></def><sym>(</sym><def># s</def><sym>, (</sym><def>f</def> <sym>+</sym><def>#</def> <num>1</num><def>#</def><sym>)</sym> <def>#</def><sym>)</sym><br />
<def>    } } }</def><br />
<com>{-# INLINE doswap #-}</com><def><br />
<br />
swap i j a s</def> <sym>=</sym><br />
<def>    if i</def> <sym>&lt;</sym><def># j</def> <kwa>then case</kwa> <def>readIntOffAddr#  a i s</def>   <kwa>of</kwa> <def>{</def> <sym>(</sym><def># s</def><sym>,</sym> <def>x #</def><sym>) -&gt;</sym><br />
<def></def>                   <kwa>case</kwa> <def>readIntOffAddr#  a j s</def>   <kwa>of</kwa> <def>{</def> <sym>(</sym><def># s</def><sym>,</sym> <def>y #</def><sym>) -&gt;</sym><br />
<def></def>                   <kwa>case</kwa> <def>writeIntOffAddr# a j x s</def> <kwa>of</kwa> <def>{ s</def>          <sym>-&gt;</sym><br />
<def></def>                   <kwa>case</kwa> <def>writeIntOffAddr# a i y s</def> <kwa>of</kwa> <def>{ s</def>          <sym>-&gt;</sym><br />
<def>                   swap</def> <sym>(</sym><def>i</def> <sym>+</sym><def>#</def> <num>1</num><def>#</def><sym>) (</sym><def>j</def> <sym>-</sym><def>#</def> <num>1</num><def>#</def><sym>)</sym> <def>a s<br />
                   } } } }</def><br />
              <kwa>else</kwa> <def></def><sym>(</sym><def># s</def><sym>, ()</sym> <def>#</def><sym>)</sym><br />
<def></def><com>{-# INLINE swap #-}</com><def><br />
<br />
loop r i a s</def> <sym>=</sym><br />
<def>    if i</def> <sym>&lt;</sym><def># r</def> <kwa>then case</kwa> <def>readIntOffAddr# a</def> <sym>(</sym><def>i</def> <sym>+</sym><def>#</def> <num>1</num><def>#</def><sym>)</sym> <def>s</def> <kwa>of</kwa><br />
<def></def>                    <sym>(</sym><def># s</def><sym>,</sym> <def>x #</def><sym>) -&gt;</sym> <def></def><kwa>case</kwa> <def>writeIntOffAddr# a i x s</def> <kwa>of</kwa><br />
<def>                        s</def> <sym>-&gt;</sym> <def>loop r</def> <sym>(</sym><def>i</def> <sym>+</sym><def>#</def> <num>1</num><def>#</def><sym>)</sym> <def>a s</def><br />
              <kwa>else</kwa> <def></def><sym>(</sym><def># s</def><sym>, ()</sym> <def>#</def><sym>)</sym><br />
<def></def><com>{-# INLINE loop #-}</com><def><br />
<br />
setcount p r s</def> <sym>=</sym><br />
<def>    if r</def> <sym>==</sym><def>#</def> <num>1</num><def>#</def> <kwa>then</kwa> <def></def><sym>(</sym><def># s</def><sym>, ()</sym> <def>#</def><sym>)</sym><br />
<def></def>                <kwa>else case</kwa> <def>writeIntOffAddr# p</def> <sym>(</sym><def>r</def> <sym>-</sym><def>#</def> <num>1</num><def>#</def><sym>)</sym> <def>r s</def> <kwa>of</kwa><br />
<def>                        s</def> <sym>-&gt;</sym> <def>setcount p</def> <sym>(</sym><def>r</def> <sym>-</sym><def>#</def> <num>1</num><def>#</def><sym>)</sym> <def>s</def><br />
<com>{-# INLINE setcount #-}</com><def><br />
<br />
rot rP n a cp s</def> <sym>=</sym><br />
<def></def>  <kwa>case</kwa> <def>readIntOffAddr# rP</def> <num>0</num><def># s</def> <kwa>of</kwa> <def>{</def> <sym>(</sym><def># s</def><sym>,</sym> <def>r #</def><sym>) -&gt;</sym><br />
<def>  if r</def> <sym>==</sym><def># n</def> <kwa>then</kwa> <def></def><sym>(</sym><def># s</def><sym>,</sym> <def></def><kwa>True</kwa> <def>#</def><sym>)</sym><br />
<def></def>             <kwa>else case</kwa> <def>readIntOffAddr# a</def> <num>0</num><def># s</def>             <kwa>of</kwa> <def>{</def> <sym>(</sym><def># s</def><sym>,</sym> <def>p0 #</def><sym>) -&gt;</sym><br />
<def></def>                  <kwa>case</kwa> <def>loop r</def> <num>0</num><def># a s</def>                      <kwa>of</kwa> <def>{</def> <sym>(</sym><def># s</def><sym>,</sym> <def>_ #</def><sym>)  -&gt;</sym><br />
<def></def>                  <kwa>case</kwa> <def>writeIntOffAddr# a r p0 s</def>          <kwa>of</kwa> <def>{ s</def>           <sym>-&gt;</sym><br />
<def></def>                  <kwa>case</kwa> <def>readIntOffAddr# cp r s</def>             <kwa>of</kwa> <def>{</def> <sym>(</sym><def># s</def><sym>,</sym> <def>cr #</def><sym>) -&gt;</sym><br />
<def></def>                  <kwa>case</kwa> <def>writeIntOffAddr# cp r</def> <sym>(</sym><def>cr</def> <sym>-</sym><def>#</def> <num>1</num><def>#</def><sym>)</sym> <def>s</def> <kwa>of</kwa> <def>{ s</def>           <sym>-&gt;</sym><br />
<def>                  if cr</def> <sym>-</sym><def>#</def> <num>1</num><def>#</def> <sym>&gt;</sym><def>#</def> <num>0</num><def>#</def> <kwa>then</kwa> <def></def><sym>(</sym><def># s</def><sym>,</sym> <def></def><kwa>False</kwa> <def>#</def><sym>)</sym><br />
<def></def>                                    <kwa>else case</kwa> <def>inc s</def> <kwa>of</kwa> <def>s</def> <sym>-&gt;</sym> <def>rot rP n a cp s<br />
  } } } } } }</def><br />
  <kwa>where</kwa> <def>inc s</def> <sym>=</sym> <def></def><kwa>case</kwa> <def>readIntOffAddr# rP</def> <num>0</num><def># s</def> <kwa>of</kwa><br />
<def></def>                  <sym>(</sym><def># s</def><sym>,</sym> <def>x #</def><sym>) -&gt;</sym> <def>writeIntOffAddr# rP</def> <num>0</num><def>#</def> <sym>(</sym><def>x</def> <sym>+</sym><def>#</def> <num>1</num><def>#</def><sym>)</sym> <def>s</def><br />
<com>{-# INLINE rot #-}</com><def><br />
<br />
ppr i n p</def> <sym>=</sym> <def>when</def> <sym>(</sym><def>i</def> <sym>&lt;</sym> <def>n</def><sym>)</sym> <def>$</def> <kwa>do</kwa><br />
<def>    putStr . show .</def> <sym>(+</sym><def></def><num>1</num><def></def><sym>) =&lt;&lt;</sym> <def>peek</def> <sym>(</sym><def>p `advancePtr` i</def><sym>)</sym><br />
<def>    ppr</def> <sym>(</sym><def>i</def><sym>+</sym><def></def><num>1</num><def></def><sym>)</sym> <def>n p</def><br />
</source>
