<source>
<def></def><slc>-------------------------------------------------------------------------------</slc><br />
<def></def><slc>--  The Computer Language Shootout http://shootout.alioth.debian.org/</slc><br />
<def></def><slc>--</slc><br />
<def></def><slc>--  Contributed by Martin Krischik</slc><br />
<def></def><slc>-------------------------------------------------------------------------------</slc><br />
<def></def><br />
<kwa>pragma</kwa> <def>Ada_95</def><sym>;</sym><br />
<def></def><br />
<slc>--  Standart set of performance improving pragmas as suggested by the GNAT users manual.</slc><br />
<def></def><kwa>pragma</kwa> <def>Restrictions</def> <sym>(</sym><def>Max_Asynchronous_Select_Nesting</def> <sym>=&gt;</sym> <def></def><num>0</num><def></def><sym>);</sym><br />
<def></def><kwa>pragma</kwa> <def>Restrictions</def> <sym>(</sym><def>No_Abort_Statements</def><sym>);</sym><br />
<def></def><kwa>pragma</kwa> <def>Restrictions</def> <sym>(</sym><def>No_Finalization</def><sym>);</sym><br />
<def></def><br />
<kwa>with</kwa> <def>Ada.Characters.Handling</def><sym>;</sym><br />
<def></def><kwa>with</kwa> <def>Ada.Characters.Latin_1</def><sym>;</sym><br />
<def></def><kwa>with</kwa> <def>Ada.Integer_Text_IO</def><sym>;</sym><br />
<def></def><kwa>with</kwa> <def>Ada.IO_Exceptions</def><sym>;</sym><br />
<def></def><kwa>with</kwa> <def>Ada.Float_Text_IO</def><sym>;</sym><br />
<def></def><kwa>with</kwa> <def>Ada.Strings.Bounded</def><sym>;</sym><br />
<def></def><kwa>with</kwa> <def>Ada.Text_IO</def><sym>;</sym><br />
<def></def><br />
<slc>--  The shootout is using an old Ada 95 compiler so only the GNAT hash tables and sort are</slc><br />
<def></def><slc>--  available. As soon as the new Ada 2005 compiler is available we can use Ada.Containers which</slc><br />
<def></def><slc>--  are more high level and should reduce the LOC significantly and make the programm more</slc><br />
<def></def><slc>--  &quot;plain vanilla&quot;.</slc><br />
<def></def><kwa>with</kwa> <def>GNAT.Heap_Sort_G</def><sym>;</sym><br />
<def></def><kwa>with</kwa> <def>GNAT.HTable</def><sym>;</sym><br />
<def></def><br />
<kwa>procedure</kwa> <def>KNucleotide</def> <kwa>is</kwa><br />
<def></def>   <kwa>subtype</kwa> <def>Frequencies</def> <kwa>is</kwa> <def></def><kwb>Integer</kwb> <def></def><kwa>range</kwa> <def></def><num>1</num> <def>..</def> <num>18</num><def></def><sym>;</sym><br />
<def></def><br />
   <kwa>package</kwa> <def>Fragments</def> <kwa>is new</kwa> <def>Ada.Strings.Bounded.Generic_Bounded_Length</def> <sym>(</sym><def>Frequencies</def><sym>'</sym><def>Last</def><sym>);</sym><br />
<def></def><br />
   <kwa>use type</kwa> <def>Fragments.Bounded_String</def><sym>;</sym><br />
<def></def><br />
   <kwa>subtype</kwa> <def>Fragment</def> <kwa>is</kwa> <def>Fragments.Bounded_String</def><sym>;</sym><br />
<def></def><br />
   <slc>----------------------------------------------------------------------------</slc><br />
<def></def>   <slc>--</slc><br />
<def></def>   <slc>--  Read data from Standart_Input and return the section THREE as String</slc><br />
<def></def>   <slc>--</slc><br />
<def></def>   <kwa>function</kwa> <def>Read</def> <kwa>return</kwa> <def></def><kwb>String</kwb><def></def><sym>;</sym><br />
<def></def><br />
   <slc>----------------------------------------------------------------------------</slc><br />
<def></def>   <slc>--</slc><br />
<def></def>   <slc>--  Calculate and write data - either a percentage for all fragments found or - when</slc><br />
<def></def>   <slc>--  Nucleotide_Fragment is given - the count for that fragment.</slc><br />
<def></def>   <slc>--</slc><br />
<def></def>   <kwa>procedure</kwa> <def>Write</def><br />
     <sym>(</sym><def>Nucleotide_Length</def>   <sym>:</sym> <def></def><kwa>in</kwa> <def>Frequencies</def><sym>;</sym><br />
<def>      Nucleotide_Fragment</def> <sym>:</sym> <def></def><kwa>in</kwa> <def>Fragment</def> <sym>:=</sym> <def>Fragments.Null_Bounded_String</def><sym>);</sym><br />
<def></def><br />
   <slc>----------------------------------------------------------------------------</slc><br />
<def></def>   <slc>--</slc><br />
<def></def>   <slc>--  List of fragments to be analyzed for this test</slc><br />
<def></def>   <slc>--</slc><br />
<def>   Fragment_3</def>  <sym>:</sym> <def></def><kwa>constant</kwa> <def>Fragment</def> <sym>:=</sym> <def>Fragments.To_Bounded_String</def> <sym>(</sym><def></def><str>&quot;GGT&quot;</str><def></def><sym>);</sym><br />
<def>   Fragment_4</def>  <sym>:</sym> <def></def><kwa>constant</kwa> <def>Fragment</def> <sym>:=</sym> <def>Fragments.To_Bounded_String</def> <sym>(</sym><def></def><str>&quot;GGTA&quot;</str><def></def><sym>);</sym><br />
<def>   Fragment_6</def>  <sym>:</sym> <def></def><kwa>constant</kwa> <def>Fragment</def> <sym>:=</sym> <def>Fragments.To_Bounded_String</def> <sym>(</sym><def></def><str>&quot;GGTATT&quot;</str><def></def><sym>);</sym><br />
<def>   Fragment_12</def> <sym>:</sym> <def></def><kwa>constant</kwa> <def>Fragment</def> <sym>:=</sym> <def>Fragments.To_Bounded_String</def> <sym>(</sym><def></def><str>&quot;GGTATTTTAATT&quot;</str><def></def><sym>);</sym><br />
<def>   Fragment_18</def> <sym>:</sym> <def></def><kwa>constant</kwa> <def>Fragment</def> <sym>:=</sym> <def>Fragments.To_Bounded_String</def> <sym>(</sym><def></def><str>&quot;GGTATTTTAATTTATAGT&quot;</str><def></def><sym>);</sym><br />
<def></def><br />
   <slc>----------------------------------------------------------------------------</slc><br />
<def></def>   <slc>--</slc><br />
<def></def>   <slc>--  Read data from Standart_Input and return the section THREE as String</slc><br />
<def></def>   <slc>--</slc><br />
<def></def>   <kwa>function</kwa> <def>Read</def> <kwa>return</kwa> <def></def><kwb>String</kwb> <def></def><kwa>is</kwa><br />
<def></def>      <slc>-------------------------------------------------------------------------</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <slc>--  Skip data on Standart_Input until &quot;&gt;THREE&quot; is found</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <kwa>procedure</kwa> <def>Skip_To_Section</def><sym>;</sym><br />
<def></def><br />
      <slc>-------------------------------------------------------------------------</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <slc>--  Read next data section - until EOF oder a line beginning with &gt; is found</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <kwa>function</kwa> <def>Read_Section</def> <kwa>return</kwa> <def></def><kwb>String</kwb><def></def><sym>;</sym><br />
<def></def><br />
      <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def>Read_Section</def><sym>);</sym><br />
<def></def>      <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def>Skip_To_Section</def><sym>);</sym><br />
<def><br />
      Section_Marker</def> <sym>:</sym> <def></def><kwa>constant</kwa> <def></def><kwb>Character</kwb> <def></def><sym>:= '&gt;';</sym><br />
<def>      Section</def>        <sym>:</sym> <def></def><kwa>constant</kwa> <def></def><kwb>String</kwb>    <def></def><sym>:=</sym> <def>Section_Marker</def> <sym>&amp;</sym> <def></def><str>&quot;THREE&quot;</str><def></def><sym>;</sym><br />
<def></def><br />
      <slc>-------------------------------------------------------------------------</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <slc>--  Read next data section - until EOF oder a line beginning with &gt; is found.</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <kwa>function</kwa> <def>Read_Section</def> <kwa>return</kwa> <def></def><kwb>String</kwb> <def></def><kwa>is</kwa><br />
<def></def>         <slc>--</slc><br />
<def></def>         <slc>--  We are using a recursive read function which won't need any heap storage. For</slc><br />
<def></def>         <slc>--  fairness sake we use the same initial buffer size as the C demo.</slc><br />
<def></def>         <slc>--</slc><br />
<def>         Buffer</def>     <sym>:</sym> <def></def><kwb>String</kwb> <def></def><sym>(</sym><def></def><num>1</num> <def>..</def> <num>10240</num><def></def><sym>);</sym><br />
<def>         Read_First</def> <sym>:</sym> <def></def><kwb>Natural</kwb> <def></def><sym>:=</sym> <def>Buffer</def><sym>'</sym><def>First</def><sym>;</sym><br />
<def>         Read_Last</def>  <sym>:</sym> <def></def><kwb>Natural</kwb> <def></def><sym>:=</sym> <def>Buffer</def><sym>'</sym><def>First</def><sym>;</sym><br />
<def></def>      <kwa>begin</kwa><br />
<def></def>         <kwa>loop</kwa><br />
<def>            Ada.Text_IO.Get_Line</def><br />
              <sym>(</sym><def>Item</def> <sym>=&gt;</sym> <def>Buffer</def> <sym>(</sym><def>Read_First .. Buffer</def><sym>'</sym><def>Last</def><sym>),</sym><br />
<def>               Last</def> <sym>=&gt;</sym> <def>Read_Last</def><sym>);</sym><br />
<def></def>            <kwa>exit when</kwa> <def>Buffer</def> <sym>(</sym><def>Read_First</def><sym>) =</sym> <def>Section_Marker</def><sym>;</sym><br />
<def></def>            <kwa>if</kwa> <def>Read_Last</def> <sym>=</sym> <def>Buffer</def><sym>'</sym><def>Last</def> <kwa>then</kwa><br />
<def></def>               <kwa>return</kwa> <def>Buffer</def> <sym>&amp;</sym> <def>Read_Section</def><sym>;</sym><br />
<def></def>            <kwa>end if</kwa><def></def><sym>;</sym><br />
<def>            Read_First</def> <sym>:=</sym> <def>Read_Last</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>         <kwa>end loop</kwa><def></def><sym>;</sym><br />
<def></def>         <kwa>return</kwa> <def>Buffer</def> <sym>(</sym><def></def><num>1</num> <def>.. Read_Last</def><sym>);</sym><br />
<def></def>      <kwa>exception</kwa><br />
<def></def>         <kwa>when</kwa> <def>Ada.IO_Exceptions.End_Error</def> <sym>=&gt;</sym><br />
<def></def>            <kwa>return</kwa> <def>Buffer</def> <sym>(</sym><def></def><num>1</num> <def>.. Read_Last</def><sym>);</sym><br />
<def></def>      <kwa>end</kwa> <def>Read_Section</def><sym>;</sym><br />
<def></def><br />
      <slc>------------------------------------------------------------------------</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <slc>--  Skip data on Standart_Input until &quot;&gt;THREE&quot; is found</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <kwa>procedure</kwa> <def>Skip_To_Section</def> <kwa>is</kwa><br />
<def></def>         <slc>--</slc><br />
<def></def>         <slc>--  The line lenght of the test data is 60 character. Note: Get_Line would survive</slc><br />
<def></def>         <slc>--  longer lines as well - they would just be read in two parts.</slc><br />
<def></def>         <slc>--</slc><br />
<def>         Line</def>      <sym>:</sym> <def></def><kwb>String</kwb> <def></def><sym>(</sym><def></def><num>1</num> <def>..</def> <num>60</num><def></def><sym>);</sym><br />
<def>         Read_Last</def> <sym>:</sym> <def></def><kwb>Natural</kwb><def></def><sym>;</sym><br />
<def></def>      <kwa>begin</kwa><br />
<def></def>         <kwa>loop</kwa><br />
<def>            Ada.Text_IO.Get_Line</def> <sym>(</sym><def>Item</def> <sym>=&gt;</sym> <def>Line</def><sym>,</sym> <def>Last</def> <sym>=&gt;</sym> <def>Read_Last</def><sym>);</sym><br />
<def></def>            <kwa>exit when</kwa> <def>Line</def> <sym>(</sym><def></def><num>1</num> <def>..</def> <num>6</num><def></def><sym>) =</sym> <def>Section</def><sym>;</sym><br />
<def></def>         <kwa>end loop</kwa><def></def><sym>;</sym><br />
<def></def>      <kwa>end</kwa> <def>Skip_To_Section</def><sym>;</sym><br />
<def></def><br />
   <kwa>begin</kwa><br />
<def>      Skip_To_Section</def><sym>;</sym><br />
<def></def>      <kwa>return</kwa> <def>Ada.Characters.Handling.To_Upper</def> <sym>(</sym><def>Read_Section</def><sym>);</sym><br />
<def></def>   <kwa>end</kwa> <def>Read</def><sym>;</sym><br />
<def></def><br />
   <slc>---------------------------------------------------------------------------</slc><br />
<def></def>   <slc>--</slc><br />
<def></def>   <slc>--  Data read as single String</slc><br />
<def></def>   <slc>--</slc><br />
<def>   Buffer</def> <sym>:</sym> <def></def><kwa>constant</kwa> <def></def><kwb>String</kwb> <def></def><sym>:=</sym> <def>Read</def><sym>;</sym><br />
<def></def><br />
   <slc>----------------------------------------------------------------------------</slc><br />
<def></def>   <slc>--</slc><br />
<def></def>   <slc>--  Calculate and write data - either a percentage for all fragments found or - when</slc><br />
<def></def>   <slc>--  Nucleotide_Fragment is given - the count for that fragment.</slc><br />
<def></def>   <slc>--</slc><br />
<def></def>   <kwa>procedure</kwa> <def>Write</def><br />
     <sym>(</sym><def>Nucleotide_Length</def>   <sym>:</sym> <def></def><kwa>in</kwa> <def>Frequencies</def><sym>;</sym><br />
<def>      Nucleotide_Fragment</def> <sym>:</sym> <def></def><kwa>in</kwa> <def>Fragment</def> <sym>:=</sym> <def>Fragments.Null_Bounded_String</def><sym>)</sym><br />
<def></def>   <kwa>is</kwa><br />
<def></def>      <slc>------------------------------------------------------------------------</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <slc>--  The Calculator package calculates the nucleotide frequencies and keeps the result</slc><br />
<def></def>      <slc>--  inside a hash table as requested by the shootout rules.</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <kwa>package</kwa> <def>Calculator</def> <kwa>is</kwa><br />
<def></def>         <slc>---------------------------------------------------------------------</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <slc>--  Elements used to store inside hash table</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <kwa>type</kwa> <def>Element_Type</def> <kwa>is private</kwa><def></def><sym>;</sym><br />
<def></def>         <kwa>type</kwa> <def>Element_Access</def> <kwa>is access</kwa> <def>Element_Type</def><sym>;</sym><br />
<def></def>         <kwa>for</kwa> <def>Element_Access</def><sym>'</sym><def>Storage_Size</def> <kwa>use</kwa> <def></def><num>16</num><def>#</def><num>60</num><def>_00_00#</def><sym>;</sym><br />
<def></def><br />
         <slc>---------------------------------------------------------------------</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <slc>--  Calculate the calculates the nucleotide frequencies</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <kwa>procedure</kwa> <def>Calculate_Frequencies</def> <sym>(</sym><def>Length</def> <sym>:</sym> <def>Frequencies</def><sym>);</sym><br />
<def></def><br />
         <slc>---------------------------------------------------------------------</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <slc>--  Get the count for the given nucleotide fragment</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <kwa>function</kwa> <def>Get</def> <sym>(</sym><def>Nucleotide_Fragment</def> <sym>:</sym> <def>Fragment</def><sym>)</sym> <def></def><kwa>return</kwa> <def></def><kwb>Natural</kwb><def></def><sym>;</sym><br />
<def></def><br />
         <slc>---------------------------------------------------------------------</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <slc>--  Start to iterate over all element of hash table</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <kwa>function</kwa> <def>Get_First</def> <kwa>return</kwa> <def>Element_Access</def><sym>;</sym><br />
<def></def><br />
         <slc>---------------------------------------------------------------------</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <slc>--  Continue itereation over the hash table</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <kwa>function</kwa> <def>Get_Next</def> <kwa>return</kwa> <def>Element_Access</def><sym>;</sym><br />
<def></def><br />
         <slc>---------------------------------------------------------------------</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <slc>--  Get count for element</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <kwa>function</kwa> <def>Count</def> <sym>(</sym><def>Element</def> <sym>:</sym> <def>Element_Access</def><sym>)</sym> <def></def><kwa>return</kwa> <def></def><kwb>Natural</kwb><def></def><sym>;</sym><br />
<def></def><br />
         <slc>---------------------------------------------------------------------</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <slc>--  Get key for element</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <kwa>function</kwa> <def>Key</def> <sym>(</sym><def>Element</def> <sym>:</sym> <def>Element_Access</def><sym>)</sym> <def></def><kwa>return</kwa> <def>Fragment</def><sym>;</sym><br />
<def></def><br />
         <slc>---------------------------------------------------------------------</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <slc>--  Get total count over all elements - as well as the count of elements</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <kwa>procedure</kwa> <def>Get_Total</def> <sym>(</sym><def>Total</def> <sym>:</sym> <def></def><kwa>out</kwa> <def></def><kwb>Natural</kwb><def></def><sym>;</sym> <def>Count</def> <sym>:</sym> <def></def><kwa>out</kwa> <def></def><kwb>Natural</kwb><def></def><sym>);</sym><br />
<def></def><br />
         <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def>Calculate_Frequencies</def><sym>);</sym><br />
<def></def>         <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def>Get</def><sym>);</sym><br />
<def></def>         <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def>Get_First</def><sym>);</sym><br />
<def></def>         <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def>Get_Next</def><sym>);</sym><br />
<def></def>         <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def>Count</def><sym>);</sym><br />
<def></def>         <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def>Key</def><sym>);</sym><br />
<def></def>         <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def>Get_Total</def><sym>);</sym><br />
<def></def>      <kwa>private</kwa><br />
<def></def>         <slc>---------------------------------------------------------------------</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <slc>--  Elements used to store inside hash table.</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <kwa>type</kwa> <def>Element_Type</def> <kwa>is record</kwa><br />
<def>            Count</def> <sym>:</sym> <def></def><kwb>Natural</kwb>        <def></def><sym>:=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def>            Key</def>   <sym>:</sym> <def>Fragment</def>       <sym>:=</sym> <def>Fragments.Null_Bounded_String</def><sym>;</sym><br />
<def>            Next</def>  <sym>:</sym> <def>Element_Access</def> <sym>:=</sym> <def></def><kwa>null</kwa><def></def><sym>;</sym><br />
<def></def>         <kwa>end record</kwa><def></def><sym>;</sym><br />
<def></def>      <kwa>end</kwa> <def>Calculator</def><sym>;</sym><br />
<def></def><br />
      <kwa>package body</kwa> <def>Calculator</def> <kwa>is</kwa><br />
<def></def>         <kwa>type</kwa> <def>Hash_Type</def> <kwa>is range</kwa> <def></def><num>0</num> <def>..</def> <num>2</num> <def></def><sym>**</sym> <def></def><num>16</num><def></def><sym>;</sym><br />
<def></def><br />
         <kwa>function</kwa> <def>Hash</def> <sym>(</sym><def>Key</def> <sym>:</sym> <def>Fragment</def><sym>)</sym> <def></def><kwa>return</kwa> <def>Hash_Type</def><sym>;</sym><br />
<def></def>         <kwa>procedure</kwa> <def>Set_Next</def> <sym>(</sym><def>E</def> <sym>:</sym> <def>Element_Access</def><sym>;</sym> <def>Next</def> <sym>:</sym> <def>Element_Access</def><sym>);</sym><br />
<def></def>         <kwa>function</kwa> <def>Next</def> <sym>(</sym><def>E</def> <sym>:</sym> <def>Element_Access</def><sym>)</sym> <def></def><kwa>return</kwa> <def>Element_Access</def><sym>;</sym><br />
<def></def>         <kwa>function</kwa> <def>Get_Key</def> <sym>(</sym><def>E</def> <sym>:</sym> <def>Element_Access</def><sym>)</sym> <def></def><kwa>return</kwa> <def>Fragment</def><sym>;</sym><br />
<def></def><br />
         <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def>Hash</def><sym>);</sym><br />
<def></def>         <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def>Set_Next</def><sym>);</sym><br />
<def></def>         <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def>Next</def><sym>);</sym><br />
<def></def>         <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def>Get_Key</def><sym>);</sym><br />
<def></def><br />
         <kwa>package</kwa> <def>Table</def> <kwa>is new</kwa> <def>GNAT.HTable.Static_HTable</def> <sym>(</sym><br />
<def>            Header_Num</def> <sym>=&gt;</sym> <def>Hash_Type</def><sym>,</sym><br />
<def>            Element</def> <sym>=&gt;</sym> <def>Element_Type</def><sym>,</sym><br />
<def>            Elmt_Ptr</def> <sym>=&gt;</sym> <def>Element_Access</def><sym>,</sym><br />
<def>            Null_Ptr</def> <sym>=&gt;</sym> <def></def><kwa>null</kwa><def></def><sym>,</sym><br />
<def>            Key</def> <sym>=&gt;</sym> <def>Fragment</def><sym>,</sym><br />
<def>            Hash</def> <sym>=&gt;</sym> <def>Hash</def><sym>,</sym><br />
<def>            Equal</def> <sym>=&gt;</sym> <def>Fragments.</def> <str>&quot;=&quot;</str><def></def><sym>,</sym><br />
<def>            Set_Next</def> <sym>=&gt;</sym> <def>Set_Next</def><sym>,</sym><br />
<def>            Next</def> <sym>=&gt;</sym> <def>Next</def><sym>,</sym><br />
<def>            Get_Key</def> <sym>=&gt;</sym> <def>Get_Key</def><sym>);</sym><br />
<def></def><br />
         <kwa>function</kwa> <def>Hash_Function</def> <kwa>is new</kwa> <def>GNAT.HTable.Hash</def> <sym>(</sym><def>Header_Num</def> <sym>=&gt;</sym> <def>Hash_Type</def><sym>);</sym><br />
<def></def><br />
         <slc>---------------------------------------------------------------------</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <slc>--  Calculate the calculates the nucleotide frequencies</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <kwa>procedure</kwa> <def>Calculate_Frequencies</def> <sym>(</sym><def>Length</def> <sym>:</sym> <def>Frequencies</def><sym>)</sym> <def></def><kwa>is</kwa><br />
<def></def>         <kwa>begin</kwa><br />
<def>            Table.Reset</def><sym>;</sym><br />
<def></def>            <kwa>for</kwa> <def>I</def> <kwa>in</kwa>  <def></def><num>1</num> <def>.. Buffer</def><sym>'</sym><def>Last</def> <sym>-</sym> <def></def><kwb>Integer</kwb> <def></def><sym>(</sym><def>Length</def><sym>) +</sym> <def></def><num>1</num> <def></def><kwa>loop</kwa><br />
<def></def>               <kwa>declare</kwa><br />
<def>                  Key</def>     <sym>:</sym> <def></def><kwa>constant</kwa> <def>Fragment</def>       <sym>:=</sym><br />
<def>                     Fragments.To_Bounded_String</def> <sym>(</sym><def>Buffer</def> <sym>(</sym><def>I .. I</def> <sym>+</sym> <def>Length</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>));</sym><br />
<def>                  Element</def> <sym>:</sym> <def></def><kwa>constant</kwa> <def>Element_Access</def> <sym>:=</sym> <def>Table.Get</def> <sym>(</sym><def>Key</def><sym>);</sym><br />
<def></def>               <kwa>begin</kwa><br />
<def></def>                  <kwa>if</kwa> <def>Element</def> <sym>/=</sym> <def></def><kwa>null then</kwa><br />
<def>                     Element.</def><kwa>all</kwa><def>.Count</def> <sym>:=</sym> <def></def><kwb>Natural</kwb><def></def><sym>'</sym><def>Succ</def> <sym>(</sym><def>Element.</def><kwa>all</kwa><def>.Count</def><sym>);</sym><br />
<def></def>                  <kwa>else</kwa><br />
<def>                     Table.Set</def> <sym>(</sym><def></def><kwa>new</kwa> <def>Element_Type</def><sym>'(</sym><def>Count</def> <sym>=&gt;</sym> <def></def><num>1</num><def></def><sym>,</sym> <def>Key</def> <sym>=&gt;</sym> <def>Key</def><sym>,</sym> <def>Next</def> <sym>=&gt;</sym> <def></def><kwa>null</kwa><def></def><sym>));</sym><br />
<def></def>                  <kwa>end if</kwa><def></def><sym>;</sym><br />
<def></def>               <kwa>end</kwa><def></def><sym>;</sym><br />
<def></def>            <kwa>end loop</kwa><def></def><sym>;</sym><br />
<def></def>            <kwa>return</kwa><def></def><sym>;</sym><br />
<def></def>         <kwa>end</kwa> <def>Calculate_Frequencies</def><sym>;</sym><br />
<def></def><br />
         <slc>---------------------------------------------------------------------</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <slc>--  Get count for element</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <kwa>function</kwa> <def>Count</def> <sym>(</sym><def>Element</def> <sym>:</sym> <def>Element_Access</def><sym>)</sym> <def></def><kwa>return</kwa> <def></def><kwb>Natural</kwb> <def></def><kwa>is</kwa><br />
<def></def>         <kwa>begin</kwa><br />
<def></def>            <kwa>return</kwa> <def>Element.</def><kwa>all</kwa><def>.Count</def><sym>;</sym><br />
<def></def>         <kwa>end</kwa> <def>Count</def><sym>;</sym><br />
<def></def><br />
         <slc>---------------------------------------------------------------------</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <slc>--  Get the count for the given nucleotide fragment</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <kwa>function</kwa> <def>Get</def> <sym>(</sym><def>Nucleotide_Fragment</def> <sym>:</sym> <def>Fragment</def><sym>)</sym> <def></def><kwa>return</kwa> <def></def><kwb>Natural</kwb> <def></def><kwa>is</kwa><br />
<def>            The_Element</def> <sym>:</sym> <def></def><kwa>constant</kwa> <def>Element_Access</def> <sym>:=</sym> <def>Table.Get</def> <sym>(</sym><def>Nucleotide_Fragment</def><sym>);</sym><br />
<def></def>         <kwa>begin</kwa><br />
<def></def>            <kwa>if</kwa> <def>The_Element</def> <sym>/=</sym> <def></def><kwa>null then</kwa><br />
<def></def>               <kwa>return</kwa> <def>The_Element.</def><kwa>all</kwa><def>.Count</def><sym>;</sym><br />
<def></def>            <kwa>else</kwa><br />
<def></def>               <kwa>return</kwa> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>            <kwa>end if</kwa><def></def><sym>;</sym><br />
<def></def>         <kwa>end</kwa> <def>Get</def><sym>;</sym><br />
<def></def><br />
         <slc>---------------------------------------------------------------------</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <slc>--  Start to iterate over all element of hash table</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <kwa>function</kwa> <def>Get_First</def> <kwa>return</kwa> <def>Element_Access</def> <kwa>is</kwa><br />
<def></def>         <kwa>begin</kwa><br />
<def></def>            <kwa>return</kwa> <def>Table.Get_First</def><sym>;</sym><br />
<def></def>         <kwa>end</kwa> <def>Get_First</def><sym>;</sym><br />
<def></def><br />
         <slc>---------------------------------------------------------------------</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <slc>--  Get key for element</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <kwa>function</kwa> <def>Get_Key</def> <sym>(</sym><def>E</def> <sym>:</sym> <def>Element_Access</def><sym>)</sym> <def></def><kwa>return</kwa> <def>Fragment</def> <kwa>is</kwa><br />
<def></def>         <kwa>begin</kwa><br />
<def></def>            <kwa>return</kwa> <def>E.</def><kwa>all</kwa><def>.Key</def><sym>;</sym><br />
<def></def>         <kwa>end</kwa> <def>Get_Key</def><sym>;</sym><br />
<def></def><br />
         <slc>---------------------------------------------------------------------</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <slc>--  Continue itereation over the hash table</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <kwa>function</kwa> <def>Get_Next</def> <kwa>return</kwa> <def>Element_Access</def> <kwa>is</kwa><br />
<def></def>         <kwa>begin</kwa><br />
<def></def>            <kwa>return</kwa> <def>Table.Get_Next</def><sym>;</sym><br />
<def></def>         <kwa>end</kwa> <def>Get_Next</def><sym>;</sym><br />
<def></def><br />
         <slc>---------------------------------------------------------------------</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <slc>--  Get total count over all elements - as well as the count of elements</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <kwa>procedure</kwa> <def>Get_Total</def> <sym>(</sym><def>Total</def> <sym>:</sym> <def></def><kwa>out</kwa> <def></def><kwb>Natural</kwb><def></def><sym>;</sym> <def>Count</def> <sym>:</sym> <def></def><kwa>out</kwa> <def></def><kwb>Natural</kwb><def></def><sym>)</sym> <def></def><kwa>is</kwa><br />
<def>            The_Element</def> <sym>:</sym> <def>Element_Access</def> <sym>:=</sym> <def>Table.Get_First</def><sym>;</sym><br />
<def></def>         <kwa>begin</kwa><br />
<def>            Total</def> <sym>:=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def>            Count</def> <sym>:=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>            <kwa>while</kwa> <def>The_Element</def> <sym>/=</sym> <def></def><kwa>null loop</kwa><br />
<def>               Total</def>       <sym>:=</sym> <def>Total</def> <sym>+</sym> <def>The_Element.</def><kwa>all</kwa><def>.Count</def><sym>;</sym><br />
<def>               Count</def>       <sym>:=</sym> <def>Count</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def>               The_Element</def> <sym>:=</sym> <def>Table.Get_Next</def><sym>;</sym><br />
<def></def>            <kwa>end loop</kwa><def></def><sym>;</sym><br />
<def></def>         <kwa>end</kwa> <def>Get_Total</def><sym>;</sym><br />
<def></def><br />
         <kwa>function</kwa> <def>Hash</def> <sym>(</sym><def>Key</def> <sym>:</sym> <def>Fragment</def><sym>)</sym> <def></def><kwa>return</kwa> <def>Hash_Type</def> <kwa>is</kwa><br />
<def></def>         <kwa>begin</kwa><br />
<def></def>            <kwa>return</kwa> <def>Hash_Function</def> <sym>(</sym><def>Fragments.To_String</def> <sym>(</sym><def>Key</def><sym>));</sym><br />
<def></def>         <kwa>end</kwa> <def>Hash</def><sym>;</sym><br />
<def></def><br />
         <slc>---------------------------------------------------------------------</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <slc>--  Get key for element</slc><br />
<def></def>         <slc>--</slc><br />
<def></def>         <kwa>function</kwa> <def>Key</def> <sym>(</sym><def>Element</def> <sym>:</sym> <def></def><kwa>in</kwa> <def>Element_Access</def><sym>)</sym> <def></def><kwa>return</kwa> <def>Fragment</def> <kwa>is</kwa><br />
<def></def>         <kwa>begin</kwa><br />
<def></def>            <kwa>return</kwa> <def>Element.</def><kwa>all</kwa><def>.Key</def><sym>;</sym><br />
<def></def>         <kwa>end</kwa> <def>Key</def><sym>;</sym><br />
<def></def><br />
         <kwa>function</kwa> <def>Next</def> <sym>(</sym><def>E</def> <sym>:</sym> <def>Element_Access</def><sym>)</sym> <def></def><kwa>return</kwa> <def>Element_Access</def> <kwa>is</kwa><br />
<def></def>         <kwa>begin</kwa><br />
<def></def>            <kwa>return</kwa> <def>E.</def><kwa>all</kwa><def>.Next</def><sym>;</sym><br />
<def></def>         <kwa>end</kwa> <def>Next</def><sym>;</sym><br />
<def></def><br />
         <kwa>procedure</kwa> <def>Set_Next</def> <sym>(</sym><def>E</def> <sym>:</sym> <def>Element_Access</def><sym>;</sym> <def>Next</def> <sym>:</sym> <def>Element_Access</def><sym>)</sym> <def></def><kwa>is</kwa><br />
<def></def>         <kwa>begin</kwa><br />
<def>            E.</def><kwa>all</kwa><def>.Next</def> <sym>:=</sym> <def>Next</def><sym>;</sym><br />
<def></def>         <kwa>end</kwa> <def>Set_Next</def><sym>;</sym><br />
<def></def>      <kwa>end</kwa> <def>Calculator</def><sym>;</sym><br />
<def></def><br />
   <kwa>begin</kwa><br />
<def>      Calculator.Calculate_Frequencies</def> <sym>(</sym><def>Nucleotide_Length</def><sym>);</sym><br />
<def></def><br />
      <kwa>if</kwa> <def>Nucleotide_Fragment</def> <sym>=</sym> <def>Fragments.Null_Bounded_String</def> <kwa>then</kwa><br />
<def>         Calculate_Total</def> <sym>:</sym> <def></def><kwa>declare</kwa><br />
<def>            Count</def> <sym>:</sym> <def></def><kwb>Natural</kwb><def></def><sym>;</sym><br />
<def>            Total</def> <sym>:</sym> <def></def><kwb>Natural</kwb><def></def><sym>;</sym><br />
<def></def>         <kwa>begin</kwa><br />
<def>            Calculator.Get_Total</def> <sym>(</sym><def>Total</def> <sym>=&gt;</sym> <def>Total</def><sym>,</sym> <def>Count</def> <sym>=&gt;</sym> <def>Count</def><sym>);</sym><br />
<def><br />
            Get_Sort_Put</def> <sym>:</sym> <def></def><kwa>declare</kwa><br />
<def>               Data</def> <sym>:</sym> <def></def><kwa>array</kwa> <def></def><sym>(</sym><def></def><num>0</num> <def>.. Count</def><sym>)</sym> <def></def><kwa>of</kwa> <def>Calculator.Element_Access</def><sym>;</sym><br />
<def></def><br />
               <kwa>procedure</kwa> <def>Move</def> <sym>(</sym><def>From</def> <sym>:</sym> <def></def><kwb>Natural</kwb><def></def><sym>;</sym> <def>To</def> <sym>:</sym> <def></def><kwb>Natural</kwb><def></def><sym>);</sym><br />
<def></def>               <kwa>function</kwa> <def>Less_Then</def> <sym>(</sym><def>Op1</def><sym>,</sym> <def>Op2</def> <sym>:</sym> <def></def><kwb>Natural</kwb><def></def><sym>)</sym> <def></def><kwa>return</kwa> <def></def><kwb>Boolean</kwb><def></def><sym>;</sym><br />
<def></def><br />
               <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def>Move</def><sym>);</sym><br />
<def></def>               <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def>Less_Then</def><sym>);</sym><br />
<def></def><br />
               <kwa>package</kwa> <def>Heap_Sort</def> <kwa>is new</kwa> <def>GNAT.Heap_Sort_G</def> <sym>(</sym><def>Move</def> <sym>=&gt;</sym> <def>Move</def><sym>,</sym> <def>Lt</def> <sym>=&gt;</sym> <def>Less_Then</def><sym>);</sym><br />
<def></def><br />
               <kwa>function</kwa> <def>Less_Then</def> <sym>(</sym><def>Op1</def><sym>,</sym> <def>Op2</def> <sym>:</sym> <def></def><kwb>Natural</kwb><def></def><sym>)</sym> <def></def><kwa>return</kwa> <def></def><kwb>Boolean</kwb> <def></def><kwa>is</kwa><br />
<def></def>               <kwa>begin</kwa><br />
<def></def>                  <kwa>return</kwa> <def>Calculator.Count</def> <sym>(</sym><def>Data</def> <sym>(</sym><def>Op1</def><sym>)) &gt;</sym> <def>Calculator.Count</def> <sym>(</sym><def>Data</def> <sym>(</sym><def>Op2</def><sym>));</sym><br />
<def></def>               <kwa>end</kwa> <def>Less_Then</def><sym>;</sym><br />
<def></def><br />
               <kwa>procedure</kwa> <def>Move</def> <sym>(</sym><def>From</def> <sym>:</sym> <def></def><kwb>Natural</kwb><def></def><sym>;</sym> <def>To</def> <sym>:</sym> <def></def><kwb>Natural</kwb><def></def><sym>)</sym> <def></def><kwa>is</kwa><br />
<def></def>               <kwa>begin</kwa><br />
<def>                  Data</def> <sym>(</sym><def>To</def><sym>) :=</sym> <def>Data</def> <sym>(</sym><def>From</def><sym>);</sym><br />
<def></def>               <kwa>end</kwa> <def>Move</def><sym>;</sym><br />
<def></def>            <kwa>begin</kwa><br />
<def>               Data</def> <sym>(</sym><def></def><num>0</num><def></def><sym>) :=</sym> <def></def><kwa>null</kwa><def></def><sym>;</sym><br />
<def>               Data</def> <sym>(</sym><def></def><num>1</num><def></def><sym>) :=</sym> <def>Calculator.Get_First</def><sym>;</sym><br />
<def></def><br />
               <kwa>for</kwa> <def>I</def> <kwa>in</kwa>  <def></def><num>2</num> <def>.. Data</def><sym>'</sym><def>Last</def> <kwa>loop</kwa><br />
<def>                  Data</def> <sym>(</sym><def>I</def><sym>) :=</sym> <def>Calculator.Get_Next</def><sym>;</sym><br />
<def></def>               <kwa>end loop</kwa><def></def><sym>;</sym><br />
<def><br />
               Heap_Sort.Sort</def> <sym>(</sym><def>Data</def><sym>'</sym><def>Last</def><sym>);</sym><br />
<def></def><br />
               <kwa>for</kwa> <def>I</def> <kwa>in</kwa>  <def></def><num>1</num> <def>.. Data</def><sym>'</sym><def>Last</def> <kwa>loop</kwa><br />
<def>                  Ada.Text_IO.Put</def> <sym>(</sym><def>Fragments.To_String</def> <sym>(</sym><def>Calculator.Key</def> <sym>(</sym><def>Data</def> <sym>(</sym><def>I</def><sym>))));</sym><br />
<def>                  Ada.Text_IO.Put</def> <sym>(</sym><def>Ada.Characters.Latin_1.Space</def><sym>);</sym><br />
<def>                  Ada.Float_Text_IO.Put</def><br />
                    <sym>(</sym><def>Item</def> <sym>=&gt;</sym> <def></def><num>100.0</num> <def></def><sym>*</sym> <def></def><kwb>Float</kwb> <def></def><sym>(</sym><def>Calculator.Count</def> <sym>(</sym><def>Data</def> <sym>(</sym><def>I</def><sym>))) /</sym> <def></def><kwb>Float</kwb> <def></def><sym>(</sym><def>Total</def><sym>),</sym><br />
<def>                     Fore</def> <sym>=&gt;</sym> <def></def><num>1</num><def></def><sym>,</sym><br />
<def>                     Aft</def>  <sym>=&gt;</sym> <def></def><num>3</num><def></def><sym>,</sym><br />
<def>                     Exp</def>  <sym>=&gt;</sym> <def></def><num>0</num><def></def><sym>);</sym><br />
<def>                  Ada.Text_IO.New_Line</def><sym>;</sym><br />
<def></def>               <kwa>end loop</kwa><def></def><sym>;</sym><br />
<def>               Ada.Text_IO.New_Line</def><sym>;</sym><br />
<def></def>            <kwa>end</kwa> <def>Get_Sort_Put</def><sym>;</sym><br />
<def></def>         <kwa>end</kwa> <def>Calculate_Total</def><sym>;</sym><br />
<def></def>      <kwa>else</kwa><br />
<def>         Ada.Integer_Text_IO.Put</def> <sym>(</sym><def>Item</def> <sym>=&gt;</sym> <def>Calculator.Get</def> <sym>(</sym><def>Nucleotide_Fragment</def><sym>),</sym> <def>Width</def> <sym>=&gt;</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def>         Ada.Text_IO.Put</def> <sym>(</sym><def>Ada.Characters.Latin_1.HT</def><sym>);</sym><br />
<def>         Ada.Text_IO.Put_Line</def> <sym>(</sym><def>Fragments.To_String</def> <sym>(</sym><def>Nucleotide_Fragment</def><sym>));</sym><br />
<def></def>      <kwa>end if</kwa><def></def><sym>;</sym><br />
<def></def>      <kwa>return</kwa><def></def><sym>;</sym><br />
<def></def>   <kwa>end</kwa> <def>Write</def><sym>;</sym><br />
<def></def><br />
<kwa>begin</kwa><br />
<def>   Write</def> <sym>(</sym><def></def><num>1</num><def></def><sym>);</sym><br />
<def>   Write</def> <sym>(</sym><def></def><num>2</num><def></def><sym>);</sym><br />
<def>   Write</def> <sym>(</sym><def>Fragments.Length</def> <sym>(</sym><def>Fragment_3</def><sym>),</sym> <def>Fragment_3</def><sym>);</sym><br />
<def>   Write</def> <sym>(</sym><def>Fragments.Length</def> <sym>(</sym><def>Fragment_4</def><sym>),</sym> <def>Fragment_4</def><sym>);</sym><br />
<def>   Write</def> <sym>(</sym><def>Fragments.Length</def> <sym>(</sym><def>Fragment_6</def><sym>),</sym> <def>Fragment_6</def><sym>);</sym><br />
<def>   Write</def> <sym>(</sym><def>Fragments.Length</def> <sym>(</sym><def>Fragment_12</def><sym>),</sym> <def>Fragment_12</def><sym>);</sym><br />
<def>   Write</def> <sym>(</sym><def>Fragments.Length</def> <sym>(</sym><def>Fragment_18</def><sym>),</sym> <def>Fragment_18</def><sym>);</sym><br />
<def></def>   <kwa>return</kwa><def></def><sym>;</sym><br />
<def></def><kwa>end</kwa> <def>KNucleotide</def><sym>;</sym><br />
<def></def><br />
<slc>-------------------------------------------------------------------------------</slc><br />
<def></def><slc>--   vim: textwidth=0 nowrap tabstop=8 shiftwidth=3 softtabstop=3 expandtab vim: filetype=ada</slc><br />
<def></def><slc>--   encoding=latin1 fileformat=unix</slc><def></def><br />
</source>
