<source>
<def></def><com>{-# OPTIONS -fglasgow-exts #-}</com><def></def><br />
<br />
<com>{-</com><br />
<com>   The Computer Language Shootout</com><br />
<com>      http://shootout.alioth.debian.org/</com><br />
<com>      contributed by Olof Kraigher</com><br />
<com>-}</com><def></def><br />
<br />
<kwa>module</kwa> <def>Main</def> <kwa>where</kwa><br />
<def></def><br />
<kwa>import</kwa> <def>System</def><sym>(</sym><def>getArgs</def><sym>);</sym>      <def></def><kwa>import</kwa> <def>Data.List</def><sym>;</sym>   <def></def><kwa>import</kwa> <def>Data.Bits</def><sym>;</sym>      <def></def><kwa>import</kwa> <def>Data.Array.IArray</def><sym>;</sym><br />
<def></def><kwa>import</kwa> <def>Data.Word</def><sym>(</sym><def>Word64</def><sym>);</sym>   <def></def><kwa>import</kwa> <def>Data.Maybe</def><sym>;</sym>   <def></def><kwa>import</kwa> <def>Control.Monad</def><sym>;</sym><br />
<def></def><br />
<kwa>data</kwa> <def>Direction</def> <sym>=</sym> <def>E</def> <sym>|</sym> <def>SE</def> <sym>|</sym> <def>SW</def> <sym>|</sym> <def>W</def> <sym>|</sym> <def>NW</def> <sym>|</sym> <def>NE</def> <kwa>deriving</kwa> <def></def><sym>(</sym><def>Enum</def><sym>,</sym> <def>Eq</def><sym>,</sym> <def>Ord</def><sym>,</sym> <def>Show</def><sym>)</sym><br />
<def></def><kwa>type</kwa> <def>Piece</def> <sym>= [</sym><def>Direction</def><sym>]</sym><br />
<def></def><kwa>type</kwa> <def>Cell</def> <sym>= (</sym><def></def><kwb>Int</kwb><def></def><sym>,</sym> <def></def><kwb>Int</kwb><def></def><sym>)</sym><br />
<def></def><kwa>type</kwa> <def>Mask</def> <sym>=</sym> <def>Word64</def><br />
<kwa>type</kwa> <def>Color</def> <sym>=</sym> <def></def><kwb>Int</kwb><br />
<def></def><br />
<kwa>class</kwa> <def>Rotatable a</def> <kwa>where</kwa><br />
<def>   rot</def> <sym>::</sym> <def>a</def> <sym>-&gt;</sym> <def>a</def><br />
<br />
<kwa>class</kwa> <def>Floppable a</def> <kwa>where</kwa><br />
<def>   flop</def> <sym>::</sym> <def>a</def> <sym>-&gt;</sym> <def>a</def><br />
<br />
<kwa>class</kwa> <def>Maskable a</def> <kwa>where</kwa><br />
<def>   mask</def> <sym>::</sym> <def>a</def> <sym>-&gt;</sym> <def>Mask</def><br />
<br />
<kwa>instance</kwa> <def>Rotatable Direction</def> <kwa>where</kwa><br />
<def>   rot NE</def> <sym>=</sym> <def>E<br />
   rot d</def> <sym>=</sym> <def>succ d</def><br />
<br />
<kwa>instance</kwa> <def>Rotatable Piece</def> <kwa>where</kwa><br />
<def>   rot a</def> <sym>=</sym> <def>map rot a</def><br />
<br />
<kwa>instance</kwa> <def>Floppable Direction</def> <kwa>where</kwa><br />
<def>   flop E</def> <sym>=</sym> <def>W<br />
   flop W</def> <sym>=</sym> <def>E<br />
   flop SE</def> <sym>=</sym> <def>SW<br />
   flop SW</def> <sym>=</sym> <def>SE<br />
   flop NE</def> <sym>=</sym> <def>NW<br />
   flop NW</def> <sym>=</sym> <def>NE</def><br />
<br />
<kwa>instance</kwa> <def>Floppable Piece</def> <kwa>where</kwa><br />
<def>   flop a</def> <sym>=</sym> <def>map flop a</def><br />
<br />
<kwa>instance</kwa> <def>Maskable Cell</def> <kwa>where</kwa><br />
<def>   mask</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>) =</sym> <def>bit</def> <sym>(</sym><def>x</def> <sym>+</sym> <def>y</def><sym>*</sym><def>width</def><sym>)</sym><br />
<def></def><br />
<kwa>instance</kwa> <def>Maskable</def> <sym>[</sym><def>Cell</def><sym>]</sym> <def></def><kwa>where</kwa><br />
<def>   mask p</def> <sym>=</sym> <def>foldl'</def> <sym>(</sym><def>\a b</def> <sym>-&gt;</sym> <def>a .</def><sym>|</sym><def>. mask b</def><sym>)</sym> <def></def><num>0</num> <def>p<br />
<br />
width</def> <sym>::</sym> <def></def><kwb>Int</kwb><br />
<def>width</def> <sym>=</sym> <def></def><num>5</num><br />
<def><br />
height</def> <sym>::</sym> <def></def><kwb>Int</kwb><br />
<def>height</def> <sym>=</sym> <def></def><num>10</num><br />
<def><br />
cells</def> <sym>:: [</sym><def>Cell</def><sym>]</sym><br />
<def>cells</def> <sym>= [(</sym><def>x</def><sym>,</sym><def>y</def><sym>) |</sym> <def>y</def> <sym>&lt;- [</sym><def></def><num>0</num><def>..height</def><sym>-</sym><def></def><num>1</num><def></def><sym>],</sym> <def>x</def> <sym>&lt;- [</sym><def></def><num>0</num><def>..width</def><sym>-</sym><def></def><num>1</num><def></def><sym>]]</sym><br />
<def><br />
fullMask</def> <sym>::</sym> <def>Mask<br />
fullMask</def> <sym>=</sym> <def></def><num>0x3FFFFFFFFFFFF</num><br />
<def><br />
pieces</def> <sym>::</sym> <def>Array Color Piece<br />
pieces</def> <sym>=</sym> <def>array</def> <sym>(</sym><def></def><num>0</num><def></def><sym>,</sym><def></def><num>9</num><def></def><sym>)</sym> <def>$ zip</def> <sym>[</sym><def></def><num>0</num><def>.</def><num>.9</num><def></def><sym>]</sym> <def>$</def><br />
      <sym>[   [</sym><def>E</def><sym>,</sym>    <def>E</def><sym>,</sym>  <def>E</def><sym>,</sym>  <def>SE</def><sym>],</sym><br />
<def></def>         <sym>[</sym><def>SE</def><sym>,</sym> <def>SW</def><sym>,</sym> <def>W</def><sym>,</sym>  <def>SW</def><sym>],</sym><br />
<def></def>         <sym>[</sym><def>W</def><sym>,</sym>  <def>W</def><sym>,</sym>  <def>SW</def><sym>,</sym> <def>SE</def><sym>],</sym><br />
<def></def>         <sym>[</sym><def>E</def><sym>,</sym>  <def>E</def><sym>,</sym>  <def>SW</def><sym>,</sym> <def>SE</def><sym>],</sym><br />
<def></def>         <sym>[</sym><def>NW</def><sym>,</sym> <def>W</def><sym>,</sym>  <def>NW</def><sym>,</sym> <def>SE</def><sym>,</sym> <def>SW</def><sym>],</sym><br />
<def></def>         <sym>[</sym><def>E</def><sym>,</sym>  <def>E</def><sym>,</sym>  <def>NE</def><sym>,</sym> <def>W</def><sym>],</sym><br />
<def></def>         <sym>[</sym><def>NW</def><sym>,</sym> <def>NE</def><sym>,</sym> <def>NE</def><sym>,</sym> <def>W</def><sym>],</sym><br />
<def></def>         <sym>[</sym><def>NE</def><sym>,</sym> <def>SE</def><sym>,</sym> <def>E</def><sym>,</sym>  <def>NE</def><sym>],</sym><br />
<def></def>         <sym>[</sym><def>SE</def><sym>,</sym> <def>SE</def><sym>,</sym> <def>E</def><sym>,</sym>  <def>SE</def><sym>],</sym><br />
<def></def>         <sym>[</sym><def>E</def><sym>,</sym>  <def>NW</def><sym>,</sym> <def>NW</def><sym>,</sym> <def>NW</def><sym>]]</sym><br />
<def><br />
valid</def> <sym>::</sym> <def>Cell</def> <sym>-&gt;</sym> <def>Maybe Cell<br />
valid p</def><sym>@(</sym><def>x</def><sym>,</sym><def>y</def><sym>)</sym><br />
<def></def>   <sym>|</sym> <def></def><num>0</num> <def></def><sym>&lt;=</sym> <def>x</def><sym>,</sym> <def>x</def> <sym>&lt;</sym> <def>width</def><sym>,</sym> <def></def><num>0</num> <def></def><sym>&lt;=</sym> <def>y</def><sym>,</sym> <def>y</def> <sym>&lt;</sym> <def>height</def> <sym>=</sym> <def>Just p</def><br />
   <sym>|</sym><def>otherwise</def> <sym>=</sym> <def>Nothing<br />
<br />
move</def> <sym>::</sym> <def>Cell</def> <sym>-&gt;</sym> <def>Direction</def> <sym>-&gt;</sym> <def>Maybe Cell<br />
move</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>)</sym> <def>E</def> <sym>=</sym> <def>valid</def> <sym>(</sym><def>x</def><sym>+</sym><def></def><num>1</num><def></def><sym>,</sym><def>y</def><sym>)</sym><br />
<def>move</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>)</sym> <def>W</def> <sym>=</sym> <def>valid</def> <sym>(</sym><def>x</def><sym>-</sym><def></def><num>1</num><def></def><sym>,</sym><def>y</def><sym>)</sym><br />
<def>move</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>)</sym> <def>NE</def> <sym>=</sym> <def>valid</def> <sym>(</sym><def>x</def><sym>+(</sym><def>mod y</def> <num>2</num><def></def><sym>),</sym><def>y</def><sym>-</sym><def></def><num>1</num><def></def><sym>)</sym><br />
<def>move</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>)</sym> <def>NW</def> <sym>=</sym> <def>valid</def> <sym>(</sym><def>x</def><sym>+(</sym><def>mod y</def> <num>2</num><def></def><sym>)-</sym><def></def><num>1</num><def></def><sym>,</sym><def>y</def><sym>-</sym><def></def><num>1</num><def></def><sym>)</sym><br />
<def>move</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>)</sym> <def>SE</def> <sym>=</sym> <def>valid</def> <sym>(</sym><def>x</def><sym>+(</sym><def>mod y</def> <num>2</num><def></def><sym>),</sym><def>y</def><sym>+</sym><def></def><num>1</num><def></def><sym>)</sym><br />
<def>move</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>)</sym> <def>SW</def> <sym>=</sym> <def>valid</def> <sym>(</sym><def>x</def><sym>+(</sym><def>mod y</def> <num>2</num><def></def><sym>)-</sym><def></def><num>1</num><def></def><sym>,</sym><def>y</def><sym>+</sym><def></def><num>1</num><def></def><sym>)</sym><br />
<def><br />
overlap</def> <sym>::</sym> <def>Mask</def> <sym>-&gt;</sym> <def>Mask</def> <sym>-&gt;</sym> <def></def><kwb>Bool</kwb><br />
<def>overlap a b</def> <sym>= (</sym><def>a .</def><sym>&amp;</sym><def>. b</def><sym>) /=</sym> <def></def><num>0</num><br />
<def><br />
bitCount</def> <sym>::</sym> <def>Mask</def> <sym>-&gt;</sym> <def></def><kwb>Int</kwb><br />
<def>bitCount</def> <num>0</num> <def></def><sym>=</sym> <def></def><num>0</num><br />
<def>bitCount mask</def> <sym>= (</sym><def>fromIntegral $</def> <sym>(</sym><def>mask .</def><sym>&amp;</sym><def>.</def> <num>1</num><def></def><sym>)) + (</sym><def>bitCount</def> <sym>(</sym><def>shiftR mask</def> <num>1</num><def></def><sym>))</sym><br />
<def><br />
floodFill</def> <sym>::</sym> <def>Mask</def> <sym>-&gt;</sym> <def>Cell</def> <sym>-&gt;</sym> <def>Mask<br />
floodFill mask cell</def><sym>@(</sym><def>x</def><sym>,</sym><def>y</def><sym>)</sym><br />
<def></def>   <sym>|</sym> <def>overlap mask</def> <sym>(</sym><def>bit $ x</def> <sym>+</sym> <def>y</def><sym>*</sym><def>width</def><sym>) =</sym> <def>mask</def><br />
   <sym>|</sym> <def>otherwise</def> <sym>=</sym><br />
<def></def>      <kwa>let</kwa> <def>mask'</def> <sym>=</sym> <def>mask .</def><sym>|</sym><def>.</def> <sym>(</sym><def>bit $ x</def> <sym>+</sym> <def>y</def><sym>*</sym><def>width</def><sym>)</sym><br />
<def></def>      <kwa>in</kwa>   <def>foldl' floodFill mask' $ mapMaybe</def> <sym>(</sym><def>move cell</def><sym>) [</sym><def>E .. NE</def><sym>]</sym><br />
<def><br />
findFreeCell</def> <sym>::</sym> <def>Mask</def> <sym>-&gt;</sym> <def>Cell<br />
findFreeCell mask</def> <sym>=</sym><br />
<def>   fromJust $ find</def> <sym>(</sym><def>\</def><sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>) -&gt;</sym> <def>not $ overlap mask</def> <sym>(</sym><def>bit $ x</def> <sym>+</sym> <def>y</def><sym>*</sym><def>width</def><sym>))</sym> <def>cells<br />
<br />
noIslands</def> <sym>::</sym> <def>Mask</def> <sym>-&gt;</sym> <def></def><kwb>Bool</kwb><br />
<def>noIslands mask</def> <sym>=</sym> <def>not $ any</def> <sym>(&lt;</sym><def></def><num>5</num><def></def><sym>)</sym> <def>$ diffs $ noIslands' mask</def> <kwa>where</kwa><br />
<def>   noIslands' mask</def><br />
      <sym>|</sym> <def>mask</def> <sym>==</sym> <def>fullMask</def> <sym>= [</sym><def>bitCount mask</def><sym>]</sym><br />
<def></def>      <sym>|</sym> <def>otherwise</def> <sym>= (</sym><def>bitCount mask</def><sym>) : (</sym><def>noIslands' $ floodFill mask $ findFreeCell mask</def><sym>)</sym><br />
<def>   diffs l</def> <sym>=</sym> <def>zipWith</def> <sym>(-) (</sym><def>tail l</def><sym>)</sym> <def>l<br />
<br />
<br />
placePiece</def> <sym>::</sym> <def>Piece</def> <sym>-&gt;</sym> <def>Cell</def> <sym>-&gt;</sym> <def>Maybe</def> <sym>[</sym><def>Cell</def><sym>]</sym><br />
<def>placePiece</def> <sym>[]</sym> <def>cell</def> <sym>=</sym> <def>Just</def> <sym>[</sym><def>cell</def><sym>]</sym><br />
<def>placePiece</def> <sym>(</sym><def>p</def><sym>:</sym><def>ps</def><sym>)</sym> <def>cell</def> <sym>=</sym> <def>move cell p</def> <sym>&gt;&gt;= (</sym><def>placePiece ps</def><sym>) &gt;&gt;=</sym> <def>return .</def> <sym>(</sym><def>cell</def><sym>:)</sym><br />
<def><br />
pieceMasks</def> <sym>::</sym> <def>Array Color</def> <sym>[</sym><def>Mask</def><sym>]</sym><br />
<def>pieceMasks</def> <sym>=</sym> <def>amap pieceMasks' pieces</def> <kwa>where</kwa><br />
<def>   pieceMasks' piece</def><br />
      <sym>|</sym> <def>piece</def> <sym>== (</sym><def>pieces</def><sym>!</sym><def></def><num>5</num><def></def><sym>) =</sym> <def></def><kwa>do</kwa><br />
<def>         piece'</def> <sym>&lt;- (</sym><def>take</def> <num>3</num> <def>$ iterate rot piece</def><sym>) ++ (</sym><def>take</def> <num>3</num> <def>$ iterate rot $ flop $ piece</def><sym>)</sym><br />
<def>         filter noIslands $ map mask $ mapMaybe</def> <sym>(</sym><def>placePiece piece'</def><sym>)</sym> <def>cells</def><br />
<br />
      <sym>|</sym> <def>otherwise</def> <sym>=</sym> <def></def><kwa>do</kwa><br />
<def>         piece'</def> <sym>&lt;- (</sym><def>take</def> <num>6</num> <def>$ iterate rot piece</def><sym>) ++ (</sym><def>take</def> <num>6</num> <def>$ iterate rot $ flop $ piece</def><sym>)</sym><br />
<def>         filter noIslands $ map mask $ mapMaybe</def> <sym>(</sym><def>placePiece piece'</def><sym>)</sym> <def>cells<br />
<br />
pieceMasksAtCell</def> <sym>::</sym> <def>Array Color</def> <sym>(</sym><def>Array Cell</def> <sym>[</sym><def>Mask</def><sym>])</sym><br />
<def>pieceMasksAtCell</def> <sym>=</sym> <def>amap pieceMasksAtCell' pieceMasks</def> <kwa>where</kwa><br />
<def>   pieceMasksAtCell' masks</def> <sym>=</sym> <def>array</def> <sym>((</sym><def></def><num>0</num><def></def><sym>,</sym><def></def><num>0</num><def></def><sym>),(</sym><def>width</def><sym>-</sym><def></def><num>1</num><def></def><sym>,</sym><def>height</def><sym>-</sym><def></def><num>1</num><def></def><sym>))</sym> <def>$ pieceMasksAtCell'' masks cells</def> <kwa>where</kwa><br />
<def>      pieceMasksAtCell'' masks</def> <sym>[] = []</sym><br />
<def>      pieceMasksAtCell'' masks</def> <sym>(</sym><def>c</def><sym>:</sym><def>cs</def><sym>) =</sym><br />
<def></def>         <kwa>let</kwa> <def></def><sym>(</sym><def>a</def><sym>,</sym><def>b</def><sym>) =</sym> <def>partition</def> <sym>(</sym><def>overlap</def> <sym>(</sym><def>mask c</def><sym>))</sym> <def>masks</def><br />
         <kwa>in</kwa> <def></def><sym>(</sym><def>c</def><sym>,</sym><def>a</def><sym>) : (</sym><def>pieceMasksAtCell'' b cs</def><sym>)</sym><br />
<def><br />
nextCell</def> <sym>::</sym> <def>Cell</def> <sym>-&gt;</sym> <def>Cell<br />
nextCell</def> <sym>(</sym><def></def><num>4</num><def></def><sym>,</sym><def>y</def><sym>) = (</sym><def></def><num>0</num><def></def><sym>,</sym><def>y</def><sym>+</sym><def></def><num>1</num><def></def><sym>)</sym><br />
<def>nextCell</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>) =  (</sym><def>x</def><sym>+</sym><def></def><num>1</num><def></def><sym>,</sym><def>y</def><sym>)</sym><br />
<def><br />
solutions</def> <sym>:: [</sym><def>String</def><sym>]</sym><br />
<def>solutions</def> <sym>=</sym> <def>solutions'</def> <num>0</num> <def></def><sym>(</sym><def></def><num>0</num><def></def><sym>,</sym><def></def><num>0</num><def></def><sym>) [</sym><def></def><num>0</num><def>.</def><num>.9</num><def></def><sym>] []</sym> <def></def><kwa>where</kwa><br />
<def><br />
   solutions'</def> <sym>::</sym> <def>Mask</def> <sym>-&gt;</sym> <def>Cell</def> <sym>-&gt; [</sym><def>Color</def><sym>] -&gt; [(</sym><def>Color</def><sym>,</sym> <def>Mask</def><sym>)]-&gt; [</sym><def>String</def><sym>]</sym><br />
<def>   solutions' _ _</def> <sym>[]</sym> <def>usedMasks</def> <sym>=</sym>    <def></def><kwa>let</kwa> <def>s</def> <sym>=</sym> <def>stringOfColorMasks usedMasks</def> <kwa>in</kwa>   <def></def><sym>[</sym><def>s</def><sym>,</sym> <def>invertString s</def><sym>]</sym><br />
<def>   solutions' board cell colorsLeft usedMasks</def><br />
      <sym>|</sym> <def>overlap board</def> <sym>(</sym><def>mask cell</def><sym>) =</sym> <def>solutions' board</def> <sym>(</sym><def>nextCell cell</def><sym>)</sym> <def>colorsLeft usedMasks</def><br />
      <sym>|</sym> <def>otherwise</def> <sym>=</sym> <def></def><kwa>do</kwa><br />
<def>         color</def> <sym>&lt;-</sym> <def>colorsLeft<br />
         mask</def> <sym>&lt;-</sym> <def>filter</def> <sym>(</sym><def>not.</def><sym>(</sym><def>overlap board</def><sym>))</sym> <def>$ pieceMasksAtCell</def><sym>!</sym><def>color</def><sym>!</sym><def>cell<br />
         solutions'</def> <sym>(</sym><def>board .</def><sym>|</sym><def>. mask</def><sym>) (</sym><def>nextCell cell</def><sym>) (</sym><def>colorsLeft \\</def> <sym>[</sym><def>color</def><sym>]) ((</sym><def>color</def><sym>,</sym> <def>mask</def><sym>):</sym><def>usedMasks</def><sym>)</sym><br />
<def><br />
stringOfColorMasks</def> <sym>:: [(</sym><def>Color</def><sym>,</sym> <def>Mask</def><sym>)] -&gt;</sym> <def>String<br />
stringOfColorMasks colorMasks</def> <sym>=</sym><br />
<def>   tail.show.</def><sym>(+</sym><def></def><num>10</num><def>^</def><sym>(</sym><def>width</def><sym>*</sym><def>height</def><sym>))</sym><def>.sum $ map</def> <sym>(</sym><def>\</def><sym>(</sym><def>c</def><sym>,</sym><def>m</def><sym>) -&gt; (</sym><def>fromIntegral c</def><sym>) * (</sym><def>binToDec m</def><sym>))</sym> <def>colorMasks</def> <kwa>where</kwa><br />
<def>   binToDec</def> <sym>::</sym> <def>Mask</def> <sym>-&gt;</sym> <def>Integer<br />
   binToDec</def> <num>0</num> <def></def><sym>=</sym> <def></def><num>0</num><br />
<def>   binToDec n</def> <sym>= (</sym><def>fromIntegral</def> <sym>(</sym><def>mod n</def> <num>2</num><def></def><sym>)) +</sym> <def></def><num>10</num><def></def><sym>*(</sym><def>binToDec $ div n</def> <num>2</num><def></def><sym>)</sym><br />
<def><br />
invertString</def> <sym>::</sym> <def>String</def> <sym>-&gt;</sym> <def>String<br />
invertString s</def> <sym>=</sym> <def>map</def> <sym>(</sym><def>\</def><sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>) -&gt;</sym> <def>s</def><sym>!!(</sym><def>width</def><sym>-</sym><def>x</def><sym>-</sym><def></def><num>1</num> <def></def><sym>+ (</sym><def>height</def><sym>-</sym><def>y</def><sym>-</sym><def></def><num>1</num><def></def><sym>)*</sym><def>width</def><sym>))</sym> <def>cells<br />
<br />
printSolution</def> <sym>::</sym> <def>String</def> <sym>-&gt;</sym> <def>IO</def> <sym>()</sym><br />
<def>printSolution solution</def> <sym>=</sym> <def>printSolution'</def> <num>0</num> <def>solution</def> <kwa>where</kwa><br />
<def>   printSolution' cell</def> <sym>[] =</sym> <def>return</def> <sym>()</sym><br />
<def>   printSolution' cell</def> <sym>(</sym><def>s</def><sym>:</sym><def>ss</def><sym>) =</sym> <def></def><kwa>do</kwa><br />
<def>      putStr $ s</def><sym>:</sym><def></def><str>&quot; &quot;</str><def></def><br />
      <kwa>case</kwa> <def>mod</def> <sym>(</sym><def>cell</def><sym>+</sym><def></def><num>1</num><def></def><sym>)</sym> <def>width</def> <kwa>of</kwa><br />
<def></def>         <num>0</num> <def></def><sym>-&gt;</sym> <def></def><kwa>case</kwa> <def>mod</def> <sym>(</sym><def>cell</def><sym>+</sym><def></def><num>1</num><def></def><sym>) (</sym><def></def><num>2</num><def></def><sym>*</sym><def>width</def><sym>)</sym> <def></def><kwa>of</kwa><br />
<def></def>            <num>0</num> <def></def><sym>-&gt;</sym> <def>putStr</def> <str>&quot;\n&quot;</str><def><br />
            _</def> <sym>-&gt;</sym> <def>putStr</def> <str>&quot;\n &quot;</str><def><br />
         _</def> <sym>-&gt;</sym> <def>return</def> <sym>()</sym><br />
<def><br />
      printSolution'</def> <sym>(</sym><def>cell</def><sym>+</sym><def></def><num>1</num><def></def><sym>)</sym> <def>ss<br />
<br />
main</def> <sym>=</sym> <def></def><kwa>do</kwa><br />
<def></def>   <sym>(</sym><def>n</def> <sym>::</sym> <def></def><kwb>Int</kwb><def></def><sym>) &lt;-</sym> <def>return.read.head</def> <sym>=&lt;&lt;</sym> <def>getArgs</def><br />
   <kwa>let</kwa> <def>nsolutions</def> <sym>=</sym> <def>take n solutions<br />
   putStrLn $</def> <sym>(</sym><def>show $ length nsolutions</def><sym>) ++</sym> <def></def><str>&quot; solutions found\n&quot;</str><def><br />
   printSolution $ minimum nsolutions<br />
   putStr</def> <str>&quot;\n&quot;</str><def><br />
   printSolution $ maximum nsolutions<br />
   putStr</def> <str>&quot;\n&quot;</str><def></def><br />
</source>
