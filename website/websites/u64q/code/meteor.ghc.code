<source>
<def></def><com>{-</com><br />
<com>   The Computer Language Shootout</com><br />
<com>      http://shootout.alioth.debian.org/</com><br />
<com>      contributed by Olof Kraigher</com><br />
<com>-}</com><def></def><br />
<br />
<kwa>module</kwa> <def>Main</def> <kwa>where</kwa><br />
<def></def><br />
<kwa>import</kwa> <def>System</def><sym>(</sym><def>getArgs</def><sym>);</sym>      <def></def><kwa>import</kwa> <def>Data.List</def><sym>;</sym>   <def></def><kwa>import</kwa> <def>Data.Bits</def><sym>;</sym>         <def></def><kwa>import</kwa> <def>Data.Array.IArray</def><sym>;</sym><br />
<def></def><kwa>import</kwa> <def></def><kwb>Char</kwb><def></def><sym>(</sym><def>intToDigit</def><sym>);</sym>   <def></def><kwa>import</kwa> <def>Data.Maybe</def><sym>;</sym>   <def></def><kwa>import</kwa> <def>Data.Word</def><sym>(</sym><def>Word64</def><sym>);</sym>   <def></def><kwa>import</kwa> <def>Numeric</def><sym>(</sym><def>showIntAtBase</def><sym>);</sym><br />
<def></def><br />
<kwa>data</kwa> <def>Direction</def> <sym>=</sym> <def>E</def> <sym>|</sym> <def>SE</def> <sym>|</sym> <def>SW</def> <sym>|</sym> <def>W</def> <sym>|</sym> <def>NW</def> <sym>|</sym> <def>NE</def> <kwa>deriving</kwa> <def></def><sym>(</sym><def>Enum</def><sym>,</sym> <def>Eq</def><sym>,</sym> <def>Ord</def><sym>,</sym> <def>Show</def><sym>)</sym><br />
<def></def><kwa>type</kwa> <def>Piece</def> <sym>= [</sym><def>Direction</def><sym>]</sym><br />
<def></def><kwa>type</kwa> <def>Cell</def> <sym>= (</sym><def></def><kwb>Int</kwb><def></def><sym>,</sym> <def></def><kwb>Int</kwb><def></def><sym>)</sym><br />
<def></def><kwa>type</kwa> <def>Mask</def> <sym>=</sym> <def>Word64</def><br />
<kwa>type</kwa> <def>Color</def> <sym>=</sym> <def></def><kwb>Int</kwb><br />
<def></def><br />
<kwa>class</kwa> <def>Rotatable a</def> <kwa>where</kwa><br />
<def>   rot</def> <sym>::</sym> <def>a</def> <sym>-&gt;</sym> <def>a</def><br />
<br />
<kwa>class</kwa> <def>Floppable a</def> <kwa>where</kwa><br />
<def>   flop</def> <sym>::</sym> <def>a</def> <sym>-&gt;</sym> <def>a</def><br />
<br />
<kwa>class</kwa> <def>Maskable a</def> <kwa>where</kwa><br />
<def>   mask</def> <sym>::</sym> <def>a</def> <sym>-&gt;</sym> <def>Mask</def><br />
<br />
<kwa>instance</kwa> <def>Rotatable Direction</def> <kwa>where</kwa><br />
<def>   rot NE</def> <sym>=</sym> <def>E<br />
   rot d</def> <sym>=</sym> <def>succ d</def><br />
<br />
<kwa>instance</kwa> <def>Rotatable Piece</def> <kwa>where</kwa><br />
<def>   rot a</def> <sym>=</sym> <def>map rot a</def><br />
<br />
<kwa>instance</kwa> <def>Floppable Direction</def> <kwa>where</kwa><br />
<def>   flop E</def> <sym>=</sym> <def>W<br />
   flop W</def> <sym>=</sym> <def>E<br />
   flop SE</def> <sym>=</sym> <def>SW<br />
   flop SW</def> <sym>=</sym> <def>SE<br />
   flop NE</def> <sym>=</sym> <def>NW<br />
   flop NW</def> <sym>=</sym> <def>NE</def><br />
<br />
<kwa>instance</kwa> <def>Floppable Piece</def> <kwa>where</kwa><br />
<def>   flop a</def> <sym>=</sym> <def>map flop a</def><br />
<br />
<kwa>instance</kwa> <def>Maskable Cell</def> <kwa>where</kwa><br />
<def>   mask</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>) =</sym> <def>bit</def> <sym>(</sym><def>x</def> <sym>+</sym> <def>y</def><sym>*</sym><def>width</def><sym>)</sym><br />
<def></def><br />
<kwa>instance</kwa> <def>Maskable</def> <sym>[</sym><def>Cell</def><sym>]</sym> <def></def><kwa>where</kwa><br />
<def>   mask p</def> <sym>=</sym> <def>foldl'</def> <sym>(</sym><def>\a b</def> <sym>-&gt;</sym> <def>a .</def><sym>|</sym><def>. mask b</def><sym>)</sym> <def></def><num>0</num> <def>p<br />
<br />
width</def> <sym>::</sym> <def></def><kwb>Int</kwb><br />
<def>width</def> <sym>=</sym> <def></def><num>5</num><br />
<def><br />
height</def> <sym>::</sym> <def></def><kwb>Int</kwb><br />
<def>height</def> <sym>=</sym> <def></def><num>10</num><br />
<def><br />
allCells</def> <sym>:: [</sym><def>Cell</def><sym>]</sym><br />
<def>allCells</def> <sym>= [(</sym><def>x</def><sym>,</sym><def>y</def><sym>) |</sym> <def>y</def> <sym>&lt;- [</sym><def></def><num>0</num><def>..height</def><sym>-</sym><def></def><num>1</num><def></def><sym>],</sym> <def>x</def> <sym>&lt;- [</sym><def></def><num>0</num><def>..width</def><sym>-</sym><def></def><num>1</num><def></def><sym>]]</sym><br />
<def><br />
left</def> <sym>::</sym> <def>Mask<br />
left</def> <sym>=</sym> <def>shift right</def> <sym>(</sym><def>width</def><sym>-</sym><def></def><num>1</num><def></def><sym>)</sym><br />
<def><br />
right</def> <sym>::</sym> <def>Mask<br />
right</def> <sym>=</sym> <def>foldl'</def> <sym>(</sym><def>\a b</def> <sym>-&gt;</sym> <def>a .</def><sym>|</sym><def>.</def> <sym>(</sym><def>shift</def> <num>1</num> <def>b</def><sym>))</sym> <def></def><num>0</num> <def></def><sym>[</sym><def></def><num>0</num><def></def><sym>,</sym><def>width..width</def><sym>*(</sym><def>height</def><sym>-</sym><def></def><num>1</num><def></def><sym>)]</sym><br />
<def><br />
bottom</def> <sym>::</sym> <def>Mask<br />
bottom</def> <sym>=</sym> <def></def><num>0x1f</num><br />
<def><br />
top</def> <sym>::</sym> <def>Mask<br />
top</def> <sym>=</sym> <def>shift bottom</def> <sym>(</sym><def>width</def><sym>*(</sym><def>height</def><sym>-</sym><def></def><num>1</num><def></def><sym>))</sym><br />
<def><br />
fullMask</def> <sym>::</sym> <def>Mask<br />
fullMask</def> <sym>=</sym> <def></def><num>0x3FFFFFFFFFFFF</num><br />
<def><br />
pieces</def> <sym>::</sym> <def>Array Color Piece<br />
pieces</def> <sym>=</sym> <def>array</def> <sym>(</sym><def></def><num>0</num><def></def><sym>,</sym><def></def><num>9</num><def></def><sym>)</sym> <def>$ zip</def> <sym>[</sym><def></def><num>0</num><def>.</def><num>.9</num><def></def><sym>]</sym> <def>$</def><br />
      <sym>[   [</sym><def>E</def><sym>,</sym>    <def>E</def><sym>,</sym>  <def>E</def><sym>,</sym>  <def>SE</def><sym>],</sym><br />
<def></def>         <sym>[</sym><def>SE</def><sym>,</sym> <def>SW</def><sym>,</sym> <def>W</def><sym>,</sym>  <def>SW</def><sym>],</sym><br />
<def></def>         <sym>[</sym><def>W</def><sym>,</sym>  <def>W</def><sym>,</sym>  <def>SW</def><sym>,</sym> <def>SE</def><sym>],</sym><br />
<def></def>         <sym>[</sym><def>E</def><sym>,</sym>  <def>E</def><sym>,</sym>  <def>SW</def><sym>,</sym> <def>SE</def><sym>],</sym><br />
<def></def>         <sym>[</sym><def>NW</def><sym>,</sym> <def>W</def><sym>,</sym>  <def>NW</def><sym>,</sym> <def>SE</def><sym>,</sym> <def>SW</def><sym>],</sym><br />
<def></def>         <sym>[</sym><def>E</def><sym>,</sym>  <def>E</def><sym>,</sym>  <def>NE</def><sym>,</sym> <def>W</def><sym>],</sym><br />
<def></def>         <sym>[</sym><def>NW</def><sym>,</sym> <def>NE</def><sym>,</sym> <def>NE</def><sym>,</sym> <def>W</def><sym>],</sym><br />
<def></def>         <sym>[</sym><def>NE</def><sym>,</sym> <def>SE</def><sym>,</sym> <def>E</def><sym>,</sym>  <def>NE</def><sym>],</sym><br />
<def></def>         <sym>[</sym><def>SE</def><sym>,</sym> <def>SE</def><sym>,</sym> <def>E</def><sym>,</sym>  <def>SE</def><sym>],</sym><br />
<def></def>         <sym>[</sym><def>E</def><sym>,</sym>  <def>NW</def><sym>,</sym> <def>NW</def><sym>,</sym> <def>NW</def><sym>]]</sym><br />
<def><br />
valid</def> <sym>::</sym> <def>Cell</def> <sym>-&gt;</sym> <def>Maybe Cell<br />
valid p</def><sym>@(</sym><def>x</def><sym>,</sym><def>y</def><sym>)</sym><br />
<def></def>   <sym>|</sym> <def></def><num>0</num> <def></def><sym>&lt;=</sym> <def>x</def><sym>,</sym> <def>x</def> <sym>&lt;</sym> <def>width</def><sym>,</sym> <def></def><num>0</num> <def></def><sym>&lt;=</sym> <def>y</def><sym>,</sym> <def>y</def> <sym>&lt;</sym> <def>height</def> <sym>=</sym> <def>Just p</def><br />
   <sym>|</sym><def>otherwise</def> <sym>=</sym> <def>Nothing<br />
<br />
move</def> <sym>::</sym> <def>Cell</def> <sym>-&gt;</sym> <def>Direction</def> <sym>-&gt;</sym> <def>Maybe Cell<br />
move</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>)</sym> <def>E</def> <sym>=</sym> <def>valid</def> <sym>(</sym><def>x</def><sym>+</sym><def></def><num>1</num><def></def><sym>,</sym><def>y</def><sym>)</sym><br />
<def>move</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>)</sym> <def>W</def> <sym>=</sym> <def>valid</def> <sym>(</sym><def>x</def><sym>-</sym><def></def><num>1</num><def></def><sym>,</sym><def>y</def><sym>)</sym><br />
<def>move</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>)</sym> <def>NE</def> <sym>=</sym> <def>valid</def> <sym>(</sym><def>x</def><sym>+(</sym><def>mod y</def> <num>2</num><def></def><sym>),</sym><def>y</def><sym>-</sym><def></def><num>1</num><def></def><sym>)</sym><br />
<def>move</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>)</sym> <def>NW</def> <sym>=</sym> <def>valid</def> <sym>(</sym><def>x</def><sym>+(</sym><def>mod y</def> <num>2</num><def></def><sym>)-</sym><def></def><num>1</num><def></def><sym>,</sym><def>y</def><sym>-</sym><def></def><num>1</num><def></def><sym>)</sym><br />
<def>move</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>)</sym> <def>SE</def> <sym>=</sym> <def>valid</def> <sym>(</sym><def>x</def><sym>+(</sym><def>mod y</def> <num>2</num><def></def><sym>),</sym><def>y</def><sym>+</sym><def></def><num>1</num><def></def><sym>)</sym><br />
<def>move</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>)</sym> <def>SW</def> <sym>=</sym> <def>valid</def> <sym>(</sym><def>x</def><sym>+(</sym><def>mod y</def> <num>2</num><def></def><sym>)-</sym><def></def><num>1</num><def></def><sym>,</sym><def>y</def><sym>+</sym><def></def><num>1</num><def></def><sym>)</sym><br />
<def><br />
cells</def> <sym>::</sym> <def>Piece</def> <sym>-&gt;</sym> <def>Cell</def> <sym>-&gt;</sym> <def>Maybe</def> <sym>[</sym><def>Cell</def><sym>]</sym><br />
<def>cells</def> <sym>[]</sym> <def>cell</def> <sym>=</sym> <def>Just</def> <sym>[</sym><def>cell</def><sym>]</sym><br />
<def>cells</def> <sym>(</sym><def>d</def><sym>:</sym><def>ds</def><sym>)</sym> <def>cell</def><sym>@(</sym><def>x</def><sym>,</sym><def>y</def><sym>) =</sym><br />
<def></def>   <kwa>case</kwa> <def>move</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>)</sym> <def>d</def> <kwa>of</kwa><br />
<def>      Nothing</def> <sym>-&gt;</sym> <def>Nothing<br />
      Just</def> <sym>(</sym><def>x'</def><sym>,</sym><def>y'</def><sym>) -&gt;</sym><br />
<def></def>         <kwa>case</kwa> <def>cells ds</def> <sym>(</sym><def>x'</def><sym>,</sym><def>y'</def><sym>)</sym> <def></def><kwa>of</kwa><br />
<def>            Nothing</def> <sym>-&gt;</sym> <def>Nothing<br />
            Just ps</def> <sym>-&gt;</sym> <def>Just $</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>) :</sym> <def>ps<br />
<br />
bitCount</def> <sym>::</sym> <def>Mask</def> <sym>-&gt;</sym> <def></def><kwb>Int</kwb><br />
<def>bitCount</def> <num>0</num> <def></def><sym>=</sym> <def></def><num>0</num><br />
<def>bitCount mask</def> <sym>= (</sym><def>fromIntegral $</def> <sym>(</sym><def>mask .</def><sym>&amp;</sym><def>.</def> <num>1</num><def></def><sym>)) + (</sym><def>bitCount</def> <sym>(</sym><def>shiftR mask</def> <num>1</num><def></def><sym>))</sym><br />
<def><br />
floodFill</def> <sym>::</sym> <def>Mask</def> <sym>-&gt;</sym> <def>Mask</def> <sym>-&gt;</sym> <def>Mask<br />
floodFill mask fromBit</def><br />
   <sym>|</sym> <def>overlaps fromBit mask</def> <sym>=</sym> <def>mask</def><br />
   <sym>|</sym> <def>otherwise</def> <sym>=</sym><br />
<def></def>      <kwa>let</kwa> <def>mask'</def> <sym>=</sym> <def>mask .</def><sym>|</sym><def>. fromBit</def><br />
      <kwa>in</kwa> <def>foldl'</def> <sym>(</sym><def>floodFill</def><sym>)</sym> <def>mask' $<br />
            map snd $ filter</def> <sym>(</sym><def>\</def><sym>(</sym><def>a</def><sym>,</sym> <def>b</def><sym>) -&gt;</sym> <def>not $ overlaps a fromBit</def><sym>)</sym> <def>$<br />
               zip</def> <sym>[</sym><def>left</def><sym>,</sym> <def>right</def><sym>,</sym> <def>top</def><sym>,</sym> <def>bottom</def><sym>]</sym> <def>$<br />
                  map</def> <sym>(</sym><def>shift fromBit</def><sym>) [</sym><def></def><num>1</num><def></def><sym>,-</sym><def></def><num>1</num><def></def><sym>,</sym><def>width</def><sym>,-</sym><def>width</def><sym>]</sym><br />
<def><br />
findFreeBit</def> <sym>::</sym> <def>Mask</def> <sym>-&gt;</sym> <def>Mask<br />
findFreeBit mask</def> <sym>=</sym> <def>fromJust $ find</def> <sym>(</sym><def>not.</def><sym>(</sym><def>overlaps mask</def><sym>))</sym> <def>$ map</def> <sym>(</sym><def>shift</def> <num>1</num><def></def><sym>) [</sym><def></def><num>0</num><def>..width</def><sym>*</sym><def>height</def><sym>-</sym><def></def><num>1</num><def></def><sym>]</sym><br />
<def><br />
noIslands</def> <sym>::</sym> <def>Mask</def> <sym>-&gt;</sym> <def></def><kwb>Bool</kwb><br />
<def>noIslands mask</def> <sym>=</sym> <def>not $ any</def> <sym>(&lt;</sym><def></def><num>5</num><def></def><sym>)</sym> <def>$ diffs $ noIslands' mask</def> <kwa>where</kwa><br />
<def>   noIslands' mask</def><br />
      <sym>|</sym> <def>mask</def> <sym>==</sym> <def>fullMask</def> <sym>= [</sym><def>bitCount mask</def><sym>]</sym><br />
<def></def>      <sym>|</sym> <def>otherwise</def> <sym>= (</sym><def>bitCount mask</def><sym>): (</sym><def>noIslands' $ floodFill mask $ findFreeBit mask</def><sym>)</sym><br />
<def>   diffs</def> <sym>(</sym><def>x</def><sym>:</sym><def>y</def><sym>:[]) = [</sym><def>y</def><sym>-</sym><def>x</def><sym>]</sym><br />
<def>   diffs</def> <sym>(</sym><def>x</def><sym>:</sym><def>y</def><sym>:</sym><def>xs</def><sym>) = (</sym><def>y</def><sym>-</sym><def>x</def><sym>): (</sym><def>diffs $ y</def><sym>:</sym><def>xs</def><sym>)</sym><br />
<def><br />
bitmasksWithColor</def> <sym>::</sym> <def>Array Color</def> <sym>[</sym><def>Mask</def><sym>]</sym><br />
<def>bitmasksWithColor</def> <sym>=</sym> <def>amap bitmasksWithColor' pieces</def> <kwa>where</kwa><br />
<def><br />
   bitmasksWithColor'</def> <sym>::</sym> <def>Piece</def> <sym>-&gt; [</sym><def>Mask</def><sym>]</sym><br />
<def>   bitmasksWithColor' piece</def><br />
      <sym>|</sym> <def>piece</def> <sym>== [</sym><def>NW</def><sym>,</sym> <def>W</def><sym>,</sym>  <def>NW</def><sym>,</sym> <def>SE</def><sym>,</sym> <def>SW</def><sym>] =</sym> <def></def><kwa>do</kwa><br />
<def>         piece'</def> <sym>&lt;- (</sym><def>take</def> <num>3</num> <def>$ iterate rot piece</def><sym>) ++ (</sym><def>take</def> <num>3</num> <def>$ iterate rot $ flop piece</def><sym>)</sym><br />
<def>         filter noIslands $ map mask $ mapMaybe</def> <sym>(</sym><def>cells piece'</def><sym>)</sym> <def>allCells</def><br />
<br />
      <sym>|</sym> <def>otherwise</def> <sym>=</sym> <def></def><kwa>do</kwa><br />
<def>         piece'</def> <sym>&lt;- (</sym><def>take</def> <num>6</num> <def>$ iterate rot piece</def><sym>) ++ (</sym><def>take</def> <num>6</num> <def>$ iterate rot $ flop piece</def><sym>)</sym><br />
<def>         filter noIslands $ map mask $ mapMaybe</def> <sym>(</sym><def>cells piece'</def><sym>)</sym> <def>allCells<br />
<br />
<br />
bitmasksAtCell</def> <sym>:: [</sym><def>Mask</def><sym>] -&gt;</sym> <def>Array Cell</def> <sym>[</sym><def>Mask</def><sym>]</sym><br />
<def>bitmasksAtCell masks</def> <sym>=</sym><br />
<def></def>   <kwa>let</kwa> <def>masks'</def> <sym>= (</sym><def>bitmasksAtCell'</def> <sym>(</sym><def>shift</def> <num>1</num> <def>$ width</def><sym>*</sym><def>height</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>) [] (</sym><def>reverse $ sort masks</def><sym>))</sym><br />
<def></def>   <kwa>in</kwa>  <def>array</def> <sym>((</sym><def></def><num>0</num><def></def><sym>,</sym><def></def><num>0</num><def></def><sym>),(</sym><def></def><num>4</num><def></def><sym>,</sym><def></def><num>9</num><def></def><sym>))</sym> <def>$ zip</def> <sym>[(</sym><def>x</def><sym>,</sym><def>y</def><sym>) |</sym> <def>y</def> <sym>&lt;- [</sym><def></def><num>9</num><def></def><sym>,</sym><def></def><num>8</num><def>.</def><num>.0</num><def></def><sym>],</sym> <def>x</def> <sym>&lt;- [</sym><def></def><num>4</num><def></def><sym>,</sym><def></def><num>3</num><def>.</def><num>.0</num><def></def><sym>]]</sym> <def>masks'</def> <kwa>where</kwa><br />
<def><br />
      bitmasksAtCell'</def> <sym>::</sym> <def>Mask</def> <sym>-&gt; [</sym><def>Mask</def><sym>] -&gt; [</sym><def>Mask</def><sym>] -&gt; [[</sym><def>Mask</def><sym>]]</sym><br />
<def>      bitmasksAtCell'</def> <num>1</num> <def>cellMasks</def> <sym>[] = [</sym><def>cellMasks</def><sym>]</sym><br />
<def>      bitmasksAtCell' cellMask cellMasks</def> <sym>[] =</sym> <def>cellMasks</def><sym>:(</sym><def>bitmasksAtCell'</def> <sym>(</sym><def>shiftR cellMask</def> <num>1</num><def></def><sym>) [] [])</sym><br />
<def>      bitmasksAtCell' cellMask cellMasks masks</def><sym>@(</sym><def>m</def><sym>:</sym><def>ms</def><sym>)</sym><br />
<def></def>         <sym>|</sym> <def>overlaps cellMask m</def> <sym>=</sym> <def>bitmasksAtCell' cellMask</def> <sym>(</sym><def>m</def><sym>:</sym><def>cellMasks</def><sym>)</sym> <def>ms</def><br />
         <sym>|</sym> <def>otherwise</def> <sym>=</sym> <def>cellMasks</def> <sym>: (</sym><def>bitmasksAtCell'</def> <sym>(</sym><def>shiftR cellMask</def> <num>1</num><def></def><sym>) []</sym> <def>masks</def><sym>)</sym><br />
<def><br />
<br />
bitmasksWithColorAtCell</def> <sym>::</sym> <def>Array Color</def> <sym>(</sym><def>Array Cell</def> <sym>[</sym><def>Mask</def><sym>])</sym><br />
<def>bitmasksWithColorAtCell</def> <sym>=</sym> <def>amap bitmasksAtCell bitmasksWithColor<br />
<br />
nextCell</def> <sym>::</sym> <def>Cell</def> <sym>-&gt;</sym> <def>Cell<br />
nextCell</def> <sym>(</sym><def></def><num>0</num><def></def><sym>,</sym><def>y</def><sym>) = (</sym><def>width</def><sym>-</sym><def></def><num>1</num><def></def><sym>,</sym><def>y</def><sym>-</sym><def></def><num>1</num><def></def><sym>)</sym><br />
<def>nextCell</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>) =  (</sym><def>x</def><sym>-</sym><def></def><num>1</num><def></def><sym>,</sym><def>y</def><sym>)</sym><br />
<def><br />
<br />
overlaps</def> <sym>::</sym> <def>Mask</def> <sym>-&gt;</sym> <def>Mask</def> <sym>-&gt;</sym> <def></def><kwb>Bool</kwb><br />
<def>overlaps a b</def> <sym>= (</sym><def>a .</def><sym>&amp;</sym><def>. b</def><sym>) /=</sym> <def></def><num>0</num><br />
<def><br />
legal</def> <sym>::</sym> <def>Mask</def> <sym>-&gt; [</sym><def>Mask</def><sym>] -&gt; [</sym><def>Mask</def><sym>]</sym><br />
<def>legal boardMask masks</def> <sym>=</sym> <def>filter</def> <sym>(</sym><def>not.</def><sym>(</sym><def>overlaps boardMask</def><sym>))</sym> <def>masks<br />
<br />
<br />
solutions</def> <sym>:: [</sym><def>String</def><sym>]</sym><br />
<def>solutions</def> <sym>=</sym> <def>solutions'</def> <num>0</num> <def></def><sym>(</sym><def>width</def><sym>-</sym><def></def><num>1</num><def></def><sym>,</sym> <def>height</def><sym>-</sym><def></def><num>1</num><def></def><sym>) [</sym><def></def><num>0</num><def>.</def><num>.9</num><def></def><sym>] []</sym> <def></def><kwa>where</kwa><br />
<def><br />
   solutions'</def> <sym>::</sym> <def>Mask</def> <sym>-&gt;</sym> <def>Cell</def> <sym>-&gt; [</sym><def>Color</def><sym>] -&gt; [(</sym><def>Color</def><sym>,</sym> <def>Mask</def><sym>)]-&gt; [</sym><def>String</def><sym>]</sym><br />
<def>   solutions' _ _</def> <sym>[]</sym> <def>usedMasks</def> <sym>=</sym>    <def></def><kwa>let</kwa> <def>s</def> <sym>=</sym> <def>stringOfColorMasks usedMasks</def> <kwa>in</kwa>   <def></def><sym>[</sym><def>s</def><sym>,</sym> <def>invertString s</def><sym>]</sym><br />
<def>   solutions' board cell colorsLeft usedMasks</def><br />
      <sym>|</sym> <def>overlaps board</def> <sym>(</sym><def>mask cell</def><sym>) =</sym> <def>solutions' board</def> <sym>(</sym><def>nextCell cell</def><sym>)</sym> <def>colorsLeft usedMasks</def><br />
      <sym>|</sym> <def>otherwise</def> <sym>=</sym> <def></def><kwa>do</kwa><br />
<def>         color</def> <sym>&lt;-</sym> <def>colorsLeft<br />
         mask</def> <sym>&lt;-</sym> <def>legal board $ bitmasksWithColorAtCell</def><sym>!</sym><def>color</def><sym>!</sym><def>cell<br />
         solutions'</def> <sym>(</sym><def>board .</def><sym>|</sym><def>. mask</def><sym>) (</sym><def>nextCell cell</def><sym>) (</sym><def>colorsLeft \\</def> <sym>[</sym><def>color</def><sym>]) ((</sym><def>color</def><sym>,</sym> <def>mask</def><sym>):</sym><def>usedMasks</def><sym>)</sym><br />
<def><br />
stringOfColorMasks</def> <sym>:: [(</sym><def>Color</def><sym>,</sym> <def>Mask</def><sym>)] -&gt;</sym> <def>String<br />
stringOfColorMasks colorMasks</def> <sym>=</sym><br />
<def>   tail $ show $</def> <sym>(+) (</sym><def></def><num>10</num><def>^</def><sym>(</sym><def>width</def><sym>*</sym><def>height</def><sym>))</sym> <def>$<br />
      sum $ map</def> <sym>(</sym><def>\</def><sym>(</sym><def>c</def><sym>,</sym><def>m</def><sym>) -&gt; ((</sym><def>fromIntegral c</def><sym>) * (</sym><def>read $ showIntAtBase</def> <num>2</num> <def>intToDigit m</def> <str>&quot;&quot;</str><def></def><sym>)) ::</sym> <def>Integer</def><sym>)</sym> <def>colorMasks<br />
<br />
invertString</def> <sym>::</sym> <def>String</def> <sym>-&gt;</sym> <def>String<br />
invertString s</def> <sym>= [</sym><def>s</def><sym>!!(</sym><def>width</def><sym>-</sym><def>x</def><sym>-</sym><def></def><num>1</num> <def></def><sym>+ (</sym><def>height</def><sym>-</sym><def>y</def><sym>-</sym><def></def><num>1</num><def></def><sym>)*</sym><def>width</def><sym>) |</sym> <def>y</def> <sym>&lt;- [</sym><def></def><num>0</num><def>..height</def><sym>-</sym><def></def><num>1</num><def></def><sym>],</sym> <def>x</def> <sym>&lt;- [</sym><def></def><num>0</num> <def>.. width</def><sym>-</sym><def></def><num>1</num><def></def><sym>]]</sym><br />
<def><br />
printSolution</def> <sym>::</sym> <def>String</def> <sym>-&gt;</sym> <def>IO</def> <sym>()</sym><br />
<def>printSolution solution</def> <sym>=</sym> <def>printSolution'</def> <num>0</num> <def>solution</def> <kwa>where</kwa><br />
<def>   printSolution' cell</def> <sym>[] =</sym> <def>return</def> <sym>()</sym><br />
<def>   printSolution' cell</def> <sym>(</sym><def>s</def><sym>:</sym><def>ss</def><sym>) =</sym> <def></def><kwa>do</kwa><br />
<def>      putStr $ s</def><sym>:</sym><def></def><str>&quot; &quot;</str><def></def><br />
      <kwa>case</kwa> <def>mod</def> <sym>(</sym><def>cell</def><sym>+</sym><def></def><num>1</num><def></def><sym>)</sym> <def>width</def> <kwa>of</kwa><br />
<def></def>         <num>0</num> <def></def><sym>-&gt;</sym> <def></def><kwa>case</kwa> <def>mod</def> <sym>(</sym><def>cell</def><sym>+</sym><def></def><num>1</num><def></def><sym>) (</sym><def></def><num>2</num><def></def><sym>*</sym><def>width</def><sym>)</sym> <def></def><kwa>of</kwa><br />
<def></def>            <num>0</num> <def></def><sym>-&gt;</sym> <def>putStr</def> <str>&quot;\n&quot;</str><def><br />
            _</def> <sym>-&gt;</sym> <def>putStr</def> <str>&quot;\n &quot;</str><def><br />
         _</def> <sym>-&gt;</sym> <def>return</def> <sym>()</sym><br />
<def><br />
      printSolution'</def> <sym>(</sym><def>cell</def><sym>+</sym><def></def><num>1</num><def></def><sym>)</sym> <def>ss<br />
<br />
main</def> <sym>=</sym> <def></def><kwa>do</kwa><br />
<def></def>   <sym>(</sym><def>n</def> <sym>::</sym> <def></def><kwb>Int</kwb><def></def><sym>) &lt;-</sym> <def>return.read.head</def> <sym>=&lt;&lt;</sym> <def>getArgs</def><br />
   <kwa>let</kwa> <def>nsolutions</def> <sym>=</sym> <def>take n solutions<br />
   putStrLn $</def> <sym>(</sym><def>show $ length nsolutions</def><sym>) ++</sym> <def></def><str>&quot; solutions found\n&quot;</str><def><br />
   printSolution $ minimum nsolutions<br />
   putStr</def> <str>&quot;\n&quot;</str><def><br />
   printSolution $ maximum nsolutions<br />
   putStr</def> <str>&quot;\n&quot;</str><def></def><br />
</source>
