<source>
<def></def><com>/**</com><br />
<com> * The Computer Language Benchmarks Game</com><br />
<com> * http://shootout.alioth.debian.org/</com><br />
<com> * contributed by Klaus Friedel</com><br />
<com> * converted to Groovy by Danno Ferrin</com><br />
<com> */</com><def></def><br />
<br />
<kwa>import</kwa> <def>java</def><sym>.</sym><def>util</def><sym>.</sym><def>concurrent</def><sym>.</sym><def>locks</def><sym>.</sym><def></def><kwc>LockSupport</kwc><def></def><sym>;</sym><br />
<def></def><br />
<kwa>public static class</kwa> <def>MessageThread</def> <kwa>extends</kwa> <def></def><kwc>Thread</kwc> <def></def><sym>{</sym><br />
<def>  MessageThread nextThread</def><sym>;</sym><br />
<def></def>  <kwa>volatile</kwa> <def></def><kwc>Integer</kwc> <def>message</def><sym>;</sym><br />
<def></def><br />
  <kwa>public</kwa> <def></def><kwd>MessageThread</kwd><def></def><sym>(</sym><def>MessageThread nextThread</def><sym>,</sym> <def></def><kwb>int</kwb> <def>name</def><sym>) {</sym><br />
<def></def>    <kwa>super</kwa><def></def><sym>(</sym><def></def><str>&quot;&quot;</str><def></def><sym>+</sym><def>name</def><sym>);</sym><br />
<def></def>    <kwa>this</kwa><def></def><sym>.</sym><def>nextThread</def> <sym>=</sym> <def>nextThread</def><sym>;</sym><br />
<def></def>  <sym>}</sym><br />
<def></def><br />
  <kwa>public</kwa> <def></def><kwb>void</kwb> <def></def><kwd>run</kwd><def></def><sym>() {</sym><br />
<def></def>    <kwa>while</kwa><def></def><sym>(</sym><def>true</def><sym>)</sym> <def>nextThread</def><sym>.</sym><def></def><kwd>enqueue</kwd><def></def><sym>(</sym><def></def><kwd>dequeue</kwd><def></def><sym>());</sym><br />
<def></def>  <sym>}</sym><br />
<def></def><br />
  <kwa>public</kwa> <def></def><kwb>void</kwb> <def></def><kwd>enqueue</kwd><def></def><sym>(</sym><def></def><kwc>Integer</kwc> <def>hopsRemaining</def><sym>) {</sym><br />
<def></def>    <kwa>if</kwa><def></def><sym>(</sym><def>hopsRemaining</def> <sym>==</sym> <def></def><num>0</num><def></def><sym>){</sym><br />
<def></def>      <kwc>System</kwc><def></def><sym>.</sym><def>out</def><sym>.</sym><def></def><kwd>println</kwd><def></def><sym>(</sym><def></def><kwd>getName</kwd><def></def><sym>());</sym><br />
<def></def>      <kwc>System</kwc><def></def><sym>.</sym><def></def><kwd>exit</kwd><def></def><sym>(</sym><def></def><num>0</num><def></def><sym>);</sym><br />
<def></def>    <sym>}</sym><br />
<def></def>    <slc>// as only one message populates the ring, it's impossible</slc><br />
<def></def>    <slc>// that queue is not empty</slc><br />
<def>    message</def> <sym>=</sym> <def>hopsRemaining</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>    <kwc>LockSupport</kwc><def></def><sym>.</sym><def></def><kwd>unpark</kwd><def></def><sym>(</sym><def></def><kwa>this</kwa><def></def><sym>);</sym> <def></def><slc>// work waiting...</slc><br />
<def></def>  <sym>}</sym><br />
<def></def><br />
  <kwa>private</kwa> <def></def><kwc>Integer</kwc> <def></def><kwd>dequeue</kwd><def></def><sym>(){</sym><br />
<def></def>    <kwa>while</kwa><def></def><sym>(</sym><def>message</def> <sym>==</sym> <def>null</def><sym>){</sym><br />
<def></def>      <kwc>LockSupport</kwc><def></def><sym>.</sym><def></def><kwd>park</kwd><def></def><sym>();</sym><br />
<def></def>    <sym>}</sym><br />
<def></def>    <kwc>Integer</kwc> <def>msg</def> <sym>=</sym> <def>message</def><sym>;</sym><br />
<def>    message</def> <sym>=</sym> <def>null</def><sym>;</sym><br />
<def></def>    <kwa>return</kwa> <def>msg</def><sym>;</sym><br />
<def></def>  <sym>}</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>int</kwb> <def>THREAD_COUNT</def> <sym>=</sym> <def></def><num>503</num><def></def><sym>;</sym><br />
<def></def><kwb>int</kwb> <def>hopCount</def> <sym>=</sym> <def></def><kwc>Integer</kwc><def></def><sym>.</sym><def></def><kwd>parseInt</kwd><def></def><sym>(</sym><def>args</def><sym>[</sym><def></def><num>0</num><def></def><sym>]);</sym><br />
<def><br />
MessageThread first</def> <sym>=</sym> <def>null</def><sym>;</sym><br />
<def>MessageThread last</def> <sym>=</sym> <def>null</def><sym>;</sym><br />
<def></def><kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i</def> <sym>=</sym> <def>THREAD_COUNT</def><sym>;</sym> <def>i</def> <sym>&gt;=</sym> <def></def><num>1</num> <def></def><sym>;</sym> <def>i</def><sym>--) {</sym><br />
<def>  first</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>MessageThread</kwd><def></def><sym>(</sym><def>first</def><sym>,</sym> <def>i</def><sym>);</sym><br />
<def></def>  <kwa>if</kwa><def></def><sym>(</sym><def>i</def> <sym>==</sym> <def>THREAD_COUNT</def><sym>)</sym> <def>last</def> <sym>=</sym> <def>first</def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><slc>// close the ring:</slc><br />
<def>last</def><sym>.</sym><def>nextThread</def> <sym>=</sym> <def>first</def><sym>;</sym><br />
<def></def><br />
<slc>// start all Threads</slc><br />
<def>MessageThread t</def> <sym>=</sym> <def>first</def><sym>;</sym><br />
<def>t</def><sym>.</sym><def></def><kwd>start</kwd><def></def><sym>();</sym><br />
<def>t</def> <sym>=</sym> <def>t</def><sym>.</sym><def>nextThread</def><sym>;</sym><br />
<def></def><kwa>while</kwa><def></def><sym>(</sym><def>t</def> <sym>!=</sym> <def>first</def><sym>) {</sym><br />
<def>  t</def><sym>.</sym><def></def><kwd>start</kwd><def></def><sym>();</sym><br />
<def>  t</def> <sym>=</sym> <def>t</def><sym>.</sym><def>nextThread</def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><slc>// inject message</slc><br />
<def>first</def><sym>.</sym><def></def><kwd>enqueue</kwd><def></def><sym>(</sym><def>hopCount</def><sym>);</sym><br />
<def>first</def><sym>.</sym><def></def><kwd>join</kwd><def></def><sym>();</sym> <def></def><slc>// wait for System.exit</slc><def></def><br />
</source>
