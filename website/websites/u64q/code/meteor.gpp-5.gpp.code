<source>
<def></def><slc>// The Computer Language Benchmarks Game</slc><br />
<def></def><slc>// http://shootout.alioth.debian.org/</slc><br />
<def></def><slc>// contributed by Ben St. John</slc><br />
<def></def><slc>// some ideas taken from Kevin Barnes' implementation</slc><br />
<def></def><com>/* A few key optimizations:</com><br />
<com>   - pre-calcing of all possible orientations of each piece</com><br />
<com>   - pre-calcing of which orientations are possible in each board position</com><br />
<com>   - fast calculation of boards with bad islands (which are unsolveable)</com><br />
<com>   - pre-calc of some boards (by top three lines) which *always* have bad islands</com><br />
<com>   - using only 32-bit boards representations (plus row offset)</com><br />
<com>   - improvement since #4 -- no caching of top three lines for other reasons</com><br />
<com>   - not using STL vector -- it noticeably slow things down</com><br />
<com>   - rotating each found solution, so only half need to be calculated -- done by removing</com><br />
<com>     half the rotations of one piece (SKIP_PIECE) chosen as the one with the most valid positions</com><br />
<com>     on the board, so only half the solution space is searched</com><br />
<com></com><br />
<com> For size, most seems to come from the standard libs.</com><br />
<com> I'm tempted to get rid of string, and maybe use cstdio.</com><br />
<com>*/</com><def></def><br />
<br />
<dir>#include &lt;string&gt;</dir><br />
<def></def><dir>#include &lt;iostream&gt;</dir><br />
<def></def><br />
<kwa>using namespace</kwa> <def>std</def><sym>;</sym><br />
<def></def><br />
<dir>#define getMask(iPos) (1 &lt;&lt; (iPos))</dir><br />
<def></def><br />
<kwb>enum</kwb> <def></def><sym>{</sym><def>X</def><sym>,</sym> <def>Y</def><sym>,</sym> <def>N_DIM</def><sym>};</sym><br />
<def></def><kwb>enum</kwb> <def></def><sym>{</sym><def>EVEN</def><sym>,</sym> <def>ODD</def><sym>,</sym> <def>N_PARITY</def><sym>};</sym><br />
<def></def><kwb>enum</kwb> <def></def><sym>{</sym><def>GOOD</def><sym>,</sym> <def>BAD</def><sym>,</sym> <def>ALWAYS_BAD</def><sym>};</sym><br />
<def></def><br />
<kwc>typedef</kwc> <def></def><kwb>unsigned int</kwb> <def>TUInt32</def><sym>;</sym><br />
<def></def><kwc>typedef</kwc> <def></def><kwb>unsigned long long</kwb> <def>TUInt64</def><sym>;</sym><br />
<def></def><kwc>typedef</kwc> <def></def><kwb>signed char</kwb> <def>TInt8</def><sym>;</sym><br />
<def></def><kwc>typedef</kwc> <def>TUInt32 BitVec</def><sym>;</sym><br />
<def></def><br />
<kwb>static const int</kwb> <def>N_COL</def> <sym>=</sym> <def></def><num>5</num><def></def><sym>;</sym><br />
<def></def><kwb>static const int</kwb> <def>N_ROW</def> <sym>=</sym> <def></def><num>10</num><def></def><sym>;</sym><br />
<def></def><kwb>static const int</kwb> <def>N_CELL</def> <sym>=</sym> <def>N_COL</def> <sym>*</sym> <def>N_ROW</def><sym>;</sym><br />
<def></def><kwb>static const int</kwb> <def>N_PIECE_TYPE</def> <sym>=</sym> <def></def><num>10</num><def></def><sym>;</sym><br />
<def></def><br />
<kwb>struct</kwb> <def>Piece</def><sym>;</sym><br />
<def></def><br />
<kwb>struct</kwb> <def>Soln</def> <sym>{</sym><br />
<def></def>   <kwb>static const int</kwb> <def>NO_PIECE</def> <sym>= -</sym><def></def><num>1</num><def></def><sym>;</sym><br />
<def></def><br />
   <kwb>void</kwb> <def></def><kwd>setCells</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>);</sym><br />
<def></def>   <kwb>bool</kwb> <def></def><kwd>lessThan</kwd><def></def><sym>(</sym><def>Soln</def> <sym>&amp;</sym> <def>r</def><sym>);</sym><br />
<def>   string</def> <kwd>toString</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>)</sym> <def></def><kwb>const</kwb><def></def><sym>;</sym><br />
<def></def>   <kwb>void</kwb> <def></def><kwd>fill</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>val</def><sym>);</sym><br />
<def></def>   <kwb>void</kwb> <def></def><kwd>spin</kwd><def></def><sym>(</sym><def>Soln</def> <sym>&amp;</sym> <def>spun</def><sym>);</sym><br />
<def></def><br />
   <kwb>bool</kwb> <def></def><kwd>isEmpty</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>) {</sym><def></def><kwa>return</kwa> <def></def><sym>(</sym><def>m_nPiece</def> <sym>==</sym> <def></def><num>0</num><def></def><sym>);}</sym><br />
<def></def>   <kwb>void</kwb> <def></def><kwd>popPiece</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>) {</sym><def>m_nPiece</def><sym>--;</sym> <def>m_synched</def> <sym>=</sym> <def></def><kwa>false</kwa><def></def><sym>;}</sym><br />
<def></def>   <kwb>void</kwb> <def></def><kwd>pushPiece</kwd><def></def><sym>(</sym><def>BitVec vec</def><sym>,</sym> <def></def><kwb>int</kwb> <def>iPiece</def><sym>,</sym> <def></def><kwb>int</kwb> <def>row</def><sym>) {</sym><br />
<def>      SPiece</def> <sym>&amp;</sym> <def>p</def> <sym>=</sym> <def>m_pieces</def><sym>[</sym><def>m_nPiece</def><sym>++];</sym><br />
<def>      p</def><sym>.</sym><def>vec</def> <sym>=</sym> <def>vec</def><sym>;</sym><br />
<def>      p</def><sym>.</sym><def>iPiece</def> <sym>= (</sym><def></def><kwb>short</kwb><def></def><sym>)</sym><def>iPiece</def><sym>;</sym><br />
<def>      p</def><sym>.</sym><def>row</def> <sym>= (</sym><def></def><kwb>short</kwb><def></def><sym>)</sym><def>row</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwd>Soln</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>fillVal</def><sym>);</sym><br />
<def></def>   <kwd>Soln</kwd><def></def><sym>() :</sym> <def></def><kwd>m_synched</kwd><def></def><sym>(</sym><def></def><kwa>false</kwa><def></def><sym>),</sym> <def></def><kwd>m_nPiece</kwd><def></def><sym>(</sym><def></def><num>0</num><def></def><sym>) {}</sym><br />
<def></def><br />
   <kwb>struct</kwb> <def>SPiece</def> <sym>{</sym><br />
<def>      BitVec vec</def><sym>;</sym><br />
<def></def>      <kwb>short</kwb> <def>iPiece</def><sym>;</sym><br />
<def></def>      <kwb>short</kwb> <def>row</def><sym>;</sym><br />
<def></def>      <kwd>SPiece</kwd><def></def><sym>() {}</sym><br />
<def></def>      <kwd>SPiece</kwd><def></def><sym>(</sym><def>BitVec avec</def><sym>,</sym> <def>TUInt32 apiece</def><sym>,</sym> <def>TUInt32 arow</def><sym>) :</sym><br />
<def></def>         <kwd>vec</kwd><def></def><sym>(</sym><def>avec</def><sym>),</sym> <def></def><kwd>iPiece</kwd><def></def><sym>(</sym><def></def><kwb>short</kwb><def></def><sym>(</sym><def>apiece</def><sym>)),</sym> <def></def><kwd>row</kwd><def></def><sym>(</sym><def></def><kwb>short</kwb><def></def><sym>(</sym><def>arow</def><sym>))</sym><br />
<def></def>         <sym>{}</sym><br />
<def></def>   <sym>};</sym><br />
<def>   SPiece m_pieces</def><sym>[</sym><def>N_PIECE_TYPE</def><sym>];</sym><br />
<def>   TUInt32 m_nPiece</def><sym>;</sym><br />
<def>   TInt8 m_cells</def><sym>[</sym><def>N_ROW</def><sym>][</sym><def>N_COL</def><sym>];</sym><br />
<def></def>   <kwb>bool</kwb> <def>m_synched</def><sym>;</sym><br />
<def></def><sym>};</sym><br />
<def></def><br />
<slc>//------------------------------------</slc><br />
<def></def><kwb>struct</kwb> <def>Board</def> <sym>{</sym><br />
<def></def>   <kwb>static const</kwb> <def>BitVec L_EDGE_MASK</def> <sym>=</sym><br />
<def></def>      <sym>(</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym>  <def></def><num>0</num><def></def><sym>) | (</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym>  <def></def><num>5</num><def></def><sym>) | (</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def></def><num>10</num><def></def><sym>) | (</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def></def><num>15</num><def></def><sym>) |</sym><br />
<def></def>      <sym>(</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def></def><num>20</num><def></def><sym>) | (</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def></def><num>25</num><def></def><sym>) | (</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def></def><num>30</num><def></def><sym>);</sym><br />
<def></def>   <kwb>static const</kwb> <def>BitVec R_EDGE_MASK</def> <sym>=</sym> <def>L_EDGE_MASK</def> <sym>&lt;&lt;</sym> <def></def><num>4</num><def></def><sym>;</sym><br />
<def></def>   <kwb>static const</kwb> <def>BitVec TOP_ROW</def> <sym>= (</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def>N_COL</def><sym>) -</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>   <kwb>static const</kwb> <def>TUInt32 TWO_ROWS</def> <sym>=</sym> <def></def><num>2</num> <def></def><sym>*</sym> <def>N_COL</def><sym>;</sym><br />
<def></def>   <kwb>static const</kwb> <def>BitVec TOP_2_ROWS</def> <sym>= (</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def>TWO_ROWS</def><sym>) -</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def><br />
   <kwb>static const</kwb> <def>BitVec ROW_0_MASK</def> <sym>=</sym><br />
<def>      TOP_ROW</def> <sym>| (</sym><def>TOP_ROW</def> <sym>&lt;&lt;</sym> <def></def><num>10</num><def></def><sym>) | (</sym><def>TOP_ROW</def> <sym>&lt;&lt;</sym> <def></def><num>20</num><def></def><sym>) | (</sym><def>TOP_ROW</def> <sym>&lt;&lt;</sym> <def></def><num>30</num><def></def><sym>);</sym><br />
<def></def>   <kwb>static const</kwb> <def>BitVec ROW_1_MASK</def> <sym>=</sym> <def>ROW_0_MASK</def> <sym>&lt;&lt;</sym> <def></def><num>5</num><def></def><sym>;</sym><br />
<def></def>   <kwb>static const</kwb> <def>BitVec BOARD_MASK</def> <sym>= (</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def></def><num>30</num><def></def><sym>) -</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def><br />
   <kwd>Board</kwd><def></def><sym>();</sym><br />
<def></def><br />
   <kwb>static</kwb> <def>TUInt32</def> <kwd>getIndex</kwd><def></def><sym>(</sym><def>TUInt32 x</def><sym>,</sym> <def>TUInt32 y</def><sym>) {</sym> <def></def><kwa>return</kwa> <def>y</def> <sym>*</sym> <def>N_COL</def> <sym>+</sym> <def>x</def><sym>; }</sym><br />
<def></def>   <kwb>static bool</kwb> <def></def><kwd>badRegion</kwd><def></def><sym>(</sym><def>BitVec</def> <sym>&amp;</sym> <def>toFill</def><sym>,</sym> <def>BitVec rNew</def><sym>);</sym><br />
<def></def>   <kwb>static int</kwb> <def></def><kwd>hasBadIslands</kwd><def></def><sym>(</sym><def>BitVec boardVec</def><sym>,</sym> <def></def><kwb>int</kwb> <def>row</def><sym>);</sym><br />
<def></def>   <kwb>static int</kwb> <def></def><kwd>calcBadIslands</kwd><def></def><sym>(</sym><def>BitVec boardVec</def><sym>,</sym> <def></def><kwb>int</kwb> <def>row</def><sym>);</sym><br />
<def></def>   <kwb>static bool</kwb> <def></def><kwd>hasBadIslandsSingle</kwd><def></def><sym>(</sym><def>BitVec boardVec</def><sym>,</sym> <def></def><kwb>int</kwb> <def>row</def><sym>);</sym><br />
<def></def>   <kwb>static void</kwb> <def></def><kwd>calcAlwaysBad</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>);</sym><br />
<def></def><br />
   <kwb>void</kwb> <def></def><kwd>genAllSolutions</kwd><def></def><sym>(</sym><def>BitVec boardVec</def><sym>,</sym> <def>TUInt32 placedPieces</def><sym>,</sym> <def>TUInt32 iNextFill</def><sym>);</sym><br />
<def></def>   <kwb>void</kwb> <def></def><kwd>recordSolution</kwd><def></def><sym>(</sym><def>Soln</def> <sym>&amp;</sym> <def>s</def><sym>);</sym><br />
<def><br />
   Soln m_curSoln</def><sym>;</sym><br />
<def>   Soln m_minSoln</def><sym>;</sym><br />
<def>   Soln m_maxSoln</def><sym>;</sym><br />
<def>   TUInt32 m_nSoln</def><sym>;</sym><br />
<def></def><sym>};</sym><br />
<def></def><br />
<slc>//------------------------------------</slc><br />
<def></def><br />
<kwb>struct</kwb> <def>Piece</def> <sym>{</sym><br />
<def></def>   <kwb>struct</kwb> <def>Instance</def> <sym>{</sym><br />
<def>      TUInt64 m_allowed</def><sym>;</sym><br />
<def>      BitVec m_vec</def><sym>;</sym><br />
<def></def>      <kwb>int</kwb> <def>m_offset</def><sym>;</sym><br />
<def></def>   <sym>};</sym><br />
<def></def><br />
   <kwb>static const int</kwb> <def>N_ELEM</def> <sym>=</sym> <def></def><num>5</num><def></def><sym>;</sym><br />
<def></def>   <kwb>static const int</kwb> <def>N_ORIENT</def> <sym>=</sym> <def></def><num>12</num><def></def><sym>;</sym><br />
<def></def>   <kwb>static const int</kwb> <def>ALL_PIECE_MASK</def> <sym>= (</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def>N_PIECE_TYPE</def><sym>) -</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>   <kwb>static const</kwb> <def>TUInt32 SKIP_PIECE</def> <sym>=</sym> <def></def><num>5</num><def></def><sym>;</sym> <def></def><slc>// it's magic!</slc><br />
<def></def><br />
   <kwc>typedef</kwc> <def></def><kwb>int</kwb> <def>TPts</def><sym>[</sym><def>N_ELEM</def><sym>][</sym><def>N_DIM</def><sym>];</sym><br />
<def></def><br />
   <kwb>static const</kwb> <def>BitVec BaseVecs</def><sym>[</sym><def>N_PIECE_TYPE</def><sym>];</sym><br />
<def></def>   <kwb>static</kwb> <def>Piece s_basePiece</def><sym>[</sym><def>N_PIECE_TYPE</def><sym>][</sym><def>N_ORIENT</def><sym>];</sym><br />
<def></def><br />
   <kwb>static const</kwb> <def>Instance</def> <sym>&amp;</sym> <def></def><kwd>getPiece</kwd><def></def><sym>(</sym><def>TUInt32 iPiece</def><sym>,</sym> <def>TUInt32 iOrient</def><sym>,</sym> <def>TUInt32 iParity</def><sym>);</sym><br />
<def></def>   <kwb>static</kwb> <def>BitVec</def> <kwd>toBitVector</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>TPts</def> <sym>&amp;</sym> <def>pts</def><sym>);</sym><br />
<def></def>   <kwb>static void</kwb> <def></def><kwd>genOrientation</kwd><def></def><sym>(</sym><def>BitVec vec</def><sym>,</sym> <def>TUInt32 iOrient</def><sym>,</sym> <def>Piece</def> <sym>&amp;</sym> <def>target</def><sym>);</sym><br />
<def></def>   <kwb>static void</kwb> <def></def><kwd>setCoordList</kwd><def></def><sym>(</sym><def>BitVec vec</def><sym>,</sym> <def>TPts</def> <sym>&amp;</sym> <def>pts</def><sym>);</sym><br />
<def></def>   <kwb>static void</kwb> <def></def><kwd>shiftUpLines</kwd><def></def><sym>(</sym><def>TPts</def> <sym>&amp;</sym> <def>pts</def><sym>,</sym> <def></def><kwb>int</kwb> <def>shift</def><sym>);</sym><br />
<def></def>   <kwb>static int</kwb> <def></def><kwd>shiftToX0</kwd><def></def><sym>(</sym><def>TPts</def> <sym>&amp;</sym> <def>pts</def><sym>,</sym> <def>Instance</def> <sym>&amp;</sym> <def>instance</def><sym>,</sym> <def></def><kwb>int</kwb> <def>offsetRow</def><sym>);</sym><br />
<def></def>   <kwb>void</kwb> <def></def><kwd>setOkPos</kwd><def></def><sym>(</sym><def>TUInt32 isOdd</def><sym>,</sym> <def></def><kwb>int</kwb> <def>w</def><sym>,</sym> <def></def><kwb>int</kwb> <def>h</def><sym>);</sym><br />
<def></def>   <kwb>static void</kwb> <def></def><kwd>genAllOrientations</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>);</sym><br />
<def><br />
   Instance m_instance</def><sym>[</sym><def>N_PARITY</def><sym>];</sym><br />
<def></def><sym>};</sym><br />
<def></def><br />
<kwb>struct</kwb> <def>OkPieces</def> <sym>{</sym><br />
<def>   TInt8 nPieces</def><sym>[</sym><def>N_PIECE_TYPE</def><sym>];</sym><br />
<def>   TUInt32 pieceVec</def><sym>[</sym><def>N_PIECE_TYPE</def><sym>][</sym><def>Piece</def><sym>::</sym><def>N_ORIENT</def><sym>];</sym><br />
<def></def><sym>};</sym><br />
<def></def><br />
<kwb>static</kwb> <def>OkPieces g_okPieces</def><sym>[</sym><def>N_ROW</def><sym>][</sym><def>N_COL</def><sym>] = {{</sym><def></def><num>0</num><def></def><sym>}};</sym><br />
<def></def><br />
<dir>#define MAX_ISLAND_OFFSET 1024</dir><br />
<def></def><kwb>struct</kwb> <def>IslandInfo</def> <sym>{</sym><br />
<def>   TUInt32 alwaysBad</def><sym>[</sym><def>N_PARITY</def><sym>];</sym><br />
<def></def><sym>};</sym><br />
<def></def><br />
<kwb>static</kwb> <def>IslandInfo g_islandInfo</def><sym>[</sym><def>MAX_ISLAND_OFFSET</def><sym>] = {</sym><def></def><num>0</num><def></def><sym>};</sym><br />
<def></def><br />
<slc>//------------------------------------</slc><br />
<def>Soln</def><sym>::</sym><def></def><kwd>Soln</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>fillVal</def><sym>) :</sym><br />
<def></def>   <kwd>m_nPiece</kwd><def></def><sym>(</sym><def></def><num>0</num><def></def><sym>) {</sym><br />
<def></def>   <kwd>fill</kwd><def></def><sym>(</sym><def>fillVal</def><sym>);</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Soln</def><sym>::</sym><def></def><kwd>fill</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>val</def><sym>) {</sym><br />
<def>   m_synched</def> <sym>=</sym> <def></def><kwa>false</kwa><def></def><sym>;</sym><br />
<def></def>   <kwd>memset</kwd><def></def><sym>(</sym><def>m_cells</def><sym>,</sym> <def>val</def><sym>,</sym> <def>N_CELL</def><sym>);</sym><br />
<def></def><sym>}</sym><br />
<def><br />
string Soln</def><sym>::</sym><def></def><kwd>toString</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>)</sym> <def></def><kwb>const</kwb> <def></def><sym>{</sym><br />
<def>   string result</def><sym>;</sym><br />
<def>   result</def><sym>.</sym><def></def><kwd>reserve</kwd><def></def><sym>(</sym><def>N_CELL</def> <sym>*</sym> <def></def><num>2</num><def></def><sym>);</sym><br />
<def></def><br />
   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>y</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>y</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>y</def><sym>++) {</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>x</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>x</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>x</def><sym>++) {</sym><br />
<def></def>         <kwb>int</kwb> <def>val</def> <sym>=</sym> <def>m_cells</def><sym>[</sym><def>y</def><sym>][</sym><def>x</def><sym>];</sym><br />
<def>         result</def> <sym>+= ((</sym><def>val</def> <sym>==</sym> <def>NO_PIECE</def><sym>)</sym> <def>?</def> <str>'.'</str><def></def> <sym>:</sym> <def></def><kwb>char</kwb><def></def><sym>(</sym><def></def><str>'0'</str><def></def> <sym>+</sym> <def>val</def><sym>));</sym><br />
<def>         result</def> <sym>+=</sym> <def></def><str>' '</str><def></def><sym>;</sym><br />
<def></def>      <sym>}</sym><br />
<def>      result</def> <sym>+=</sym> <def></def><str>'</str><esc>\n</esc><str>'</str><def></def><sym>;</sym><br />
<def></def><br />
      <slc>// indent every second line</slc><br />
<def></def>      <kwa>if</kwa> <def></def><sym>(</sym><def>y</def> <sym>%</sym> <def></def><num>2</num> <def></def><sym>==</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def>         result</def> <sym>+=</sym> <def></def><str>&quot; &quot;</str><def></def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def>   <kwa>return</kwa> <def>result</def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Soln</def><sym>::</sym><def></def><kwd>setCells</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>) {</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>m_synched</def><sym>)</sym><br />
<def></def>      <kwa>return</kwa><def></def><sym>;</sym><br />
<def></def><br />
   <kwa>for</kwa> <def></def><sym>(</sym><def>TUInt32 iPiece</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iPiece</def> <sym>&lt;</sym> <def>m_nPiece</def><sym>;</sym> <def>iPiece</def><sym>++) {</sym><br />
<def></def>      <kwb>const</kwb> <def>SPiece</def> <sym>&amp;</sym> <def>p</def> <sym>=</sym> <def>m_pieces</def><sym>[</sym><def>iPiece</def><sym>];</sym><br />
<def>      BitVec vec</def> <sym>=</sym> <def>p</def><sym>.</sym><def>vec</def><sym>;</sym><br />
<def>      TInt8 pID</def> <sym>= (</sym><def>TInt8</def><sym>)</sym><def>p</def><sym>.</sym><def>iPiece</def><sym>;</sym><br />
<def></def>      <kwb>int</kwb> <def>rowOffset</def> <sym>=</sym> <def>p</def><sym>.</sym><def>row</def><sym>;</sym><br />
<def></def><br />
      <kwb>int</kwb> <def>nNewCells</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>y</def> <sym>=</sym> <def>rowOffset</def><sym>;</sym> <def>y</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>y</def><sym>++) {</sym><br />
<def></def>         <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>x</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>x</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>x</def><sym>++) {</sym><br />
<def></def>            <kwa>if</kwa> <def></def><sym>(</sym><def>vec</def> <sym>&amp;</sym> <def></def><num>1</num><def></def><sym>) {</sym><br />
<def>               m_cells</def><sym>[</sym><def>y</def><sym>][</sym><def>x</def><sym>] =</sym> <def>pID</def><sym>;</sym><br />
<def>               nNewCells</def><sym>++;</sym><br />
<def></def>            <sym>}</sym><br />
<def>            vec</def> <sym>&gt;&gt;=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>         <sym>}</sym><br />
<def></def>         <kwa>if</kwa> <def></def><sym>(</sym><def>nNewCells</def> <sym>==</sym> <def>Piece</def><sym>::</sym><def>N_ELEM</def><sym>)</sym><br />
<def></def>            <kwa>break</kwa><def></def><sym>;</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def>   m_synched</def> <sym>=</sym> <def></def><kwa>true</kwa><def></def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>bool</kwb> <def>Soln</def><sym>::</sym><def></def><kwd>lessThan</kwd><def></def><sym>(</sym><def>Soln</def> <sym>&amp;</sym> <def>r</def><sym>) {</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>m_pieces</def><sym>[</sym><def></def><num>0</num><def></def><sym>].</sym><def>iPiece</def> <sym>!=</sym> <def>r</def><sym>.</sym><def>m_pieces</def><sym>[</sym><def></def><num>0</num><def></def><sym>].</sym><def>iPiece</def><sym>) {</sym><br />
<def></def>      <kwa>return</kwa> <def>m_pieces</def><sym>[</sym><def></def><num>0</num><def></def><sym>].</sym><def>iPiece</def> <sym>&lt;</sym> <def>r</def><sym>.</sym><def>m_pieces</def><sym>[</sym><def></def><num>0</num><def></def><sym>].</sym><def>iPiece</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwd>setCells</kwd><def></def><sym>();</sym><br />
<def>   r</def><sym>.</sym><def></def><kwd>setCells</kwd><def></def><sym>();</sym><br />
<def></def><br />
   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>y</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>y</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>y</def><sym>++) {</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>x</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>x</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>x</def><sym>++) {</sym><br />
<def></def>         <kwb>int</kwb> <def>lval</def> <sym>=</sym> <def>m_cells</def><sym>[</sym><def>y</def><sym>][</sym><def>x</def><sym>];</sym><br />
<def></def>         <kwb>int</kwb> <def>rval</def> <sym>=</sym> <def>r</def><sym>.</sym><def>m_cells</def><sym>[</sym><def>y</def><sym>][</sym><def>x</def><sym>];</sym><br />
<def></def><br />
         <kwa>if</kwa> <def></def><sym>(</sym><def>lval</def> <sym>!=</sym> <def>rval</def><sym>)</sym><br />
<def></def>            <kwa>return</kwa> <def></def><sym>(</sym><def>lval</def> <sym>&lt;</sym> <def>rval</def><sym>);</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>return false</kwa><def></def><sym>;</sym> <def></def><slc>// solutions are equal</slc><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Soln</def><sym>::</sym><def></def><kwd>spin</kwd><def></def><sym>(</sym><def>Soln</def> <sym>&amp;</sym> <def>spun</def><sym>) {</sym><br />
<def></def>   <kwd>setCells</kwd><def></def><sym>();</sym><br />
<def></def><br />
   <slc>// swap cells</slc><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>y</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>y</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>y</def><sym>++) {</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>x</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>x</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>x</def><sym>++) {</sym><br />
<def>         TInt8 flipped</def> <sym>=</sym> <def>m_cells</def><sym>[</sym><def>N_ROW</def> <sym>-</sym> <def>y</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>][</sym><def>N_COL</def> <sym>-</sym> <def>x</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>];</sym><br />
<def>         spun</def><sym>.</sym><def>m_cells</def><sym>[</sym><def>y</def><sym>][</sym><def>x</def><sym>] =</sym> <def>flipped</def><sym>;</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <slc>// swap first and last pieces (the rest aren't used)</slc><br />
<def>   spun</def><sym>.</sym><def>m_pieces</def><sym>[</sym><def></def><num>0</num><def></def><sym>].</sym><def>iPiece</def> <sym>=</sym> <def>m_pieces</def><sym>[</sym><def>N_PIECE_TYPE</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>].</sym><def>iPiece</def><sym>;</sym><br />
<def>   spun</def><sym>.</sym><def>m_synched</def> <sym>=</sym> <def></def><kwa>true</kwa><def></def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<slc>//------------------------------------</slc><br />
<def><br />
Piece Piece</def><sym>::</sym><def>s_basePiece</def><sym>[</sym><def>N_PIECE_TYPE</def><sym>][</sym><def>N_ORIENT</def><sym>];</sym><br />
<def></def><br />
<kwb>const</kwb> <def>BitVec Piece</def><sym>::</sym><def>BaseVecs</def><sym>[] = {</sym><br />
<def></def>   <num>0x10f</num><def></def><sym>,</sym> <def></def><num>0x0cb</num><def></def><sym>,</sym> <def></def><num>0x1087</num><def></def><sym>,</sym> <def></def><num>0x427</num><def></def><sym>,</sym> <def></def><num>0x465</num><def></def><sym>,</sym><br />
<def></def>   <num>0x0c7</num><def></def><sym>,</sym> <def></def><num>0x8423</num><def></def><sym>,</sym> <def></def><num>0x0a7</num><def></def><sym>,</sym> <def></def><num>0x187</num><def></def><sym>,</sym> <def></def><num>0x08f</num><br />
<def></def><sym>};</sym><br />
<def></def><br />
<kwb>int</kwb> <def></def><kwd>floor</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>top</def><sym>,</sym> <def></def><kwb>int</kwb> <def>bot</def><sym>) {</sym><br />
<def></def>   <kwb>int</kwb> <def>toZero</def> <sym>=</sym> <def>top</def> <sym>/</sym> <def>bot</def><sym>;</sym><br />
<def></def>   <slc>// negative numbers should be rounded down, not towards zero</slc><br />
<def></def>   <kwa>if</kwa> <def></def><sym>((</sym><def>toZero</def> <sym>*</sym> <def>bot</def> <sym>!=</sym> <def>top</def><sym>) &amp;&amp; ((</sym><def>top</def> <sym>&lt;</sym> <def></def><num>0</num><def></def><sym>) != (</sym><def>bot</def> <sym>&lt;=</sym> <def></def><num>0</num><def></def><sym>)))</sym><br />
<def>      toZero</def><sym>--;</sym><br />
<def></def><br />
   <kwa>return</kwa> <def>toZero</def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>const</kwb> <def>TUInt32 s_firstOne</def><sym>[</sym><def></def><num>32</num><def></def><sym>] = {</sym><br />
<def></def>   <num>0</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym>   <def></def><num>2</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym><br />
<def></def>   <num>3</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym>   <def></def><num>2</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym><br />
<def></def><br />
   <num>4</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym>   <def></def><num>2</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym><br />
<def></def>   <num>3</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym>   <def></def><num>2</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym><br />
<def></def><sym>};</sym><br />
<def><br />
TUInt32</def> <kwd>getFirstOne</kwd><def></def><sym>(</sym><def>BitVec v</def><sym>,</sym> <def>TUInt32 startPos</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>) {</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>v</def> <sym>==</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def></def>      <kwa>return</kwa> <def></def><num>0</num><def></def><sym>;</sym><br />
<def><br />
   TUInt32 iPos</def> <sym>=</sym> <def>startPos</def><sym>;</sym><br />
<def>   BitVec mask</def> <sym>=</sym> <def></def><num>0xff</num> <def></def><sym>&lt;&lt;</sym> <def>startPos</def><sym>;</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>((</sym><def>mask</def> <sym>&amp;</sym> <def>v</def><sym>) ==</sym> <def></def><num>0</num><def></def><sym>) {</sym><br />
<def>      mask</def> <sym>&lt;&lt;=</sym> <def></def><num>8</num><def></def><sym>;</sym> <def>iPos</def> <sym>+=</sym> <def></def><num>8</num><def></def><sym>;</sym><br />
<def></def>      <kwa>if</kwa> <def></def><sym>((</sym><def>mask</def> <sym>&amp;</sym> <def>v</def><sym>) ==</sym> <def></def><num>0</num><def></def><sym>) {</sym><br />
<def>         mask</def> <sym>&lt;&lt;=</sym> <def></def><num>8</num><def></def><sym>;</sym> <def>iPos</def> <sym>+=</sym> <def></def><num>8</num><def></def><sym>;</sym><br />
<def></def>         <kwa>if</kwa> <def></def><sym>((</sym><def>mask</def> <sym>&amp;</sym> <def>v</def><sym>) ==</sym> <def></def><num>0</num><def></def><sym>) {</sym><br />
<def>            mask</def> <sym>&lt;&lt;=</sym> <def></def><num>8</num><def></def><sym>;</sym> <def>iPos</def> <sym>+=</sym> <def></def><num>8</num><def></def><sym>;</sym><br />
<def></def>         <sym>}</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def><br />
   TUInt32 result</def> <sym>=</sym> <def></def><kwd>TUInt32</kwd><def></def><sym>((</sym><def>mask</def> <sym>&amp;</sym> <def>v</def><sym>) &gt;&gt;</sym> <def>iPos</def><sym>);</sym><br />
<def>   TUInt32 resultLow</def> <sym>=</sym> <def>result</def> <sym>&amp;</sym> <def></def><num>0x0f</num><def></def><sym>;</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>resultLow</def> <sym>!=</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def>      iPos</def> <sym>+=</sym> <def>s_firstOne</def><sym>[</sym><def>resultLow</def><sym>];</sym><br />
<def></def>   <kwa>else</kwa><br />
<def>      iPos</def> <sym>+=</sym> <def></def><num>4</num> <def></def><sym>+</sym> <def>s_firstOne</def><sym>[</sym><def>result</def> <sym>&gt;&gt;</sym> <def></def><num>4</num><def></def><sym>];</sym><br />
<def></def><br />
   <kwa>return</kwa> <def>iPos</def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Piece</def><sym>::</sym><def></def><kwd>setCoordList</kwd><def></def><sym>(</sym><def>BitVec vec</def><sym>,</sym> <def>TPts</def> <sym>&amp;</sym> <def>pts</def><sym>) {</sym><br />
<def></def>   <kwb>int</kwb> <def>iPt</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def>   BitVec mask</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>y</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>y</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>y</def><sym>++) {</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>x</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>x</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>x</def><sym>++) {</sym><br />
<def></def>         <kwa>if</kwa> <def></def><sym>(</sym><def>mask</def> <sym>&amp;</sym> <def>vec</def><sym>) {</sym><br />
<def>            pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>X</def><sym>] =</sym> <def>x</def><sym>;</sym><br />
<def>            pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>Y</def><sym>] =</sym> <def>y</def><sym>;</sym><br />
<def><br />
            iPt</def><sym>++;</sym><br />
<def></def>         <sym>}</sym><br />
<def>         mask</def> <sym>&lt;&lt;=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><sym>}</sym><br />
<def><br />
BitVec Piece</def><sym>::</sym><def></def><kwd>toBitVector</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>TPts</def> <sym>&amp;</sym> <def>pts</def><sym>) {</sym><br />
<def></def>   <kwb>int</kwb> <def>y</def><sym>,</sym> <def>x</def><sym>;</sym><br />
<def>   BitVec result</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iPt</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iPt</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iPt</def><sym>++) {</sym><br />
<def>      x</def> <sym>=</sym> <def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>X</def><sym>];</sym><br />
<def>      y</def> <sym>=</sym> <def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def><br />
      <kwb>int</kwb> <def>pos</def> <sym>=</sym> <def>Board</def><sym>::</sym><def></def><kwd>getIndex</kwd><def></def><sym>(</sym><def>x</def><sym>,</sym> <def>y</def><sym>);</sym><br />
<def>      result</def> <sym>|= (</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def>pos</def><sym>);</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>return</kwa> <def>result</def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Piece</def><sym>::</sym><def></def><kwd>shiftUpLines</kwd><def></def><sym>(</sym><def>TPts</def> <sym>&amp;</sym> <def>pts</def><sym>,</sym> <def></def><kwb>int</kwb> <def>shift</def><sym>) {</sym><br />
<def></def>   <slc>// vertical shifts have a twist</slc><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iPt</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iPt</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iPt</def><sym>++) {</sym><br />
<def></def>      <kwb>int</kwb> <def></def><sym>&amp;</sym> <def>rx</def> <sym>=</sym> <def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>X</def><sym>];</sym><br />
<def></def>      <kwb>int</kwb> <def></def><sym>&amp;</sym> <def>ry</def> <sym>=</sym> <def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def><br />
      <kwa>if</kwa> <def></def><sym>(</sym><def>ry</def> <sym>&amp;</sym> <def>shift</def> <sym>&amp;</sym> <def></def><num>0x1</num><def></def><sym>)</sym><br />
<def>         rx</def><sym>++;</sym><br />
<def>      ry</def> <sym>-=</sym> <def>shift</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>int</kwb> <def>Piece</def><sym>::</sym><def></def><kwd>shiftToX0</kwd><def></def><sym>(</sym><def>TPts</def> <sym>&amp;</sym> <def>pts</def><sym>,</sym> <def>Instance</def> <sym>&amp;</sym> <def>instance</def><sym>,</sym> <def></def><kwb>int</kwb> <def>offsetRow</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <slc>// .. determine shift</slc><br />
<def></def>   <kwb>int</kwb> <def>x</def><sym>,</sym> <def>y</def><sym>,</sym> <def>iPt</def><sym>;</sym><br />
<def></def>   <kwb>int</kwb> <def>xMin</def> <sym>=</sym> <def>pts</def><sym>[</sym><def></def><num>0</num><def></def><sym>][</sym><def>X</def><sym>];</sym><br />
<def></def>   <kwb>int</kwb> <def>xMax</def> <sym>=</sym> <def>xMin</def><sym>;</sym><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def>iPt</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym> <def>iPt</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iPt</def><sym>++) {</sym><br />
<def>      x</def> <sym>=</sym> <def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>X</def><sym>];</sym><br />
<def>      y</def> <sym>=</sym> <def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def><br />
      <kwa>if</kwa> <def></def><sym>(</sym><def>x</def> <sym>&lt;</sym> <def>xMin</def><sym>)</sym><br />
<def>         xMin</def> <sym>=</sym> <def>x</def><sym>;</sym><br />
<def></def>      <kwa>else if</kwa> <def></def><sym>(</sym><def>x</def> <sym>&gt;</sym> <def>xMax</def><sym>)</sym><br />
<def>         xMax</def> <sym>=</sym> <def>x</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <slc>// I'm dying for a 'foreach' here</slc><br />
<def></def>   <kwb>int</kwb> <def>offset</def> <sym>=</sym> <def>N_ELEM</def><sym>;</sym><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def>iPt</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iPt</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iPt</def><sym>++) {</sym><br />
<def></def>      <kwb>int</kwb> <def></def><sym>&amp;</sym> <def>rx</def> <sym>=</sym> <def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>X</def><sym>];</sym><br />
<def></def>      <kwb>int</kwb> <def></def><sym>&amp;</sym> <def>ry</def> <sym>=</sym> <def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def><br />
      rx</def> <sym>-=</sym> <def>xMin</def><sym>;</sym><br />
<def></def><br />
      <slc>// check offset -- leftmost cell on top line</slc><br />
<def></def>      <kwa>if</kwa> <def></def><sym>((</sym><def>ry</def> <sym>==</sym> <def>offsetRow</def><sym>) &amp;&amp; (</sym><def>rx</def> <sym>&lt;</sym> <def>offset</def><sym>))</sym><br />
<def>         offset</def> <sym>=</sym> <def>rx</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def><br />
   instance</def><sym>.</sym><def>m_offset</def> <sym>=</sym> <def>offset</def><sym>;</sym><br />
<def>   instance</def><sym>.</sym><def>m_vec</def> <sym>=</sym> <def></def><kwd>toBitVector</kwd><def></def><sym>(</sym><def>pts</def><sym>);</sym><br />
<def></def>   <kwa>return</kwa> <def>xMax</def> <sym>-</sym> <def>xMin</def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Piece</def><sym>::</sym><def></def><kwd>setOkPos</kwd><def></def><sym>(</sym><def>TUInt32 isOdd</def><sym>,</sym> <def></def><kwb>int</kwb> <def>w</def><sym>,</sym> <def></def><kwb>int</kwb> <def>h</def><sym>) {</sym><br />
<def>   Instance</def> <sym>&amp;</sym> <def>p</def> <sym>=</sym> <def>m_instance</def><sym>[</sym><def>isOdd</def><sym>];</sym><br />
<def>   TUInt64</def> <sym>&amp;</sym> <def>allowed</def> <sym>=</sym> <def>p</def><sym>.</sym><def>m_allowed</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def>   TUInt64 posMask</def> <sym>=</sym> <def></def><num>1L</num><def>L</def> <sym>&lt;&lt; (</sym><def>isOdd</def> <sym>*</sym> <def>N_COL</def><sym>);</sym><br />
<def></def><br />
   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>y</def> <sym>=</sym> <def>isOdd</def><sym>;</sym> <def>y</def> <sym>&lt;</sym> <def>N_ROW</def> <sym>-</sym> <def>h</def><sym>;</sym> <def>y</def><sym>+=</sym><def></def><num>2</num><def></def><sym>,</sym> <def>posMask</def> <sym>&lt;&lt;=</sym> <def>N_COL</def><sym>) {</sym><br />
<def></def>      <kwa>if</kwa> <def></def><sym>(</sym><def>p</def><sym>.</sym><def>m_offset</def><sym>)</sym><br />
<def>         posMask</def> <sym>&lt;&lt;=</sym> <def>p</def><sym>.</sym><def>m_offset</def><sym>;</sym><br />
<def></def><br />
      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>xPos</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>xPos</def> <sym>&lt;</sym> <def>N_COL</def> <sym>-</sym> <def>p</def><sym>.</sym><def>m_offset</def><sym>;</sym> <def>xPos</def><sym>++,</sym> <def>posMask</def> <sym>&lt;&lt;=</sym> <def></def><num>1</num><def></def><sym>) {</sym><br />
<def></def>         <slc>// check if the new position is on the board</slc><br />
<def></def>         <kwa>if</kwa> <def></def><sym>(</sym><def>xPos</def> <sym>&gt;=</sym> <def>N_COL</def> <sym>-</sym> <def>w</def><sym>)</sym><br />
<def></def>            <kwa>continue</kwa><def></def><sym>;</sym><br />
<def></def><br />
         <slc>// move it to the desired location</slc><br />
<def>         BitVec pieceVec</def> <sym>=</sym> <def>p</def><sym>.</sym><def>m_vec</def> <sym>&lt;&lt;</sym> <def>xPos</def><sym>;</sym><br />
<def></def><br />
         <kwa>if</kwa> <def></def><sym>(</sym><def>Board</def><sym>::</sym><def></def><kwd>hasBadIslandsSingle</kwd><def></def><sym>(</sym><def>pieceVec</def><sym>,</sym> <def>y</def><sym>))</sym><br />
<def></def>            <kwa>continue</kwa><def></def><sym>;</sym><br />
<def></def><br />
         <slc>// position is allowed</slc><br />
<def>         allowed</def> <sym>|=</sym> <def>posMask</def><sym>;</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Piece</def><sym>::</sym><def></def><kwd>genOrientation</kwd><def></def><sym>(</sym><def>BitVec vec</def><sym>,</sym> <def>TUInt32 iOrient</def><sym>,</sym> <def>Piece</def> <sym>&amp;</sym> <def>target</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <slc>// get (x,y) coordinates</slc><br />
<def>   TPts pts</def><sym>;</sym><br />
<def></def>   <kwd>setCoordList</kwd><def></def><sym>(</sym><def>vec</def><sym>,</sym> <def>pts</def><sym>);</sym><br />
<def></def><br />
   <kwb>int</kwb> <def>y</def><sym>,</sym> <def>x</def><sym>,</sym> <def>iPt</def><sym>;</sym><br />
<def></def>   <kwb>int</kwb> <def>rot</def> <sym>=</sym> <def>iOrient</def> <sym>%</sym> <def></def><num>6</num><def></def><sym>;</sym><br />
<def></def>   <kwb>int</kwb> <def>flip</def> <sym>=</sym> <def>iOrient</def> <sym>&gt;=</sym> <def></def><num>6</num><def></def><sym>;</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>flip</def><sym>) {</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def>iPt</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iPt</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iPt</def><sym>++)</sym><br />
<def>         pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>Y</def><sym>] = -</sym><def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <slc>// rotate as necessary</slc><br />
<def></def>   <kwa>while</kwa> <def></def><sym>(</sym><def>rot</def><sym>--) {</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def>iPt</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iPt</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iPt</def><sym>++) {</sym><br />
<def>         x</def> <sym>=</sym> <def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>X</def><sym>];</sym><br />
<def>         y</def> <sym>=</sym> <def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def><br />
         <slc>// I just worked this out by hand. Took a while.</slc><br />
<def></def>         <kwb>int</kwb> <def>xNew</def> <sym>=</sym> <def></def><kwd>floor</kwd><def></def><sym>((</sym><def></def><num>2</num> <def></def><sym>*</sym> <def>x</def> <sym>-</sym> <def></def><num>3</num> <def></def><sym>*</sym> <def>y</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>),</sym> <def></def><num>4</num><def></def><sym>);</sym><br />
<def></def>         <kwb>int</kwb> <def>yNew</def> <sym>=</sym> <def></def><kwd>floor</kwd><def></def><sym>((</sym><def></def><num>2</num> <def></def><sym>*</sym> <def>x</def> <sym>+</sym> <def>y</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>),</sym> <def></def><num>2</num><def></def><sym>);</sym><br />
<def>         pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>X</def><sym>] =</sym> <def>xNew</def><sym>;</sym><br />
<def>         pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>Y</def><sym>] =</sym> <def>yNew</def><sym>;</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <slc>// determine vertical shift</slc><br />
<def></def>   <kwb>int</kwb> <def>yMin</def> <sym>=</sym> <def>pts</def><sym>[</sym><def></def><num>0</num><def></def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def>   <kwb>int</kwb> <def>yMax</def> <sym>=</sym> <def>yMin</def><sym>;</sym><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def>iPt</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym> <def>iPt</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iPt</def><sym>++) {</sym><br />
<def>      y</def> <sym>=</sym> <def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def><br />
      <kwa>if</kwa> <def></def><sym>(</sym><def>y</def> <sym>&lt;</sym> <def>yMin</def><sym>)</sym><br />
<def>         yMin</def> <sym>=</sym> <def>y</def><sym>;</sym><br />
<def></def>      <kwa>else if</kwa> <def></def><sym>(</sym><def>y</def> <sym>&gt;</sym> <def>yMax</def><sym>)</sym><br />
<def>         yMax</def> <sym>=</sym> <def>y</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def>   <kwb>int</kwb> <def>h</def> <sym>=</sym> <def>yMax</def> <sym>-</sym> <def>yMin</def><sym>;</sym><br />
<def>   Instance</def> <sym>&amp;</sym> <def>even</def> <sym>=</sym> <def>target</def><sym>.</sym><def>m_instance</def><sym>[</sym><def>EVEN</def><sym>];</sym><br />
<def>   Instance</def> <sym>&amp;</sym> <def>odd</def> <sym>=</sym> <def>target</def><sym>.</sym><def>m_instance</def><sym>[</sym><def>ODD</def><sym>];</sym><br />
<def></def><br />
   <kwd>shiftUpLines</kwd><def></def><sym>(</sym><def>pts</def><sym>,</sym> <def>yMin</def><sym>);</sym><br />
<def></def>   <kwb>int</kwb> <def>w</def> <sym>=</sym> <def></def><kwd>shiftToX0</kwd><def></def><sym>(</sym><def>pts</def><sym>,</sym> <def>even</def><sym>,</sym> <def></def><num>0</num><def></def><sym>);</sym><br />
<def>   target</def><sym>.</sym><def></def><kwd>setOkPos</kwd><def></def><sym>(</sym><def>EVEN</def><sym>,</sym> <def>w</def><sym>,</sym> <def>h</def><sym>);</sym><br />
<def>   even</def><sym>.</sym><def>m_vec</def> <sym>&gt;&gt;=</sym> <def>even</def><sym>.</sym><def>m_offset</def><sym>;</sym><br />
<def></def><br />
   <slc>// shift down one line</slc><br />
<def></def>   <kwd>shiftUpLines</kwd><def></def><sym>(</sym><def>pts</def><sym>, -</sym><def></def><num>1</num><def></def><sym>);</sym><br />
<def>   w</def> <sym>=</sym> <def></def><kwd>shiftToX0</kwd><def></def><sym>(</sym><def>pts</def><sym>,</sym> <def>odd</def><sym>,</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def></def>   <slc>// shift the bitmask back one line</slc><br />
<def>   odd</def><sym>.</sym><def>m_vec</def> <sym>&gt;&gt;=</sym> <def>N_COL</def><sym>;</sym><br />
<def>   target</def><sym>.</sym><def></def><kwd>setOkPos</kwd><def></def><sym>(</sym><def>ODD</def><sym>,</sym> <def>w</def><sym>,</sym> <def>h</def><sym>);</sym><br />
<def>   odd</def><sym>.</sym><def>m_vec</def> <sym>&gt;&gt;=</sym> <def>odd</def><sym>.</sym><def>m_offset</def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Piece</def><sym>::</sym><def></def><kwd>genAllOrientations</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>) {</sym><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iPiece</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iPiece</def> <sym>&lt;</sym> <def>N_PIECE_TYPE</def><sym>;</sym> <def>iPiece</def><sym>++) {</sym><br />
<def>      BitVec refPiece</def> <sym>=</sym> <def>BaseVecs</def><sym>[</sym><def>iPiece</def><sym>];</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iOrient</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iOrient</def> <sym>&lt;</sym> <def>N_ORIENT</def><sym>;</sym> <def>iOrient</def><sym>++) {</sym><br />
<def>         Piece</def> <sym>&amp;</sym> <def>p</def> <sym>=</sym> <def>s_basePiece</def><sym>[</sym><def>iPiece</def><sym>][</sym><def>iOrient</def><sym>];</sym><br />
<def></def>         <kwd>genOrientation</kwd><def></def><sym>(</sym><def>refPiece</def><sym>,</sym> <def>iOrient</def><sym>,</sym> <def>p</def><sym>);</sym><br />
<def></def>         <kwa>if</kwa> <def></def><sym>((</sym><def>iPiece</def> <sym>==</sym> <def>SKIP_PIECE</def><sym>) &amp;&amp; ((</sym><def>iOrient</def> <sym>/</sym> <def></def><num>3</num><def></def><sym>) &amp;</sym> <def></def><num>1</num><def></def><sym>))</sym><br />
<def>            p</def><sym>.</sym><def>m_instance</def><sym>[</sym><def></def><num>0</num><def></def><sym>].</sym><def>m_allowed</def> <sym>=</sym> <def>p</def><sym>.</sym><def>m_instance</def><sym>[</sym><def></def><num>1</num><def></def><sym>].</sym><def>m_allowed</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iPiece</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iPiece</def> <sym>&lt;</sym> <def>N_PIECE_TYPE</def><sym>;</sym> <def>iPiece</def><sym>++) {</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iOrient</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iOrient</def> <sym>&lt;</sym> <def>N_ORIENT</def><sym>;</sym> <def>iOrient</def><sym>++) {</sym><br />
<def>         TUInt64 mask</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>         <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iRow</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iRow</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>iRow</def><sym>++) {</sym><br />
<def></def>            <kwb>const</kwb> <def>Instance</def> <sym>&amp;</sym> <def>p</def> <sym>=</sym> <def></def><kwd>getPiece</kwd><def></def><sym>(</sym><def>iPiece</def><sym>,</sym> <def>iOrient</def><sym>, (</sym><def>iRow</def> <sym>&amp;</sym> <def></def><num>1</num><def></def><sym>));</sym><br />
<def></def>            <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iCol</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iCol</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>iCol</def><sym>++) {</sym><br />
<def>               OkPieces</def> <sym>&amp;</sym> <def>allowed</def> <sym>=</sym> <def>g_okPieces</def><sym>[</sym><def>iRow</def><sym>][</sym><def>iCol</def><sym>];</sym><br />
<def></def>               <kwa>if</kwa> <def></def><sym>(</sym><def>p</def><sym>.</sym><def>m_allowed</def> <sym>&amp;</sym> <def>mask</def><sym>) {</sym><br />
<def>                  TInt8</def> <sym>&amp;</sym> <def>nPiece</def> <sym>=</sym> <def>allowed</def><sym>.</sym><def>nPieces</def><sym>[</sym><def>iPiece</def><sym>];</sym><br />
<def>                  allowed</def><sym>.</sym><def>pieceVec</def><sym>[</sym><def>iPiece</def><sym>][</sym><def>nPiece</def><sym>] =</sym> <def>p</def><sym>.</sym><def>m_vec</def> <sym>&lt;&lt;</sym> <def>iCol</def><sym>;</sym><br />
<def>                  nPiece</def><sym>++;</sym><br />
<def></def>               <sym>}</sym><br />
<def><br />
               mask</def> <sym>&lt;&lt;=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>            <sym>}</sym><br />
<def></def>         <sym>}</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<br />
<kwc>inline</kwc> <def></def><kwb>const</kwb> <def>Piece</def><sym>::</sym><def>Instance</def> <sym>&amp;</sym> <def>Piece</def><sym>::</sym><def></def><kwd>getPiece</kwd><def></def><sym>(</sym><def>TUInt32 iPiece</def><sym>,</sym> <def>TUInt32 iOrient</def><sym>,</sym> <def>TUInt32 iParity</def><sym>) {</sym><br />
<def></def>   <kwa>return</kwa> <def>s_basePiece</def><sym>[</sym><def>iPiece</def><sym>][</sym><def>iOrient</def><sym>].</sym><def>m_instance</def><sym>[</sym><def>iParity</def><sym>];</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<slc>// ------------------------------------</slc><br />
<def><br />
Board</def><sym>::</sym><def></def><kwd>Board</kwd><def></def><sym>() :</sym><br />
<def></def>   <kwd>m_curSoln</kwd><def></def><sym>(</sym><def>Soln</def><sym>::</sym><def>NO_PIECE</def><sym>),</sym> <def></def><kwd>m_minSoln</kwd><def></def><sym>(</sym><def>N_PIECE_TYPE</def><sym>),</sym><br />
<def></def>   <kwd>m_maxSoln</kwd><def></def><sym>(</sym><def>Soln</def><sym>::</sym><def>NO_PIECE</def><sym>),</sym> <def></def><kwd>m_nSoln</kwd><def></def><sym>(</sym><def></def><num>0</num><def></def><sym>)</sym><br />
<def></def><sym>{}</sym><br />
<def><br />
TUInt32 g_flip</def><sym>[] = {</sym><br />
<def></def>   <num>0x00</num><def></def><sym>,</sym> <def></def><num>0x10</num><def></def><sym>,</sym> <def></def><num>0x08</num><def></def><sym>,</sym> <def></def><num>0x18</num><def></def><sym>,</sym> <def></def><num>0x04</num><def></def><sym>,</sym> <def></def><num>0x14</num><def></def><sym>,</sym> <def></def><num>0x0c</num><def></def><sym>,</sym> <def></def><num>0x1c</num><def></def><sym>,</sym><br />
<def></def>   <num>0x02</num><def></def><sym>,</sym> <def></def><num>0x12</num><def></def><sym>,</sym> <def></def><num>0x0a</num><def></def><sym>,</sym> <def></def><num>0x1a</num><def></def><sym>,</sym> <def></def><num>0x06</num><def></def><sym>,</sym> <def></def><num>0x16</num><def></def><sym>,</sym> <def></def><num>0x0e</num><def></def><sym>,</sym> <def></def><num>0x1e</num><def></def><sym>,</sym><br />
<def></def><br />
   <num>0x01</num><def></def><sym>,</sym> <def></def><num>0x11</num><def></def><sym>,</sym> <def></def><num>0x09</num><def></def><sym>,</sym> <def></def><num>0x19</num><def></def><sym>,</sym> <def></def><num>0x05</num><def></def><sym>,</sym> <def></def><num>0x15</num><def></def><sym>,</sym> <def></def><num>0x0d</num><def></def><sym>,</sym> <def></def><num>0x1d</num><def></def><sym>,</sym><br />
<def></def>   <num>0x03</num><def></def><sym>,</sym> <def></def><num>0x13</num><def></def><sym>,</sym> <def></def><num>0x0b</num><def></def><sym>,</sym> <def></def><num>0x1b</num><def></def><sym>,</sym> <def></def><num>0x07</num><def></def><sym>,</sym> <def></def><num>0x17</num><def></def><sym>,</sym> <def></def><num>0x0f</num><def></def><sym>,</sym> <def></def><num>0x1f</num><def></def><sym>,</sym><br />
<def></def><sym>};</sym><br />
<def></def><br />
<kwc>inline</kwc> <def>TUInt32</def> <kwd>flipTwoRows</kwd><def></def><sym>(</sym><def>TUInt32 bits</def><sym>) {</sym><br />
<def>   TUInt32 flipped</def> <sym>=</sym> <def>g_flip</def><sym>[</sym><def>bits</def> <sym>&gt;&gt;</sym> <def>N_COL</def><sym>] &lt;&lt;</sym> <def>N_COL</def><sym>;</sym><br />
<def></def>   <kwa>return</kwa> <def></def><sym>(</sym><def>flipped</def> <sym>|</sym> <def>g_flip</def><sym>[</sym><def>bits</def> <sym>&amp;</sym> <def>Board</def><sym>::</sym><def>TOP_ROW</def><sym>]);</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Board</def><sym>::</sym><def></def><kwd>calcAlwaysBad</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>) {</sym><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def>TUInt32 iWord</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym> <def>iWord</def> <sym>&lt;</sym> <def>MAX_ISLAND_OFFSET</def><sym>;</sym> <def>iWord</def><sym>++) {</sym><br />
<def>      IslandInfo</def> <sym>&amp;</sym> <def>isleInfo</def> <sym>=</sym> <def>g_islandInfo</def><sym>[</sym><def>iWord</def><sym>];</sym><br />
<def>      IslandInfo</def> <sym>&amp;</sym> <def>flipped</def> <sym>=</sym> <def>g_islandInfo</def><sym>[</sym><def></def><kwd>flipTwoRows</kwd><def></def><sym>(</sym><def>iWord</def><sym>)];</sym><br />
<def></def><br />
      <kwa>for</kwa> <def></def><sym>(</sym><def>TUInt32 i</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>,</sym> <def>mask</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym> <def>i</def> <sym>&lt;</sym> <def></def><num>32</num><def></def><sym>;</sym> <def>i</def><sym>++,</sym> <def>mask</def> <sym>&lt;&lt;=</sym> <def></def><num>1</num><def></def><sym>) {</sym><br />
<def>         TUInt32 boardVec</def> <sym>= (</sym><def>i</def> <sym>&lt;&lt;</sym> <def>TWO_ROWS</def><sym>) |</sym> <def>iWord</def><sym>;</sym><br />
<def></def><br />
         <kwb>int</kwb> <def>hasBad</def> <sym>=</sym> <def></def><kwd>calcBadIslands</kwd><def></def><sym>(</sym><def>boardVec</def><sym>,</sym> <def></def><num>0</num><def></def><sym>);</sym><br />
<def></def>         <kwa>if</kwa> <def></def><sym>(</sym><def>hasBad</def> <sym>==</sym> <def>ALWAYS_BAD</def><sym>) {</sym><br />
<def>            isleInfo</def><sym>.</sym><def>alwaysBad</def><sym>[</sym><def>EVEN</def><sym>] |=</sym> <def>mask</def><sym>;</sym><br />
<def><br />
            TUInt32 flipMask</def> <sym>=</sym> <def></def><kwd>getMask</kwd><def></def><sym>(</sym><def>g_flip</def><sym>[</sym><def>i</def><sym>]);</sym><br />
<def>            flipped</def><sym>.</sym><def>alwaysBad</def><sym>[</sym><def>ODD</def><sym>] |=</sym> <def>flipMask</def><sym>;</sym><br />
<def></def>         <sym>}</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>bool</kwb> <def>Board</def><sym>::</sym><def></def><kwd>hasBadIslandsSingle</kwd><def></def><sym>(</sym><def>BitVec boardVec</def><sym>,</sym> <def></def><kwb>int</kwb> <def>row</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def>   BitVec toFill</def> <sym>= ~</sym><def>boardVec</def><sym>;</sym><br />
<def></def>   <kwb>bool</kwb> <def>isOdd</def> <sym>= (</sym><def>row</def> <sym>&amp;</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>isOdd</def><sym>) {</sym><br />
<def>      row</def><sym>--;</sym><br />
<def>      toFill</def> <sym>&lt;&lt;=</sym> <def>N_COL</def><sym>;</sym> <def></def><slc>// shift to even aligned</slc><br />
<def>      toFill</def> <sym>|=</sym> <def>TOP_ROW</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def><br />
   BitVec startRegion</def> <sym>=</sym> <def>TOP_ROW</def><sym>;</sym><br />
<def>   BitVec lastRow</def> <sym>=</sym> <def>TOP_ROW</def> <sym>&lt;&lt; (</sym><def></def><num>5</num> <def></def><sym>*</sym> <def>N_COL</def><sym>);</sym><br />
<def>   BitVec boardMask</def> <sym>=</sym> <def>BOARD_MASK</def><sym>;</sym> <def></def><slc>// all but the first two bits</slc><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>row</def> <sym>&gt;=</sym> <def></def><num>4</num><def></def><sym>)</sym><br />
<def>      boardMask</def> <sym>&gt;&gt;= ((</sym><def>row</def> <sym>-</sym> <def></def><num>4</num><def></def><sym>) *</sym> <def>N_COL</def><sym>);</sym><br />
<def></def>   <kwa>else if</kwa> <def></def><sym>(</sym><def>isOdd</def> <sym>|| (</sym><def>row</def> <sym>==</sym> <def></def><num>0</num><def></def><sym>))</sym><br />
<def>      startRegion</def> <sym>=</sym> <def>lastRow</def><sym>;</sym><br />
<def><br />
   toFill</def> <sym>&amp;=</sym> <def>boardMask</def><sym>;</sym><br />
<def>   startRegion</def> <sym>&amp;=</sym> <def>toFill</def><sym>;</sym><br />
<def></def><br />
   <kwa>while</kwa> <def></def><sym>(</sym><def>toFill</def><sym>)    {</sym><br />
<def></def>      <kwa>if</kwa> <def></def><sym>(</sym><def></def><kwd>badRegion</kwd><def></def><sym>(</sym><def>toFill</def><sym>,</sym> <def>startRegion</def><sym>))</sym><br />
<def></def>         <kwa>return true</kwa><def></def><sym>;</sym><br />
<def></def>      <kwb>int</kwb> <def>iPos</def> <sym>=</sym> <def></def><kwd>getFirstOne</kwd><def></def><sym>(</sym><def>toFill</def><sym>);</sym><br />
<def>      startRegion</def> <sym>=</sym> <def></def><kwd>getMask</kwd><def></def><sym>(</sym><def>iPos</def><sym>);</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>return false</kwa><def></def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Board</def><sym>::</sym><def></def><kwd>recordSolution</kwd><def></def><sym>(</sym><def>Soln</def> <sym>&amp;</sym> <def>s</def><sym>) {</sym><br />
<def>   m_nSoln</def> <sym>+=</sym> <def></def><num>2</num><def></def><sym>;</sym> <def></def><slc>// add solution and its rotation</slc><br />
<def></def><br />
   <kwa>if</kwa> <def></def><sym>(</sym><def>m_minSoln</def><sym>.</sym><def></def><kwd>isEmpty</kwd><def></def><sym>()) {</sym><br />
<def>      m_minSoln</def> <sym>=</sym> <def>m_maxSoln</def> <sym>=</sym> <def>s</def><sym>;</sym><br />
<def></def>      <kwa>return</kwa><def></def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>if</kwa> <def></def><sym>(</sym><def>s</def><sym>.</sym><def></def><kwd>lessThan</kwd><def></def><sym>(</sym><def>m_minSoln</def><sym>))</sym><br />
<def>      m_minSoln</def> <sym>=</sym> <def>s</def><sym>;</sym><br />
<def></def>   <kwa>else if</kwa> <def></def><sym>(</sym><def>m_maxSoln</def><sym>.</sym><def></def><kwd>lessThan</kwd><def></def><sym>(</sym><def>s</def><sym>))</sym><br />
<def>      m_maxSoln</def> <sym>=</sym> <def>s</def><sym>;</sym><br />
<def><br />
   Soln spun</def><sym>;</sym><br />
<def>   s</def><sym>.</sym><def></def><kwd>spin</kwd><def></def><sym>(</sym><def>spun</def><sym>);</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>spun</def><sym>.</sym><def></def><kwd>lessThan</kwd><def></def><sym>(</sym><def>m_minSoln</def><sym>))</sym><br />
<def>      m_minSoln</def> <sym>=</sym> <def>spun</def><sym>;</sym><br />
<def></def>   <kwa>else if</kwa> <def></def><sym>(</sym><def>m_maxSoln</def><sym>.</sym><def></def><kwd>lessThan</kwd><def></def><sym>(</sym><def>spun</def><sym>))</sym><br />
<def>      m_maxSoln</def> <sym>=</sym> <def>spun</def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def><br />
TUInt32</def> <kwd>countOnes</kwd><def></def><sym>(</sym><def>BitVec v</def><sym>) {</sym><br />
<def>   TUInt32 n</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>   <kwa>while</kwa> <def></def><sym>(</sym><def>v</def><sym>) {</sym><br />
<def>      n</def><sym>++;</sym><br />
<def>      v</def> <sym>=</sym> <def>v</def> <sym>&amp; (</sym><def>v</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>return</kwa> <def>n</def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>bool</kwb> <def>Board</def><sym>::</sym><def></def><kwd>badRegion</kwd><def></def><sym>(</sym><def>BitVec</def> <sym>&amp;</sym> <def>toFill</def><sym>,</sym> <def>BitVec rNew</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <slc>// grow empty region, until it doesn't change any more</slc><br />
<def>   BitVec region</def><sym>;</sym><br />
<def></def>   <kwa>do</kwa> <def></def><sym>{</sym><br />
<def>      region</def> <sym>=</sym> <def>rNew</def><sym>;</sym><br />
<def></def><br />
      <slc>// simple grow up/down</slc><br />
<def>      rNew</def> <sym>|= (</sym><def>region</def> <sym>&gt;&gt;</sym> <def>N_COL</def><sym>);</sym><br />
<def>      rNew</def> <sym>|= (</sym><def>region</def> <sym>&lt;&lt;</sym> <def>N_COL</def><sym>);</sym><br />
<def></def><br />
      <slc>// grow right/left</slc><br />
<def>      rNew</def> <sym>|= (</sym><def>region</def> <sym>&amp; ~</sym><def>L_EDGE_MASK</def><sym>) &gt;&gt;</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def>      rNew</def> <sym>|= (</sym><def>region</def> <sym>&amp; ~</sym><def>R_EDGE_MASK</def><sym>) &lt;&lt;</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def><br />
      <slc>// tricky growth</slc><br />
<def>      BitVec evenRegion</def> <sym>=</sym> <def>region</def> <sym>&amp; (</sym><def>ROW_0_MASK</def> <sym>&amp; ~</sym><def>L_EDGE_MASK</def><sym>);</sym><br />
<def>      rNew</def> <sym>|=</sym> <def>evenRegion</def> <sym>&gt;&gt; (</sym><def>N_COL</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def>      rNew</def> <sym>|=</sym> <def>evenRegion</def> <sym>&lt;&lt; (</sym><def>N_COL</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def>      BitVec oddRegion</def> <sym>=</sym> <def>region</def> <sym>&amp; (</sym><def>ROW_1_MASK</def> <sym>&amp; ~</sym><def>R_EDGE_MASK</def><sym>);</sym><br />
<def>      rNew</def> <sym>|=</sym> <def>oddRegion</def> <sym>&gt;&gt; (</sym><def>N_COL</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def>      rNew</def> <sym>|=</sym> <def>oddRegion</def> <sym>&lt;&lt; (</sym><def>N_COL</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def></def><br />
      <slc>// clamp against existing pieces</slc><br />
<def>      rNew</def> <sym>&amp;=</sym> <def>toFill</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def>   <kwa>while</kwa> <def></def><sym>((</sym><def>rNew</def> <sym>!=</sym> <def>toFill</def><sym>) &amp;&amp; (</sym><def>rNew</def> <sym>!=</sym> <def>region</def><sym>));</sym><br />
<def></def><br />
   <slc>// subtract empty region from board</slc><br />
<def>   toFill ^</def><sym>=</sym> <def>rNew</def><sym>;</sym><br />
<def><br />
   TUInt32 nCells</def> <sym>=</sym> <def></def><kwd>countOnes</kwd><def></def><sym>(</sym><def>toFill</def><sym>);</sym><br />
<def></def>   <kwa>return</kwa> <def></def><sym>(</sym><def>nCells</def> <sym>%</sym> <def>Piece</def><sym>::</sym><def>N_ELEM</def> <sym>!=</sym> <def></def><num>0</num><def></def><sym>);</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>static</kwb> <def>TUInt32 g_firstRegion</def><sym>[] = {</sym><br />
<def></def>   <num>0x00</num><def></def><sym>,</sym> <def></def><num>0x01</num><def></def><sym>,</sym> <def></def><num>0x02</num><def></def><sym>,</sym> <def></def><num>0x03</num><def></def><sym>,</sym>   <def></def><num>0x04</num><def></def><sym>,</sym> <def></def><num>0x01</num><def></def><sym>,</sym> <def></def><num>0x06</num><def></def><sym>,</sym> <def></def><num>0x07</num><def></def><sym>,</sym><br />
<def></def>   <num>0x08</num><def></def><sym>,</sym> <def></def><num>0x01</num><def></def><sym>,</sym> <def></def><num>0x02</num><def></def><sym>,</sym> <def></def><num>0x03</num><def></def><sym>,</sym>   <def></def><num>0x0c</num><def></def><sym>,</sym> <def></def><num>0x01</num><def></def><sym>,</sym> <def></def><num>0x0e</num><def></def><sym>,</sym> <def></def><num>0x0f</num><def></def><sym>,</sym><br />
<def></def><br />
   <num>0x10</num><def></def><sym>,</sym> <def></def><num>0x01</num><def></def><sym>,</sym> <def></def><num>0x02</num><def></def><sym>,</sym> <def></def><num>0x03</num><def></def><sym>,</sym>   <def></def><num>0x04</num><def></def><sym>,</sym> <def></def><num>0x01</num><def></def><sym>,</sym> <def></def><num>0x06</num><def></def><sym>,</sym> <def></def><num>0x07</num><def></def><sym>,</sym><br />
<def></def>   <num>0x18</num><def></def><sym>,</sym> <def></def><num>0x01</num><def></def><sym>,</sym> <def></def><num>0x02</num><def></def><sym>,</sym> <def></def><num>0x03</num><def></def><sym>,</sym>   <def></def><num>0x1c</num><def></def><sym>,</sym> <def></def><num>0x01</num><def></def><sym>,</sym> <def></def><num>0x1e</num><def></def><sym>,</sym> <def></def><num>0x1f</num><br />
<def></def><sym>};</sym><br />
<def></def><br />
<kwb>int</kwb> <def>Board</def><sym>::</sym><def></def><kwd>calcBadIslands</kwd><def></def><sym>(</sym><def>BitVec boardVec</def><sym>,</sym> <def></def><kwb>int</kwb> <def>row</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def>   BitVec toFill</def> <sym>= ~</sym><def>boardVec</def><sym>;</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>row</def> <sym>&amp;</sym> <def></def><num>1</num><def></def><sym>) {</sym><br />
<def>      row</def><sym>--;</sym><br />
<def>      toFill</def> <sym>&lt;&lt;=</sym> <def>N_COL</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def><br />
   BitVec boardMask</def> <sym>=</sym> <def>BOARD_MASK</def><sym>;</sym> <def></def><slc>// all but the first two bits</slc><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>row</def> <sym>&gt;</sym> <def></def><num>4</num><def></def><sym>) {</sym><br />
<def></def>      <kwb>int</kwb> <def>boardMaskShift</def> <sym>= (</sym><def>row</def> <sym>-</sym> <def></def><num>4</num><def></def><sym>) *</sym> <def>N_COL</def><sym>;</sym><br />
<def>      boardMask</def> <sym>&gt;&gt;=</sym> <def>boardMaskShift</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def>   toFill</def> <sym>&amp;=</sym> <def>boardMask</def><sym>;</sym><br />
<def></def><br />
   <slc>// a little pre-work to speed things up</slc><br />
<def>   BitVec bottom</def> <sym>= (</sym><def>TOP_ROW</def> <sym>&lt;&lt; (</sym><def></def><num>5</num> <def></def><sym>*</sym> <def>N_COL</def><sym>));</sym><br />
<def></def>   <kwb>bool</kwb> <def>filled</def> <sym>= ((</sym><def>bottom</def> <sym>&amp;</sym> <def>toFill</def><sym>) ==</sym> <def>bottom</def><sym>);</sym><br />
<def></def>   <kwa>while</kwa> <def></def><sym>((</sym><def>bottom</def> <sym>&amp;</sym> <def>toFill</def><sym>) ==</sym> <def>bottom</def><sym>) {</sym><br />
<def>      toFill ^</def><sym>=</sym> <def>bottom</def><sym>;</sym><br />
<def>      bottom</def> <sym>&gt;&gt;=</sym> <def>N_COL</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def><br />
   BitVec startRegion</def><sym>;</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>filled</def> <sym>|| (</sym><def>row</def> <sym>&lt;</sym> <def></def><num>4</num><def></def><sym>))</sym><br />
<def>      startRegion</def> <sym>=</sym> <def>bottom</def> <sym>&amp;</sym> <def>toFill</def><sym>;</sym><br />
<def></def>   <kwa>else</kwa> <def></def><sym>{</sym><br />
<def>      startRegion</def> <sym>=</sym> <def>g_firstRegion</def><sym>[</sym><def>toFill</def> <sym>&amp;</sym> <def>TOP_ROW</def><sym>];</sym><br />
<def></def>      <kwa>if</kwa> <def></def><sym>(</sym><def>startRegion</def> <sym>==</sym> <def></def><num>0</num><def></def><sym>)  {</sym><br />
<def>         startRegion</def> <sym>= (</sym><def>toFill</def> <sym>&gt;&gt;</sym> <def>N_COL</def><sym>) &amp;</sym> <def>TOP_ROW</def><sym>;</sym><br />
<def>         startRegion</def> <sym>=</sym> <def>g_firstRegion</def><sym>[</sym><def>startRegion</def><sym>];</sym><br />
<def>         startRegion</def> <sym>&lt;&lt;=</sym> <def>N_COL</def><sym>;</sym><br />
<def></def>      <sym>}</sym><br />
<def>      startRegion</def> <sym>|= (</sym><def>startRegion</def> <sym>&lt;&lt;</sym> <def>N_COL</def><sym>) &amp;</sym> <def>toFill</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>do</kwa> <def></def><sym>{</sym><br />
<def></def>      <kwa>if</kwa> <def></def><sym>(</sym><def></def><kwd>badRegion</kwd><def></def><sym>(</sym><def>toFill</def><sym>,</sym> <def>startRegion</def><sym>))</sym><br />
<def></def>         <kwa>return</kwa> <def>ALWAYS_BAD</def><sym>;</sym><br />
<def></def>      <kwb>int</kwb> <def>iPos</def> <sym>=</sym> <def></def><kwd>getFirstOne</kwd><def></def><sym>(</sym><def>toFill</def><sym>);</sym><br />
<def>      startRegion</def> <sym>=</sym> <def></def><kwd>getMask</kwd><def></def><sym>(</sym><def>iPos</def><sym>);</sym><br />
<def></def>   <sym>}</sym> <def></def><kwa>while</kwa> <def></def><sym>(</sym><def>toFill</def><sym>);</sym><br />
<def></def><br />
   <kwa>return</kwa> <def>GOOD</def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>int</kwb> <def>Board</def><sym>::</sym><def></def><kwd>hasBadIslands</kwd><def></def><sym>(</sym><def>BitVec boardVec</def><sym>,</sym> <def></def><kwb>int</kwb> <def>row</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <slc>// skip over any filled rows</slc><br />
<def></def>   <kwa>while</kwa> <def></def><sym>((</sym><def>boardVec</def> <sym>&amp;</sym> <def>TOP_ROW</def><sym>) ==</sym> <def>TOP_ROW</def><sym>) {</sym><br />
<def>      boardVec</def> <sym>&gt;&gt;=</sym> <def>N_COL</def><sym>;</sym><br />
<def>      row</def><sym>++;</sym><br />
<def></def>   <sym>}</sym><br />
<def><br />
   TUInt32 iInfo</def> <sym>=</sym> <def>boardVec</def> <sym>&amp;</sym> <def>TOP_2_ROWS</def><sym>;</sym><br />
<def>   IslandInfo</def> <sym>&amp;</sym> <def>info</def> <sym>=</sym> <def>g_islandInfo</def><sym>[</sym><def>iInfo</def><sym>];</sym><br />
<def><br />
   TUInt32 thirdRow</def> <sym>= (</sym><def>boardVec</def> <sym>&gt;&gt;</sym> <def>TWO_ROWS</def><sym>) &amp;</sym> <def>TOP_ROW</def><sym>;</sym><br />
<def>   TUInt32 mask</def> <sym>=</sym> <def></def><kwd>getMask</kwd><def></def><sym>(</sym><def>thirdRow</def><sym>);</sym><br />
<def>   TUInt32 isOdd</def> <sym>=</sym> <def>row</def> <sym>&amp;</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def>   TUInt32</def> <sym>&amp;</sym> <def>alwaysBad</def> <sym>=</sym> <def>info</def><sym>.</sym><def>alwaysBad</def><sym>[</sym><def>isOdd</def><sym>];</sym><br />
<def></def><br />
   <kwa>if</kwa> <def></def><sym>(</sym><def>alwaysBad</def> <sym>&amp;</sym> <def>mask</def><sym>)</sym><br />
<def></def>      <kwa>return</kwa> <def>ALWAYS_BAD</def><sym>;</sym><br />
<def></def><br />
   <kwa>if</kwa> <def></def><sym>(</sym><def>boardVec</def> <sym>==</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def></def>      <kwa>return</kwa> <def>GOOD</def><sym>;</sym><br />
<def></def><br />
   <kwa>return</kwa> <def></def><kwd>calcBadIslands</kwd><def></def><sym>(</sym><def>boardVec</def><sym>,</sym> <def>row</def><sym>);</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Board</def><sym>::</sym><def></def><kwd>genAllSolutions</kwd><def></def><sym>(</sym><def>BitVec boardVec</def><sym>,</sym> <def>TUInt32 placedPieces</def><sym>,</sym> <def>TUInt32 row</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <kwa>while</kwa> <def></def><sym>((</sym><def>boardVec</def> <sym>&amp;</sym> <def>TOP_ROW</def><sym>) ==</sym> <def>TOP_ROW</def><sym>) {</sym><br />
<def>      boardVec</def> <sym>&gt;&gt;=</sym> <def>N_COL</def><sym>;</sym><br />
<def>      row</def><sym>++;</sym><br />
<def></def>   <sym>}</sym><br />
<def>   TUInt32 iNextFill</def> <sym>=</sym> <def>s_firstOne</def><sym>[~</sym><def>boardVec</def> <sym>&amp;</sym> <def>TOP_ROW</def><sym>];</sym><br />
<def></def>   <kwb>const</kwb> <def>OkPieces</def> <sym>&amp;</sym> <def>allowed</def> <sym>=</sym> <def>g_okPieces</def><sym>[</sym><def>row</def><sym>][</sym><def>iNextFill</def><sym>];</sym><br />
<def></def><br />
   <kwb>int</kwb> <def>iPiece</def> <sym>=</sym> <def></def><kwd>getFirstOne</kwd><def></def><sym>(~</sym><def>placedPieces</def><sym>);</sym><br />
<def></def>   <kwb>int</kwb> <def>pieceMask</def> <sym>=</sym> <def></def><kwd>getMask</kwd><def></def><sym>(</sym><def>iPiece</def><sym>);</sym><br />
<def></def><br />
   <kwa>for</kwa> <def></def><sym>(;</sym> <def>iPiece</def> <sym>&lt;</sym> <def>N_PIECE_TYPE</def><sym>;</sym> <def>iPiece</def><sym>++,</sym> <def>pieceMask</def> <sym>&lt;&lt;=</sym> <def></def><num>1</num><def></def><sym>)</sym><br />
<def></def>   <sym>{</sym><br />
<def></def>      <slc>// skip if we've already used this piece</slc><br />
<def></def>      <kwa>if</kwa> <def></def><sym>(</sym><def>pieceMask</def> <sym>&amp;</sym> <def>placedPieces</def><sym>)</sym><br />
<def></def>         <kwa>continue</kwa><def></def><sym>;</sym><br />
<def><br />
      placedPieces</def> <sym>|=</sym> <def>pieceMask</def><sym>;</sym><br />
<def></def><br />
      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iOrient</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iOrient</def> <sym>&lt;</sym> <def>allowed</def><sym>.</sym><def>nPieces</def><sym>[</sym><def>iPiece</def><sym>];</sym> <def>iOrient</def><sym>++) {</sym><br />
<def>         BitVec pieceVec</def> <sym>=</sym> <def>allowed</def><sym>.</sym><def>pieceVec</def><sym>[</sym><def>iPiece</def><sym>][</sym><def>iOrient</def><sym>];</sym><br />
<def></def><br />
         <slc>// check if piece conflicts with other pieces</slc><br />
<def></def>         <kwa>if</kwa> <def></def><sym>((</sym><def>pieceVec</def> <sym>&amp;</sym> <def>boardVec</def><sym>) ||</sym> <def></def><kwd>hasBadIslands</kwd><def></def><sym>(</sym><def>boardVec</def> <sym>|</sym> <def>pieceVec</def><sym>,</sym> <def>row</def><sym>))</sym><br />
<def></def>            <kwa>continue</kwa><def></def><sym>;</sym><br />
<def><br />
         m_curSoln</def><sym>.</sym><def></def><kwd>pushPiece</kwd><def></def><sym>(</sym><def>pieceVec</def><sym>,</sym> <def>iPiece</def><sym>,</sym> <def>row</def><sym>);</sym><br />
<def></def><br />
         <slc>// recur or record solution</slc><br />
<def></def>         <kwa>if</kwa> <def></def><sym>(</sym><def>placedPieces</def> <sym>!=</sym> <def>Piece</def><sym>::</sym><def>ALL_PIECE_MASK</def><sym>)</sym><br />
<def></def>            <kwd>genAllSolutions</kwd><def></def><sym>(</sym><def>boardVec</def> <sym>|</sym> <def>pieceVec</def><sym>,</sym> <def>placedPieces</def><sym>,</sym> <def>row</def><sym>);</sym><br />
<def></def>         <kwa>else</kwa><br />
<def></def>            <kwd>recordSolution</kwd><def></def><sym>(</sym><def>m_curSoln</def><sym>);</sym><br />
<def></def><br />
         <slc>// remove the piece before continuing with a new piece</slc><br />
<def>         m_curSoln</def><sym>.</sym><def></def><kwd>popPiece</kwd><def></def><sym>();</sym><br />
<def></def>      <sym>}</sym><br />
<def><br />
      placedPieces ^</def><sym>=</sym> <def>pieceMask</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>int</kwb> <def></def><kwd>main</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>argc</def><sym>,</sym> <def></def><kwb>char</kwb> <def></def><sym>* []) {</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>argc</def> <sym>&gt;</sym> <def></def><num>2</num><def></def><sym>)</sym><br />
<def></def>      <kwa>return</kwa> <def></def><num>1</num><def></def><sym>;</sym> <def></def><slc>// spec says this is an error</slc><br />
<def><br />
   Board b</def><sym>;</sym><br />
<def>   Piece</def><sym>::</sym><def></def><kwd>genAllOrientations</kwd><def></def><sym>();</sym><br />
<def>   Board</def><sym>::</sym><def></def><kwd>calcAlwaysBad</kwd><def></def><sym>();</sym><br />
<def>   b</def><sym>.</sym><def></def><kwd>genAllSolutions</kwd><def></def><sym>(</sym><def></def><num>0</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>);</sym><br />
<def>   cout</def> <sym>&lt;&lt;</sym> <def>b</def><sym>.</sym><def>m_nSoln</def> <sym>&lt;&lt;</sym> <def></def><str>&quot; solutions found</str><esc>\n\n</esc><str>&quot;</str><def></def><sym>;</sym><br />
<def>   cout</def> <sym>&lt;&lt;</sym> <def>b</def><sym>.</sym><def>m_minSoln</def><sym>.</sym><def></def><kwd>toString</kwd><def></def><sym>() &lt;&lt;</sym> <def></def><str>'</str><esc>\n</esc><str>'</str><def></def><sym>;</sym><br />
<def>   cout</def> <sym>&lt;&lt;</sym> <def>b</def><sym>.</sym><def>m_maxSoln</def><sym>.</sym><def></def><kwd>toString</kwd><def></def><sym>() &lt;&lt;</sym> <def>endl</def><sym>;</sym><br />
<def></def><br />
   <kwa>return</kwa> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def><sym>}</sym><def></def><br />
</source>
