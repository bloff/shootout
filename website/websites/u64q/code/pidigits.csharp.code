<source>
<def></def><com>/* The Great Computer Language Shootout</com><br />
<com>   http://shootout.alioth.debian.org/</com><br />
<com></com><br />
<com>   contributed by Alp Toker &lt;alp@atoker.com&gt;</com><br />
<com>*/</com><def></def><br />
<br />
<kwa>using</kwa> <def>System</def><sym>;</sym><br />
<def></def><kwa>using</kwa> <def>UBigInteger</def> <sym>=</sym> <def>Mono</def><sym>.</sym><def>Math</def><sym>.</sym><def>BigInteger</def><sym>;</sym><br />
<def></def><kwa>using</kwa> <def>Sign</def> <sym>=</sym> <def>Mono</def><sym>.</sym><def>Math</def><sym>.</sym><def>BigInteger</def><sym>.</sym><def>Sign</def><sym>;</sym><br />
<def></def><br />
<kwa>public class</kwa> <def>pidigits</def><br />
<sym>{</sym><br />
<def></def>	<kwb>const int</kwb> <def>L</def> <sym>=</sym> <def></def><num>10</num><def></def><sym>;</sym><br />
<def></def><br />
	<kwa>public static</kwa> <def></def><kwb>void</kwb> <def></def><kwd>Main</kwd> <def></def><sym>(</sym><def></def><kwb>string</kwb><def></def><sym>[]</sym> <def>args</def><sym>)</sym><br />
<def></def>	<sym>{</sym><br />
<def></def>		<kwa>if</kwa> <def></def><sym>(</sym><def>args</def><sym>.</sym><def>Length</def> <sym>!=</sym> <def></def><num>1</num><def></def><sym>)</sym><br />
<def></def>			<kwa>return</kwa><def></def><sym>;</sym><br />
<def></def><br />
		<kwb>int</kwb> <def>n</def> <sym>=</sym> <def>Int32</def><sym>.</sym><def></def><kwd>Parse</kwd> <def></def><sym>(</sym><def>args</def><sym>[</sym><def></def><num>0</num><def></def><sym>]);</sym><br />
<def></def>		<kwb>int</kwb> <def>j</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def><br />
		PiDigitSpigot digits</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>PiDigitSpigot</kwd> <def></def><sym>();</sym><br />
<def></def><br />
		<kwa>while</kwa> <def></def><sym>(</sym><def>n</def> <sym>&gt;</sym> <def></def><num>0</num><def></def><sym>) {</sym><br />
<def></def>			<kwa>if</kwa> <def></def><sym>(</sym><def>n</def> <sym>&gt;=</sym> <def>L</def><sym>) {</sym><br />
<def></def>				<kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i</def> <sym>=</sym> <def></def><num>0</num> <def></def><sym>;</sym> <def>i</def> <sym>!=</sym> <def>L</def> <sym>;</sym> <def>i</def><sym>++)</sym><br />
<def>					Console</def><sym>.</sym><def></def><kwd>Write</kwd> <def></def><sym>(</sym><def>digits</def><sym>.</sym><def></def><kwd>Next</kwd> <def></def><sym>());</sym><br />
<def>				j</def> <sym>+=</sym> <def>L</def><sym>;</sym><br />
<def></def>			<sym>}</sym> <def></def><kwa>else</kwa> <def></def><sym>{</sym><br />
<def></def>				<kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i</def> <sym>=</sym> <def></def><num>0</num> <def></def><sym>;</sym> <def>i</def> <sym>!=</sym> <def>n</def> <sym>;</sym> <def>i</def><sym>++)</sym><br />
<def>					Console</def><sym>.</sym><def></def><kwd>Write</kwd> <def></def><sym>(</sym><def>digits</def><sym>.</sym><def></def><kwd>Next</kwd> <def></def><sym>());</sym><br />
<def></def>				<kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i</def> <sym>=</sym> <def>n</def> <sym>;</sym> <def>i</def> <sym>!=</sym> <def>L</def> <sym>;</sym> <def>i</def><sym>++)</sym><br />
<def>					Console</def><sym>.</sym><def></def><kwd>Write</kwd> <def></def><sym>(</sym><def></def><str>&quot; &quot;</str><def></def><sym>);</sym><br />
<def>				j</def> <sym>+=</sym> <def>n</def><sym>;</sym><br />
<def></def>			<sym>}</sym><br />
<def><br />
			Console</def><sym>.</sym><def></def><kwd>Write</kwd> <def></def><sym>(</sym><def></def><str>&quot;</str><esc>\t</esc><str>:&quot;</str><def></def><sym>);</sym><br />
<def>			Console</def><sym>.</sym><def></def><kwd>WriteLine</kwd> <def></def><sym>(</sym><def>j</def><sym>);</sym><br />
<def>			n</def> <sym>-=</sym> <def>L</def><sym>;</sym><br />
<def></def>		<sym>}</sym><br />
<def></def>	<sym>}</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwa>class</kwa> <def>PiDigitSpigot</def><br />
<sym>{</sym><br />
<def>	Transformation z</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>Transformation</kwd> <def></def><sym>(</sym><def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def>	Transformation x</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>Transformation</kwd> <def></def><sym>(</sym><def></def><num>0</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>);</sym><br />
<def>	Transformation inverse</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>Transformation</kwd> <def></def><sym>(</sym><def></def><num>0</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>);</sym><br />
<def></def><br />
	<kwa>public</kwa> <def></def><kwb>int</kwb> <def></def><kwd>Next</kwd> <def></def><sym>()</sym><br />
<def></def>	<sym>{</sym><br />
<def></def>		<kwb>int</kwb> <def>y</def> <sym>=</sym> <def>Digit</def><sym>;</sym><br />
<def></def><br />
		<kwa>if</kwa> <def></def><sym>(</sym><def></def><kwd>IsSafe</kwd> <def></def><sym>(</sym><def>y</def><sym>))</sym><br />
<def></def>		<sym>{</sym><br />
<def>			z</def> <sym>=</sym> <def></def><kwd>Produce</kwd> <def></def><sym>(</sym><def>y</def><sym>);</sym><br />
<def></def>			<kwa>return</kwa> <def>y</def><sym>;</sym><br />
<def></def>		<sym>}</sym><br />
<def></def>		<kwa>else</kwa> <def></def><sym>{</sym><br />
<def>			z</def> <sym>=</sym> <def></def><kwd>Consume</kwd> <def></def><sym>(</sym><def>x</def><sym>.</sym><def></def><kwd>Next</kwd> <def></def><sym>());</sym><br />
<def></def>			<kwa>return</kwa> <def></def><kwd>Next</kwd> <def></def><sym>();</sym><br />
<def></def>		<sym>}</sym><br />
<def></def>	<sym>}</sym><br />
<def></def><br />
	<kwa>public</kwa> <def></def><kwb>int</kwb> <def>Digit</def><br />
	<sym>{</sym><br />
<def></def>		<kwa>get</kwa> <def></def><sym>{</sym><br />
<def></def>			<kwa>return</kwa> <def>z</def><sym>.</sym><def></def><kwd>Extract</kwd> <def></def><sym>(</sym><def></def><num>3</num><def></def><sym>);</sym><br />
<def></def>		<sym>}</sym><br />
<def></def>	<sym>}</sym><br />
<def></def><br />
	<kwa>public</kwa> <def></def><kwb>bool</kwb> <def></def><kwd>IsSafe</kwd> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>digit</def><sym>)</sym><br />
<def></def>	<sym>{</sym><br />
<def></def>		<kwa>return</kwa> <def>digit</def> <sym>==</sym> <def>z</def><sym>.</sym><def></def><kwd>Extract</kwd> <def></def><sym>(</sym><def></def><num>4</num><def></def><sym>);</sym><br />
<def></def>	<sym>}</sym><br />
<def></def><br />
	<kwa>public</kwa> <def>Transformation</def> <kwd>Produce</kwd> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i</def><sym>)</sym><br />
<def></def>	<sym>{</sym><br />
<def></def>		<kwa>return</kwa> <def></def><sym>(</sym><def>inverse</def><sym>.</sym><def></def><kwd>qrst</kwd> <def></def><sym>(</sym><def></def><num>10</num><def></def><sym>,-</sym><def></def><num>10</num><def></def><sym>*</sym><def>i</def><sym>,</sym><def></def><num>0</num><def></def><sym>,</sym><def></def><num>1</num><def></def><sym>)).</sym><def></def><kwd>Compose</kwd> <def></def><sym>(</sym><def>z</def><sym>);</sym><br />
<def></def>	<sym>}</sym><br />
<def></def><br />
	<kwa>public</kwa> <def>Transformation</def> <kwd>Consume</kwd> <def></def><sym>(</sym><def>Transformation a</def><sym>)</sym><br />
<def></def>	<sym>{</sym><br />
<def></def>		<kwa>return</kwa> <def>z</def><sym>.</sym><def></def><kwd>Compose</kwd> <def></def><sym>(</sym><def>a</def><sym>);</sym><br />
<def></def>	<sym>}</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwa>class</kwa> <def>Transformation</def><br />
<sym>{</sym><br />
<def>	BigInteger q</def><sym>,</sym> <def>r</def><sym>,</sym> <def>s</def><sym>,</sym> <def>t</def><sym>;</sym><br />
<def></def>	<kwb>int</kwb> <def>k</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def><br />
	<kwa>public</kwa> <def></def><kwd>Transformation</kwd> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>q</def><sym>,</sym> <def></def><kwb>int</kwb> <def>r</def><sym>,</sym> <def></def><kwb>int</kwb> <def>s</def><sym>,</sym> <def></def><kwb>int</kwb> <def>t</def><sym>)</sym><br />
<def></def>	<sym>{</sym><br />
<def></def>		<kwa>this</kwa><def></def><sym>.</sym><def>q</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>BigInteger</kwd> <def></def><sym>(</sym><def>q</def><sym>);</sym><br />
<def></def>		<kwa>this</kwa><def></def><sym>.</sym><def>r</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>BigInteger</kwd> <def></def><sym>(</sym><def>r</def><sym>);</sym><br />
<def></def>		<kwa>this</kwa><def></def><sym>.</sym><def>s</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>BigInteger</kwd> <def></def><sym>(</sym><def>s</def><sym>);</sym><br />
<def></def>		<kwa>this</kwa><def></def><sym>.</sym><def>t</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>BigInteger</kwd> <def></def><sym>(</sym><def>t</def><sym>);</sym><br />
<def></def>	<sym>}</sym><br />
<def></def><br />
	<kwa>public</kwa> <def></def><kwd>Transformation</kwd> <def></def><sym>(</sym><def>BigInteger q</def><sym>,</sym> <def>BigInteger r</def><sym>,</sym> <def>BigInteger s</def><sym>,</sym> <def>BigInteger t</def><sym>)</sym><br />
<def></def>	<sym>{</sym><br />
<def></def>		<kwa>this</kwa><def></def><sym>.</sym><def>q</def> <sym>=</sym> <def>q</def><sym>;</sym><br />
<def></def>		<kwa>this</kwa><def></def><sym>.</sym><def>r</def> <sym>=</sym> <def>r</def><sym>;</sym><br />
<def></def>		<kwa>this</kwa><def></def><sym>.</sym><def>s</def> <sym>=</sym> <def>s</def><sym>;</sym><br />
<def></def>		<kwa>this</kwa><def></def><sym>.</sym><def>t</def> <sym>=</sym> <def>t</def><sym>;</sym><br />
<def></def>	<sym>}</sym><br />
<def></def><br />
	<kwa>public</kwa> <def>Transformation</def> <kwd>Next</kwd> <def></def><sym>()</sym><br />
<def></def>	<sym>{</sym><br />
<def>		k</def><sym>++;</sym><br />
<def>		q</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>BigInteger</kwd> <def></def><sym>(</sym><def>k</def><sym>);</sym><br />
<def>		r</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>BigInteger</kwd> <def></def><sym>(</sym><def></def><num>4</num><def></def><sym>*</sym><def>k</def> <sym>+</sym> <def></def><num>2</num><def></def><sym>);</sym><br />
<def>		s</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>BigInteger</kwd> <def></def><sym>(</sym><def></def><num>0</num><def></def><sym>);</sym><br />
<def>		t</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>BigInteger</kwd> <def></def><sym>(</sym><def></def><num>2</num><def></def><sym>*</sym><def>k</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def></def><br />
		<kwa>return this</kwa><def></def><sym>;</sym><br />
<def></def>	<sym>}</sym><br />
<def></def><br />
	<kwa>public</kwa> <def></def><kwb>int</kwb> <def></def><kwd>Extract</kwd> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>j</def><sym>)</sym><br />
<def></def>	<sym>{</sym><br />
<def>		BigInteger J</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>BigInteger</kwd> <def></def><sym>(</sym><def>j</def><sym>);</sym><br />
<def></def>		<kwa>return</kwa> <def></def><sym>((</sym><def>q</def> <sym>*</sym> <def>J</def> <sym>+</sym> <def>r</def><sym>) / (</sym><def>s</def> <sym>*</sym> <def>J</def> <sym>+</sym> <def>t</def><sym>)).</sym><def></def><kwd>IntValue</kwd> <def></def><sym>();</sym><br />
<def></def>	<sym>}</sym><br />
<def></def><br />
	<kwa>public</kwa> <def>Transformation</def> <kwd>qrst</kwd> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>q</def><sym>,</sym> <def></def><kwb>int</kwb> <def>r</def><sym>,</sym> <def></def><kwb>int</kwb> <def>s</def><sym>,</sym> <def></def><kwb>int</kwb> <def>t</def><sym>)</sym><br />
<def></def>	<sym>{</sym><br />
<def></def>		<kwa>this</kwa><def></def><sym>.</sym><def>q</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>BigInteger</kwd> <def></def><sym>(</sym><def>q</def><sym>);</sym><br />
<def></def>		<kwa>this</kwa><def></def><sym>.</sym><def>r</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>BigInteger</kwd> <def></def><sym>(</sym><def>r</def><sym>);</sym><br />
<def></def>		<kwa>this</kwa><def></def><sym>.</sym><def>s</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>BigInteger</kwd> <def></def><sym>(</sym><def>s</def><sym>);</sym><br />
<def></def>		<kwa>this</kwa><def></def><sym>.</sym><def>t</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>BigInteger</kwd> <def></def><sym>(</sym><def>t</def><sym>);</sym><br />
<def>		k</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def><br />
		<kwa>return this</kwa><def></def><sym>;</sym><br />
<def></def>	<sym>}</sym><br />
<def></def><br />
	<kwa>public</kwa> <def>Transformation</def> <kwd>Compose</kwd> <def></def><sym>(</sym><def>Transformation a</def><sym>)</sym><br />
<def></def>	<sym>{</sym><br />
<def></def>		<kwa>return new</kwa> <def></def><kwd>Transformation</kwd> <def></def><sym>(</sym><def>q</def><sym>*</sym><def>a</def><sym>.</sym><def>q</def><sym>,</sym> <def>q</def><sym>*</sym><def>a</def><sym>.</sym><def>r</def> <sym>+</sym> <def>r</def><sym>*</sym><def>a</def><sym>.</sym><def>t</def><sym>,</sym> <def>s</def><sym>*</sym><def>a</def><sym>.</sym><def>q</def> <sym>+</sym> <def>t</def><sym>*</sym><def>a</def><sym>.</sym><def>s</def><sym>,</sym> <def>s</def><sym>*</sym><def>a</def><sym>.</sym><def>r</def> <sym>+</sym> <def>t</def><sym>*</sym><def>a</def><sym>.</sym><def>t</def><sym>);</sym><br />
<def></def>	<sym>}</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwa>class</kwa> <def>BigInteger</def><br />
<sym>{</sym><br />
<def></def>	<kwa>protected</kwa> <def>UBigInteger bi</def><sym>;</sym><br />
<def></def>	<kwa>protected</kwa> <def>Sign sign</def><sym>;</sym><br />
<def></def><br />
	<kwa>protected</kwa> <def></def><kwd>BigInteger</kwd> <def></def><sym>() {}</sym><br />
<def></def><br />
	<kwa>public</kwa> <def></def><kwd>BigInteger</kwd> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def></def><kwa>value</kwa><def></def><sym>)</sym><br />
<def></def>	<sym>{</sym><br />
<def></def>		<kwa>if</kwa> <def></def><sym>(</sym><def></def><kwa>value</kwa> <def></def><sym>==</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def>			sign</def> <sym>=</sym> <def>Sign</def><sym>.</sym><def>Zero</def><sym>;</sym><br />
<def></def>		<kwa>else if</kwa> <def></def><sym>(</sym><def></def><kwa>value</kwa> <def></def><sym>&lt;</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def>			sign</def> <sym>=</sym> <def>Sign</def><sym>.</sym><def>Negative</def><sym>;</sym><br />
<def></def>		<kwa>else</kwa><br />
<def>			sign</def> <sym>=</sym> <def>Sign</def><sym>.</sym><def>Positive</def><sym>;</sym><br />
<def><br />
		bi</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>UBigInteger</kwd> <def></def><sym>((</sym><def></def><kwb>int</kwb><def></def><sym>)</sym><def>sign</def><sym>*</sym><def></def><kwa>value</kwa><def></def><sym>);</sym><br />
<def></def>	<sym>}</sym><br />
<def></def><br />
	<kwa>public</kwa> <def></def><kwb>int</kwb> <def></def><kwd>IntValue</kwd> <def></def><sym>()</sym><br />
<def></def>	<sym>{</sym><br />
<def></def>		<kwa>return</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb><def></def><sym>)</sym><def>sign</def> <sym>* (</sym><def></def><kwb>int</kwb><def></def><sym>)</sym><def>bi</def><sym>.</sym><def></def><kwd>GetBytes</kwd> <def></def><sym>()[</sym><def></def><num>0</num><def></def><sym>];</sym><br />
<def></def>	<sym>}</sym><br />
<def></def><br />
	<kwa>public override</kwa> <def></def><kwb>string</kwb> <def></def><kwd>ToString</kwd> <def></def><sym>()</sym><br />
<def></def>	<sym>{</sym><br />
<def></def>		<kwa>return</kwa> <def></def><sym>(</sym><def>sign</def> <sym>==</sym> <def>Sign</def><sym>.</sym><def>Negative ?</def> <str>&quot;-&quot;</str><def></def> <sym>:</sym> <def></def><str>&quot;&quot;</str><def></def><sym>) +</sym> <def>bi</def><sym>.</sym><def></def><kwd>ToString</kwd> <def></def><sym>();</sym><br />
<def></def>	<sym>}</sym><br />
<def></def><br />
	<kwa>public static</kwa> <def>BigInteger</def> <kwa>operator</kwa> <def></def><sym>* (</sym><def>BigInteger bi1</def><sym>,</sym> <def>BigInteger bi2</def><sym>)</sym><br />
<def></def>	<sym>{</sym><br />
<def>		BigInteger ret</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>BigInteger</kwd> <def></def><sym>();</sym><br />
<def>		ret</def><sym>.</sym><def>bi</def> <sym>=</sym> <def>bi1</def><sym>.</sym><def>bi</def> <sym>*</sym> <def>bi2</def><sym>.</sym><def>bi</def><sym>;</sym><br />
<def>		ret</def><sym>.</sym><def>sign</def> <sym>= (</sym><def>Sign</def><sym>) ((</sym><def></def><kwb>int</kwb><def></def><sym>)</sym><def>bi1</def><sym>.</sym><def>sign</def> <sym>* (</sym><def></def><kwb>int</kwb><def></def><sym>)</sym><def>bi2</def><sym>.</sym><def>sign</def><sym>);</sym><br />
<def></def>		<kwa>return</kwa> <def>ret</def><sym>;</sym><br />
<def></def>	<sym>}</sym><br />
<def></def><br />
	<kwa>public static</kwa> <def>BigInteger</def> <kwa>operator</kwa> <def></def><sym>/ (</sym><def>BigInteger bi1</def><sym>,</sym> <def>BigInteger bi2</def><sym>)</sym><br />
<def></def>	<sym>{</sym><br />
<def>		BigInteger ret</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>BigInteger</kwd> <def></def><sym>();</sym><br />
<def>		ret</def><sym>.</sym><def>bi</def> <sym>=</sym> <def>bi1</def><sym>.</sym><def>bi</def> <sym>/</sym> <def>bi2</def><sym>.</sym><def>bi</def><sym>;</sym><br />
<def>		ret</def><sym>.</sym><def>sign</def> <sym>= (</sym><def>Sign</def><sym>) ((</sym><def></def><kwb>int</kwb><def></def><sym>)</sym><def>bi1</def><sym>.</sym><def>sign</def> <sym>* (</sym><def></def><kwb>int</kwb><def></def><sym>)</sym><def>bi2</def><sym>.</sym><def>sign</def><sym>);</sym><br />
<def></def>		<kwa>return</kwa> <def>ret</def><sym>;</sym><br />
<def></def>	<sym>}</sym><br />
<def></def><br />
	<kwa>public static</kwa> <def>BigInteger</def> <kwa>operator</kwa> <def></def><sym>+ (</sym><def>BigInteger bi1</def><sym>,</sym> <def>BigInteger bi2</def><sym>)</sym><br />
<def></def>	<sym>{</sym><br />
<def>		BigInteger ret</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>BigInteger</kwd> <def></def><sym>();</sym><br />
<def></def>		<kwa>if</kwa> <def></def><sym>(</sym><def>bi1</def><sym>.</sym><def>sign</def> <sym>==</sym> <def>Sign</def><sym>.</sym><def>Zero</def><sym>)</sym><br />
<def></def>			<kwa>return</kwa> <def>bi2</def><sym>;</sym><br />
<def></def><br />
		<kwa>if</kwa> <def></def><sym>(</sym><def>bi2</def><sym>.</sym><def>sign</def> <sym>==</sym> <def>Sign</def><sym>.</sym><def>Zero</def><sym>)</sym><br />
<def></def>			<kwa>return</kwa> <def>bi1</def><sym>;</sym><br />
<def></def><br />
		<kwa>if</kwa> <def></def><sym>(</sym><def>bi1</def><sym>.</sym><def>sign</def> <sym>==</sym> <def>bi2</def><sym>.</sym><def>sign</def><sym>) {</sym><br />
<def>			ret</def><sym>.</sym><def>bi</def> <sym>=</sym> <def>bi1</def><sym>.</sym><def>bi</def> <sym>+</sym> <def>bi2</def><sym>.</sym><def>bi</def><sym>;</sym><br />
<def>			ret</def><sym>.</sym><def>sign</def> <sym>=</sym> <def>bi1</def><sym>.</sym><def>sign</def><sym>;</sym><br />
<def></def>			<kwa>return</kwa> <def>ret</def><sym>;</sym><br />
<def></def>		<sym>}</sym><br />
<def></def><br />
		<kwa>if</kwa> <def></def><sym>(</sym><def>bi1</def><sym>.</sym><def>bi</def> <sym>==</sym> <def>bi2</def><sym>.</sym><def>bi</def><sym>) {</sym><br />
<def>			ret</def><sym>.</sym><def>bi</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def>			ret</def><sym>.</sym><def>sign</def> <sym>=</sym> <def>Sign</def><sym>.</sym><def>Zero</def><sym>;</sym><br />
<def></def>			<kwa>return</kwa> <def>ret</def><sym>;</sym><br />
<def></def>		<sym>}</sym><br />
<def></def><br />
		<kwa>if</kwa> <def></def><sym>(</sym><def>bi1</def><sym>.</sym><def>bi</def> <sym>&lt;</sym> <def>bi2</def><sym>.</sym><def>bi</def><sym>) {</sym><br />
<def>			ret</def><sym>.</sym><def>bi</def> <sym>=</sym> <def>bi2</def><sym>.</sym><def>bi</def> <sym>-</sym> <def>bi1</def><sym>.</sym><def>bi</def><sym>;</sym><br />
<def>			ret</def><sym>.</sym><def>sign</def> <sym>= (</sym><def>Sign</def><sym>)((</sym><def></def><kwb>int</kwb><def></def><sym>)</sym><def>Sign</def><sym>.</sym><def>Positive</def> <sym>* (</sym><def></def><kwb>int</kwb><def></def><sym>)</sym><def>bi2</def><sym>.</sym><def>sign</def><sym>);</sym><br />
<def></def>			<kwa>return</kwa> <def>ret</def><sym>;</sym><br />
<def></def>		<sym>}</sym> <def></def><kwa>else</kwa> <def></def><sym>{</sym><br />
<def>			ret</def><sym>.</sym><def>bi</def> <sym>=</sym> <def>bi1</def><sym>.</sym><def>bi</def> <sym>-</sym> <def>bi2</def><sym>.</sym><def>bi</def><sym>;</sym><br />
<def>			ret</def><sym>.</sym><def>sign</def> <sym>= (</sym><def>Sign</def><sym>)((</sym><def></def><kwb>int</kwb><def></def><sym>)</sym><def>Sign</def><sym>.</sym><def>Negative</def> <sym>* (</sym><def></def><kwb>int</kwb><def></def><sym>)</sym><def>bi2</def><sym>.</sym><def>sign</def><sym>);</sym><br />
<def></def>			<kwa>return</kwa> <def>ret</def><sym>;</sym><br />
<def></def>		<sym>}</sym><br />
<def></def>	<sym>}</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
</source>
