<source>
<def></def><slc>-- The Computer Language Benchmarks Game</slc><br />
<def></def><slc>-- http://shootout.alioth.debian.org/</slc><br />
<def></def><slc>-- contributed by Jim Rogers</slc><br />
<def></def><br />
<kwa>with</kwa> <def>Ada.Text_Io</def><sym>;</sym> <def></def><kwa>use</kwa> <def>Ada.Text_Io</def><sym>;</sym><br />
<def></def><kwa>with</kwa> <def>Ada.Command_Line</def><sym>;</sym> <def></def><kwa>use</kwa> <def>Ada.Command_Line</def><sym>;</sym><br />
<def></def><kwa>with</kwa> <def>Ada.Integer_Text_IO</def><sym>;</sym> <def></def><kwa>use</kwa> <def>Ada.Integer_Text_IO</def><sym>;</sym><br />
<def></def><br />
<kwa>procedure</kwa> <def>ThreadRing</def> <kwa>is</kwa><br />
<def></def><br />
   <kwa>protected</kwa> <def>Flag</def> <kwa>is</kwa><br />
<def></def>      <kwa>procedure</kwa> <def>Set</def><sym>(</sym><def>Num</def> <sym>:</sym> <def></def><kwb>Positive</kwb><def></def><sym>);</sym><br />
<def></def>      <kwa>entry</kwa> <def>Wait</def><sym>(</sym><def>Last</def> <sym>:</sym> <def></def><kwa>out</kwa> <def></def><kwb>Positive</kwb><def></def><sym>);</sym><br />
<def></def>   <kwa>private</kwa><br />
<def>      Done</def> <sym>:</sym> <def></def><kwb>Boolean</kwb> <def></def><sym>:=</sym> <def>False</def><sym>;</sym><br />
<def>      Id</def> <sym>:</sym> <def></def><kwb>Positive</kwb><def></def><sym>;</sym><br />
<def></def>   <kwa>end</kwa> <def>Flag</def><sym>;</sym><br />
<def></def>   <kwa>protected body</kwa> <def>Flag</def> <kwa>is</kwa><br />
<def></def>      <kwa>procedure</kwa> <def>Set</def><sym>(</sym><def>Num</def> <sym>:</sym> <def></def><kwb>Positive</kwb><def></def><sym>)</sym> <def></def><kwa>is</kwa><br />
<def></def>      <kwa>begin</kwa><br />
<def>         Done</def> <sym>:=</sym> <def>True</def><sym>;</sym><br />
<def>         Id</def> <sym>:=</sym> <def>Num</def><sym>;</sym><br />
<def></def>      <kwa>end</kwa> <def>Set</def><sym>;</sym><br />
<def></def>      <kwa>entry</kwa> <def>Wait</def><sym>(</sym><def>Last</def> <sym>:</sym> <def></def><kwa>out</kwa> <def></def><kwb>Positive</kwb><def></def><sym>)</sym> <def></def><kwa>when</kwa> <def>Done</def> <kwa>is</kwa><br />
<def></def>      <kwa>begin</kwa><br />
<def>         Last</def> <sym>:=</sym> <def>Id</def><sym>;</sym><br />
<def></def>      <kwa>end</kwa> <def>Wait</def><sym>;</sym><br />
<def></def>   <kwa>end</kwa> <def>Flag</def><sym>;</sym><br />
<def></def><br />
   <kwa>type</kwa> <def>Node</def><sym>;</sym><br />
<def></def>   <kwa>type</kwa> <def>Node_Access</def> <kwa>is access</kwa> <def>Node</def><sym>;</sym><br />
<def><br />
   Ring</def> <sym>:</sym> <def></def><kwa>array</kwa><def></def><sym>(</sym><def></def><num>1</num><def>.</def><num>.503</num><def></def><sym>)</sym> <def></def><kwa>of</kwa> <def>Node_Access</def><sym>;</sym><br />
<def></def><br />
   <kwa>task type</kwa> <def>Node</def><sym>(</sym><def>Id</def> <sym>:</sym> <def></def><kwb>Positive</kwb><def></def><sym>)</sym> <def></def><kwa>is</kwa><br />
<def></def>      <kwa>entry</kwa> <def>Start</def><sym>(</sym><def>Next</def> <sym>:</sym> <def>Node_Access</def><sym>);</sym><br />
<def></def>      <kwa>entry</kwa> <def>Put</def><sym>(</sym><def>Item</def> <sym>:</sym> <def></def><kwa>in</kwa> <def></def><kwb>Natural</kwb><def></def><sym>);</sym><br />
<def></def>      <kwa>entry</kwa> <def>Stop</def><sym>;</sym><br />
<def></def>   <kwa>end</kwa> <def>Node</def><sym>;</sym><br />
<def></def><br />
   <kwa>task body</kwa> <def>Node</def> <kwa>is</kwa><br />
<def>      Val</def> <sym>:</sym> <def></def><kwb>Natural</kwb><def></def><sym>;</sym><br />
<def>      Next_Node</def> <sym>:</sym> <def>Node_Access</def><sym>;</sym><br />
<def></def>   <kwa>begin</kwa><br />
<def></def>      <kwa>accept</kwa> <def>Start</def><sym>(</sym><def>Next</def> <sym>:</sym> <def>Node_Access</def><sym>)</sym> <def></def><kwa>do</kwa><br />
<def>         Next_Node</def> <sym>:=</sym> <def>Next</def><sym>;</sym><br />
<def></def>      <kwa>end</kwa> <def>Start</def><sym>;</sym><br />
<def></def><br />
      <kwa>loop</kwa><br />
<def></def>         <kwa>select</kwa><br />
<def></def>            <kwa>accept</kwa> <def>Put</def><sym>(</sym><def>Item</def> <sym>:</sym> <def></def><kwa>in</kwa> <def></def><kwb>Natural</kwb><def></def><sym>)</sym> <def></def><kwa>do</kwa><br />
<def>               Val</def> <sym>:=</sym> <def>Item</def><sym>;</sym><br />
<def></def>            <kwa>end</kwa> <def>Put</def><sym>;</sym><br />
<def></def>         <kwa>or</kwa><br />
<def></def>            <kwa>accept</kwa> <def>Stop</def><sym>;</sym><br />
<def></def>            <kwa>exit</kwa><def></def><sym>;</sym><br />
<def></def>         <kwa>end select</kwa><def></def><sym>;</sym><br />
<def></def>         <kwa>if</kwa> <def>Val</def> <sym>&gt;</sym> <def></def><num>0</num> <def></def><kwa>then</kwa><br />
<def>            Val</def> <sym>:=</sym> <def>Val</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def>            Next_Node.Put</def><sym>(</sym><def>Val</def><sym>);</sym><br />
<def></def>         <kwa>else</kwa><br />
<def>            Flag.Set</def><sym>(</sym><def>Id</def><sym>);</sym><br />
<def></def>         <kwa>end if</kwa><def></def><sym>;</sym><br />
<def></def>      <kwa>end loop</kwa><def></def><sym>;</sym><br />
<def></def>   <kwa>end</kwa> <def>Node</def><sym>;</sym><br />
<def><br />
   Num_Passes</def> <sym>:</sym> <def></def><kwb>Natural</kwb><def></def><sym>;</sym><br />
<def>   Last_Node</def> <sym>:</sym> <def></def><kwb>Positive</kwb><def></def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def>   Num_Passes</def> <sym>:=</sym> <def></def><kwb>Natural</kwb><def></def><sym>'</sym><def>Value</def><sym>(</sym><def>Argument</def><sym>(</sym><def></def><num>1</num><def></def><sym>));</sym><br />
<def></def>   <kwa>for</kwa> <def>I</def> <kwa>in</kwa> <def>Ring</def><sym>'</sym><def></def><kwa>range loop</kwa><br />
<def>      Ring</def><sym>(</sym><def>I</def><sym>) :=</sym> <def></def><kwa>new</kwa> <def>Node</def><sym>(</sym><def>I</def><sym>);</sym><br />
<def></def>   <kwa>end loop</kwa><def></def><sym>;</sym><br />
<def>   Ring</def><sym>(</sym><def>Ring</def><sym>'</sym><def>Last</def><sym>)</sym><def>.Start</def><sym>(</sym><def>Ring</def><sym>(</sym><def></def><num>1</num><def></def><sym>));</sym><br />
<def></def>   <kwa>for</kwa> <def>I</def> <kwa>in</kwa> <def>Ring</def><sym>'</sym><def>First..Ring</def><sym>'</sym><def>Last</def> <sym>-</sym> <def></def><num>1</num> <def></def><kwa>loop</kwa><br />
<def>      Ring</def><sym>(</sym><def>I</def><sym>)</sym><def>.Start</def><sym>(</sym><def>Ring</def><sym>(</sym><def>I</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>));</sym><br />
<def></def>   <kwa>end loop</kwa><def></def><sym>;</sym><br />
<def>   Ring</def><sym>(</sym><def></def><num>1</num><def></def><sym>)</sym><def>.Put</def><sym>(</sym><def>Num_Passes</def><sym>);</sym><br />
<def>   Flag.Wait</def><sym>(</sym><def>Last_Node</def><sym>);</sym><br />
<def>   Put</def><sym>(</sym><def>Item</def> <sym>=&gt;</sym> <def>Last_Node</def><sym>,</sym> <def>Width</def> <sym>=&gt;</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def>   New_Line</def><sym>;</sym><br />
<def></def>   <kwa>for</kwa> <def>I</def> <kwa>in</kwa> <def>Ring</def><sym>'</sym><def></def><kwa>range loop</kwa><br />
<def>      Ring</def><sym>(</sym><def>I</def><sym>)</sym><def>.Stop</def><sym>;</sym><br />
<def></def>   <kwa>end loop</kwa><def></def><sym>;</sym><br />
<def></def><br />
<kwa>end</kwa> <def>ThreadRing</def><sym>;</sym><def></def><br />
</source>
