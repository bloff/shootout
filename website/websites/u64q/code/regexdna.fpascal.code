<source>
<def></def><com>(*</com><br />
<com>  The Computer Language Benchmarks Game</com><br />
<com>  http://shootout.alioth.debian.org</com><br />
<com></com><br />
<com>  regex-dna benchmark using libpcre</com><br />
<com></com><br />
<com>  contributed by Vitaly Trifonov</com><br />
<com>*)</com><def></def><br />
<br />
<com>{$Mode objfpc}</com><def></def><br />
<com>{$INLINE ON}</com><def></def><br />
<br />
<com>{$IFNDEF DEBUG}</com><def></def><br />
<com>{$CHECKPOINTER OFF}</com><def></def><br />
<com>{$RANGECHECKS OFF}</com><def></def><br />
<com>{$OVERFLOWCHECKS OFF}</com><def></def><br />
<com>{$IOCHECKS OFF}</com><def></def><br />
<com>{$ENDIF}</com><def></def><br />
<br />
<kwa>uses</kwa> <def>sysutils</def><sym>;</sym><br />
<def></def><br />
<com>(******************************    pcre wrap   *****************************)</com><def></def><br />
<br />
<kwa>const</kwa><br />
<def>  libpcre</def> <sym>=</sym> <def></def><str>'pcre'</str><def></def><sym>;</sym><br />
<def>  PCRE_CASELESS</def> <sym>=</sym> <def></def><num>$00000001</num><def></def><sym>;</sym><br />
<def></def><br />
<kwa>type</kwa><br />
<def>  pcre</def> <sym>=</sym> <def></def><kwb>Pointer</kwb><def></def><sym>;</sym><br />
<def>  pcre_extra</def> <sym>=</sym> <def></def><kwb>Pointer</kwb><def></def><sym>;</sym><br />
<def>  PPChar</def> <sym>= ^</sym><def>PChar</def><sym>;</sym><br />
<def></def><br />
<br />
<kwa>function</kwa> <def></def><kwd>pcre_compile</kwd><def></def><sym>(</sym> <def></def><kwa>const</kwa> <def>pattern</def><sym>:</sym> <def>PChar</def><sym>;</sym><br />
<def>                       options</def><sym>:</sym> <def></def><kwb>Integer</kwb><def></def><sym>;</sym><br />
<def></def>                       <kwa>const</kwa> <def>errptr</def><sym>:</sym> <def>PPChar</def><sym>;</sym><br />
<def>                       erroffset</def><sym>:</sym> <def>PInteger</def><sym>;</sym><br />
<def></def>                       <kwa>const</kwa> <def>tableptr</def><sym>:</sym> <def>PChar</def> <sym>):</sym> <def>pcre</def><sym>;</sym> <def></def><kwa>cdecl</kwa><def></def><sym>;</sym> <def></def><kwa>external</kwa> <def>libpcre</def><sym>;</sym><br />
<def></def><br />
<kwa>function</kwa> <def></def><kwd>pcre_exec</kwd><def></def><sym>(</sym> <def></def><kwa>const</kwa> <def>code</def><sym>:</sym> <def>pcre</def><sym>;</sym><br />
<def></def>                    <kwa>const</kwa> <def>extra</def><sym>:</sym> <def>pcre_extra</def><sym>;</sym><br />
<def></def>                    <kwa>const</kwa> <def>subject</def><sym>:</sym> <def>PChar</def><sym>;</sym><br />
<def>                    length</def><sym>,</sym> <def>startoffset</def><sym>,</sym> <def>options</def><sym>:</sym> <def></def><kwb>Integer</kwb><def></def><sym>;</sym><br />
<def>                    ovector</def><sym>:</sym> <def>PInteger</def><sym>;</sym><br />
<def>                    ovecsize</def><sym>:</sym> <def></def><kwb>Integer</kwb> <def></def><sym>):</sym> <def></def><kwb>Integer</kwb><def></def><sym>;</sym> <def></def><kwa>cdecl</kwa><def></def><sym>;</sym> <def></def><kwa>external</kwa> <def>libpcre</def><sym>;</sym><br />
<def></def><br />
<kwa>function</kwa> <def></def><kwd>pcre_study</kwd><def></def><sym>(</sym> <def></def><kwa>const</kwa> <def>external_re</def><sym>:</sym> <def>pcre</def><sym>;</sym><br />
<def>                     options</def><sym>:</sym> <def></def><kwb>integer</kwb><def></def><sym>;</sym><br />
<def>                     errorptr</def><sym>:</sym> <def>PPChar</def> <sym>):</sym> <def>pcre_extra</def><sym>;</sym> <def></def><kwa>cdecl</kwa><def></def><sym>;</sym> <def></def><kwa>external</kwa> <def>libpcre</def><sym>;</sym><br />
<def></def><br />
<com>(***************************************************************************)</com><def></def><br />
<br />
<kwa>const</kwa><br />
<def>  patt</def><sym>:</sym> <def></def><kwa>array</kwa><def></def><sym>[</sym><def></def><num>0</num><def></def><sym>.</sym><def></def><num>.10</num><def></def><sym>]</sym> <def></def><kwa>of</kwa> <def>PChar</def> <sym>= (</sym><def></def><str>'B'</str><def></def><sym>,</sym><def></def><str>'D'</str><def></def><sym>,</sym><def></def><str>'H'</str><def></def><sym>,</sym><def></def><str>'K'</str><def></def><sym>,</sym><def></def><str>'M'</str><def></def><sym>,</sym><def></def><str>'N'</str><def></def><sym>,</sym><def></def><str>'R'</str><def></def><sym>,</sym><def></def><str>'S'</str><def></def><sym>,</sym><def></def><str>'V'</str><def></def><sym>,</sym><def></def><str>'W'</str><def></def><sym>,</sym><def></def><str>'Y'</str><def></def><sym>);</sym><br />
<def>  repl</def><sym>:</sym> <def></def><kwa>array</kwa><def></def><sym>[</sym><def></def><num>0</num><def></def><sym>.</sym><def></def><num>.10</num><def></def><sym>]</sym> <def></def><kwa>of</kwa> <def>PChar</def> <sym>= (</sym><def></def><str>'(c|g|t)'</str><def></def><sym>,</sym> <def></def><str>'(a|g|t)'</str><def></def><sym>,</sym> <def></def><str>'(a|c|t)'</str><def></def><sym>,</sym> <def></def><str>'(g|t)'</str><def></def><sym>,</sym><br />
<def></def>      <str>'(a|c)'</str><def></def><sym>,</sym><def></def><str>'(a|c|g|t)'</str><def></def><sym>,</sym> <def></def><str>'(a|g)'</str><def></def><sym>,</sym> <def></def><str>'(c|g)'</str><def></def><sym>,</sym> <def></def><str>'(a|c|g)'</str><def></def><sym>,</sym> <def></def><str>'(a|t)'</str><def></def><sym>,</sym> <def></def><str>'(c|t)'</str><def></def><sym>);</sym><br />
<def></def><br />
<kwa>var</kwa><br />
<def>  patterns</def><sym>:</sym> <def></def><kwa>array</kwa><def></def><sym>[</sym><def></def><num>0</num><def></def><sym>.</sym><def></def><num>.8</num><def></def><sym>]</sym> <def></def><kwa>of</kwa> <def>PChar</def> <sym>=</sym><br />
<def></def>    <sym>(</sym><br />
<def></def>      <str>'agggtaaa|tttaccct'</str><def></def><sym>,</sym><br />
<def></def>      <str>'[cgt]gggtaaa|tttaccc[acg]'</str><def></def><sym>,</sym><br />
<def></def>      <str>'a[act]ggtaaa|tttacc[agt]t'</str><def></def><sym>,</sym><br />
<def></def>      <str>'ag[act]gtaaa|tttac[agt]ct'</str><def></def><sym>,</sym><br />
<def></def>      <str>'agg[act]taaa|ttta[agt]cct'</str><def></def><sym>,</sym><br />
<def></def>      <str>'aggg[acg]aaa|ttt[cgt]ccct'</str><def></def><sym>,</sym><br />
<def></def>      <str>'agggt[cgt]aa|tt[acg]accct'</str><def></def><sym>,</sym><br />
<def></def>      <str>'agggta[cgt]a|t[acg]taccct'</str><def></def><sym>,</sym><br />
<def></def>      <str>'agggtaa[cgt]|[acg]ttaccct'</str><def></def><br />
    <sym>);</sym><br />
<def></def><br />
<br />
<com>(* Count match with pattern of regexp in seq buffer. *)</com><def></def><br />
<kwa>function</kwa> <def></def><kwd>count</kwd><def></def><sym>(</sym> <def></def><kwa>const</kwa> <def>pattern</def><sym>,</sym> <def>seq</def><sym>:</sym> <def>PChar</def><sym>;</sym> <def>len</def><sym>:</sym> <def></def><kwb>Integer</kwb> <def></def><sym>):</sym> <def></def><kwb>Longint</kwb><def></def><sym>;</sym><br />
<def></def><kwa>var</kwa><br />
<def>  cre</def><sym>:</sym> <def>pcre</def><sym>;</sym><br />
<def>  cre_ex</def><sym>:</sym> <def>pcre_extra</def><sym>;</sym><br />
<def>  err</def><sym>:</sym> <def>PChar</def><sym>;</sym><br />
<def>  ofs</def><sym>:</sym> <def></def><kwb>Integer</kwb><def></def><sym>;</sym><br />
<def>  ind</def><sym>:</sym> <def></def><kwb>Longint</kwb> <def></def><sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def>  m</def><sym>:</sym> <def></def><kwa>array</kwa><def></def><sym>[</sym><def></def><num>0</num><def></def><sym>.</sym><def></def><num>.2</num><def></def><sym>]</sym> <def></def><kwa>of</kwa> <def></def><kwb>Integer</kwb><def></def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def>  cre</def> <sym>:=</sym> <def></def><kwd>pcre_compile</kwd><def></def><sym>(</sym><def>pattern</def><sym>,</sym> <def></def><num>0</num><def></def><sym>, @</sym><def>err</def><sym>, @</sym><def>ofs</def><sym>,</sym> <def></def><kwa>nil</kwa><def></def><sym>);</sym><br />
<def>  cre_ex</def> <sym>:=</sym> <def></def><kwd>pcre_study</kwd><def></def><sym>(</sym><def>cre</def><sym>,</sym> <def></def><num>0</num><def></def><sym>, @</sym><def>err</def><sym>);</sym><br />
<def>  m</def><sym>[</sym><def></def><num>1</num><def></def><sym>] :=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def><br />
  <kwa>while</kwa> <def></def><kwd>pcre_exec</kwd><def></def><sym>(</sym><def>cre</def><sym>,</sym>   <def>cre_ex</def><sym>,</sym> <def>seq</def><sym>,</sym> <def>len</def><sym>,</sym>   <def>m</def><sym>[</sym><def></def><num>1</num><def></def><sym>],</sym> <def></def><num>0</num><def></def><sym>,</sym> <def>m</def><sym>,</sym> <def></def><num>3</num><def></def><sym>) &gt;=</sym> <def></def><num>0</num> <def></def><kwa>do</kwa><br />
<def>    ind</def> <sym>+=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def><br />
  count</def> <sym>:=</sym> <def>ind</def><br />
<kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><br />
<kwa>function</kwa> <def></def><kwd>split_count</kwd> <def></def><sym>(</sym> <def></def><kwa>const</kwa> <def>pattern</def><sym>,</sym> <def>seq</def><sym>:</sym> <def>PChar</def><sym>;</sym> <def>len</def><sym>:</sym> <def></def><kwb>Integer</kwb> <def></def><sym>):</sym> <def></def><kwb>Longint</kwb><def></def><sym>;</sym> <def></def><kwa>inline</kwa><def></def><sym>;</sym><br />
<def></def><kwa>var</kwa><br />
<def>  split</def><sym>:</sym> <def>PChar</def><sym>;</sym><br />
<def>  vcount</def><sym>:</sym> <def></def><kwb>Longint</kwb><def></def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def>  split</def> <sym>:=</sym> <def></def><kwd>strscan</kwd><def></def><sym>(</sym><def>pattern</def><sym>,</sym> <def></def><str>'|'</str><def></def><sym>);</sym><br />
<def></def>  <kwb>Byte</kwb><def></def><sym>(</sym><def>split</def><sym>^) :=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def><br />
  vcount</def> <sym>:=</sym> <def></def><kwd>count</kwd><def></def><sym>(</sym><def>pattern</def><sym>,</sym> <def>seq</def><sym>,</sym> <def>len</def><sym>);</sym><br />
<def>  vcount</def> <sym>+=</sym> <def></def><kwd>count</kwd><def></def><sym>(@</sym><def>split</def><sym>[</sym><def></def><num>1</num><def></def><sym>],</sym> <def>seq</def><sym>,</sym> <def>len</def><sym>);</sym><br />
<def><br />
  split</def><sym>^ :=</sym> <def></def><str>'|'</str><def></def><sym>;</sym><br />
<def>  split_count</def> <sym>:=</sym> <def>vcount</def><br />
<kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><br />
<com>(* Substitute pattern of regexp with repl, return new length. *)</com><def></def><br />
<kwa>function</kwa> <def></def><kwd>subst</kwd><def></def><sym>(</sym> <def></def><kwa>const</kwa> <def>pattern</def><sym>,</sym> <def>repl</def><sym>:</sym> <def>PChar</def><sym>;</sym> <def></def><kwa>var</kwa> <def>seq</def><sym>:</sym> <def>PChar</def><sym>;</sym> <def>len</def><sym>:</sym> <def></def><kwb>Integer</kwb> <def></def><sym>):</sym> <def></def><kwb>Longint</kwb><def></def><sym>;</sym><br />
<def></def><kwa>var</kwa><br />
<def>  cre</def><sym>:</sym> <def>pcre</def><sym>;</sym><br />
<def>  cre_ex</def><sym>:</sym> <def>pcre_extra</def><sym>;</sym><br />
<def>  err</def><sym>:</sym> <def>PChar</def><sym>;</sym><br />
<def>  ofs</def><sym>:</sym> <def></def><kwb>Integer</kwb><def></def><sym>;</sym><br />
<def>  size_repl</def><sym>,</sym> <def>size</def><sym>,</sym> <def>bsize</def><sym>,</sym> <def>pos</def><sym>:</sym> <def></def><kwb>Longint</kwb><def></def><sym>;</sym><br />
<def>  m</def><sym>:</sym> <def></def><kwa>array</kwa><def></def><sym>[</sym><def></def><num>0</num><def></def><sym>.</sym><def></def><num>.2</num><def></def><sym>]</sym> <def></def><kwa>of</kwa> <def></def><kwb>Integer</kwb><def></def><sym>;</sym><br />
<def>  newSeq</def><sym>,</sym> <def>otmpseq</def><sym>:</sym> <def>PChar</def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def>  cre</def> <sym>:=</sym> <def></def><kwd>pcre_compile</kwd><def></def><sym>(</sym><def>pattern</def><sym>,</sym> <def></def><num>0</num><def></def><sym>, @</sym><def>err</def><sym>, @</sym><def>ofs</def><sym>,</sym> <def></def><kwa>nil</kwa><def></def><sym>);</sym><br />
<def>  cre_ex</def> <sym>:=</sym> <def></def><kwd>pcre_study</kwd><def></def><sym>(</sym><def>cre</def><sym>,</sym> <def></def><num>0</num><def></def><sym>, @</sym><def>err</def><sym>);</sym><br />
<def>  size_repl</def> <sym>:=</sym> <def></def><kwd>strlen</kwd><def></def><sym>(</sym><def>repl</def><sym>);</sym><br />
<def>  m</def><sym>[</sym><def></def><num>1</num><def></def><sym>] :=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>size</def> <sym>:=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def><br />
<com>(* Calculate required size for malloc. *)</com><def></def><br />
  <kwa>while</kwa> <def></def><kwd>pcre_exec</kwd><def></def><sym>(</sym><def>cre</def><sym>,</sym>   <def>cre_ex</def><sym>,</sym> <def>seq</def><sym>,</sym> <def>len</def><sym>,</sym>   <def>m</def><sym>[</sym><def></def><num>1</num><def></def><sym>],</sym> <def></def><num>0</num><def></def><sym>,</sym> <def>m</def><sym>,</sym> <def></def><num>3</num><def></def><sym>) &gt;=</sym> <def></def><num>0</num> <def></def><kwa>do</kwa><br />
<def>    size</def> <sym>+=</sym> <def>size_repl</def> <sym>-</sym> <def>m</def><sym>[</sym><def></def><num>1</num><def></def><sym>] +</sym> <def>m</def><sym>[</sym><def></def><num>0</num><def></def><sym>];</sym><br />
<def>  size</def> <sym>+=</sym> <def>len</def><sym>;</sym><br />
<def></def><br />
  <kwd>GetMem</kwd><def></def><sym>(</sym><def>newSeq</def><sym>,</sym> <def></def><kwd>SizeOf</kwd><def></def><sym>(</sym><def></def><kwb>Char</kwb><def></def><sym>)*</sym><def>size</def><sym>);</sym><br />
<def></def><br />
<com>(* Do substitute. *)</com><def><br />
  m</def><sym>[</sym><def></def><num>1</num><def></def><sym>] :=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>pos</def> <sym>:=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def>  otmpseq</def> <sym>:=</sym> <def>newSeq</def><sym>;</sym><br />
<def></def><br />
<br />
  <kwa>if</kwa> <def>size_repl</def> <sym>&lt;&gt;</sym> <def></def><num>0</num> <def></def><kwa>then</kwa><br />
<def></def>    <kwa>while</kwa> <def></def><kwd>pcre_exec</kwd><def></def><sym>(</sym><def>cre</def><sym>,</sym>   <def>cre_ex</def><sym>,</sym> <def>seq</def><sym>,</sym> <def>len</def><sym>,</sym>   <def>m</def><sym>[</sym><def></def><num>1</num><def></def><sym>],</sym> <def></def><num>0</num><def></def><sym>,</sym> <def>m</def><sym>,</sym> <def></def><num>3</num><def></def><sym>) &gt;=</sym> <def></def><num>0</num> <def></def><kwa>do</kwa><br />
<def></def>    <kwa>begin</kwa><br />
<def>      bsize</def> <sym>:=</sym> <def>m</def><sym>[</sym><def></def><num>0</num><def></def><sym>] -</sym> <def>pos</def><sym>;</sym><br />
<def></def>      <kwd>strlcopy</kwd><def></def><sym>(</sym><def>otmpseq</def><sym>, @</sym><def>seq</def><sym>[</sym><def>pos</def><sym>],</sym> <def>bsize</def><sym>);</sym><br />
<def><br />
      otmpseq</def> <sym>:= @</sym><def>otmpseq</def><sym>[</sym><def>bsize</def><sym>];</sym><br />
<def>      pos</def> <sym>:=</sym> <def>m</def><sym>[</sym><def></def><num>1</num><def></def><sym>];</sym><br />
<def><br />
      otmpseq</def> <sym>:=</sym> <def></def><kwd>strecopy</kwd><def></def><sym>(</sym><def>otmpseq</def><sym>,</sym> <def>repl</def><sym>);</sym><br />
<def></def>    <kwa>end</kwa><br />
<def></def>  <kwa>else</kwa><br />
<def></def>    <kwa>while</kwa> <def></def><kwd>pcre_exec</kwd><def></def><sym>(</sym><def>cre</def><sym>,</sym>   <def>cre_ex</def><sym>,</sym> <def>seq</def><sym>,</sym> <def>len</def><sym>,</sym>   <def>m</def><sym>[</sym><def></def><num>1</num><def></def><sym>],</sym> <def></def><num>0</num><def></def><sym>,</sym> <def>m</def><sym>,</sym> <def></def><num>3</num><def></def><sym>) &gt;=</sym> <def></def><num>0</num> <def></def><kwa>do</kwa><br />
<def></def>    <kwa>begin</kwa><br />
<def>      bsize</def> <sym>:=</sym> <def>m</def><sym>[</sym><def></def><num>0</num><def></def><sym>] -</sym> <def>pos</def><sym>;</sym><br />
<def></def>      <kwd>strlcopy</kwd><def></def><sym>(</sym><def>otmpseq</def><sym>, @</sym><def>seq</def><sym>[</sym><def>pos</def><sym>],</sym> <def>bsize</def><sym>);</sym><br />
<def><br />
      otmpseq</def> <sym>:= @</sym><def>otmpseq</def><sym>[</sym><def>bsize</def><sym>];</sym><br />
<def>      pos</def> <sym>:=</sym> <def>m</def><sym>[</sym><def></def><num>1</num><def></def><sym>];</sym><br />
<def></def>    <kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><br />
  <kwd>strcopy</kwd><def></def><sym>(</sym><def>otmpseq</def><sym>, @</sym><def>seq</def><sym>[</sym><def>pos</def><sym>]);</sym><br />
<def></def><br />
  <kwd>FreeMem</kwd><def></def><sym>(</sym><def>seq</def><sym>);</sym><br />
<def>  seq</def> <sym>:=</sym> <def>newSeq</def><sym>;</sym><br />
<def><br />
  subst</def> <sym>:=</sym> <def>size</def><br />
<kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><br />
<br />
<kwa>var</kwa><br />
<def>  readLen</def><sym>:</sym> <def></def><kwb>Longint</kwb> <def></def><sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def>  maxSeqLen</def><sym>:</sym> <def></def><kwb>Longint</kwb> <def></def><sym>=</sym> <def></def><num>6000000</num><def></def><sym>;</sym><br />
<def>  seqLen</def><sym>:</sym> <def></def><kwb>Longint</kwb> <def></def><sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def>  seq</def><sym>,</sym> <def>newSeq</def><sym>:</sym> <def>PChar</def><sym>;</sym><br />
<def>  ch</def><sym>:</sym> <def></def><kwb>Char</kwb><def></def><sym>;</sym><br />
<def>  i</def><sym>:</sym> <def></def><kwb>Longint</kwb><def></def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def></def>  <kwd>GetMem</kwd><def></def><sym>(</sym><def>seq</def><sym>,</sym> <def></def><kwd>SizeOf</kwd><def></def><sym>(</sym><def></def><kwb>Char</kwb><def></def><sym>)*(</sym><def>maxSeqLen</def><sym>+</sym><def></def><num>1</num><def></def><sym>));</sym><br />
<def></def><br />
<com>(* Read FASTA format file from stdin and count length. *)</com><def></def><br />
  <kwa>while not</kwa> <def>eof</def> <kwa>do</kwa><br />
<def></def>  <kwa>begin</kwa><br />
<def></def>    <kwa>if</kwa> <def>readLen</def> <sym>=</sym> <def>maxSeqLen</def> <kwa>then</kwa><br />
<def></def>    <kwa>begin</kwa><br />
<def>      maxSeqLen</def> <sym>+=</sym> <def></def><num>3000000</num><def></def><sym>;</sym><br />
<def>      seq</def> <sym>:=</sym> <def></def><kwd>ReAllocMem</kwd><def></def><sym>(</sym><def>seq</def><sym>,</sym> <def></def><kwd>SizeOf</kwd><def></def><sym>(</sym><def></def><kwb>Char</kwb><def></def><sym>)*(</sym><def>maxSeqLen</def><sym>+</sym><def></def><num>1</num><def></def><sym>));</sym><br />
<def></def>    <kwa>end</kwa><def></def><sym>;</sym><br />
<def></def>    <kwd>read</kwd><def></def><sym>(</sym><def>seq</def><sym>[</sym><def>readLen</def><sym>]);</sym><br />
<def>    readLen</def> <sym>+=</sym> <def></def><num>1</num><br />
<def></def>  <kwa>end</kwa><def></def><sym>;</sym><br />
<def></def>  <kwb>Byte</kwb><def></def><sym>(</sym><def>seq</def><sym>[</sym><def>readLen</def><sym>]) :=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def></def><slc>//end read data</slc><br />
<def></def><br />
<br />
<com>(* Remove FASTA sequence descriptions and all linefeed characters.  *)</com><def><br />
  seqLen</def> <sym>:=</sym> <def></def><kwd>subst</kwd><def></def><sym>(</sym><def></def><str>'&gt;.*|\n'</str><def></def><sym>,</sym> <def></def><str>''</str><def></def><sym>,</sym> <def>seq</def><sym>,</sym> <def>readLen</def><sym>);</sym><br />
<def></def><br />
<br />
<com>(* Count all matches of patterns[i] in  seq buffer. *)</com><def></def><br />
  <kwa>for</kwa> <def>i</def> <sym>:=</sym> <def></def><num>0</num> <def></def><kwa>to</kwa> <def></def><num>8</num> <def></def><kwa>do</kwa><br />
<def></def>    <kwd>writeln</kwd><def></def><sym>(</sym><def>patterns</def><sym>[</sym><def>i</def><sym>],</sym> <def></def><str>' '</str><def></def><sym>,</sym> <def></def><kwd>split_count</kwd><def></def><sym>(</sym><def>patterns</def><sym>[</sym><def>i</def><sym>],</sym> <def>seq</def><sym>,</sym> <def>seqLen</def><sym>));</sym><br />
<def></def>    <slc>//writeln(patterns[i], ' ', count(patterns[i], seq, seqLen));</slc><br />
<def><br />
  writeln</def><sym>;</sym><br />
<def></def>  <kwd>writeln</kwd><def></def><sym>(</sym><def>readLen</def><sym>);</sym><br />
<def></def><br />
  <kwd>writeln</kwd><def></def><sym>(</sym><def>seqLen</def><sym>);</sym><br />
<def></def>  <slc>//writeln(strlen(seq));</slc><br />
<def></def><br />
<com>(* All IUB substitutes. *)</com><def></def><br />
  <kwa>for</kwa> <def>i</def> <sym>:=</sym> <def></def><num>0</num> <def></def><kwa>to</kwa> <def></def><num>10</num> <def></def><kwa>do</kwa><br />
<def>    seqLen</def> <sym>:=</sym> <def></def><kwd>subst</kwd><def></def><sym>(</sym><def>patt</def><sym>[</sym><def>i</def><sym>],</sym> <def>repl</def><sym>[</sym><def>i</def><sym>],</sym> <def>seq</def><sym>,</sym> <def>seqLen</def><sym>);</sym><br />
<def></def><br />
  <kwd>writeln</kwd><def></def><sym>(</sym><def>seqLen</def><sym>);</sym><br />
<def></def>  <slc>//writeln(strlen(seq));</slc><br />
<def></def><br />
  <kwd>FreeMem</kwd><def></def><sym>(</sym><def>seq</def><sym>);</sym><br />
<def></def><kwa>end</kwa><def></def><sym>.</sym><def></def><br />
</source>
