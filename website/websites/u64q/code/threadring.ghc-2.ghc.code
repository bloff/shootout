<source>
<def></def><slc>-- The Computer Language Benchmarks Game</slc><br />
<def></def><slc>-- http://shootout.alioth.debian.org/</slc><br />
<def></def><slc>-- Contributed by Jed Brown with improvements by Spencer Janssen and Don Stewart</slc><br />
<def></def><br />
<kwa>import</kwa> <def>Control.Monad</def><br />
<kwa>import</kwa> <def>Control.Concurrent</def><br />
<kwa>import</kwa> <def>System.Environment<br />
<br />
ring</def> <sym>=</sym> <def></def><num>503</num><br />
<def><br />
new l i</def> <sym>=</sym> <def></def><kwa>do</kwa><br />
<def>  r</def> <sym>&lt;-</sym> <def>newEmptyMVar<br />
  forkIO</def> <sym>(</sym><def>thread i l r</def><sym>)</sym><br />
<def>  return r<br />
<br />
thread</def> <sym>::</sym> <def></def><kwb>Int</kwb> <def></def><sym>-&gt;</sym> <def>MVar</def> <kwb>Int</kwb> <def></def><sym>-&gt;</sym> <def>MVar</def> <kwb>Int</kwb> <def></def><sym>-&gt;</sym> <def>IO</def> <sym>()</sym><br />
<def>thread i l r</def> <sym>=</sym> <def>go</def><br />
  <kwa>where</kwa> <def>go</def> <sym>=</sym> <def></def><kwa>do</kwa><br />
<def>          m</def> <sym>&lt;-</sym> <def>takeMVar l<br />
          when</def> <sym>(</sym><def>m</def> <sym>==</sym> <def></def><num>1</num><def></def><sym>) (</sym><def>print i</def><sym>)</sym><br />
<def>          putMVar r $</def><sym>!</sym> <def>m</def> <sym>-</sym> <def></def><num>1</num><br />
<def>          when</def> <sym>(</sym><def>m</def> <sym>&gt;</sym> <def></def><num>0</num><def></def><sym>)</sym> <def>go<br />
<br />
main</def> <sym>=</sym> <def></def><kwa>do</kwa><br />
<def>  a</def> <sym>&lt;-</sym> <def>newMVar . read . head</def> <sym>=&lt;&lt;</sym> <def>getArgs<br />
  z</def> <sym>&lt;-</sym> <def>foldM new a</def> <sym>[</sym><def></def><num>2</num><def>..ring</def><sym>]</sym><br />
<def>  thread</def> <num>1</num> <def>z a</def><br />
</source>
