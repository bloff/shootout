<source>
<def></def><com>/* The Great Computer Language Shootout</com><br />
<com>   http://shootout.alioth.debian.org/</com><br />
<com></com><br />
<com>   contributed by James McIlree</com><br />
<com>*/</com><def></def><br />
<br />
<kwa>import</kwa> <def>java</def><sym>.</sym><def>util</def><sym>.*;</sym><br />
<def></def><kwa>import</kwa> <def>java</def><sym>.</sym><def>io</def><sym>.*;</sym><br />
<def></def><kwa>import</kwa> <def>java</def><sym>.</sym><def>text</def><sym>.*;</sym><br />
<def></def><br />
<kwa>public class</kwa> <def>knucleotide</def> <sym>{</sym><br />
<def></def>  <kwc>String</kwc> <def>sequence</def><sym>;</sym><br />
<def></def>  <kwb>int</kwb> <def>count</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def><br />
  <kwd>knucleotide</kwd><def></def><sym>(</sym><def></def><kwc>String</kwc> <def>s</def><sym>) {</sym><br />
<def>    sequence</def> <sym>=</sym> <def>s</def><sym>;</sym><br />
<def></def>  <sym>}</sym><br />
<def></def><br />
  <kwa>public static</kwa> <def></def><kwb>void</kwb> <def></def><kwd>main</kwd><def></def><sym>(</sym><def></def><kwc>String</kwc><def></def><sym>[]</sym> <def>args</def><sym>)</sym> <def></def><kwa>throws</kwa> <def></def><kwc>Exception</kwc><br />
<def></def>  <sym>{</sym><br />
<def></def>    <kwc>StringBuffer</kwc> <def>sbuffer</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwc>StringBuffer</kwc><def></def><sym>();</sym><br />
<def></def>    <kwc>String</kwc> <def>line</def><sym>;</sym><br />
<def></def><br />
    <kwc>BufferedReader</kwc> <def>in</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwc>BufferedReader</kwc><def></def><sym>(</sym><def></def><kwa>new</kwa> <def></def><kwc>InputStreamReader</kwc><def></def><sym>(</sym><def></def><kwc>System</kwc><def></def><sym>.</sym><def>in</def><sym>));</sym><br />
<def></def>    <kwa>while</kwa> <def></def><sym>((</sym><def>line</def> <sym>=</sym> <def>in</def><sym>.</sym><def></def><kwd>readLine</kwd><def></def><sym>()) !=</sym> <def>null</def><sym>) {</sym><br />
<def></def>      <kwa>if</kwa> <def></def><sym>(</sym><def>line</def><sym>.</sym><def></def><kwd>startsWith</kwd><def></def><sym>(</sym><def></def><str>&quot;&gt;THREE&quot;</str><def></def><sym>))</sym> <def></def><kwa>break</kwa><def></def><sym>;</sym><br />
<def></def>    <sym>}</sym><br />
<def></def><br />
    <kwa>while</kwa> <def></def><sym>((</sym><def>line</def> <sym>=</sym> <def>in</def><sym>.</sym><def></def><kwd>readLine</kwd><def></def><sym>()) !=</sym> <def>null</def><sym>) {</sym><br />
<def></def>      <kwb>char</kwb> <def>c</def> <sym>=</sym> <def>line</def><sym>.</sym><def></def><kwd>charAt</kwd><def></def><sym>(</sym><def></def><num>0</num><def></def><sym>);</sym><br />
<def></def>      <kwa>if</kwa> <def></def><sym>(</sym><def>c</def> <sym>==</sym> <def></def><str>'&gt;'</str><def></def><sym>)</sym><br />
<def></def>        <kwa>break</kwa><def></def><sym>;</sym><br />
<def></def>      <kwa>else if</kwa> <def></def><sym>(</sym><def>c</def> <sym>!=</sym> <def></def><str>';'</str><def></def><sym>)</sym><br />
<def>        sbuffer</def><sym>.</sym><def></def><kwd>append</kwd><def></def><sym>(</sym><def>line</def><sym>.</sym><def></def><kwd>toUpperCase</kwd><def></def><sym>());</sym><br />
<def></def>    <sym>}</sym><br />
<def><br />
    knucleotide kn</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>knucleotide</kwd><def></def><sym>(</sym><def>sbuffer</def><sym>.</sym><def></def><kwd>toString</kwd><def></def><sym>());</sym><br />
<def>    kn</def><sym>.</sym><def></def><kwd>writeFrequencies</kwd><def></def><sym>(</sym><def></def><num>1</num><def></def><sym>);</sym><br />
<def>    kn</def><sym>.</sym><def></def><kwd>writeFrequencies</kwd><def></def><sym>(</sym><def></def><num>2</num><def></def><sym>);</sym><br />
<def><br />
    kn</def><sym>.</sym><def></def><kwd>writeCount</kwd><def></def><sym>(</sym><def></def><str>&quot;GGT&quot;</str><def></def><sym>);</sym><br />
<def>    kn</def><sym>.</sym><def></def><kwd>writeCount</kwd><def></def><sym>(</sym><def></def><str>&quot;GGTA&quot;</str><def></def><sym>);</sym><br />
<def>    kn</def><sym>.</sym><def></def><kwd>writeCount</kwd><def></def><sym>(</sym><def></def><str>&quot;GGTATT&quot;</str><def></def><sym>);</sym><br />
<def>    kn</def><sym>.</sym><def></def><kwd>writeCount</kwd><def></def><sym>(</sym><def></def><str>&quot;GGTATTTTAATT&quot;</str><def></def><sym>);</sym><br />
<def>    kn</def><sym>.</sym><def></def><kwd>writeCount</kwd><def></def><sym>(</sym><def></def><str>&quot;GGTATTTTAATTTATAGT&quot;</str><def></def><sym>);</sym><br />
<def></def>  <sym>}</sym><br />
<def></def><br />
  <kwb>void</kwb> <def></def><kwd>writeFrequencies</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>nucleotideLength</def><sym>) {</sym><br />
<def></def>    <kwc>Map</kwc> <def>frequencies</def> <sym>=</sym> <def></def><kwd>calculateFrequencies</kwd><def></def><sym>(</sym><def>nucleotideLength</def><sym>);</sym><br />
<def></def>    <kwc>ArrayList</kwc> <def>list</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwc>ArrayList</kwc><def></def><sym>(</sym><def>frequencies</def><sym>.</sym><def></def><kwd>size</kwd><def></def><sym>());</sym><br />
<def></def>    <kwc>Iterator</kwc> <def>it</def> <sym>=</sym> <def>frequencies</def><sym>.</sym><def></def><kwd>entrySet</kwd><def></def><sym>().</sym><def></def><kwd>iterator</kwd><def></def><sym>();</sym><br />
<def></def><br />
    <kwa>while</kwa> <def></def><sym>(</sym><def>it</def><sym>.</sym><def></def><kwd>hasNext</kwd><def></def><sym>()) {</sym><br />
<def>      knucleotide fragment</def> <sym>= (</sym><def>knucleotide</def><sym>)((</sym><def></def><kwc>Map</kwc><def></def><sym>.</sym><def>Entry</def><sym>)</sym><def>it</def><sym>.</sym><def></def><kwd>next</kwd><def></def><sym>()).</sym><def></def><kwd>getValue</kwd><def></def><sym>();</sym><br />
<def>      list</def><sym>.</sym><def></def><kwd>add</kwd><def></def><sym>(</sym><def>fragment</def><sym>);</sym><br />
<def></def>    <sym>}</sym><br />
<def></def><br />
    <kwc>Collections</kwc><def></def><sym>.</sym><def></def><kwd>sort</kwd><def></def><sym>(</sym><def>list</def><sym>,</sym> <def></def><kwa>new</kwa> <def></def><kwc>Comparator</kwc><def></def><sym>() {</sym><br />
<def></def>        <kwa>public</kwa> <def></def><kwb>int</kwb> <def></def><kwd>compare</kwd><def></def><sym>(</sym><def></def><kwc>Object</kwc> <def>o1</def><sym>,</sym> <def></def><kwc>Object</kwc> <def>o2</def><sym>) {</sym><br />
<def></def>          <kwb>int</kwb> <def>c</def> <sym>= ((</sym><def>knucleotide</def><sym>)</sym><def>o2</def><sym>).</sym><def>count</def> <sym>- ((</sym><def>knucleotide</def><sym>)</sym><def>o1</def><sym>).</sym><def>count</def><sym>;</sym><br />
<def></def>          <kwa>if</kwa> <def></def><sym>(</sym><def>c</def> <sym>==</sym> <def></def><num>0</num><def></def><sym>) {</sym><br />
<def>            c</def> <sym>= ((</sym><def>knucleotide</def><sym>)</sym><def>o1</def><sym>).</sym><def>sequence</def><sym>.</sym><def></def><kwd>compareTo</kwd><def></def><sym>(((</sym><def>knucleotide</def><sym>)</sym><def>o2</def><sym>).</sym><def>sequence</def><sym>);</sym><br />
<def></def>          <sym>}</sym><br />
<def></def>          <kwa>return</kwa> <def>c</def><sym>;</sym><br />
<def></def>        <sym>}</sym><br />
<def></def>      <sym>});</sym><br />
<def></def><br />
    <kwc>NumberFormat</kwc> <def>nf</def> <sym>=</sym> <def></def><kwc>NumberFormat</kwc><def></def><sym>.</sym><def></def><kwd>getInstance</kwd><def></def><sym>();</sym><br />
<def>    nf</def><sym>.</sym><def></def><kwd>setMaximumFractionDigits</kwd><def></def><sym>(</sym><def></def><num>3</num><def></def><sym>);</sym><br />
<def>    nf</def><sym>.</sym><def></def><kwd>setMinimumFractionDigits</kwd><def></def><sym>(</sym><def></def><num>3</num><def></def><sym>);</sym><br />
<def></def><br />
    <kwb>int</kwb> <def>sum</def> <sym>=</sym> <def>sequence</def><sym>.</sym><def></def><kwd>length</kwd><def></def><sym>() -</sym> <def>nucleotideLength</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def><br />
    <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i</def><sym>=</sym><def></def><num>0</num><def></def><sym>;</sym> <def>i</def><sym>&lt;</sym><def>list</def><sym>.</sym><def></def><kwd>size</kwd><def></def><sym>();</sym> <def>i</def><sym>++) {</sym><br />
<def>      knucleotide fragment</def> <sym>= (</sym><def>knucleotide</def><sym>)</sym><def>list</def><sym>.</sym><def></def><kwd>get</kwd><def></def><sym>(</sym><def>i</def><sym>);</sym><br />
<def></def>      <kwb>double</kwb> <def>percent</def> <sym>= (</sym><def></def><kwb>double</kwb><def></def><sym>)</sym><def>fragment</def><sym>.</sym><def>count</def><sym>/(</sym><def></def><kwb>double</kwb><def></def><sym>)</sym><def>sum</def> <sym>*</sym> <def></def><num>100.0</num><def></def><sym>;</sym><br />
<def></def>      <kwc>System</kwc><def></def><sym>.</sym><def>out</def><sym>.</sym><def></def><kwd>println</kwd><def></def><sym>(</sym><def>fragment</def><sym>.</sym><def>sequence</def> <sym>+</sym> <def></def><str>&quot; &quot;</str><def></def> <sym>+</sym> <def>nf</def><sym>.</sym><def></def><kwd>format</kwd><def></def><sym>(</sym><def>percent</def><sym>) );</sym><br />
<def></def>    <sym>}</sym><br />
<def></def>    <kwc>System</kwc><def></def><sym>.</sym><def>out</def><sym>.</sym><def></def><kwd>println</kwd><def></def><sym>(</sym><def></def><str>&quot;&quot;</str><def></def><sym>);</sym><br />
<def></def>  <sym>}</sym><br />
<def></def><br />
  <kwb>void</kwb> <def></def><kwd>writeCount</kwd><def></def><sym>(</sym><def></def><kwc>String</kwc> <def>nucleotideFragment</def><sym>) {</sym><br />
<def></def>    <kwc>Map</kwc> <def>frequencies</def> <sym>=</sym> <def></def><kwd>calculateFrequencies</kwd><def></def><sym>(</sym><def>nucleotideFragment</def><sym>.</sym><def></def><kwd>length</kwd><def></def><sym>());</sym><br />
<def><br />
    knucleotide found</def> <sym>= (</sym><def>knucleotide</def><sym>)</sym><def>frequencies</def><sym>.</sym><def></def><kwd>get</kwd><def></def><sym>(</sym><def>nucleotideFragment</def><sym>);</sym><br />
<def></def>    <kwb>int</kwb> <def>count</def> <sym>= (</sym><def>found</def> <sym>==</sym> <def>null</def><sym>)</sym> <def>?</def> <num>0</num> <def></def><sym>:</sym> <def>found</def><sym>.</sym><def>count</def><sym>;</sym><br />
<def></def>    <kwc>System</kwc><def></def><sym>.</sym><def>out</def><sym>.</sym><def></def><kwd>println</kwd><def></def><sym>(</sym><def>count</def> <sym>+</sym> <def></def><str>&quot;</str><esc>\t</esc><str>&quot;</str><def></def> <sym>+</sym> <def>nucleotideFragment</def><sym>);</sym><br />
<def></def>  <sym>}</sym><br />
<def></def><br />
  <kwc>Map</kwc> <def></def><kwd>calculateFrequencies</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>fragmentLength</def><sym>) {</sym><br />
<def></def>    <kwc>HashMap</kwc> <def>map</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwc>HashMap</kwc><def></def><sym>();</sym><br />
<def></def>    <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>offset</def><sym>=</sym><def></def><num>0</num><def></def><sym>;</sym> <def>offset</def><sym>&lt;</sym><def>fragmentLength</def><sym>;</sym> <def>offset</def><sym>++)</sym><br />
<def></def>      <kwd>calculateFrequencies</kwd><def></def><sym>(</sym><def>map</def><sym>,</sym> <def>offset</def><sym>,</sym> <def>fragmentLength</def><sym>);</sym><br />
<def></def><br />
    <kwa>return</kwa> <def>map</def><sym>;</sym><br />
<def></def>  <sym>}</sym><br />
<def></def><br />
  <slc>// Is this method really needed? The benchmark specification seems to</slc><br />
<def></def>  <slc>// indicate so, but it is not entirely clear. This method could easily</slc><br />
<def></def>  <slc>// be folded up.</slc><br />
<def></def>  <kwb>void</kwb> <def></def><kwd>calculateFrequencies</kwd><def></def><sym>(</sym><def></def><kwc>Map</kwc> <def>map</def><sym>,</sym> <def></def><kwb>int</kwb> <def>offset</def><sym>,</sym> <def></def><kwb>int</kwb> <def>fragmentLength</def><sym>) {</sym><br />
<def></def>    <kwb>int</kwb> <def>lastIndex</def> <sym>=</sym> <def>sequence</def><sym>.</sym><def></def><kwd>length</kwd><def></def><sym>() -</sym> <def>fragmentLength</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>    <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>index</def><sym>=</sym><def>offset</def><sym>;</sym> <def>index</def><sym>&lt;</sym><def>lastIndex</def><sym>;</sym> <def>index</def><sym>+=</sym><def>fragmentLength</def><sym>) {</sym><br />
<def></def>      <kwc>String</kwc> <def>temp</def> <sym>=</sym> <def>sequence</def><sym>.</sym><def></def><kwd>substring</kwd><def></def><sym>(</sym><def>index</def><sym>,</sym> <def>index</def> <sym>+</sym> <def>fragmentLength</def><sym>);</sym><br />
<def>      knucleotide fragment</def> <sym>= (</sym><def>knucleotide</def><sym>)</sym><def>map</def><sym>.</sym><def></def><kwd>get</kwd><def></def><sym>(</sym><def>temp</def><sym>);</sym><br />
<def></def>      <kwa>if</kwa> <def></def><sym>(</sym><def>fragment</def> <sym>!=</sym> <def>null</def><sym>)</sym><br />
<def>        fragment</def><sym>.</sym><def>count</def><sym>++;</sym><br />
<def></def>      <kwa>else</kwa><br />
<def>        map</def><sym>.</sym><def></def><kwd>put</kwd><def></def><sym>(</sym><def>temp</def><sym>,</sym> <def></def><kwa>new</kwa> <def></def><kwd>knucleotide</kwd><def></def><sym>(</sym><def>temp</def><sym>));</sym><br />
<def></def>    <sym>}</sym><br />
<def></def>  <sym>}</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
</source>
