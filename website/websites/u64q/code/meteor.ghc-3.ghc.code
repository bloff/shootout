<source>
<def></def><com>{-# OPTIONS -O3 -fglasgow-exts #-}</com><def></def><br />
<br />
<com>{-</com><br />
<com>	The Computer Language Shootout</com><br />
<com>   	http://shootout.alioth.debian.org/</com><br />
<com>   	contributed by Olof Kraigher</com><br />
<com>-}</com><def></def><br />
<br />
<kwa>module</kwa> <def>Main</def> <kwa>where</kwa><br />
<def></def><br />
<kwa>import</kwa> <def>System</def><sym>(</sym><def>getArgs</def><sym>);</sym>		<def></def><kwa>import</kwa> <def>Data.List</def><sym>;</sym>	<def></def><kwa>import</kwa> <def>Data.Bits</def><sym>;</sym>		<def></def><kwa>import</kwa> <def>Data.Array.IArray</def><sym>;</sym><br />
<def></def><kwa>import</kwa> <def>Data.Word</def><sym>(</sym><def>Word64</def><sym>);</sym>	<def></def><kwa>import</kwa> <def>Data.Maybe</def><sym>;</sym>	<def></def><kwa>import</kwa> <def>Control.Monad</def><sym>;</sym><br />
<def></def><br />
<kwa>data</kwa> <def>Direction</def> <sym>=</sym> <def>E</def> <sym>|</sym> <def>SE</def> <sym>|</sym> <def>SW</def> <sym>|</sym> <def>W</def> <sym>|</sym> <def>NW</def> <sym>|</sym> <def>NE</def> <kwa>deriving</kwa> <def></def><sym>(</sym><def>Enum</def><sym>,</sym> <def>Eq</def><sym>,</sym> <def>Ord</def><sym>)</sym><br />
<def></def><kwa>type</kwa> <def>Piece</def> <sym>= [</sym><def>Direction</def><sym>]</sym><br />
<def></def><kwa>type</kwa> <def>CellCoord</def> <sym>= (</sym><def></def><kwb>Int</kwb><def></def><sym>,</sym> <def></def><kwb>Int</kwb><def></def><sym>)</sym><br />
<def></def><kwa>type</kwa> <def>CellIndex</def> <sym>=</sym> <def></def><kwb>Int</kwb><br />
<def></def><kwa>type</kwa> <def>Mask</def> <sym>=</sym> <def>Word64</def><br />
<kwa>type</kwa> <def>Color</def> <sym>=</sym> <def></def><kwb>Int</kwb><br />
<def></def><kwa>type</kwa> <def>Solution</def> <sym>=</sym> <def>String</def><br />
<br />
<kwa>class</kwa> <def>Rotatable a</def> <kwa>where</kwa> <def>rot</def> <sym>::</sym> <def>a</def> <sym>-&gt;</sym> <def>a</def><br />
<kwa>class</kwa> <def>Floppable a</def> <kwa>where</kwa> <def>flop</def> <sym>::</sym> <def>a</def> <sym>-&gt;</sym> <def>a</def><br />
<kwa>class</kwa> <def>Maskable a</def> <kwa>where</kwa> <def>mask</def> <sym>::</sym> <def>a</def> <sym>-&gt;</sym> <def>Mask</def><br />
<br />
<kwa>instance</kwa> <def>Rotatable Direction</def>	<kwa>where</kwa> <def>rot d</def> <sym>=</sym> <def>toEnum $ mod</def> <sym>((</sym><def>fromEnum d</def><sym>) +</sym> <def></def><num>1</num><def></def><sym>)</sym> <def></def><num>6</num><br />
<def></def><kwa>instance</kwa> <def>Rotatable Piece</def> 		<kwa>where</kwa> <def>rot a</def> <sym>=</sym> <def>map rot a</def><br />
<br />
<kwa>instance</kwa> <def>Floppable Direction</def> 	<kwa>where</kwa> <def>flop d</def> <sym>=</sym> <def>toEnum $ mod</def> <sym>(</sym><def></def><num>9</num> <def></def><sym>- (</sym><def>fromEnum d</def><sym>))</sym> <def></def><num>6</num><br />
<def></def><kwa>instance</kwa> <def>Floppable Piece</def> 		<kwa>where</kwa> <def>flop a</def> <sym>=</sym> <def>map flop a</def><br />
<br />
<kwa>instance</kwa> <def>Maskable CellCoord</def> 	<kwa>where</kwa> <def>mask</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>) =</sym> <def>bit</def> <sym>(</sym><def>x</def> <sym>+</sym> <def>y</def><sym>*</sym><def>width</def><sym>)</sym><br />
<def></def><kwa>instance</kwa> <def>Maskable</def> <sym>[</sym><def>CellCoord</def><sym>]</sym>	<def></def><kwa>where</kwa> <def>mask p</def> <sym>=</sym> <def>foldl'</def> <sym>(</sym><def>\a b</def> <sym>-&gt;</sym> <def>a .</def><sym>|</sym><def>. mask b</def><sym>)</sym> <def></def><num>0</num> <def>p</def><br />
<kwa>instance</kwa> <def>Maskable CellIndex</def> 	<kwa>where</kwa> <def>mask i</def> <sym>=</sym> <def>bit i<br />
<br />
<br />
width</def> <sym>::</sym> <def></def><kwb>Int</kwb><br />
<def>width</def> <sym>=</sym> <def></def><num>5</num><br />
<def><br />
height</def> <sym>::</sym> <def></def><kwb>Int</kwb><br />
<def>height</def> <sym>=</sym> <def></def><num>10</num><br />
<def><br />
cellcs</def> <sym>:: [</sym><def>CellCoord</def><sym>]</sym><br />
<def>cellcs</def> <sym>= [(</sym><def>x</def><sym>,</sym><def>y</def><sym>) |</sym> <def>y</def> <sym>&lt;- [</sym><def></def><num>0</num><def>..height</def><sym>-</sym><def></def><num>1</num><def></def><sym>],</sym> <def>x</def> <sym>&lt;- [</sym><def></def><num>0</num><def>..width</def><sym>-</sym><def></def><num>1</num><def></def><sym>]]</sym><br />
<def><br />
cellis</def> <sym>:: [</sym><def>CellIndex</def><sym>]</sym><br />
<def>cellis</def> <sym>= [</sym><def></def><num>0</num><def>..width</def><sym>*</sym><def>height</def><sym>-</sym><def></def><num>1</num><def></def><sym>]</sym><br />
<def><br />
fullMask</def> <sym>::</sym> <def>Mask<br />
fullMask</def> <sym>=</sym> <def></def><num>0x3FFFFFFFFFFFF</num><br />
<def><br />
pieces</def> <sym>::</sym> <def>Array Color Piece<br />
pieces</def> <sym>=</sym> <def>array</def> <sym>(</sym><def></def><num>0</num><def></def><sym>,</sym><def></def><num>9</num><def></def><sym>)</sym> <def>$ zip</def> <sym>[</sym><def></def><num>0</num><def>.</def><num>.9</num><def></def><sym>]</sym> <def>$</def><br />
		<sym>[	[</sym><def>E</def><sym>,</sym>	 <def>E</def><sym>,</sym>  <def>E</def><sym>,</sym>  <def>SE</def><sym>],</sym><br />
<def></def>			<sym>[</sym><def>SE</def><sym>,</sym> <def>SW</def><sym>,</sym> <def>W</def><sym>,</sym>  <def>SW</def><sym>],</sym><br />
<def></def>			<sym>[</sym><def>W</def><sym>,</sym>  <def>W</def><sym>,</sym>  <def>SW</def><sym>,</sym> <def>SE</def><sym>],</sym><br />
<def></def>			<sym>[</sym><def>E</def><sym>,</sym>  <def>E</def><sym>,</sym>  <def>SW</def><sym>,</sym> <def>SE</def><sym>],</sym><br />
<def></def>			<sym>[</sym><def>NW</def><sym>,</sym> <def>W</def><sym>,</sym>  <def>NW</def><sym>,</sym> <def>SE</def><sym>,</sym> <def>SW</def><sym>],</sym><br />
<def></def>			<sym>[</sym><def>E</def><sym>,</sym>  <def>E</def><sym>,</sym>  <def>NE</def><sym>,</sym> <def>W</def><sym>],</sym><br />
<def></def>			<sym>[</sym><def>NW</def><sym>,</sym> <def>NE</def><sym>,</sym> <def>NE</def><sym>,</sym> <def>W</def><sym>],</sym><br />
<def></def>			<sym>[</sym><def>NE</def><sym>,</sym> <def>SE</def><sym>,</sym> <def>E</def><sym>,</sym>  <def>NE</def><sym>],</sym><br />
<def></def>			<sym>[</sym><def>SE</def><sym>,</sym> <def>SE</def><sym>,</sym> <def>E</def><sym>,</sym>  <def>SE</def><sym>],</sym><br />
<def></def>			<sym>[</sym><def>E</def><sym>,</sym>  <def>NW</def><sym>,</sym> <def>NW</def><sym>,</sym> <def>NW</def><sym>]]</sym><br />
<def><br />
valid</def> <sym>::</sym> <def>CellCoord</def> <sym>-&gt;</sym> <def>Maybe CellCoord<br />
valid p</def><sym>@(</sym><def>x</def><sym>,</sym><def>y</def><sym>)</sym><br />
<def></def>	<sym>|</sym> <def></def><num>0</num> <def></def><sym>&lt;=</sym> <def>x</def><sym>,</sym> <def>x</def> <sym>&lt;</sym> <def>width</def><sym>,</sym> <def></def><num>0</num> <def></def><sym>&lt;=</sym> <def>y</def><sym>,</sym> <def>y</def> <sym>&lt;</sym> <def>height</def> <sym>=</sym> <def>Just p</def><br />
	<sym>|</sym><def>otherwise</def> <sym>=</sym> <def>Nothing<br />
<br />
move</def> <sym>::</sym> <def>CellCoord</def> <sym>-&gt;</sym> <def>Direction</def> <sym>-&gt;</sym> <def>Maybe CellCoord<br />
move</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>)</sym> <def>E</def> <sym>=</sym> <def>valid</def> <sym>(</sym><def>x</def><sym>+</sym><def></def><num>1</num><def></def><sym>,</sym><def>y</def><sym>)</sym><br />
<def>move</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>)</sym> <def>W</def> <sym>=</sym> <def>valid</def> <sym>(</sym><def>x</def><sym>-</sym><def></def><num>1</num><def></def><sym>,</sym><def>y</def><sym>)</sym><br />
<def>move</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>)</sym> <def>NE</def> <sym>=</sym> <def>valid</def> <sym>(</sym><def>x</def><sym>+(</sym><def>mod y</def> <num>2</num><def></def><sym>),</sym><def>y</def><sym>-</sym><def></def><num>1</num><def></def><sym>)</sym><br />
<def>move</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>)</sym> <def>NW</def> <sym>=</sym> <def>valid</def> <sym>(</sym><def>x</def><sym>+(</sym><def>mod y</def> <num>2</num><def></def><sym>)-</sym><def></def><num>1</num><def></def><sym>,</sym><def>y</def><sym>-</sym><def></def><num>1</num><def></def><sym>)</sym><br />
<def>move</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>)</sym> <def>SE</def> <sym>=</sym> <def>valid</def> <sym>(</sym><def>x</def><sym>+(</sym><def>mod y</def> <num>2</num><def></def><sym>),</sym><def>y</def><sym>+</sym><def></def><num>1</num><def></def><sym>)</sym><br />
<def>move</def> <sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>)</sym> <def>SW</def> <sym>=</sym> <def>valid</def> <sym>(</sym><def>x</def><sym>+(</sym><def>mod y</def> <num>2</num><def></def><sym>)-</sym><def></def><num>1</num><def></def><sym>,</sym><def>y</def><sym>+</sym><def></def><num>1</num><def></def><sym>)</sym><br />
<def><br />
<br />
overlap</def> <sym>::</sym> <def>Mask</def> <sym>-&gt;</sym> <def>Mask</def> <sym>-&gt;</sym> <def></def><kwb>Bool</kwb><br />
<def>overlap a b</def> <sym>= (</sym><def>a .</def><sym>&amp;</sym><def>. b</def><sym>) /=</sym> <def></def><num>0</num><br />
<def><br />
legal</def> <sym>::</sym> <def>Mask</def> <sym>-&gt;</sym> <def>Mask</def> <sym>-&gt;</sym> <def></def><kwb>Bool</kwb><br />
<def>legal a b</def> <sym>=</sym> <def>not $ overlap a b<br />
<br />
bc</def> <sym>::</sym> <def>Mask</def> <sym>-&gt;</sym> <def></def><kwb>Int</kwb><br />
<def>bc</def> <num>0</num> <def></def><sym>=</sym> <def></def><num>0</num><br />
<def>bc mask</def> <sym>= (</sym><def>fromIntegral $</def> <sym>(</sym><def>mask .</def><sym>&amp;</sym><def>.</def> <num>1</num><def></def><sym>)) + (</sym><def>bc</def> <sym>(</sym><def>shiftR mask</def> <num>1</num><def></def><sym>))</sym><br />
<def><br />
fill</def> <sym>::</sym> <def>Mask</def> <sym>-&gt;</sym> <def>CellCoord</def> <sym>-&gt;</sym> <def>Mask<br />
fill mask cell</def><sym>@(</sym><def>x</def><sym>,</sym><def>y</def><sym>)</sym><br />
<def></def>	<sym>|</sym> <def>overlap mask</def> <sym>(</sym><def>bit $ x</def> <sym>+</sym> <def>y</def><sym>*</sym><def>width</def><sym>) =</sym> <def>mask</def><br />
	<sym>|</sym> <def>otherwise</def> <sym>=</sym><br />
<def></def>		<kwa>let</kwa> <def>mask'</def> <sym>=</sym> <def>mask .</def><sym>|</sym><def>.</def> <sym>(</sym><def>bit $ x</def> <sym>+</sym> <def>y</def><sym>*</sym><def>width</def><sym>)</sym><br />
<def></def>		<kwa>in</kwa>	<def>foldl' fill mask' $ mapMaybe</def> <sym>(</sym><def>move cell</def><sym>) [</sym><def>E .. NE</def><sym>]</sym><br />
<def><br />
freeCell</def> <sym>::</sym> <def>Mask</def> <sym>-&gt;</sym> <def>CellCoord<br />
freeCell mask</def> <sym>=</sym><br />
<def>	fromJust $ find</def> <sym>(</sym><def>\</def><sym>(</sym><def>x</def><sym>,</sym><def>y</def><sym>) -&gt;</sym> <def>legal mask</def> <sym>(</sym><def>bit $ x</def> <sym>+</sym> <def>y</def><sym>*</sym><def>width</def><sym>))</sym> <def>cellcs<br />
<br />
noIslands</def> <sym>::</sym> <def>Mask</def> <sym>-&gt;</sym> <def></def><kwb>Bool</kwb><br />
<def>noIslands mask</def> <sym>=</sym> <def>not $ any</def> <sym>(&lt;</sym><def></def><num>5</num><def></def><sym>)</sym> <def>$ diffs $ noIslands' mask</def> <kwa>where</kwa><br />
<def>	noIslands' mask</def><br />
		<sym>|</sym> <def>mask</def> <sym>==</sym> <def>fullMask</def> <sym>= [</sym><def>bc mask</def><sym>]</sym><br />
<def></def>		<sym>|</sym> <def>otherwise</def> <sym>= (</sym><def>bc mask</def><sym>) : (</sym><def>noIslands' $ fill mask $ freeCell mask</def><sym>)</sym><br />
<def>	diffs l</def> <sym>=</sym> <def>zipWith</def> <sym>(-) (</sym><def>tail l</def><sym>)</sym> <def>l<br />
<br />
<br />
placePiece</def> <sym>::</sym> <def>Piece</def> <sym>-&gt;</sym> <def>CellCoord</def> <sym>-&gt;</sym> <def>Maybe</def> <sym>[</sym><def>CellCoord</def><sym>]</sym><br />
<def>placePiece</def> <sym>[]</sym> <def>cell</def> <sym>=</sym> <def>Just</def> <sym>[</sym><def>cell</def><sym>]</sym><br />
<def>placePiece</def> <sym>(</sym><def>p</def><sym>:</sym><def>ps</def><sym>)</sym> <def>cell</def> <sym>=</sym> <def>move cell p</def> <sym>&gt;&gt;= (</sym><def>placePiece ps</def><sym>) &gt;&gt;=</sym> <def>return .</def> <sym>(</sym><def>cell</def><sym>:)</sym><br />
<def><br />
pieceMasks</def> <sym>::</sym> <def>Array Color</def> <sym>[</sym><def>Mask</def><sym>]</sym><br />
<def>pieceMasks</def> <sym>=</sym> <def>amap pieceMasks' pieces</def> <kwa>where</kwa><br />
<def>	pieceMasks' piece</def><br />
		<sym>|</sym> <def>piece</def> <sym>== (</sym><def>pieces</def><sym>!</sym><def></def><num>5</num><def></def><sym>) =</sym> <def></def><kwa>do</kwa><br />
<def>			piece'</def> <sym>&lt;- (</sym><def>take</def> <num>3</num> <def>$ iterate rot piece</def><sym>) ++ (</sym><def>take</def> <num>3</num> <def>$ iterate rot $ flop $ piece</def><sym>)</sym><br />
<def>			filter noIslands $ map mask $ mapMaybe</def> <sym>(</sym><def>placePiece piece'</def><sym>)</sym> <def>cellcs</def><br />
<br />
		<sym>|</sym> <def>otherwise</def> <sym>=</sym> <def></def><kwa>do</kwa><br />
<def>			piece'</def> <sym>&lt;- (</sym><def>take</def> <num>6</num> <def>$ iterate rot piece</def><sym>) ++ (</sym><def>take</def> <num>6</num> <def>$ iterate rot $ flop $ piece</def><sym>)</sym><br />
<def>			filter noIslands $ map mask $ mapMaybe</def> <sym>(</sym><def>placePiece piece'</def><sym>)</sym> <def>cellcs<br />
<br />
pieceMasksAtCell</def> <sym>::</sym> <def>Array Color</def> <sym>(</sym><def>Array CellIndex</def> <sym>[</sym><def>Mask</def><sym>])</sym><br />
<def>pieceMasksAtCell</def> <sym>=</sym> <def>amap pieceMasksAtCell' pieceMasks</def> <kwa>where</kwa><br />
<def>	pieceMasksAtCell' masks</def> <sym>=</sym> <def>array</def> <sym>(</sym><def></def><num>0</num><def></def><sym>,</sym><def>width</def><sym>*</sym><def>height</def><sym>-</sym><def></def><num>1</num><def></def><sym>)</sym> <def>$ pieceMasksAtCell'' masks cellis</def> <kwa>where</kwa><br />
<def>		pieceMasksAtCell'' masks</def> <sym>[] = []</sym><br />
<def>		pieceMasksAtCell'' masks</def> <sym>(</sym><def>c</def><sym>:</sym><def>cs</def><sym>) =</sym><br />
<def></def>			<kwa>let</kwa> <def></def><sym>(</sym><def>a</def><sym>,</sym><def>b</def><sym>) =</sym> <def>partition</def> <sym>(</sym><def>overlap</def> <sym>(</sym><def>mask c</def><sym>))</sym> <def>masks</def><br />
			<kwa>in</kwa> <def></def><sym>(</sym><def>c</def><sym>,</sym><def>a</def><sym>) : (</sym><def>pieceMasksAtCell'' b cs</def><sym>)</sym><br />
<def><br />
format</def> <sym>::</sym> <def>Color</def> <sym>-&gt;</sym> <def>Mask</def> <sym>-&gt;</sym> <def>Integer<br />
format c m</def> <sym>=  (</sym><def>fromIntegral c</def><sym>) * (</sym><def>binToDec m</def><sym>)</sym> <def></def><kwa>where</kwa><br />
<def>	binToDec</def> <sym>::</sym> <def>Mask</def> <sym>-&gt;</sym> <def>Integer<br />
	binToDec</def> <num>0</num> <def></def><sym>=</sym> <def></def><num>0</num><br />
<def>	binToDec n</def> <sym>= (</sym><def>fromIntegral</def> <sym>(</sym><def>mod n</def> <num>2</num><def></def><sym>)) +</sym> <def></def><num>10</num><def></def><sym>*(</sym><def>binToDec $ div n</def> <num>2</num><def></def><sym>)</sym><br />
<def><br />
ps</def> <sym>::</sym> <def>Solution</def> <sym>-&gt;</sym> <def>IO</def> <sym>()</sym><br />
<def>ps solution</def> <sym>=</sym> <def>pe $ map</def> <sym>(</sym><def>concatMap</def> <sym>(</sym><def>\a</def> <sym>-&gt; [</sym><def>a</def><sym>,</sym><def>' '</def><sym>]))</sym> <def>$<br />
					take height $ map</def> <sym>(</sym><def>take</def> <num>5</num><def></def><sym>)</sym> <def>$ iterate</def> <sym>(</sym><def>drop width</def><sym>)</sym> <def>solution</def> <kwa>where</kwa><br />
<def>	po</def> <sym>[] =</sym> <def>return</def> <sym>()</sym><br />
<def>	po</def> <sym>(</sym><def>s</def><sym>:</sym><def>ss</def><sym>) =</sym> <def></def><kwa>do</kwa><br />
<def>		putStrLn $ ' '</def><sym>:</sym><def>s<br />
		pe ss<br />
<br />
	pe</def> <sym>[] =</sym> <def>return</def> <sym>()</sym><br />
<def>	pe</def> <sym>(</sym><def>s</def><sym>:</sym><def>ss</def><sym>) =</sym> <def></def><kwa>do</kwa><br />
<def>		putStrLn s<br />
		po ss<br />
<br />
solutions</def> <sym>:: [</sym><def>Solution</def><sym>]</sym><br />
<def>solutions</def> <sym>=</sym> <def>solutions'</def> <num>0 0</num> <def></def><sym>[</sym><def></def><num>0</num><def>.</def><num>.9</num><def></def><sym>] (</sym><def></def><num>10</num><def>^</def><sym>(</sym><def>width</def><sym>*</sym><def>height</def><sym>))</sym> <def></def><kwa>where</kwa><br />
<def><br />
	solutions'</def> <sym>::</sym> <def>Mask</def> <sym>-&gt;</sym> <def>CellIndex</def> <sym>-&gt; [</sym><def>Color</def><sym>] -&gt;</sym> <def>Integer</def><sym>-&gt; [</sym><def>Solution</def><sym>]</sym><br />
<def>	solutions' _ _</def> <sym>[]</sym> <def>i</def> <sym>=</sym> 	<def></def><kwa>let</kwa> <def>s</def> <sym>=</sym> <def>tail.show $ i</def> <kwa>in</kwa> <def></def><sym>[</sym><def>s</def><sym>,</sym> <def>reverse s</def><sym>]</sym><br />
<def>	solutions' board cell colorsLeft i</def><br />
		<sym>|</sym> <def>overlap board</def> <sym>(</sym><def>mask cell</def><sym>) =</sym> <def>solutions' board</def> <sym>(</sym><def>cell</def><sym>+</sym><def></def><num>1</num><def></def><sym>)</sym> <def>colorsLeft i</def><br />
		<sym>|</sym> <def>otherwise</def> <sym>=</sym> <def></def><kwa>do</kwa><br />
<def>			color</def> <sym>&lt;-</sym> <def>colorsLeft<br />
			mask</def> <sym>&lt;-</sym> <def>filter</def> <sym>(</sym><def>legal board</def><sym>)</sym> <def>$ pieceMasksAtCell</def><sym>!</sym><def>color</def><sym>!</sym><def>cell<br />
			solutions'</def> <sym>(</sym><def>board .</def><sym>|</sym><def>. mask</def><sym>) (</sym><def>cell</def><sym>+</sym><def></def><num>1</num><def></def><sym>) (</sym><def>delete color colorsLeft</def><sym>) (</sym><def>i</def> <sym>+ (</sym><def>format color mask</def><sym>))</sym><br />
<def><br />
<br />
main</def> <sym>=</sym> <def></def><kwa>do</kwa><br />
<def></def>	<sym>(</sym><def>n</def> <sym>::</sym> <def></def><kwb>Int</kwb><def></def><sym>) &lt;-</sym> <def>return.read.head</def> <sym>=&lt;&lt;</sym> <def>getArgs</def><br />
	<kwa>let</kwa> <def>nsolutions</def> <sym>=</sym> <def>take n solutions<br />
	putStrLn $</def> <sym>(</sym><def>show $ length nsolutions</def><sym>) ++</sym> <def></def><str>&quot; solutions found\n&quot;</str><def><br />
	ps $ minimum nsolutions<br />
	putStr</def> <str>&quot;\n&quot;</str><def><br />
	ps $ maximum nsolutions<br />
	putStr</def> <str>&quot;\n&quot;</str><def></def><br />
</source>
