<source>
<def></def><com>{-# OPTIONS -fvia-C -fexcess-precision #-}</com><def></def><br />
<slc>--</slc><br />
<def></def><slc>-- The Computer Language Benchmarks Game</slc><br />
<def></def><slc>-- http://shootout.alioth.debian.org/</slc><br />
<def></def><slc>--</slc><br />
<def></def><slc>-- Modified by Ryan Trinkle: 1) change from divInt# to uncheckedIShiftRA#</slc><br />
<def></def><slc>--                           2) changed -optc-O to -optc-O3</slc><br />
<def></def><slc>--                           3) added -optc-ffast-math</slc><br />
<def></def><slc>-- Translation from Clean by Don Stewart</slc><br />
<def></def><slc>--</slc><br />
<def></def><slc>-- Should be compiled with:</slc><br />
<def></def><slc>--      -O -fglasgow-exts -fbang-patterns</slc><br />
<def></def><slc>--      -optc-O3 -optc-march=pentium4 -optc-mfpmath=sse -optc-msse2 -optc-ffast-math</slc><br />
<def></def><slc>--</slc><br />
<def></def><slc>-- Note: The following flags appear to INCREASE running time:</slc><br />
<def></def><slc>--      -O2 -optc-funroll-loops</slc><br />
<def></def><br />
<kwa>import</kwa> <def>System</def><br />
<kwa>import</kwa> <def>Foreign.Marshal.Array</def><br />
<kwa>import</kwa> <def>Foreign</def><br />
<kwa>import</kwa> <def>Text.Printf</def><br />
<kwa>import</kwa> <def>Control.Monad</def><br />
<kwa>import</kwa> <def>Data.ByteString.Internal</def><br />
<br />
<kwa>import</kwa> <def>GHC.Base</def><br />
<kwa>import</kwa> <def>GHC.</def><kwb>Float</kwb><br />
<def></def><kwa>import</kwa> <def>GHC.</def><kwb>Int</kwb><br />
<def></def><br />
<kwa>type</kwa> <def>Reals</def> <sym>=</sym> <def>Ptr</def> <kwb>Double</kwb><br />
<def><br />
main</def> <sym>=</sym> <def></def><kwa>do</kwa><br />
<def>    n</def> <sym>&lt;-</sym> <def>getArgs</def> <sym>&gt;&gt;=</sym> <def>readIO . head<br />
<br />
    u</def> <sym>&lt;-</sym> <def>mallocArray n</def> <sym>::</sym> <def>IO Reals<br />
    forM_</def> <sym>[</sym><def></def><num>0</num><def>..n</def><sym>-</sym><def></def><num>1</num><def></def><sym>]</sym> <def>$ \i</def> <sym>-&gt;</sym> <def>pokeElemOff u i</def> <num>1</num><br />
<def>    v</def> <sym>&lt;-</sym> <def>mallocArray n</def> <sym>::</sym> <def>IO Reals<br />
    forM_</def> <sym>[</sym><def></def><num>0</num><def>..n</def><sym>-</sym><def></def><num>1</num><def></def><sym>]</sym> <def>$ \i</def> <sym>-&gt;</sym> <def>pokeElemOff v i</def> <num>0</num><br />
<def><br />
    powerMethod</def> <num>10</num> <def>n u v<br />
    printf</def> <str>&quot;%.9f\n&quot;</str><def></def> <sym>(</sym><def>eigenvalue n u v</def> <num>0 0 0</num><def></def><sym>)</sym><br />
<def></def><br />
<slc>------------------------------------------------------------------------</slc><br />
<def><br />
eigenvalue</def> <sym>::</sym> <def></def><kwb>Int</kwb> <def></def><sym>-&gt;</sym> <def>Reals</def> <sym>-&gt;</sym> <def>Reals</def> <sym>-&gt;</sym> <def></def><kwb>Int</kwb> <def></def><sym>-&gt;</sym> <def></def><kwb>Double</kwb> <def></def><sym>-&gt;</sym> <def></def><kwb>Double</kwb> <def></def><sym>-&gt;</sym> <def></def><kwb>Double</kwb><br />
<def>eigenvalue</def> <sym>!</sym><def>n</def> <sym>!</sym><def>u</def> <sym>!</sym><def>v</def> <sym>!</sym><def>i</def> <sym>!</sym><def>vBv</def> <sym>!</sym><def>vv</def><br />
    <sym>|</sym> <def>i</def> <sym>&lt;</sym> <def>n</def>     <sym>=</sym> <def>eigenvalue n u v</def> <sym>(</sym><def>i</def><sym>+</sym><def></def><num>1</num><def></def><sym>) (</sym><def>vBv</def> <sym>+</sym> <def>ui</def> <sym>*</sym> <def>vi</def><sym>) (</sym><def>vv</def> <sym>+</sym> <def>vi</def> <sym>*</sym> <def>vi</def><sym>)</sym><br />
<def></def>    <sym>|</sym> <def>otherwise</def> <sym>=</sym> <def>sqrt $</def><sym>!</sym> <def>vBv</def> <sym>/</sym> <def>vv</def><br />
    <kwa>where</kwa><br />
<def>       ui</def> <sym>=</sym> <def>inlinePerformIO</def> <sym>(</sym><def>peekElemOff u i</def><sym>)</sym><br />
<def>       vi</def> <sym>=</sym> <def>inlinePerformIO</def> <sym>(</sym><def>peekElemOff v i</def><sym>)</sym><br />
<def></def><br />
<slc>------------------------------------------------------------------------</slc><br />
<def><br />
powerMethod</def> <sym>::</sym> <def></def><kwb>Int</kwb> <def></def><sym>-&gt;</sym> <def></def><kwb>Int</kwb> <def></def><sym>-&gt;</sym> <def>Reals</def> <sym>-&gt;</sym> <def>Reals</def> <sym>-&gt;</sym> <def>IO</def> <sym>()</sym><br />
<def>powerMethod</def> <sym>!</sym><def>i</def> <sym>!</sym><def>n</def> <sym>!</sym><def>u</def> <sym>!</sym><def>v</def> <sym>=</sym> <def>allocaArray n $ \t</def> <sym>-&gt;</sym><br />
<def>    replicateM_ i $ timesAtAv t n u v</def> <sym>&gt;&gt;</sym> <def>timesAtAv t n v u</def><br />
<br />
<slc>-- multiply vector v by matrix A and then by matrix A transposed</slc><br />
<def>timesAtAv</def> <sym>::</sym> <def>Reals</def> <sym>-&gt;</sym> <def></def><kwb>Int</kwb> <def></def><sym>-&gt;</sym> <def>Reals</def> <sym>-&gt;</sym> <def>Reals</def> <sym>-&gt;</sym> <def>IO</def> <sym>()</sym><br />
<def>timesAtAv</def> <sym>!</sym><def>t</def> <sym>!</sym><def>n</def> <sym>!</sym><def>u</def> <sym>!</sym><def>atau</def> <sym>=</sym> <def></def><kwa>do</kwa><br />
<def>    timesAv  n u t<br />
    timesAtv n t atau<br />
<br />
timesAv</def> <sym>::</sym> <def></def><kwb>Int</kwb> <def></def><sym>-&gt;</sym> <def>Reals</def> <sym>-&gt;</sym> <def>Reals</def> <sym>-&gt;</sym> <def>IO</def> <sym>()</sym><br />
<def>timesAv</def> <sym>!</sym><def>n</def> <sym>!</sym><def>u</def> <sym>!</sym><def>au</def> <sym>=</sym> <def>go</def> <num>0</num><br />
<def></def>  <kwa>where</kwa><br />
<def>    go</def> <sym>::</sym> <def></def><kwb>Int</kwb> <def></def><sym>-&gt;</sym> <def>IO</def> <sym>()</sym><br />
<def>    go</def> <sym>!</sym><def>i</def> <sym>=</sym> <def>when</def> <sym>(</sym><def>i</def> <sym>&lt;</sym> <def>n</def><sym>)</sym> <def>$</def> <kwa>do</kwa><br />
<def>        pokeElemOff au i</def> <sym>(</sym><def>avsum i</def> <num>0 0</num><def></def><sym>)</sym><br />
<def>        go</def> <sym>(</sym><def>i</def><sym>+</sym><def></def><num>1</num><def></def><sym>)</sym><br />
<def><br />
    avsum</def> <sym>::</sym> <def></def><kwb>Int</kwb> <def></def><sym>-&gt;</sym> <def></def><kwb>Int</kwb> <def></def><sym>-&gt;</sym> <def></def><kwb>Double</kwb> <def></def><sym>-&gt;</sym> <def></def><kwb>Double</kwb><br />
<def>    avsum</def> <sym>!</sym><def>i</def> <sym>!</sym><def>j</def> <sym>!</sym><def>acc</def><br />
        <sym>|</sym> <def>j</def> <sym>&lt;</sym> <def>n</def> <sym>=</sym> <def>avsum i</def> <sym>(</sym><def>j</def><sym>+</sym><def></def><num>1</num><def></def><sym>) (</sym><def>acc</def> <sym>+ ((</sym><def>aij i j</def><sym>) *</sym> <def>uj</def><sym>))</sym><br />
<def></def>        <sym>|</sym> <def>otherwise</def> <sym>=</sym> <def>acc</def><br />
        <kwa>where</kwa> <def>uj</def> <sym>=</sym> <def>inlinePerformIO</def> <sym>(</sym><def>peekElemOff u j</def><sym>)</sym><br />
<def><br />
timesAtv</def> <sym>::</sym> <def></def><kwb>Int</kwb> <def></def><sym>-&gt;</sym> <def>Reals</def> <sym>-&gt;</sym> <def>Reals</def> <sym>-&gt;</sym> <def>IO</def> <sym>()</sym><br />
<def>timesAtv</def> <sym>!</sym><def>n</def> <sym>!</sym><def>u</def> <sym>!</sym><def>a</def> <sym>=</sym> <def>go</def> <num>0</num><br />
<def></def>  <kwa>where</kwa><br />
<def>    go</def> <sym>::</sym> <def></def><kwb>Int</kwb> <def></def><sym>-&gt;</sym> <def>IO</def> <sym>()</sym><br />
<def>    go</def> <sym>!</sym><def>i</def> <sym>=</sym> <def>when</def> <sym>(</sym><def>i</def> <sym>&lt;</sym> <def>n</def><sym>)</sym> <def>$</def> <kwa>do</kwa><br />
<def>        pokeElemOff a i</def> <sym>(</sym><def>atvsum i</def> <num>0 0</num><def></def><sym>)</sym><br />
<def>        go</def> <sym>(</sym><def>i</def><sym>+</sym><def></def><num>1</num><def></def><sym>)</sym><br />
<def><br />
    atvsum</def> <sym>::</sym> <def></def><kwb>Int</kwb> <def></def><sym>-&gt;</sym> <def></def><kwb>Int</kwb> <def></def><sym>-&gt;</sym> <def></def><kwb>Double</kwb> <def></def><sym>-&gt;</sym> <def></def><kwb>Double</kwb><br />
<def>    atvsum</def> <sym>!</sym><def>i</def> <sym>!</sym><def>j</def> <sym>!</sym><def>acc</def><br />
        <sym>|</sym> <def>j</def> <sym>&lt;</sym> <def>n</def>     <sym>=</sym> <def>atvsum i</def> <sym>(</sym><def>j</def><sym>+</sym><def></def><num>1</num><def></def><sym>) (</sym><def>acc</def> <sym>+ ((</sym><def>aij j i</def><sym>) *</sym> <def>uj</def><sym>))</sym><br />
<def></def>        <sym>|</sym> <def>otherwise</def> <sym>=</sym> <def>acc</def><br />
        <kwa>where</kwa> <def>uj</def> <sym>=</sym> <def>inlinePerformIO</def> <sym>(</sym><def>peekElemOff u j</def><sym>)</sym><br />
<def></def><br />
<slc>--</slc><br />
<def></def><slc>-- manually unbox the inner loop:</slc><br />
<def></def><slc>-- aij i j = 1 / fromIntegral ((i+j) * (i+j+1) `div` 2 + i + 1)</slc><br />
<def></def><slc>--</slc><br />
<def>aij</def> <sym>(</sym><def>I# i</def><sym>) (</sym><def>I# j</def><sym>) =</sym> <def>D#</def> <sym>(</sym><br />
<def></def>    <kwa>case</kwa> <def>i</def> <sym>+</sym><def># j</def> <kwa>of</kwa><br />
<def>        n</def> <sym>-&gt;</sym> <def></def><kwa>case</kwa> <def>n</def> <sym>*</sym><def>#</def> <sym>(</sym><def>n</def><sym>+</sym><def>#</def><num>1</num><def>#</def><sym>)</sym> <def></def><kwa>of</kwa><br />
<def>                t</def> <sym>-&gt;</sym> <def></def><kwa>case</kwa> <def>t `uncheckedIShiftRA#`</def> <num>1</num><def>#</def> <kwa>of</kwa><br />
<def>                        u</def> <sym>-&gt;</sym> <def></def><kwa>case</kwa> <def>u</def> <sym>+</sym><def>#</def> <sym>(</sym><def>i</def> <sym>+</sym><def>#</def> <num>1</num><def>#</def><sym>)</sym> <def></def><kwa>of</kwa><br />
<def>                                r</def> <sym>-&gt;</sym> <def></def><num>1.0</num><def>##</def> <sym>/</sym><def>##</def> <sym>(</sym><def>int2Double# r</def><sym>))</sym><def></def><br />
</source>
