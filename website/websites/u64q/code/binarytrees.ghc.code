<source>
<def></def><com>{-# OPTIONS -fbang-patterns -funbox-strict-fields #-}</com><def></def><br />
<slc>--</slc><br />
<def></def><slc>-- The Computer Language Shootout</slc><br />
<def></def><slc>-- http://shootout.alioth.debian.org/</slc><br />
<def></def><slc>--</slc><br />
<def></def><slc>-- Contributed by Don Stewart</slc><br />
<def></def><slc>--</slc><br />
<def></def><br />
<kwa>import</kwa> <def>System</def><br />
<kwa>import</kwa> <def>Data.Bits</def><br />
<kwa>import</kwa> <def>Text.Printf</def><br />
<br />
<slc>--</slc><br />
<def></def><slc>-- an artificially strict tree.</slc><br />
<def></def><slc>--</slc><br />
<def></def><slc>-- normally you would ensure the branches are lazy, but this benchmark</slc><br />
<def></def><slc>-- requires strict allocation.</slc><br />
<def></def><slc>--</slc><br />
<def></def><kwa>data</kwa> <def>Tree</def> <sym>=</sym> <def>Nil</def> <sym>|</sym> <def>Node</def> <sym>!</sym><def></def><kwb>Int</kwb> <def></def><sym>!</sym><def>Tree</def> <sym>!</sym><def>Tree<br />
<br />
minN</def> <sym>=</sym> <def></def><num>4</num><br />
<def><br />
io s n t</def> <sym>=</sym> <def>printf</def> <str>&quot;%s of depth %d\t check: %d\n&quot;</str><def> s n t<br />
<br />
main</def> <sym>=</sym> <def></def><kwa>do</kwa><br />
<def>    n</def> <sym>&lt;-</sym> <def>getArgs</def> <sym>&gt;&gt;=</sym> <def>readIO . head</def><br />
    <kwa>let</kwa> <def>maxN</def>     <sym>=</sym> <def>max</def> <sym>(</sym><def>minN</def> <sym>+</sym> <def></def><num>2</num><def></def><sym>)</sym> <def>n<br />
        stretchN</def> <sym>=</sym> <def>maxN</def> <sym>+</sym> <def></def><num>1</num><br />
<def></def><br />
    <slc>-- stretch memory tree</slc><br />
<def></def>    <kwa>let</kwa> <def>c</def> <sym>=</sym> <def>check</def> <sym>(</sym><def>make</def> <num>0</num> <def>stretchN</def><sym>)</sym><br />
<def>    io</def> <str>&quot;stretch tree&quot;</str><def> stretchN c</def><br />
<br />
    <slc>-- allocate a long lived tree</slc><br />
<def></def>    <kwa>let</kwa> <def></def><sym>!</sym><def>long</def>    <sym>=</sym> <def>make</def> <num>0</num> <def>maxN</def><br />
<br />
    <slc>-- allocate, walk, and deallocate many bottom-up binary trees</slc><br />
<def></def>    <kwa>let</kwa> <def>vs</def> <sym>=</sym> <def>depth minN maxN<br />
    mapM_</def> <sym>(</sym><def>\</def><sym>((</sym><def>m</def><sym>,</sym><def>d</def><sym>,</sym><def>i</def><sym>)) -&gt;</sym> <def>io</def> <sym>(</sym><def>show m</def> <sym>++</sym> <def></def><str>&quot;\t trees&quot;</str><def></def><sym>)</sym> <def>d i</def><sym>)</sym> <def>vs</def><br />
<br />
    <slc>-- confirm the the long-lived binary tree still exists</slc><br />
<def>    io</def> <str>&quot;long lived tree&quot;</str><def> maxN</def> <sym>(</sym><def>check long</def><sym>)</sym><br />
<def></def><br />
<slc>-- generate many trees</slc><br />
<def>depth</def> <sym>::</sym> <def></def><kwb>Int</kwb> <def></def><sym>-&gt;</sym> <def></def><kwb>Int</kwb> <def></def><sym>-&gt; [(</sym><def></def><kwb>Int</kwb><def></def><sym>,</sym><def></def><kwb>Int</kwb><def></def><sym>,</sym><def></def><kwb>Int</kwb><def></def><sym>)]</sym><br />
<def>depth d m</def><br />
    <sym>|</sym> <def>d</def> <sym>&lt;=</sym> <def>m</def>    <sym>= (</sym><def></def><num>2</num><def></def><sym>*</sym><def>n</def><sym>,</sym><def>d</def><sym>,</sym><def>sumT d n</def> <num>0</num><def></def><sym>) :</sym> <def>depth</def> <sym>(</sym><def>d</def><sym>+</sym><def></def><num>2</num><def></def><sym>)</sym> <def>m</def><br />
    <sym>|</sym> <def>otherwise</def> <sym>= []</sym><br />
<def></def>  <kwa>where</kwa> <def>n</def> <sym>=</sym> <def></def><num>1</num> <def>`shiftL`</def> <sym>(</sym><def>m</def> <sym>-</sym> <def>d</def> <sym>+</sym> <def>minN</def><sym>)</sym><br />
<def></def><br />
<slc>-- allocate and check lots of trees</slc><br />
<def>sumT</def> <sym>::</sym> <def></def><kwb>Int</kwb> <def></def><sym>-&gt;</sym> <def></def><kwb>Int</kwb> <def></def><sym>-&gt;</sym> <def></def><kwb>Int</kwb> <def></def><sym>-&gt;</sym> <def></def><kwb>Int</kwb><br />
<def>sumT d</def> <num>0</num> <def>t</def> <sym>=</sym> <def>t<br />
sumT  d i t</def> <sym>=</sym> <def>sumT d</def> <sym>(</sym><def>i</def><sym>-</sym><def></def><num>1</num><def></def><sym>) (</sym><def>t</def> <sym>+</sym> <def>a</def> <sym>+</sym> <def>b</def><sym>)</sym><br />
<def></def>  <kwa>where</kwa> <def>a</def> <sym>=</sym> <def>check</def> <sym>(</sym><def>make i    d</def><sym>)</sym><br />
<def>        b</def> <sym>=</sym> <def>check</def> <sym>(</sym><def>make</def> <sym>(-</sym><def>i</def><sym>)</sym> <def>d</def><sym>)</sym><br />
<def></def><br />
<slc>-- traverse the tree, counting up the nodes</slc><br />
<def>check</def> <sym>::</sym> <def>Tree</def> <sym>-&gt;</sym> <def></def><kwb>Int</kwb><br />
<def>check Nil</def>          <sym>=</sym> <def></def><num>0</num><br />
<def>check</def> <sym>(</sym><def>Node i l r</def><sym>) =</sym> <def>i</def> <sym>+</sym> <def>check l</def> <sym>-</sym> <def>check r</def><br />
<br />
<slc>-- build a tree</slc><br />
<def>make</def> <sym>::</sym> <def></def><kwb>Int</kwb> <def></def><sym>-&gt;</sym> <def></def><kwb>Int</kwb> <def></def><sym>-&gt;</sym> <def>Tree<br />
make i</def> <num>0</num> <def></def><sym>=</sym> <def>Node i Nil Nil<br />
make i d</def> <sym>=</sym> <def>Node i</def> <sym>(</sym><def>make</def> <sym>(</sym><def>i2</def><sym>-</sym><def></def><num>1</num><def></def><sym>)</sym> <def>d2</def><sym>) (</sym><def>make i2 d2</def><sym>)</sym><br />
<def></def>  <kwa>where</kwa> <def>i2</def> <sym>=</sym> <def></def><num>2</num><def></def><sym>*</sym><def>i</def><sym>;</sym> <def>d2</def> <sym>=</sym> <def>d</def><sym>-</sym><def></def><num>1</num><def></def><br />
</source>
