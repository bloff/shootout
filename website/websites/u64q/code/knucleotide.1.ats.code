<span class="hl com">(*</span>
<span class="hl com">** The Computer Language Benchmarks Game</span>
<span class="hl com">** http://shootout.alioth.debian.org/</span>
<span class="hl com">**</span>
<span class="hl com">** contributed by Hongwei Xi</span>
<span class="hl com">**</span>
<span class="hl com">** compilation command:</span>
<span class="hl com">**   atscc -O3 knucleotide.dats -o knucleotide -D_ATS_GCATS</span>
<span class="hl com">*)</span>

<span class="hl com">(* ****** ****** *)</span>

staload <span class="hl str">&quot;libc/SATS/stdio.sats&quot;</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl sym">//</span> The hashtable implementation is based on linear<span class="hl sym">-</span>probing
<span class="hl sym">//</span> <span class="hl dir">#include</span> <span class="hl dstr">&quot;symtbl.dats&quot;</span><span class="hl dir"></span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl sym">%{</span>^

<span class="hl sym">//</span> <span class="hl dir">#include</span> <span class="hl dstr">&quot;symtbl.hats&quot;</span><span class="hl dir"></span>
<span class="hl kwa">typedef</span> ats_ptr_type ats_string_type <span class="hl sym">;</span>
<span class="hl kwa">typedef struct</span> <span class="hl sym">{</span> int beg <span class="hl sym">;</span> int len <span class="hl sym">; }</span> symbol_t <span class="hl sym">;</span>
<span class="hl kwa">typedef struct</span> <span class="hl sym">{</span> symbol_t sym <span class="hl sym">;</span> int cnt <span class="hl sym">; }</span> tblent_t <span class="hl sym">;</span>

<span class="hl sym">%}</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl sym">//</span> staload <span class="hl str">&quot;symtbl.sats&quot;</span>
<span class="hl kwa">abstype</span> dna_t <span class="hl sym">//</span> boxed type
abst&#64;ype symbol_t <span class="hl sym">=</span> $extype <span class="hl str">&quot;symbol_t&quot;</span>
<span class="hl kwa">abstype</span> symtbl_t <span class="hl sym">//</span> boxed type

<span class="hl kwa">extern fun</span> print_symbol <span class="hl sym">(</span>dna<span class="hl sym">:</span> dna_t<span class="hl sym">,</span> sym<span class="hl sym">:</span> symbol_t<span class="hl sym">):</span> void
<span class="hl kwa">extern fun</span> symtbl_make <span class="hl sym">(</span>dna<span class="hl sym">:</span> dna_t<span class="hl sym">,</span> size<span class="hl sym">:</span> Nat<span class="hl sym">) :</span> symtbl_t
<span class="hl kwa">extern fun</span> symtbl_clear <span class="hl sym">(</span>tbl<span class="hl sym">:</span> symtbl_t<span class="hl sym">) :</span> void <span class="hl sym">=</span> <span class="hl str">&quot;symtbl_clear&quot;</span>
<span class="hl kwa">extern fun</span> symtbl_search <span class="hl sym">(</span>tbl<span class="hl sym">:</span> symtbl_t<span class="hl sym">,</span> name<span class="hl sym">:</span> string<span class="hl sym">) :</span> int
  <span class="hl sym">=</span> <span class="hl str">&quot;symtbl_search&quot;</span>
<span class="hl kwa">extern fun</span> symtbl_insert <span class="hl sym">(</span>tbl<span class="hl sym">:</span> symtbl_t<span class="hl sym">,</span> sym<span class="hl sym">:</span> symbol_t<span class="hl sym">,</span> cnt<span class="hl sym">:</span> int<span class="hl sym">) :</span> void
  <span class="hl sym">=</span> <span class="hl str">&quot;symtbl_insert&quot;</span>
<span class="hl kwa">extern fun</span> symtbl_fold <span class="hl sym">{</span>a<span class="hl sym">:</span>viewt&#64;ype<span class="hl sym">}</span>
  <span class="hl sym">(</span>tbl<span class="hl sym">:</span> symtbl_t<span class="hl sym">,</span> f<span class="hl sym">: !(</span>symbol_t<span class="hl sym">,</span> int<span class="hl sym">, &amp;</span>a<span class="hl sym">) -&lt;</span>cloptr1<span class="hl sym">&gt;</span> void<span class="hl sym">,</span> res<span class="hl sym">: &amp;</span>a<span class="hl sym">) :</span> void
<span class="hl kwa">extern fun</span> symtbl_dna <span class="hl sym">(</span>tbl<span class="hl sym">:</span> symtbl_t<span class="hl sym">):</span> dna_t

<span class="hl com">(* ****** ****** *)</span>

abst&#64;ype tblent_t <span class="hl sym">=</span> $extype <span class="hl str">&quot;tblent_t&quot;</span>

<span class="hl kwa">viewtypedef</span> symtbl <span class="hl sym">(</span>sz<span class="hl sym">:</span>int<span class="hl sym">,</span> n<span class="hl sym">:</span>int<span class="hl sym">,</span> l<span class="hl sym">:</span>addr<span class="hl sym">) =</span> &#64;<span class="hl sym">{</span>
  dna<span class="hl sym">=</span> dna_t
<span class="hl sym">,</span> ptr<span class="hl sym">=</span> ptr l
<span class="hl sym">,</span> view_arr<span class="hl sym">=</span> &#64;<span class="hl sym">[</span>tblent_t<span class="hl sym">][</span>sz<span class="hl sym">]</span> &#64; l
<span class="hl sym">,</span> view_arr_gc<span class="hl sym">=</span> free_gc_v l
<span class="hl sym">,</span> size<span class="hl sym">=</span> int sz
<span class="hl sym">,</span> nitm<span class="hl sym">=</span> int n
<span class="hl sym">}</span>

<span class="hl kwa">viewtypedef</span> symtbl0 <span class="hl sym">=</span> symtbl <span class="hl sym">(</span><span class="hl num">0</span><span class="hl sym">,</span> <span class="hl num">0</span><span class="hl sym">,</span> null<span class="hl sym">)</span>
<span class="hl kwa">viewtypedef</span> symtbl <span class="hl sym">= [</span>sz<span class="hl sym">,</span>n<span class="hl sym">:</span>nat <span class="hl sym">|</span> sz <span class="hl sym">&gt;</span> <span class="hl num">0</span><span class="hl sym">] [</span>l<span class="hl sym">:</span>addr<span class="hl sym">]</span> symtbl <span class="hl sym">(</span>sz<span class="hl sym">,</span> n<span class="hl sym">,</span> l<span class="hl sym">)</span>
<span class="hl kwa">assume</span> symtbl_t <span class="hl sym">= [</span>l_tbl<span class="hl sym">:</span> addr<span class="hl sym">] (</span>vbox <span class="hl sym">(</span>symtbl &#64; l_tbl<span class="hl sym">) |</span> ptr l_tbl<span class="hl sym">)</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl kwa">extern fun</span> fprint_symbol <span class="hl sym">{</span>m<span class="hl sym">:</span>file_mode<span class="hl sym">}</span>
  <span class="hl sym">(</span>pf<span class="hl sym">:</span> file_mode_lte <span class="hl sym">(</span>m<span class="hl sym">,</span> w<span class="hl sym">) |</span> out<span class="hl sym">: &amp;</span>FILE m<span class="hl sym">,</span> dna<span class="hl sym">:</span> dna_t<span class="hl sym">,</span> sym<span class="hl sym">:</span> symbol_t<span class="hl sym">):</span> void
  <span class="hl sym">=</span> <span class="hl str">&quot;fprint_symbol&quot;</span>

<span class="hl sym">%{</span>

ats_void_type fprint_symbol
  <span class="hl sym">(</span>ats_ptr_type out<span class="hl sym">,</span> ats_ptr_type dna<span class="hl sym">,</span> symbol_t sym<span class="hl sym">) {</span>
  char <span class="hl sym">*</span>s <span class="hl sym">;</span> int i <span class="hl sym">;</span>

  s <span class="hl sym">= (</span>char*)dna <span class="hl sym">+</span> sym<span class="hl sym">.</span>beg <span class="hl sym">-</span> <span class="hl num">1</span> <span class="hl sym">;</span> i <span class="hl sym">=</span> <span class="hl num">0</span> <span class="hl sym">;</span>

  <span class="hl kwa">while</span> <span class="hl sym">(</span>i <span class="hl sym">&lt;</span> sym<span class="hl sym">.</span>len<span class="hl sym">) {</span>
    fputc <span class="hl com">(*s, (FILE*)</span>out<span class="hl sym">) ; ++</span>i <span class="hl sym">; ++</span>s <span class="hl sym">;</span>
  <span class="hl sym">}</span>

  return <span class="hl sym">;</span>

<span class="hl sym">}</span>

<span class="hl sym">%}</span>

<span class="hl kwa">implement</span> print_symbol <span class="hl sym">(</span>dna<span class="hl sym">,</span> sym<span class="hl sym">) =</span>
  <span class="hl kwa">let</span>
     <span class="hl kwa">val</span> <span class="hl sym">(</span>pf_stdout <span class="hl sym">|</span> ptr_stdout<span class="hl sym">) =</span> stdout_get <span class="hl sym">()</span>
  <span class="hl kwa">in</span>
     fprint_symbol <span class="hl sym">(</span>file_mode_lte_w_w <span class="hl sym">| !</span>ptr_stdout<span class="hl sym">,</span> dna<span class="hl sym">,</span> sym<span class="hl sym">);</span>
     stdout_view_set <span class="hl sym">(</span>pf_stdout <span class="hl sym">|</span> <span class="hl com">(*none*)</span><span class="hl sym">)</span>
  <span class="hl kwa">end</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl dir">#define i2u uint1_of_int1</span>
<span class="hl kwa">extern fun</span> hash_string_33 <span class="hl sym">(</span>s<span class="hl sym">:</span> string<span class="hl sym">):&lt;&gt;</span> uInt <span class="hl sym">=</span> <span class="hl str">&quot;hash_string_33&quot;</span>
<span class="hl kwa">extern fun</span> hash_symbol_33 <span class="hl sym">(</span>dna<span class="hl sym">:</span> dna_t<span class="hl sym">,</span> sym<span class="hl sym">:</span> symbol_t<span class="hl sym">):&lt;&gt;</span> uInt <span class="hl sym">=</span> <span class="hl str">&quot;hash_symbol_33&quot;</span>

<span class="hl sym">%{</span>

<span class="hl sym">//</span> a commonly used simple hash function

ats_uint_type hash_string_33 <span class="hl sym">(</span>ats_ptr_type s0<span class="hl sym">) {</span>
  unsigned int hash_val <span class="hl sym">;</span> unsigned char <span class="hl sym">*</span>s <span class="hl sym">;</span> int c <span class="hl sym">;</span>
  hash_val <span class="hl sym">=</span> <span class="hl num">314159</span> <span class="hl sym">;</span>

  s <span class="hl sym">= (</span>unsigned char*)s0 <span class="hl sym">;</span>
  <span class="hl kwa">while</span> <span class="hl sym">(</span><span class="hl num">1</span><span class="hl sym">) {</span>
    c <span class="hl sym">= *</span>s <span class="hl sym">;</span>
    <span class="hl kwa">if</span> <span class="hl sym">(!</span>c<span class="hl sym">)</span> return hash_val <span class="hl sym">;</span>
    hash_val <span class="hl sym">= ((</span>hash_val <span class="hl sym">&lt;&lt;</span> <span class="hl num">5</span><span class="hl sym">) +</span> hash_val<span class="hl sym">) +</span> c <span class="hl sym">;</span>
    s <span class="hl sym">+=</span> <span class="hl num">1</span> <span class="hl sym">;</span>
  <span class="hl sym">}</span>
<span class="hl sym">}</span>

ats_uint_type hash_symbol_33 <span class="hl sym">(</span>ats_ptr_type dna<span class="hl sym">,</span> symbol_t sym<span class="hl sym">) {</span>

  unsigned int hash_val<span class="hl sym">,</span> n <span class="hl sym">;</span> unsigned char <span class="hl sym">*</span>s <span class="hl sym">;</span>
  hash_val <span class="hl sym">=</span> <span class="hl num">314159</span> <span class="hl sym">;</span>

  n <span class="hl sym">=</span> sym<span class="hl sym">.</span>len <span class="hl sym">;</span>
  s <span class="hl sym">= (</span>unsigned char*)dna <span class="hl sym">+</span> sym<span class="hl sym">.</span>beg <span class="hl sym">-</span> <span class="hl num">1</span> <span class="hl sym">;</span>

  <span class="hl kwa">while</span> <span class="hl sym">(</span>n <span class="hl sym">&gt;</span> <span class="hl num">0</span><span class="hl sym">) {</span>
    hash_val <span class="hl sym">= ((</span>hash_val <span class="hl sym">&lt;&lt;</span> <span class="hl num">5</span><span class="hl sym">) +</span> hash_val<span class="hl sym">) + *</span>s <span class="hl sym">;</span>
    <span class="hl sym">++</span>s <span class="hl sym">; --</span>n <span class="hl sym">;</span>
  <span class="hl sym">}</span>
<span class="hl com">/*</span>
<span class="hl com">  fprintf (stdout, &quot;has_symbol_33: \n&quot;) ;</span>
<span class="hl com">  fprintf (stdout, &quot;  sym = &quot;) ;</span>
<span class="hl com">  fprint_symbol (stdout, dna, sym) ;</span>
<span class="hl com">  fprintf (stdout, &quot;\n  hash_val = %u\n&quot;, hash_val) ;</span>
<span class="hl com">*/</span>
  return hash_val <span class="hl sym">;</span>
<span class="hl sym">}</span>

<span class="hl sym">%}</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl kwa">extern fun</span> tblent_array_make <span class="hl sym">{</span>sz<span class="hl sym">:</span> nat<span class="hl sym">}</span>
  <span class="hl sym">(</span>sz<span class="hl sym">:</span> int sz<span class="hl sym">):&lt;&gt; [</span>l<span class="hl sym">:</span>addr<span class="hl sym">] (</span>free_gc_v l<span class="hl sym">,</span> array_v <span class="hl sym">(</span>tblent_t<span class="hl sym">,</span> sz<span class="hl sym">,</span> l<span class="hl sym">) |</span> ptr l<span class="hl sym">)</span>
  <span class="hl sym">=</span> <span class="hl str">&quot;tblent_array_make&quot;</span>

<span class="hl sym">%{</span>

ats_ptr_type
tblent_array_make <span class="hl sym">(</span>ats_int_type sz<span class="hl sym">) {</span>
  return ats_calloc_gc <span class="hl sym">(</span>sz<span class="hl sym">,</span> sizeof<span class="hl sym">(</span>tblent_t<span class="hl sym">)) ;</span>
<span class="hl sym">}</span>

<span class="hl sym">%}</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl kwa">implement</span> symtbl_make <span class="hl sym">(</span>dna<span class="hl sym">,</span> sz<span class="hl sym">) =</span> <span class="hl kwa">let</span>
<span class="hl kwa">val</span> sz <span class="hl sym">=</span> max <span class="hl sym">(</span>sz<span class="hl sym">,</span> <span class="hl num">1</span><span class="hl sym">)</span>
<span class="hl kwa">val</span> <span class="hl sym">(</span>pf_tbl_gc<span class="hl sym">,</span> pf_tbl <span class="hl sym">|</span> p_tbl<span class="hl sym">) =</span> ptr_alloc_tsz <span class="hl sym">{</span>symtbl0<span class="hl sym">} (</span>sizeof<span class="hl sym">&lt;</span>symtbl0<span class="hl sym">&gt;)</span>
<span class="hl kwa">val</span> <span class="hl sym">(</span>pf_arr_gc<span class="hl sym">,</span> pf_arr <span class="hl sym">|</span> p_arr<span class="hl sym">) =</span> tblent_array_make <span class="hl sym">(</span>sz<span class="hl sym">)</span>

<span class="hl kwa">val</span> <span class="hl sym">() =</span> <span class="hl kwa">begin</span>
  p_tbl<span class="hl sym">-&gt;</span>dna <span class="hl sym">:=</span> dna<span class="hl sym">;</span>
  p_tbl<span class="hl sym">-&gt;</span>ptr <span class="hl sym">:=</span> p_arr<span class="hl sym">;</span>
  p_tbl<span class="hl sym">-&gt;</span>view_arr <span class="hl sym">:=</span> pf_arr<span class="hl sym">;</span>
  p_tbl<span class="hl sym">-&gt;</span>view_arr_gc <span class="hl sym">:=</span> pf_arr_gc<span class="hl sym">;</span>
  p_tbl<span class="hl sym">-&gt;</span>size <span class="hl sym">:=</span> sz<span class="hl sym">;</span>
  p_tbl<span class="hl sym">-&gt;</span>nitm <span class="hl sym">:=</span> <span class="hl num">0</span>
<span class="hl kwa">end</span>

<span class="hl kwa">val</span> <span class="hl sym">(</span>pfbox <span class="hl sym">| ()) =</span> vbox_make_view_ptr_gc <span class="hl sym">(</span>pf_tbl_gc<span class="hl sym">,</span> pf_tbl <span class="hl sym">|</span> p_tbl<span class="hl sym">)</span>

<span class="hl kwa">in</span>
  <span class="hl sym">(</span>pfbox <span class="hl sym">|</span> p_tbl<span class="hl sym">)</span>
<span class="hl kwa">end</span> <span class="hl sym">//</span> symtbl_make

<span class="hl com">(* ****** ****** *)</span>

<span class="hl kwa">extern fun</span> tblent_array_clear <span class="hl sym">{</span>sz<span class="hl sym">:</span>nat<span class="hl sym">} {</span>l<span class="hl sym">:</span>addr<span class="hl sym">}</span>
  <span class="hl sym">(</span>pf<span class="hl sym">: !</span>array_v <span class="hl sym">(</span>tblent_t<span class="hl sym">,</span> sz<span class="hl sym">,</span> l<span class="hl sym">) |</span> p<span class="hl sym">:</span> ptr l<span class="hl sym">,</span> sz<span class="hl sym">:</span> int sz<span class="hl sym">):&lt;&gt;</span> void
  <span class="hl sym">=</span> <span class="hl str">&quot;tblent_array_clear&quot;</span>

<span class="hl sym">%{</span>

ats_void_type
tblent_array_clear <span class="hl sym">(</span>ats_ptr_type p<span class="hl sym">,</span> ats_int_type sz<span class="hl sym">) {</span>
  memset <span class="hl sym">(</span>p<span class="hl sym">,</span> <span class="hl num">0</span><span class="hl sym">,</span> sz <span class="hl sym">*</span> sizeof<span class="hl sym">(</span>tblent_t<span class="hl sym">)) ;</span>
<span class="hl sym">}</span>

<span class="hl sym">%}</span>

<span class="hl kwa">implement</span> symtbl_clear <span class="hl sym">(</span>tbl<span class="hl sym">) =</span> <span class="hl kwa">let</span>

<span class="hl kwa">val</span> <span class="hl sym">(</span>vbox pf_tbl <span class="hl sym">|</span> p_tbl<span class="hl sym">) =</span> tbl

<span class="hl kwa">in</span>

tblent_array_clear <span class="hl sym">(</span>p_tbl<span class="hl sym">-&gt;</span>view_arr <span class="hl sym">|</span>  p_tbl<span class="hl sym">-&gt;</span>ptr<span class="hl sym">,</span> p_tbl<span class="hl sym">-&gt;</span>size<span class="hl sym">);</span>
p_tbl<span class="hl sym">-&gt;</span>nitm <span class="hl sym">:=</span> <span class="hl num">0</span>

<span class="hl kwa">end</span>

<span class="hl sym">//</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl sym">//</span> linear probing
<span class="hl kwa">extern fun</span> symtbl_search_probe <span class="hl sym">{</span>sz<span class="hl sym">,</span>i<span class="hl sym">:</span>nat <span class="hl sym">|</span> i <span class="hl sym">&lt;</span> sz<span class="hl sym">} {</span>l<span class="hl sym">:</span>addr<span class="hl sym">}</span>
  <span class="hl sym">(</span>pf<span class="hl sym">: !</span>array_v<span class="hl sym">(</span>tblent_t<span class="hl sym">,</span> sz<span class="hl sym">,</span> l<span class="hl sym">) |</span>
  dna<span class="hl sym">:</span> dna_t<span class="hl sym">,</span> p<span class="hl sym">:</span> ptr l<span class="hl sym">,</span> sz<span class="hl sym">:</span> int sz<span class="hl sym">,</span> name<span class="hl sym">:</span> string<span class="hl sym">,</span> i<span class="hl sym">:</span> int i<span class="hl sym">):&lt;&gt;</span> int
  <span class="hl sym">=</span> <span class="hl str">&quot;symtbl_search_probe&quot;</span>

<span class="hl sym">%{</span>

ats_int_type symtbl_search_probe
  <span class="hl sym">(</span>ats_string_type dna<span class="hl sym">,</span>
   ats_ptr_type p<span class="hl sym">,</span>
   ats_int_type sz<span class="hl sym">,</span>
   ats_string_type name<span class="hl sym">,</span>
   ats_int_type i<span class="hl sym">) {</span>

  tblent_t <span class="hl sym">*</span>ent <span class="hl sym">;</span> int beg <span class="hl sym">;</span>

  ent <span class="hl sym">= ((</span>tblent_t *)p<span class="hl sym">) +</span> i <span class="hl sym">;</span>

  <span class="hl kwa">while</span> <span class="hl sym">(</span><span class="hl num">1</span><span class="hl sym">) {</span>
    beg <span class="hl sym">= (</span>ent<span class="hl sym">-&gt;</span>sym<span class="hl sym">).</span>beg <span class="hl sym">;</span>
    <span class="hl kwa">if</span> <span class="hl sym">(</span>beg <span class="hl sym">==</span> <span class="hl num">0</span><span class="hl sym">)</span> return <span class="hl num">0</span> <span class="hl sym">; //</span> the entry is unoccupied
    <span class="hl kwa">if</span> <span class="hl sym">(</span>strncmp <span class="hl sym">(((</span>char*)dna<span class="hl sym">)+</span>beg<span class="hl sym">-</span><span class="hl num">1</span><span class="hl sym">, (</span>char*)name<span class="hl sym">, (</span>ent<span class="hl sym">-&gt;</span>sym<span class="hl sym">).</span>len<span class="hl sym">) ==</span> <span class="hl num">0</span><span class="hl sym">) {</span>
      return ent<span class="hl sym">-&gt;</span>cnt <span class="hl sym">;</span>
    <span class="hl sym">}</span>
    <span class="hl sym">++</span>i <span class="hl sym">;</span> <span class="hl kwa">if</span> <span class="hl sym">(</span>i <span class="hl sym">&gt;=</span> sz<span class="hl sym">) {</span> i <span class="hl sym">=</span> <span class="hl num">0</span> <span class="hl sym">;</span> ent <span class="hl sym">= (</span>tblent_t *)p <span class="hl sym">; }</span> <span class="hl kwa">else</span> <span class="hl sym">++</span>ent <span class="hl sym">;</span>
  <span class="hl sym">}</span>
<span class="hl sym">}</span>

<span class="hl sym">%}</span>

<span class="hl kwa">implement</span> symtbl_search <span class="hl sym">(</span>tbl<span class="hl sym">,</span> name<span class="hl sym">) =</span> <span class="hl kwa">let</span>

<span class="hl kwa">val</span> hash_val <span class="hl sym">=</span> hash_string_33 name
<span class="hl kwa">val</span> <span class="hl sym">(</span>vbox pf_tbl <span class="hl sym">|</span> p_tbl<span class="hl sym">) =</span> tbl
<span class="hl kwa">val</span> i <span class="hl sym">=</span> hash_val uimod p_tbl<span class="hl sym">-&gt;</span>size

<span class="hl kwa">in</span>

symtbl_search_probe <span class="hl sym">(</span>
  p_tbl<span class="hl sym">-&gt;</span>view_arr <span class="hl sym">|</span> p_tbl<span class="hl sym">-&gt;</span>dna<span class="hl sym">,</span> p_tbl<span class="hl sym">-&gt;</span>ptr<span class="hl sym">,</span> p_tbl<span class="hl sym">-&gt;</span>size<span class="hl sym">,</span> name<span class="hl sym">,</span> i
<span class="hl sym">)</span>

<span class="hl kwa">end</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl kwa">extern fun</span> symtbl_insert_probe <span class="hl sym">{</span>sz<span class="hl sym">,</span>i<span class="hl sym">:</span>nat <span class="hl sym">|</span> i <span class="hl sym">&lt;</span> sz<span class="hl sym">} {</span>l<span class="hl sym">:</span>addr<span class="hl sym">}</span>
  <span class="hl sym">(</span>pf<span class="hl sym">: !</span>array_v <span class="hl sym">(</span>tblent_t<span class="hl sym">,</span> sz<span class="hl sym">,</span> l<span class="hl sym">) |</span>
   dna<span class="hl sym">:</span> dna_t<span class="hl sym">,</span> p<span class="hl sym">:</span> ptr l<span class="hl sym">,</span> sz<span class="hl sym">:</span> int sz<span class="hl sym">,</span> sym<span class="hl sym">:</span> symbol_t<span class="hl sym">,</span> cnt<span class="hl sym">:</span> int<span class="hl sym">,</span> i<span class="hl sym">:</span> int i<span class="hl sym">):&lt;&gt;</span> bool
  <span class="hl sym">=</span> <span class="hl str">&quot;symtbl_insert_probe&quot;</span>

<span class="hl sym">%{</span>

ats_bool_type symtbl_insert_probe
  <span class="hl sym">(</span>ats_ptr_type dna<span class="hl sym">,</span>
   ats_ptr_type p<span class="hl sym">,</span> ats_int_type sz<span class="hl sym">,</span>
   symbol_t sym<span class="hl sym">,</span> ats_int_type cnt<span class="hl sym">,</span>
   ats_int_type i<span class="hl sym">) {</span>

  tblent_t <span class="hl sym">*</span>ent <span class="hl sym">;</span>
<span class="hl com">/*</span>
<span class="hl com">  printf (&quot;symtbl_insert_probe: sz = %i\n&quot;, sz) ;</span>
<span class="hl com">*/</span>

  ent <span class="hl sym">= ((</span>tblent_t *)p<span class="hl sym">) +</span> i <span class="hl sym">;</span>
  <span class="hl kwa">while</span> <span class="hl sym">(</span><span class="hl num">1</span><span class="hl sym">) {</span>
    <span class="hl kwa">if</span> <span class="hl sym">(!(</span>ent<span class="hl sym">-&gt;</span>sym<span class="hl sym">).</span>beg<span class="hl sym">) { //</span> the entry is not occupied
      ent<span class="hl sym">-&gt;</span>sym <span class="hl sym">=</span> sym <span class="hl sym">;</span>
      <span class="hl kwa">if</span> <span class="hl sym">(</span>cnt <span class="hl sym">&gt;</span> <span class="hl num">0</span><span class="hl sym">)</span> ent<span class="hl sym">-&gt;</span>cnt <span class="hl sym">=</span> cnt <span class="hl sym">;</span> <span class="hl kwa">else</span> ent<span class="hl sym">-&gt;</span>cnt <span class="hl sym">=</span> <span class="hl num">1</span> <span class="hl sym">;</span>
      return <span class="hl num">1</span> <span class="hl sym">;</span>
    <span class="hl sym">}</span>
<span class="hl com">/*</span>
<span class="hl com">    printf (&quot;symtbl_insert_probe: i = %i\n&quot;, i) ;</span>
<span class="hl com">    fprint_symbol (stdout, dna, ent-&gt;sym) ; printf (&quot;\n&quot;) ;</span>
<span class="hl com">    fprint_symbol (stdout, dna, sym) ; printf (&quot;\n&quot;) ;</span>
<span class="hl com">*/</span>
    <span class="hl sym">//</span> linear probing
    <span class="hl kwa">if</span> <span class="hl sym">(</span>strncmp <span class="hl sym">(</span>dna<span class="hl sym">+(</span>ent<span class="hl sym">-&gt;</span>sym<span class="hl sym">).</span>beg<span class="hl sym">-</span><span class="hl num">1</span><span class="hl sym">,</span> dna<span class="hl sym">+</span>sym<span class="hl sym">.</span>beg<span class="hl sym">-</span><span class="hl num">1</span><span class="hl sym">,</span> sym<span class="hl sym">.</span>len<span class="hl sym">) ==</span> <span class="hl num">0</span><span class="hl sym">) {</span>
      <span class="hl kwa">if</span> <span class="hl sym">(</span>cnt <span class="hl sym">&gt;</span> <span class="hl num">0</span><span class="hl sym">)</span> ent<span class="hl sym">-&gt;</span>cnt <span class="hl sym">=</span> cnt <span class="hl sym">;</span> <span class="hl kwa">else</span> ent<span class="hl sym">-&gt;</span>cnt <span class="hl sym">+=</span> <span class="hl num">1</span> <span class="hl sym">;</span>
      return <span class="hl num">0</span> <span class="hl sym">;</span>
    <span class="hl sym">}</span>
    <span class="hl sym">++</span>i <span class="hl sym">;</span> <span class="hl kwa">if</span> <span class="hl sym">(</span>i <span class="hl sym">&gt;=</span> sz<span class="hl sym">) {</span> i <span class="hl sym">=</span> <span class="hl num">0</span> <span class="hl sym">;</span> ent <span class="hl sym">= (</span>tblent_t *)p <span class="hl sym">; }</span> <span class="hl kwa">else</span> <span class="hl sym">++</span>ent <span class="hl sym">;</span>
  <span class="hl sym">}</span>
<span class="hl sym">}</span>

<span class="hl sym">%}</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl kwa">extern fun</span> symtbl_resize_move <span class="hl sym">{</span>sz<span class="hl sym">:</span>nat<span class="hl sym">} {</span>l<span class="hl sym">,</span>l_new<span class="hl sym">:</span>addr<span class="hl sym">}</span>
  <span class="hl sym">(</span>pf<span class="hl sym">: !</span>array_v<span class="hl sym">(</span>tblent_t<span class="hl sym">,</span> sz<span class="hl sym">,</span> l<span class="hl sym">),</span>
   pf_new<span class="hl sym">: !</span>array_v<span class="hl sym">(</span>tblent_t<span class="hl sym">,</span> sz<span class="hl sym">+</span>sz<span class="hl sym">,</span> l_new<span class="hl sym">) |</span>
   dna<span class="hl sym">:</span> dna_t<span class="hl sym">,</span> p<span class="hl sym">:</span> ptr l<span class="hl sym">,</span> p_new<span class="hl sym">:</span> ptr l_new<span class="hl sym">,</span> sz<span class="hl sym">:</span> int sz<span class="hl sym">):&lt;&gt;</span> void
  <span class="hl sym">=</span> <span class="hl str">&quot;symtbl_resize_move&quot;</span>

<span class="hl sym">%{</span>

ats_void_type symtbl_resize_move
  <span class="hl sym">(</span>ats_ptr_type dna<span class="hl sym">,</span> ats_ptr_type p<span class="hl sym">,</span> ats_ptr_type p_new<span class="hl sym">,</span> ats_int_type sz<span class="hl sym">) {</span>

  int i<span class="hl sym">,</span> sz2<span class="hl sym">,</span> h <span class="hl sym">;</span>
  tblent_t <span class="hl sym">*</span>ent <span class="hl sym">;</span>

  i <span class="hl sym">=</span> <span class="hl num">0</span> <span class="hl sym">;</span> sz2 <span class="hl sym">=</span> sz <span class="hl sym">+</span> sz <span class="hl sym">;</span> ent <span class="hl sym">= (</span>tblent_t *)p <span class="hl sym">;</span>
<span class="hl com">/*</span>
<span class="hl com">  printf (&quot;symtbl_resize_move: sz2 = %i\n&quot;, sz2) ;</span>
<span class="hl com">*/</span>
  <span class="hl kwa">while</span> <span class="hl sym">(</span>i <span class="hl sym">&lt;</span> sz<span class="hl sym">) {</span>
    <span class="hl kwa">if</span> <span class="hl sym">(!(</span>ent<span class="hl sym">-&gt;</span>sym<span class="hl sym">).</span>beg<span class="hl sym">) { ++</span>i <span class="hl sym">; ++</span>ent <span class="hl sym">;</span> <span class="hl kwa">continue</span> <span class="hl sym">; }</span>
    h <span class="hl sym">=</span> hash_symbol_33 <span class="hl sym">(</span>dna<span class="hl sym">,</span> ent<span class="hl sym">-&gt;</span>sym<span class="hl sym">) %</span> sz2 <span class="hl sym">;</span>
    symtbl_insert_probe <span class="hl sym">(</span>dna<span class="hl sym">,</span> p_new<span class="hl sym">,</span> sz2<span class="hl sym">,</span> ent<span class="hl sym">-&gt;</span>sym<span class="hl sym">,</span> ent<span class="hl sym">-&gt;</span>cnt<span class="hl sym">,</span> h<span class="hl sym">) ;</span>
    <span class="hl sym">++</span>i <span class="hl sym">; ++</span>ent <span class="hl sym">;</span>
  <span class="hl sym">}</span>

  return <span class="hl sym">;</span>
<span class="hl sym">}</span>

<span class="hl sym">%}</span>

<span class="hl kwa">fn</span> symtbl_resize <span class="hl sym">(</span>tbl<span class="hl sym">:</span> symtbl_t<span class="hl sym">):&lt;!</span>ref<span class="hl sym">&gt;</span> void <span class="hl sym">=</span> <span class="hl kwa">let</span>

<span class="hl kwa">val</span> <span class="hl sym">(</span>vbox pf_tbl <span class="hl sym">|</span> p_tbl<span class="hl sym">) =</span> tbl
<span class="hl kwa">val</span> p_arr <span class="hl sym">=</span> p_tbl<span class="hl sym">-&gt;</span>ptr
<span class="hl kwa">prval</span> pf_arr <span class="hl sym">=</span> p_tbl<span class="hl sym">-&gt;</span>view_arr
<span class="hl kwa">prval</span> pf_arr_gc <span class="hl sym">=</span> p_tbl<span class="hl sym">-&gt;</span>view_arr_gc
<span class="hl kwa">val</span> sz <span class="hl sym">=</span> p_tbl<span class="hl sym">-&gt;</span>size
<span class="hl kwa">val</span> <span class="hl sym">(</span>pf_arr_gc_new<span class="hl sym">,</span> pf_arr_new <span class="hl sym">|</span> p_arr_new<span class="hl sym">) =</span> tblent_array_make <span class="hl sym">(</span>sz <span class="hl sym">+</span> sz<span class="hl sym">)</span>

<span class="hl kwa">in</span>

symtbl_resize_move <span class="hl sym">(</span>pf_arr<span class="hl sym">,</span> pf_arr_new <span class="hl sym">|</span> p_tbl<span class="hl sym">-&gt;</span>dna<span class="hl sym">,</span> p_arr<span class="hl sym">,</span> p_arr_new<span class="hl sym">,</span> sz<span class="hl sym">);</span>
array_ptr_free <span class="hl sym">{</span>tblent_t<span class="hl sym">} (</span>pf_arr_gc<span class="hl sym">,</span> pf_arr <span class="hl sym">|</span> p_arr<span class="hl sym">);</span>
p_tbl<span class="hl sym">-&gt;</span>ptr <span class="hl sym">:=</span> p_arr_new<span class="hl sym">;</span>
p_tbl<span class="hl sym">-&gt;</span>view_arr <span class="hl sym">:=</span> pf_arr_new<span class="hl sym">;</span>
p_tbl<span class="hl sym">-&gt;</span>view_arr_gc <span class="hl sym">:=</span> pf_arr_gc_new<span class="hl sym">;</span>
p_tbl<span class="hl sym">-&gt;</span>size <span class="hl sym">:=</span> sz <span class="hl sym">+</span> sz<span class="hl sym">;</span>

<span class="hl kwa">end</span> <span class="hl sym">//</span> <span class="hl kwa">end of</span> <span class="hl sym">[</span>symtbl_resize<span class="hl sym">]</span>

<span class="hl kwa">fun</span> symtbl_resize_if <span class="hl sym">(</span>tbl<span class="hl sym">:</span> symtbl_t<span class="hl sym">):</span> void <span class="hl sym">=</span> <span class="hl kwa">let</span>
  <span class="hl kwa">val</span> nitm <span class="hl sym">=</span> <span class="hl kwa">let val</span> <span class="hl sym">(</span>vbox pf_tbl <span class="hl sym">|</span> p_tbl<span class="hl sym">) =</span> tbl <span class="hl kwa">in</span> p_tbl<span class="hl sym">-&gt;</span>nitm <span class="hl kwa">end</span>
  <span class="hl kwa">val</span> size <span class="hl sym">=</span> <span class="hl kwa">let val</span> <span class="hl sym">(</span>vbox pf_tbl <span class="hl sym">|</span> p_tbl<span class="hl sym">) =</span> tbl <span class="hl kwa">in</span> p_tbl<span class="hl sym">-&gt;</span>size <span class="hl kwa">end</span>
<span class="hl kwa">in</span>
  <span class="hl kwa">if</span> <span class="hl sym">(</span><span class="hl num">2</span> <span class="hl sym">*</span> nitm <span class="hl sym">&gt;</span> size<span class="hl sym">)</span> <span class="hl kwa">then</span> symtbl_resize <span class="hl sym">(</span>tbl<span class="hl sym">)</span>
<span class="hl kwa">end</span> <span class="hl sym">//</span> <span class="hl kwa">end of</span> <span class="hl sym">[</span>symtbl_resize<span class="hl sym">]</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl kwa">implement</span> symtbl_insert <span class="hl sym">(</span>tbl<span class="hl sym">,</span> sym<span class="hl sym">,</span> cnt<span class="hl sym">) =</span> <span class="hl kwa">let</span>
<span class="hl kwa">val</span> <span class="hl sym">() =</span> symtbl_resize_if <span class="hl sym">(</span>tbl<span class="hl sym">)</span>
<span class="hl kwa">val</span> <span class="hl sym">(</span>vbox pf_tbl <span class="hl sym">|</span> p_tbl<span class="hl sym">) =</span> tbl
<span class="hl kwa">val</span> hash_val <span class="hl sym">=</span> hash_symbol_33 <span class="hl sym">(</span>p_tbl<span class="hl sym">-&gt;</span>dna<span class="hl sym">,</span> sym<span class="hl sym">)</span>
<span class="hl kwa">val</span> i <span class="hl sym">=</span> hash_val uimod p_tbl<span class="hl sym">-&gt;</span>size
<span class="hl kwa">val</span> is_new <span class="hl sym">=</span> symtbl_insert_probe
  <span class="hl sym">(</span>p_tbl<span class="hl sym">-&gt;</span>view_arr <span class="hl sym">|</span> p_tbl<span class="hl sym">-&gt;</span>dna<span class="hl sym">,</span> p_tbl<span class="hl sym">-&gt;</span>ptr<span class="hl sym">,</span> p_tbl<span class="hl sym">-&gt;</span>size<span class="hl sym">,</span> sym<span class="hl sym">,</span> cnt<span class="hl sym">,</span> i<span class="hl sym">)</span>
<span class="hl kwa">in</span>

<span class="hl kwa">if</span> is_new <span class="hl kwa">then</span> p_tbl<span class="hl sym">-&gt;</span>nitm <span class="hl sym">:=</span> <span class="hl num">1</span> <span class="hl sym">+</span> p_tbl<span class="hl sym">-&gt;</span>nitm <span class="hl kwa">else</span> <span class="hl sym">()</span>

<span class="hl kwa">end</span> <span class="hl sym">//</span> <span class="hl kwa">end of</span> <span class="hl sym">[</span>symtbl_insert<span class="hl sym">]</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl kwa">extern fun</span> tblent_array_fold <span class="hl sym">{</span>a<span class="hl sym">:</span>viewt&#64;ype<span class="hl sym">} {</span>sz<span class="hl sym">:</span> nat<span class="hl sym">} {</span>l<span class="hl sym">:</span>addr<span class="hl sym">}</span>
  <span class="hl sym">(</span>pf<span class="hl sym">: !</span>array_v <span class="hl sym">(</span>tblent_t<span class="hl sym">,</span> sz<span class="hl sym">,</span> l<span class="hl sym">) |</span>
   p<span class="hl sym">:</span> ptr l<span class="hl sym">,</span> sz<span class="hl sym">:</span> int sz<span class="hl sym">,</span> f<span class="hl sym">: !(</span>symbol_t<span class="hl sym">,</span> int<span class="hl sym">, &amp;</span>a<span class="hl sym">) -&lt;</span>cloptr1<span class="hl sym">&gt;</span> void<span class="hl sym">,</span> res<span class="hl sym">: &amp;</span>a<span class="hl sym">)</span>
  <span class="hl sym">:&lt;&gt;</span> void
  <span class="hl sym">=</span> <span class="hl str">&quot;tblent_array_fold&quot;</span>

<span class="hl sym">%{</span>

ats_void_type tblent_array_fold
  <span class="hl sym">(</span>ats_ptr_type p<span class="hl sym">,</span> ats_int_type sz<span class="hl sym">,</span> ats_ptr_type f<span class="hl sym">,</span> ats_ptr_type res<span class="hl sym">) {</span>

  int i <span class="hl sym">;</span> tblent_t <span class="hl sym">*</span>ent <span class="hl sym">;</span>

  i <span class="hl sym">=</span> <span class="hl num">0</span> <span class="hl sym">;</span> ent <span class="hl sym">= (</span>tblent_t *)p <span class="hl sym">;</span>
  <span class="hl kwa">while</span> <span class="hl sym">(</span>i <span class="hl sym">&lt;</span> sz<span class="hl sym">) {</span>
    <span class="hl kwa">if</span> <span class="hl sym">(!(</span>ent<span class="hl sym">-&gt;</span>sym<span class="hl sym">).</span>beg<span class="hl sym">) { ++</span>i <span class="hl sym">; ++</span>ent <span class="hl sym">;</span> <span class="hl kwa">continue</span> <span class="hl sym">; }</span>
    <span class="hl sym">((</span>ats_void_type <span class="hl com">(*)(ats_clo_ptr_type, symbol_t, ats_int_type, ats_ptr_type))(ats_closure_fun(f)))(f, ent-&gt;sym, ent-&gt;cnt, res) ;</span>
<span class="hl com">    ++i ; ++ent ;</span>
<span class="hl com">  }</span>
<span class="hl com">}</span>
<span class="hl com"></span>
<span class="hl com">%}</span>
<span class="hl com"></span>
<span class="hl com">implement symtbl_fold {a} (tbl, f, res) = let</span>
<span class="hl com"></span>
<span class="hl com">val (vbox pf_tbl | p_tbl) = tbl</span>
<span class="hl com"></span>
<span class="hl com">in</span>
<span class="hl com"></span>
<span class="hl com">tblent_array_fold {a}</span>
<span class="hl com">  (p_tbl-&gt;view_arr | p_tbl-&gt;ptr, p_tbl-&gt;size, f, res)</span>
<span class="hl com"></span>
<span class="hl com">end // end of [symtbl_insert]</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">implement symtbl_dna (tbl) = begin</span>
<span class="hl com">  let val (vbox pf_tbl | p_tbl) = tbl in p_tbl-&gt;dna end</span>
<span class="hl com">end</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">(* end of [symtbl.dats] *)</span>
<span class="hl com"></span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">extern fun dna_count {n,k:nat | k &lt;= n}</span>
<span class="hl com">  (tbl: symtbl_t, n: int n, k: int k) : symtbl_t = &quot;dna_count&quot;</span>
<span class="hl com"></span>
<span class="hl com">// a linear datatype</span>
<span class="hl com">dataviewtype frqlst = FRQLSTnil | FRQLSTcons of (symbol_t, float, frqlst)</span>
<span class="hl com"></span>
<span class="hl com">// linear append</span>
<span class="hl com">fun frqlst_append</span>
<span class="hl com">  (xs0: &amp;frqlst &gt;&gt; frqlst, ys: frqlst): void = begin case xs0 of</span>
<span class="hl com">  | FRQLSTcons (k, f, !xs) =&gt; (frqlst_append (!xs, ys); fold&#64; xs0)</span>
<span class="hl com">  | ~FRQLSTnil () =&gt; (xs0 := ys)</span>
<span class="hl com">end // end of [frqlst_append]</span>
<span class="hl com"></span>
<span class="hl com">// quick sort</span>
<span class="hl com">fun qsort (xs: frqlst): frqlst = begin case+ xs of</span>
<span class="hl com">  | FRQLSTcons (!k1_r, !f1_r, !xs1_r) =&gt; let</span>
<span class="hl com">      val k1 = !k1_r and f1 = !f1_r and xs1 = !xs1_r</span>
<span class="hl com">    in</span>
<span class="hl com">      partition (</span>
<span class="hl com">        view&#64; (!k1_r), view&#64; (!f1_r), view&#64; (!xs1_r)</span>
<span class="hl com">      | xs, xs1_r, k1, f1, xs1, FRQLSTnil (), FRQLSTnil ()</span>
<span class="hl com">      ) // end of [partition]</span>
<span class="hl com">    end</span>
<span class="hl com">  | FRQLSTnil () =&gt; (fold&#64; xs; xs)</span>
<span class="hl com">end // end of [qsort]</span>
<span class="hl com"></span>
<span class="hl com">and partition {l00,l01,l1:addr}</span>
<span class="hl com">  (pf00: symbol_t &#64; l00, pf01: float &#64; l01, pf1: frqlst? &#64; l1 |</span>
<span class="hl com">   node: FRQLSTcons_unfold (l00, l01, l1), node1: ptr l1,</span>
<span class="hl com">   k0: symbol_t, f0: float, xs: frqlst, l: frqlst, r: frqlst)</span>
<span class="hl com">  : frqlst = begin case+ xs of</span>
<span class="hl com">  | FRQLSTcons (k1, f1, !xs1_r) =&gt;</span>
<span class="hl com">    let val xs1 = !xs1_r in</span>
<span class="hl com">      if compare (f1, f0) &gt;= 0 then begin</span>
<span class="hl com">        !xs1_r := l; fold&#64; xs;</span>
<span class="hl com">        partition (pf00, pf01, pf1 | node, node1, k0, f0, xs1, xs, r)</span>
<span class="hl com">      end else begin</span>
<span class="hl com">        !xs1_r := r; fold&#64; xs;</span>
<span class="hl com">        partition (pf00, pf01, pf1 | node, node1, k0, f0, xs1, l, xs)</span>
<span class="hl com">      end</span>
<span class="hl com">    end</span>
<span class="hl com">  | ~FRQLSTnil () =&gt;</span>
<span class="hl com">    let var l = qsort l and r = qsort r in</span>
<span class="hl com">      !node1 := r; fold&#64; node; frqlst_append (l, node); l</span>
<span class="hl com">    end</span>
<span class="hl com">end // end of [partition]</span>
<span class="hl com"></span>
<span class="hl com">// print and free</span>
<span class="hl com">fun print_frqlst</span>
<span class="hl com">  (dna: dna_t, kfs: frqlst): void = begin case+ kfs of</span>
<span class="hl com">  | ~FRQLSTcons (k, f, kfs) =&gt; begin</span>
<span class="hl com">      print_symbol (dna, k); printf (&quot; %.3f\n&quot;, &#64;(double_of f));</span>
<span class="hl com">      print_frqlst (dna, kfs)</span>
<span class="hl com">    end</span>
<span class="hl com">  | ~FRQLSTnil () =&gt; ()</span>
<span class="hl com">end // end of [print_frqlst]</span>
<span class="hl com"></span>
<span class="hl com">fn write_frequencies {n,k:nat | k &lt;= n}</span>
<span class="hl com">  (tbl: symtbl_t, n: int n, k: int k): void = let</span>
<span class="hl com">  val tbl = dna_count (tbl, n, k)</span>
<span class="hl com">  var total: int = (0: int)</span>
<span class="hl com">  fn f (k: symbol_t, cnt: int, res: &amp;int):&lt;cloptr&gt; void = (res := res + cnt)</span>
<span class="hl com">  val () = symtbl_fold {int} (tbl, f, total)</span>
<span class="hl com">  val ftotal = float_of total</span>
<span class="hl com">  var frqs: frqlst = FRQLSTnil ()</span>
<span class="hl com">  fn f (k: symbol_t, cnt: int, res: &amp;frqlst):&lt;cloptr&gt; void =</span>
<span class="hl com">    let val fval = (float_of 100) * float_of cnt / ftotal in</span>
<span class="hl com">      res := FRQLSTcons (k, fval, res)</span>
<span class="hl com">    end</span>
<span class="hl com">  val () = symtbl_fold {frqlst} (tbl, f, frqs)</span>
<span class="hl com">in</span>
<span class="hl com">  print_frqlst (symtbl_dna tbl, qsort frqs)</span>
<span class="hl com">end // end of [write_frequencies]</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">fn write_count {n,k:nat}</span>
<span class="hl com">  (tbl: symtbl_t, n: int n, seq: string k): void = let</span>
<span class="hl com">  val k = length seq</span>
<span class="hl com">  val () = assert (k &lt;= n)</span>
<span class="hl com">  val tbl = dna_count (tbl, n, k)</span>
<span class="hl com">  val cnt = symtbl_search (tbl, seq)</span>
<span class="hl com">in</span>
<span class="hl com">  printf (&quot;%d\t%s\n&quot;, &#64;(cnt, seq))</span>
<span class="hl com">end // end of [write_count]</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">typedef string_int = [n:nat] (string n, int n)</span>
<span class="hl com"></span>
<span class="hl com">extern fun getline (): string</span>
<span class="hl com">extern fun getrest (): string_int</span>
<span class="hl com"></span>
<span class="hl com">dataviewtype charlst (int) =</span>
<span class="hl com">  | charlst_nil (0)</span>
<span class="hl com">  | {n:nat} charlst_cons (n+1) of (char, charlst n)</span>
<span class="hl com"></span>
<span class="hl com">#define nil charlst_nil</span>
<span class="hl com">#define cons charlst_cons</span>
<span class="hl com">#define :: charlst_cons</span>
<span class="hl com"></span>
<span class="hl com">extern fun charlst_is_nil {n:nat} (cs: &amp;charlst n): bool (n == 0) =</span>
<span class="hl com">  &quot;charlst_is_nil&quot;</span>
<span class="hl com"></span>
<span class="hl com">implement charlst_is_nil (cs) = case+ cs of</span>
<span class="hl com">  | nil () =&gt; (fold&#64; cs; true) | cons (c, !cs_r) =&gt; (fold&#64; cs; false)</span>
<span class="hl com"></span>
<span class="hl com">extern fun</span>
<span class="hl com">charlst_uncons {n:pos} (cs: &amp;charlst n &gt;&gt; charlst (n-1)): char =</span>
<span class="hl com">  &quot;charlst_uncons&quot;</span>
<span class="hl com"></span>
<span class="hl com">implement charlst_uncons (cs) =</span>
<span class="hl com">  let val ~(c :: cs_r) = cs in cs := cs_r; c end</span>
<span class="hl com"></span>
<span class="hl com">extern fun</span>
<span class="hl com">string_make_charlst_int {n:nat} (cs: charlst n, n: int n): string n =</span>
<span class="hl com">  &quot;string_make_charlst_int&quot;</span>
<span class="hl com"></span>
<span class="hl com">#define i2c char_of_int</span>
<span class="hl com"></span>
<span class="hl com">implement getline () = let</span>
<span class="hl com">  fun loop {n:nat} (cs: charlst n, n: int n): string =</span>
<span class="hl com">    let val i = getchar () in</span>
<span class="hl com">      if i &gt;= 0 then let</span>
<span class="hl com">        val c = i2c i</span>
<span class="hl com">      in</span>
<span class="hl com">        if c &lt;&gt; '\n' then loop (charlst_cons (c, cs), n+1)</span>
<span class="hl com">        else string_make_charlst_int (cs, n)</span>
<span class="hl com">      end else begin</span>
<span class="hl com">        string_make_charlst_int (cs, n)</span>
<span class="hl com">      end</span>
<span class="hl com">   end // end of [loop]</span>
<span class="hl com">in</span>
<span class="hl com">  loop (charlst_nil (), 0)</span>
<span class="hl com">end // end of [getline]</span>
<span class="hl com"></span>
<span class="hl com">implement getrest () = let</span>
<span class="hl com">  fun loop {n:nat} (cs: charlst n, n: int n): string_int =</span>
<span class="hl com">    let val i = getchar () in</span>
<span class="hl com">      if i &gt;= 0 then let</span>
<span class="hl com">        val c = i2c i</span>
<span class="hl com">      in</span>
<span class="hl com">        if c &lt;&gt; '\n' then</span>
<span class="hl com">          loop (charlst_cons (char_toupper c, cs), n+1)</span>
<span class="hl com">        else loop (cs, n)</span>
<span class="hl com">      end else begin</span>
<span class="hl com">        &#64;(string_make_charlst_int (cs, n), n)</span>
<span class="hl com">      end</span>
<span class="hl com">    end // end of [let]</span>
<span class="hl com">in</span>
<span class="hl com">  loop (charlst_nil (), 0)</span>
<span class="hl com">end // end of [getrest]</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">extern fun dna_of_string (s: string): dna_t = &quot;dna_of_string&quot;</span>
<span class="hl com">extern fun is_three (s: string): bool = &quot;is_three&quot;</span>
<span class="hl com"></span>
<span class="hl com">%{$</span>
<span class="hl com"></span>
<span class="hl com">ats_ptr_type dna_of_string (ats_string_type s) { return s ; }</span>
<span class="hl com"></span>
<span class="hl com">ats_bool_type is_three (ats_ptr_type s0) {</span>
<span class="hl com">  char *s = (char*)</span> s0 <span class="hl sym">;</span>

  <span class="hl kwa">if</span> <span class="hl com">(*s != '&gt;') return ats_false_bool ; ++s ;</span>
<span class="hl com">  if (*s != 'T') return ats_false_bool ; ++s ;</span>
<span class="hl com">  if (*s != 'H') return ats_false_bool ; ++s ;</span>
<span class="hl com">  if (*s != 'R') return ats_false_bool ; ++s ;</span>
<span class="hl com">  if (*s != 'E') return ats_false_bool ; ++s ;</span>
<span class="hl com">  if (*s != 'E') return ats_false_bool ;</span>
<span class="hl com">  return ats_true_bool ;</span>
<span class="hl com">}</span>
<span class="hl com"></span>
<span class="hl com">%}</span>
<span class="hl com"></span>
<span class="hl com">implement main (argc, argv) = let</span>
<span class="hl com"></span>
<span class="hl com">fun dna_three_get (): string_int = let</span>
<span class="hl com">  val s = getline ()</span>
<span class="hl com">in</span>
<span class="hl com">  if s &lt;&gt; &quot;&quot; then</span>
<span class="hl com">    if is_three (s) then getrest () else dna_three_get ()</span>
<span class="hl com">  else begin</span>
<span class="hl com">    exit_errmsg {string_int} (1, &quot;[dna_three_get] failed.\n&quot;)</span>
<span class="hl com">  end</span>
<span class="hl com">end // end of [dna_three_get]</span>
<span class="hl com"></span>
<span class="hl com">val () = gc_chunk_count_limit_max_set (~1) // no max</span>
<span class="hl com"></span>
<span class="hl com">val (dna_three, n) = dna_three_get ()</span>
<span class="hl com">val dna_three = dna_of_string dna_three</span>
<span class="hl com">val dna_table = symtbl_make (dna_three, 0x1000)</span>
<span class="hl com">val () = assert (n &gt;= 2)</span>
<span class="hl com"></span>
<span class="hl com">in</span>
<span class="hl com"></span>
<span class="hl com">write_frequencies (dna_table, n, 1) ;</span>
<span class="hl com">print_newline () ;</span>
<span class="hl com"></span>
<span class="hl com">write_frequencies (dna_table, n, 2) ;</span>
<span class="hl com">print_newline () ;</span>
<span class="hl com"></span>
<span class="hl com">write_count (dna_table, n, &quot;GGT&quot;) ;</span>
<span class="hl com">write_count (dna_table, n, &quot;GGTA&quot;) ;</span>
<span class="hl com">write_count (dna_table, n, &quot;GGTATT&quot;) ;</span>
<span class="hl com">write_count (dna_table, n, &quot;GGTATTTTAATT&quot;) ;</span>
<span class="hl com">write_count (dna_table, n, &quot;GGTATTTTAATTTATAGT&quot;) ;</span>
<span class="hl com"></span>
<span class="hl com">end</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">%{$</span>
<span class="hl com"></span>
<span class="hl com">ats_ptr_type</span>
<span class="hl com">dna_count (ats_ptr_type tbl, ats_int_type n, ats_int_type k) {</span>
<span class="hl com">  symbol_t sym ; int i, nk = n - k ;</span>
<span class="hl com"></span>
<span class="hl com">  symtbl_clear (tbl) ;</span>
<span class="hl com">  i = 0 ;</span>
<span class="hl com">  while (i &lt;= nk) {</span>
<span class="hl com">    ++i ; sym.beg = i ; sym.len= k ;</span>
<span class="hl com">    symtbl_insert (tbl, sym, 0) ;</span>
<span class="hl com">  }</span>
<span class="hl com">  return tbl ;</span>
<span class="hl com">}</span>
<span class="hl com"></span>
<span class="hl com">ats_ptr_type</span>
<span class="hl com">string_make_charlst_int (ats_ptr_type cs, const ats_int_type n) {</span>
<span class="hl com">  char *s0, *s;</span>
<span class="hl com">  s0 = ats_malloc_gc(n+1) ;</span>
<span class="hl com">  s = s0 + n ; *s = '\0' ; --s ;</span>
<span class="hl com">  while (!charlst_is_nil(&amp;cs)) { *s = charlst_uncons(&amp;cs) ; --s ; }</span>
<span class="hl com">  return s0 ;</span>
<span class="hl com">}</span>
<span class="hl com"></span>
<span class="hl com">%}</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">(* end of [k-nucleotide.dats] *)</span>
