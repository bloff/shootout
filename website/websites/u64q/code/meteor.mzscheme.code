<source>
<def></def><slc>;; The Computer Language Benchmarks Game</slc><br />
<def></def><slc>;; http://shootout.alioth.debian.org/</slc><br />
<def></def><slc>;;</slc><br />
<def></def><slc>;; Based on a Python version contributed by Olof Kraigher, modified by Tupteq</slc><br />
<def></def><slc>;; contributed by Matthew Flatt</slc><br />
<def><br />
#lang scheme</def><sym>/</sym><def>base</def><br />
<sym>(</sym><def>require scheme</def><sym>/</sym><def>cmdline</def><sym>)</sym><br />
<def></def><br />
<sym>(</sym><def>define width</def> <num>5</num><def></def><sym>)</sym><br />
<def></def><sym>(</sym><def>define height</def> <num>10</num><def></def><sym>)</sym><br />
<def></def><br />
<sym>(</sym><def>define</def> <sym>(</sym><def>rotate dir</def><sym>)</sym><br />
<def></def>  <sym>(</sym><def>case dir</def><br />
    <sym>[(</sym><def>E</def><sym>) '</sym><def>NE</def><sym>]</sym><br />
<def></def>    <sym>[(</sym><def>NE</def><sym>) '</sym><def>NW</def><sym>]</sym><br />
<def></def>    <sym>[(</sym><def>NW</def><sym>) '</sym><def>W</def><sym>]</sym><br />
<def></def>    <sym>[(</sym><def>W</def><sym>) '</sym><def>SW</def><sym>]</sym><br />
<def></def>    <sym>[(</sym><def>SW</def><sym>) '</sym><def>SE</def><sym>]</sym><br />
<def></def>    <sym>[(</sym><def>SE</def><sym>) '</sym><def>E</def><sym>]))</sym><br />
<def></def><br />
<sym>(</sym><def>define</def> <sym>(</sym><def>flip dir</def><sym>)</sym><br />
<def></def>  <sym>(</sym><def>case dir</def><br />
    <sym>[(</sym><def>E</def><sym>) '</sym><def>W</def><sym>]</sym><br />
<def></def>    <sym>[(</sym><def>NE</def><sym>) '</sym><def>NW</def><sym>]</sym><br />
<def></def>    <sym>[(</sym><def>NW</def><sym>) '</sym><def>NE</def><sym>]</sym><br />
<def></def>    <sym>[(</sym><def>W</def><sym>) '</sym><def>E</def><sym>]</sym><br />
<def></def>    <sym>[(</sym><def>SW</def><sym>) '</sym><def>SE</def><sym>]</sym><br />
<def></def>    <sym>[(</sym><def>SE</def><sym>) '</sym><def>SW</def><sym>]))</sym><br />
<def></def><br />
<sym>(</sym><def>define move</def><br />
  <sym>(</sym><def>make</def><sym>-</sym><def>immutable</def><sym>-</sym><def>hash</def><br />
   <sym>(</sym><def></def><kwa>list</kwa><br />
<def></def>    <sym>(</sym><def></def><kwa>cons</kwa> <def></def><sym>'</sym><def>E</def> <sym>(</sym><def></def><kwa>lambda</kwa> <def></def><sym>(</sym><def>x y</def><sym>) (</sym><def>values</def> <sym>(</sym><def>add1 x</def><sym>)</sym> <def>y</def><sym>)))</sym><br />
<def></def>    <sym>(</sym><def></def><kwa>cons</kwa> <def></def><sym>'</sym><def>W</def> <sym>(</sym><def></def><kwa>lambda</kwa> <def></def><sym>(</sym><def>x y</def><sym>) (</sym><def>values</def> <sym>(</sym><def>sub1 x</def><sym>)</sym> <def>y</def><sym>)))</sym><br />
<def></def>    <sym>(</sym><def></def><kwa>cons</kwa> <def></def><sym>'</sym><def>NE</def> <sym>(</sym><def></def><kwa>lambda</kwa> <def></def><sym>(</sym><def>x y</def><sym>) (</sym><def>values</def> <sym>(+</sym> <def>x</def> <sym>(</sym><def>bitwise</def><sym>-</sym><def></def><kwa>and</kwa> <def>y</def> <num>1</num><def></def><sym>)) (</sym><def>sub1 y</def><sym>))))</sym><br />
<def></def>    <sym>(</sym><def></def><kwa>cons</kwa> <def></def><sym>'</sym><def>NW</def> <sym>(</sym><def></def><kwa>lambda</kwa> <def></def><sym>(</sym><def>x y</def><sym>) (</sym><def>values</def> <sym>(</sym><def>sub1</def> <sym>(+</sym> <def>x</def> <sym>(</sym><def>bitwise</def><sym>-</sym><def></def><kwa>and</kwa> <def>y</def> <num>1</num><def></def><sym>))) (</sym><def>sub1 y</def><sym>))))</sym><br />
<def></def>    <sym>(</sym><def></def><kwa>cons</kwa> <def></def><sym>'</sym><def>SE</def> <sym>(</sym><def></def><kwa>lambda</kwa> <def></def><sym>(</sym><def>x y</def><sym>) (</sym><def>values</def> <sym>(+</sym> <def>x</def> <sym>(</sym><def>bitwise</def><sym>-</sym><def></def><kwa>and</kwa> <def>y</def> <num>1</num><def></def><sym>)) (</sym><def>add1 y</def><sym>))))</sym><br />
<def></def>    <sym>(</sym><def></def><kwa>cons</kwa> <def></def><sym>'</sym><def>SW</def> <sym>(</sym><def></def><kwa>lambda</kwa> <def></def><sym>(</sym><def>x y</def><sym>) (</sym><def>values</def> <sym>(</sym><def>sub1</def> <sym>(+</sym> <def>x</def> <sym>(</sym><def>bitwise</def><sym>-</sym><def></def><kwa>and</kwa> <def>y</def> <num>1</num><def></def><sym>))) (</sym><def>add1 y</def><sym>)))))))</sym><br />
<def></def><br />
<sym>(</sym><def>define move</def><sym>-</sym><def>procs</def><br />
  <sym>(</sym><def>hash</def><sym>-</sym><def>map move</def> <sym>(</sym><def></def><kwa>lambda</kwa> <def></def><sym>(</sym><def>k v</def><sym>)</sym> <def>v</def><sym>)))</sym><br />
<def></def><br />
<sym>(</sym><def>define</def> <sym>(</sym><def>valid? x y</def><sym>)</sym><br />
<def></def>  <sym>(</sym><def></def><kwa>and</kwa> <def></def><sym>(</sym><def></def><num>0</num> <def>.</def> <sym>&lt;=</sym> <def>. x</def><sym>)</sym><br />
<def></def>       <sym>(</sym><def>x .</def> <sym>&lt;</sym> <def>. width</def><sym>)</sym><br />
<def></def>       <sym>(</sym><def></def><num>0</num> <def>.</def> <sym>&lt;=</sym> <def>. y</def><sym>)</sym><br />
<def></def>       <sym>(</sym><def>y .</def> <sym>&lt;</sym> <def>. height</def><sym>)))</sym><br />
<def></def><br />
<sym>(</sym><def>define</def> <sym>(</sym><def>clear? board pos</def><sym>)</sym><br />
<def></def>  <sym>(</sym><def>zero?</def> <sym>(</sym><def>bitwise</def><sym>-</sym><def></def><kwa>and</kwa> <def>board</def> <sym>(</sym><def>arithmetic</def><sym>-</sym><def>shift</def> <num>1</num> <def>pos</def><sym>))))</sym><br />
<def></def><sym>(</sym><def>define</def> <sym>(</sym><def></def><kwa>set</kwa> <def>board pos</def><sym>)</sym><br />
<def></def>  <sym>(</sym><def>bitwise</def><sym>-</sym><def>ior board</def> <sym>(</sym><def>arithmetic</def><sym>-</sym><def>shift</def> <num>1</num> <def>pos</def><sym>)))</sym><br />
<def></def><br />
<sym>(</sym><def>define</def> <sym>(</sym><def>zero</def><sym>-</sym><def>count board</def><sym>)</sym><br />
<def></def>  <sym>(</sym><def>for</def><sym>/</sym><def>fold</def> <sym>([</sym><def>count</def> <num>0</num><def></def><sym>])</sym><br />
<def></def>            <sym>([</sym><def>i</def> <sym>(</sym><def>in</def><sym>-</sym><def>range</def> <sym>(*</sym> <def>width height</def><sym>))])</sym><br />
<def></def>    <sym>(</sym><def></def><kwa>if</kwa> <def></def><sym>(</sym><def>clear? board i</def><sym>)</sym><br />
<def></def>        <sym>(</sym><def>add1 count</def><sym>)</sym><br />
<def>        count</def><sym>)))</sym><br />
<def></def><br />
<sym>(</sym><def>define</def> <sym>(</sym><def>find</def><sym>-</sym><def>free</def><sym>-</sym><def>cell board</def><sym>)</sym><br />
<def></def>  <sym>(</sym><def>let yloop</def> <sym>([</sym><def>y</def> <num>0</num><def></def><sym>])</sym><br />
<def></def>    <sym>(</sym><def>let xloop</def> <sym>([</sym><def>x</def> <num>0</num><def></def><sym>])</sym><br />
<def></def>      <sym>(</sym><def></def><kwa>if</kwa> <def></def><sym>(=</sym> <def>x width</def><sym>)</sym><br />
<def></def>          <sym>(</sym><def>yloop</def> <sym>(</sym><def>add1 y</def><sym>))</sym><br />
<def></def>          <sym>(</sym><def></def><kwa>if</kwa> <def></def><sym>(</sym><def>clear? board</def> <sym>(+</sym> <def>x</def> <sym>(*</sym> <def>width y</def><sym>)))</sym><br />
<def></def>              <sym>(</sym><def>values x y</def><sym>)</sym><br />
<def></def>              <sym>(</sym><def>xloop</def> <sym>(</sym><def>add1 x</def><sym>)))))))</sym><br />
<def></def><br />
<sym>(</sym><def>define</def> <sym>(</sym><def>flood</def><sym>-</sym><def>fill board x y</def><sym>)</sym><br />
<def></def>  <sym>(</sym><def></def><kwa>if</kwa> <def></def><sym>(</sym><def>valid? x y</def><sym>)</sym><br />
<def></def>      <sym>(</sym><def>let</def> <sym>([</sym><def>pos</def> <sym>(+</sym> <def>x</def> <sym>(*</sym> <def>y width</def><sym>))])</sym><br />
<def></def>        <sym>(</sym><def></def><kwa>if</kwa> <def></def><sym>(</sym><def>clear? board pos</def><sym>)</sym><br />
<def></def>            <sym>(</sym><def>for</def><sym>/</sym><def>fold</def> <sym>([</sym><def>board</def> <sym>(</sym><def></def><kwa>set</kwa> <def>board pos</def><sym>)])</sym><br />
<def></def>                      <sym>([</sym><def>move</def><sym>-</sym><def>proc move</def><sym>-</sym><def>procs</def><sym>])</sym><br />
<def></def>              <sym>(</sym><def>let</def><sym>-</sym><def>values</def> <sym>([(</sym><def>x y</def><sym>) (</sym><def>move</def><sym>-</sym><def>proc x y</def><sym>)])</sym><br />
<def></def>                <sym>(</sym><def>flood</def><sym>-</sym><def>fill board x y</def><sym>)))</sym><br />
<def>            board</def><sym>))</sym><br />
<def>      board</def><sym>))</sym><br />
<def></def><br />
<sym>(</sym><def>define</def> <sym>(</sym><def>no</def><sym>-</sym><def>islands? mask</def><sym>)</sym><br />
<def></def>  <sym>(</sym><def>let</def> <sym>([</sym><def>zeros</def> <sym>(</sym><def>zero</def><sym>-</sym><def>count mask</def><sym>)])</sym><br />
<def></def>    <sym>(</sym><def></def><kwa>if</kwa> <def></def><sym>(</sym><def>zeros .</def> <sym>&lt;</sym> <def>.</def> <num>5</num><def></def><sym>)</sym><br />
<def>        #f</def><br />
        <sym>(</sym><def>let loop</def> <sym>([</sym><def>mask mask</def><sym>][</sym><def>zeros zeros</def><sym>])</sym><br />
<def></def>          <sym>(</sym><def></def><kwa>if</kwa> <def></def><sym>(=</sym> <def>mask #x3FFFFFFFFFFFF</def><sym>)</sym><br />
<def>              #t</def><br />
              <sym>(</sym><def>let</def><sym>*-</sym><def>values</def> <sym>([(</sym><def>x y</def><sym>) (</sym><def>find</def><sym>-</sym><def>free</def><sym>-</sym><def>cell mask</def><sym>)]</sym><br />
<def></def>                            <sym>[(</sym><def>mask</def><sym>) (</sym><def>flood</def><sym>-</sym><def>fill mask x y</def><sym>)]</sym><br />
<def></def>                            <sym>[(</sym><def>new</def><sym>-</sym><def>zeros</def><sym>) (</sym><def>zero</def><sym>-</sym><def>count mask</def><sym>)])</sym><br />
<def></def>                <sym>(</sym><def></def><kwa>if</kwa> <def></def><sym>((-</sym> <def>zeros new</def><sym>-</sym><def>zeros</def><sym>)</sym> <def>.</def> <sym>&lt;</sym> <def>.</def> <num>5</num><def></def><sym>)</sym><br />
<def>                    #f</def><br />
                    <sym>(</sym><def>loop mask new</def><sym>-</sym><def>zeros</def><sym>))))))))</sym><br />
<def></def><br />
<sym>(</sym><def>define</def> <sym>(</sym><def>get</def><sym>-</sym><def>bitmask x y piece</def><sym>)</sym><br />
<def></def>  <sym>(</sym><def>let</def> <sym>([</sym><def>mask</def> <sym>(</sym><def>arithmetic</def><sym>-</sym><def>shift</def> <num>1</num> <def></def><sym>(+</sym> <def>x</def> <sym>(*</sym> <def>y width</def><sym>)))])</sym><br />
<def></def>    <sym>(</sym><def>let loop</def> <sym>([</sym><def>x x</def><sym>][</sym><def>y y</def><sym>][</sym><def>cells piece</def><sym>][</sym><def>mask mask</def><sym>])</sym><br />
<def></def>      <sym>(</sym><def></def><kwa>if</kwa> <def></def><sym>(</sym><def></def><kwa>null</kwa><def>? cells</def><sym>)</sym><br />
<def>          mask</def><br />
          <sym>(</sym><def>let</def><sym>-</sym><def>values</def> <sym>([(</sym><def>x y</def><sym>) ((</sym><def>hash</def><sym>-</sym><def>ref move</def> <sym>(</sym><def></def><kwa>car</kwa> <def>cells</def><sym>))</sym> <def>x y</def><sym>)])</sym><br />
<def></def>            <sym>(</sym><def></def><kwa>if</kwa> <def></def><sym>(</sym><def>valid? x y</def><sym>)</sym><br />
<def></def>                <sym>(</sym><def>loop x y</def> <sym>(</sym><def></def><kwa>cdr</kwa> <def>cells</def><sym>) (</sym><def></def><kwa>set</kwa> <def>mask</def> <sym>(+</sym> <def>x</def> <sym>(*</sym> <def>width y</def><sym>))))</sym><br />
<def>                #f</def><sym>))))))</sym><br />
<def></def><br />
<sym>(</sym><def>define</def> <sym>(</sym><def>all</def><sym>-</sym><def>bitmasks piece color</def><sym>)</sym><br />
<def></def>  <sym>(</sym><def>let</def> <sym>([</sym><def>pieces</def><br />
         <sym>(</sym><def>let</def><sym>-</sym><def>values</def> <sym>([(</sym><def>accum piece</def><sym>)</sym><br />
<def></def>                       <sym>(</sym><def>for</def><sym>/</sym><def>fold</def> <sym>([</sym><def>accum</def> <kwa>null</kwa><def></def><sym>] [</sym><def>piece piece</def><sym>])</sym><br />
<def></def>                           <sym>([</sym><def>orientations</def> <sym>(</sym><def>in</def><sym>-</sym><def>range</def> <num>2</num><def></def><sym>)])</sym><br />
<def></def>                         <sym>(</sym><def>let</def><sym>-</sym><def>values</def> <sym>([(</sym><def>accum piece</def><sym>)</sym><br />
<def></def>                                       <sym>(</sym><def>for</def><sym>/</sym><def>fold</def> <sym>([</sym><def>accum accum</def><sym>] [</sym><def>piece piece</def><sym>])</sym><br />
<def></def>                                           <sym>([</sym><def>orientations</def> <sym>(</sym><def>in</def><sym>-</sym><def>range</def> <sym>(-</sym> <def></def><num>6</num> <def></def><sym>(*</sym> <def></def><num>3</num> <def></def><sym>(</sym><def></def><kwa>if</kwa> <def></def><sym>(=</sym> <def>color</def> <num>4</num><def></def><sym>)</sym><br />
<def></def>                                                                                  <num>1</num><br />
<def></def>                                                                                  <num>0</num><def></def><sym>))))])</sym><br />
<def></def>                                         <sym>(</sym><def>values</def> <sym>(</sym><def></def><kwa>cons</kwa> <def>piece accum</def><sym>)</sym><br />
<def></def>                                                 <sym>(</sym><def>map rotate piece</def><sym>)))])</sym><br />
<def></def>                           <sym>(</sym><def>values accum</def> <sym>(</sym><def>map flip piece</def><sym>))))])</sym><br />
<def>           accum</def><sym>)])</sym><br />
<def></def>    <sym>(</sym><def>for</def><sym>*/</sym><def></def><kwa>list</kwa> <def></def><sym>([</sym><def>piece</def> <sym>(</sym><def>in</def><sym>-</sym><def></def><kwa>list</kwa> <def>pieces</def><sym>)]</sym><br />
<def></def>                <sym>[</sym><def>y</def> <sym>(</sym><def>in</def><sym>-</sym><def>range height</def><sym>)]</sym><br />
<def></def>                <sym>[</sym><def>x</def> <sym>(</sym><def>in</def><sym>-</sym><def>range width</def><sym>)]</sym><br />
<def></def>                <sym>[</sym><def>mask</def> <sym>(:</sym><def>do</def><sym>-</sym><def>in</def> <sym>([(</sym><def>mask</def><sym>) (</sym><def>get</def><sym>-</sym><def>bitmask x y piece</def><sym>)])</sym> <def></def><slc>; should be in-value</slc><br />
<def>                              #t</def> <sym>()</sym> <def>#t</def> <sym>()</sym> <def>#t #f</def> <sym>())]</sym><br />
<def>                #</def><sym>:</sym><def>when</def> <sym>(</sym><def></def><kwa>and</kwa> <def>mask</def> <sym>(</sym><def>no</def><sym>-</sym><def>islands? mask</def><sym>)))</sym><br />
<def>      mask</def><sym>)))</sym><br />
<def></def><br />
<sym>(</sym><def>define</def> <sym>(</sym><def>generate</def><sym>-</sym><def>bitmasks</def><sym>)</sym><br />
<def></def>  <sym>(</sym><def>let</def> <sym>([</sym><def>pieces</def> <sym>'((</sym><def>E E E SE</def><sym>)</sym><br />
<def></def>                  <sym>(</sym><def>SE SW W SW</def><sym>)</sym><br />
<def></def>                  <sym>(</sym><def>W W SW SE</def><sym>)</sym><br />
<def></def>                  <sym>(</sym><def>E E SW SE</def><sym>)</sym><br />
<def></def>                  <sym>(</sym><def>NW W NW SE SW</def><sym>)</sym><br />
<def></def>                  <sym>(</sym><def>E E NE W</def><sym>)</sym><br />
<def></def>                  <sym>(</sym><def>NW NE NE W</def><sym>)</sym><br />
<def></def>                  <sym>(</sym><def>NE SE E NE</def><sym>)</sym><br />
<def></def>                  <sym>(</sym><def>SE SE E SE</def><sym>)</sym><br />
<def></def>                  <sym>(</sym><def>E NW NW NW</def><sym>))]</sym><br />
<def></def>        <sym>[</sym><def>masks</def><sym>-</sym><def>at</def><sym>-</sym><def>cell</def><br />
         <sym>(</sym><def></def><kwa>list</kwa><def></def><sym>-&gt;</sym><def>vector</def><br />
          <sym>(</sym><def>for</def><sym>/</sym><def></def><kwa>list</kwa> <def></def><sym>([</sym><def>i</def> <sym>(</sym><def>in</def><sym>-</sym><def>range</def> <sym>(*</sym> <def>width height</def><sym>))])</sym><br />
<def></def>            <sym>(</sym><def></def><kwa>list</kwa><def></def><sym>-&gt;</sym><def>vector</def><br />
             <sym>(</sym><def>for</def><sym>/</sym><def></def><kwa>list</kwa> <def></def><sym>([</sym><def>j</def> <sym>(</sym><def>in</def><sym>-</sym><def>range</def> <num>10</num><def></def><sym>)])</sym><br />
<def></def>               <kwa>null</kwa><def></def><sym>))))])</sym><br />
<def></def>    <sym>(</sym><def>for</def> <sym>([</sym><def>piece</def> <sym>(</sym><def>in</def><sym>-</sym><def></def><kwa>list</kwa> <def>pieces</def><sym>)]</sym><br />
<def></def>          <sym>[</sym><def>color</def> <sym>(</sym><def>in</def><sym>-</sym><def>naturals</def><sym>)])</sym><br />
<def></def>      <sym>(</sym><def>let loop</def> <sym>([</sym><def>masks</def> <sym>(</sym><def>sort</def> <sym>(</sym><def>all</def><sym>-</sym><def>bitmasks piece color</def><sym>) &gt;)]</sym><br />
<def></def>                 <sym>[</sym><def>cell</def><sym>-</sym><def>mask</def> <sym>(</sym><def>arithmetic</def><sym>-</sym><def>shift</def> <num>1</num> <def></def><sym>(</sym><def>sub1</def> <sym>(*</sym> <def>width height</def><sym>)))]</sym><br />
<def></def>                 <sym>[</sym><def>cell</def><sym>-</sym><def>counter</def> <sym>(</sym><def>sub1</def> <sym>(*</sym> <def>width height</def><sym>))])</sym><br />
<def></def>        <sym>(</sym><def></def><kwa>if</kwa> <def></def><sym>(</sym><def></def><kwa>null</kwa><def>? masks</def><sym>)</sym><br />
<def>            masks</def><sym>-</sym><def>at</def><sym>-</sym><def>cell</def><br />
            <sym>(</sym><def></def><kwa>if</kwa> <def></def><sym>(= (</sym><def>bitwise</def><sym>-</sym><def></def><kwa>and</kwa> <def></def><sym>(</sym><def></def><kwa>car</kwa> <def>masks</def><sym>)</sym> <def>cell</def><sym>-</sym><def>mask</def><sym>)</sym> <def>cell</def><sym>-</sym><def>mask</def><sym>)</sym><br />
<def></def>                <sym>(</sym><def>let</def> <sym>([</sym><def>vec</def> <sym>(</sym><def>vector</def><sym>-</sym><def>ref masks</def><sym>-</sym><def>at</def><sym>-</sym><def>cell cell</def><sym>-</sym><def>counter</def><sym>)])</sym><br />
<def></def>                  <sym>(</sym><def>vector</def><sym>-</sym><def></def><kwa>set</kwa><def></def><sym>!</sym> <def>vec color</def> <sym>(</sym><def></def><kwa>cons</kwa> <def></def><sym>(</sym><def></def><kwa>car</kwa> <def>masks</def><sym>) (</sym><def>vector</def><sym>-</sym><def>ref vec color</def><sym>)))</sym><br />
<def></def>                  <sym>(</sym><def>loop</def> <sym>(</sym><def></def><kwa>cdr</kwa> <def>masks</def><sym>)</sym> <def>cell</def><sym>-</sym><def>mask cell</def><sym>-</sym><def>counter</def><sym>))</sym><br />
<def></def>                <sym>(</sym><def>loop masks</def> <sym>(</sym><def>arithmetic</def><sym>-</sym><def>shift cell</def><sym>-</sym><def>mask</def> <sym>-</sym><def></def><num>1</num><def></def><sym>) (</sym><def>sub1 cell</def><sym>-</sym><def>counter</def><sym>))))))</sym><br />
<def></def>    <sym>(</sym><def>for</def> <sym>([</sym><def>v</def> <sym>(</sym><def>in</def><sym>-</sym><def>vector masks</def><sym>-</sym><def>at</def><sym>-</sym><def>cell</def><sym>)])</sym><br />
<def></def>      <sym>(</sym><def>for</def> <sym>([</sym><def>j</def> <sym>(</sym><def>in</def><sym>-</sym><def>naturals</def><sym>)]</sym><br />
<def></def>            <sym>[</sym><def>val</def> <sym>(</sym><def>in</def><sym>-</sym><def>vector v</def><sym>)])</sym><br />
<def></def>        <sym>(</sym><def>vector</def><sym>-</sym><def></def><kwa>set</kwa><def></def><sym>!</sym> <def>v j</def> <sym>(</sym><def></def><kwa>reverse</kwa> <def>val</def><sym>))))</sym><br />
<def>    masks</def><sym>-</sym><def>at</def><sym>-</sym><def>cell</def><sym>))</sym><br />
<def></def><br />
<sym>(</sym><def>define masks</def><sym>-</sym><def>at</def><sym>-</sym><def>cell</def> <sym>(</sym><def>generate</def><sym>-</sym><def>bitmasks</def><sym>))</sym><br />
<def></def><br />
<sym>(</sym><def>define masks</def> <sym>(</sym><def>make</def><sym>-</sym><def>vector</def> <num>10 0</num><def></def><sym>))</sym><br />
<def></def><sym>(</sym><def>define to</def><sym>-</sym><def>go</def> <num>0</num><def></def><sym>)</sym><br />
<def></def><sym>(</sym><def>define solutions</def> <kwa>null</kwa><def></def><sym>)</sym><br />
<def></def><br />
<sym>(</sym><def>define</def> <sym>(</sym><def>solve</def><sym>-</sym><def>cell</def><sym>!</sym> <def>cell board</def><sym>)</sym><br />
<def></def>  <sym>(</sym><def>when</def> <sym>(</sym><def></def><kwa>and</kwa> <def></def><sym>(</sym><def>positive? to</def><sym>-</sym><def>go</def><sym>)</sym><br />
<def></def>             <sym>(</sym><def></def><kwa>not</kwa> <def></def><sym>(</sym><def>negative? cell</def><sym>)))</sym><br />
<def></def>    <slc>;; Need solutions and not off board</slc><br />
<def></def>    <sym>(</sym><def></def><kwa>cond</kwa><br />
<def></def>     <sym>[(=</sym> <def>board #x3FFFFFFFFFFFF</def><sym>)</sym><br />
<def></def>      <slc>;; Solved</slc><br />
<def></def>      <sym>(</sym><def>add</def><sym>-</sym><def>solutions</def><sym>!)]</sym><br />
<def></def>     <sym>[(</sym><def></def><kwa>not</kwa> <def></def><sym>(</sym><def>clear? board cell</def><sym>))</sym><br />
<def></def>      <slc>;; Cell full, so try next</slc><br />
<def></def>      <sym>(</sym><def>solve</def><sym>-</sym><def>cell</def><sym>! (</sym><def>sub1 cell</def><sym>)</sym> <def>board</def><sym>)]</sym><br />
<def></def>     <sym>[</sym><def>else</def><br />
      <slc>;; Recur</slc><br />
<def></def>      <sym>(</sym><def>for</def> <sym>([</sym><def>color</def> <sym>(</sym><def>in</def><sym>-</sym><def>range</def> <num>10</num><def></def><sym>)])</sym><br />
<def></def>        <sym>(</sym><def>when</def> <sym>(</sym><def>zero?</def> <sym>(</sym><def>vector</def><sym>-</sym><def>ref masks color</def><sym>))</sym><br />
<def></def>          <sym>(</sym><def>for</def> <sym>([</sym><def>mask</def> <sym>(</sym><def>in</def><sym>-</sym><def></def><kwa>list</kwa> <def></def><sym>(</sym><def>vector</def><sym>-</sym><def>ref</def><br />
                                <sym>(</sym><def>vector</def><sym>-</sym><def>ref masks</def><sym>-</sym><def>at</def><sym>-</sym><def>cell cell</def><sym>)</sym><br />
<def>                                color</def><sym>))])</sym><br />
<def></def>            <sym>(</sym><def>when</def> <sym>(</sym><def>zero?</def> <sym>(</sym><def>bitwise</def><sym>-</sym><def></def><kwa>and</kwa> <def>mask board</def><sym>))</sym><br />
<def></def>              <sym>(</sym><def>vector</def><sym>-</sym><def></def><kwa>set</kwa><def></def><sym>!</sym> <def>masks color mask</def><sym>)</sym><br />
<def></def>              <sym>(</sym><def>solve</def><sym>-</sym><def>cell</def><sym>! (</sym><def>sub1 cell</def><sym>) (</sym><def>bitwise</def><sym>-</sym><def>ior board mask</def><sym>))</sym><br />
<def></def>              <sym>(</sym><def>vector</def><sym>-</sym><def></def><kwa>set</kwa><def></def><sym>!</sym> <def>masks color</def> <num>0</num><def></def><sym>)))))])))</sym><br />
<def></def><br />
<sym>(</sym><def>define</def> <sym>(</sym><def>add</def><sym>-</sym><def>solutions</def><sym>!)</sym><br />
<def></def>  <sym>(</sym><def>let</def> <sym>([</sym><def>digits</def><br />
         <sym>(</sym><def>for</def><sym>/</sym><def></def><kwa>list</kwa> <def></def><sym>([</sym><def>pos</def> <sym>(</sym><def>in</def><sym>-</sym><def>range</def> <sym>(*</sym> <def>width height</def><sym>))])</sym><br />
<def></def>           <sym>(</sym><def>for</def><sym>/</sym><def></def><kwa>or</kwa> <def></def><sym>([</sym><def>color</def> <sym>(</sym><def>in</def><sym>-</sym><def>range</def> <num>10</num><def></def><sym>)])</sym><br />
<def></def>                   <sym>(</sym><def></def><kwa>and</kwa> <def></def><sym>(</sym><def></def><kwa>not</kwa> <def></def><sym>(</sym><def>clear?</def> <sym>(</sym><def>vector</def><sym>-</sym><def>ref masks color</def><sym>)</sym> <def>pos</def><sym>))</sym><br />
<def>                        color</def><sym>)))])</sym><br />
<def></def>    <sym>(</sym><def>let</def> <sym>([</sym><def>s</def> <sym>(</sym><def></def><kwa>list</kwa><def></def><sym>-&gt;</sym><def>string</def><br />
              <sym>(</sym><def>map</def> <sym>(</sym><def></def><kwa>lambda</kwa> <def></def><sym>(</sym><def>digit</def><sym>)</sym><br />
<def></def>                     <sym>(</sym><def></def><kwa>if</kwa> <def>digit</def><br />
                         <sym>(</sym><def>integer</def><sym>-&gt;</sym><def>char</def> <sym>(+</sym> <def>digit</def> <sym>(</sym><def>char</def><sym>-&gt;</sym><def>integer #\</def><num>0</num><def></def><sym>)))</sym><br />
<def>                         #\.</def><sym>))</sym><br />
<def>                   digits</def><sym>))]</sym><br />
<def></def>          <sym>[</sym><def>ns</def> <sym>(</sym><def>make</def><sym>-</sym><def>string</def> <sym>(*</sym> <def>width height</def><sym>))])</sym><br />
<def></def>      <slc>;; Inverse</slc><br />
<def></def>      <sym>(</sym><def>for</def><sym>* ([</sym><def>y</def> <sym>(</sym><def>in</def><sym>-</sym><def>range height</def><sym>)]</sym><br />
<def></def>             <sym>[</sym><def>x</def> <sym>(</sym><def>in</def><sym>-</sym><def>range width</def><sym>)])</sym><br />
<def></def>            <sym>(</sym><def>string</def><sym>-</sym><def></def><kwa>set</kwa><def></def><sym>!</sym> <def>ns</def> <sym>(+</sym> <def>x</def> <sym>(*</sym> <def>y width</def><sym>))</sym><br />
<def></def>                         <sym>(</sym><def>string</def><sym>-</sym><def>ref s</def> <sym>(+ (-</sym> <def>width</def> <sym>(+</sym> <def>x</def> <num>1</num><def></def><sym>))</sym><br />
<def></def>                                          <sym>(*</sym> <def>width</def> <sym>(-</sym> <def>height</def> <sym>(+</sym> <def>y</def> <num>1</num><def></def><sym>)))))))</sym><br />
<def></def>      <slc>;; Append</slc><br />
<def></def>      <sym>(</sym><def></def><kwa>set</kwa><def></def><sym>!</sym> <def>solutions</def> <sym>(</sym><def></def><kwa>cons</kwa> <def>s solutions</def><sym>))</sym><br />
<def></def>      <sym>(</sym><def></def><kwa>set</kwa><def></def><sym>!</sym> <def>solutions</def> <sym>(</sym><def></def><kwa>cons</kwa> <def>ns solutions</def><sym>))</sym><br />
<def></def>      <sym>(</sym><def></def><kwa>set</kwa><def></def><sym>!</sym> <def>to</def><sym>-</sym><def>go</def> <sym>(-</sym> <def>to</def><sym>-</sym><def>go</def> <num>2</num><def></def><sym>)))))</sym><br />
<def></def><br />
<sym>(</sym><def>define</def> <sym>(</sym><def></def><kwa>print</kwa><def></def><sym>-</sym><def>solution solution</def><sym>)</sym><br />
<def></def>  <sym>(</sym><def>for</def> <sym>([</sym><def>y</def> <sym>(</sym><def>in</def><sym>-</sym><def>range height</def><sym>)])</sym><br />
<def></def>    <sym>(</sym><def>for</def> <sym>([</sym><def>x</def> <sym>(</sym><def>in</def><sym>-</sym><def>range width</def><sym>)])</sym><br />
<def></def>      <sym>(</sym><def>display</def> <sym>(</sym><def>string</def><sym>-</sym><def>ref solution</def> <sym>(+</sym> <def>x</def> <sym>(*</sym> <def>y width</def><sym>))))</sym><br />
<def></def>      <sym>(</sym><def>display</def> <str>&quot; &quot;</str><def></def><sym>))</sym><br />
<def></def>    <sym>(</sym><def>display</def> <str>&quot;</str><esc>\</esc><str>n&quot;</str><def></def><sym>)</sym><br />
<def></def>    <sym>(</sym><def>when</def> <sym>(</sym><def>even? y</def><sym>)</sym><br />
<def></def>      <sym>(</sym><def>display</def> <str>&quot; &quot;</str><def></def><sym>)))</sym><br />
<def></def>  <sym>(</sym><def>newline</def><sym>))</sym><br />
<def></def><br />
<sym>(</sym><def>define</def> <sym>(</sym><def>solve</def><sym>!</sym> <def>n</def><sym>)</sym><br />
<def></def>  <sym>(</sym><def></def><kwa>set</kwa><def></def><sym>!</sym> <def>to</def><sym>-</sym><def>go n</def><sym>)</sym><br />
<def></def>  <sym>(</sym><def>solve</def><sym>-</sym><def>cell</def><sym>! (</sym><def>sub1</def> <sym>(*</sym> <def>width height</def><sym>))</sym> <def></def><num>0</num><def></def><sym>))</sym><br />
<def></def><br />
<sym>(</sym><def></def><kwa>command</kwa><def></def><sym>-</sym><def></def><kwa>line</kwa> <def>#</def><sym>:</sym><def>args</def> <sym>(</sym><def>n</def><sym>) (</sym><def>solve</def><sym>! (</sym><def>string</def><sym>-&gt;</sym><def>number n</def><sym>)))</sym><br />
<def></def><sym>(</sym><def>let</def> <sym>([</sym><def>solutions</def> <sym>(</sym><def>sort solutions string</def><sym>&lt;</sym><def>?</def><sym>)])</sym><br />
<def></def>  <sym>(</sym><def>printf</def> <str>&quot;~a solutions found</str><esc>\</esc><str>n</str><esc>\</esc><str>n&quot;</str><def></def> <sym>(</sym><def></def><kwa>length</kwa> <def>solutions</def><sym>))</sym><br />
<def></def>  <sym>(</sym><def></def><kwa>print</kwa><def></def><sym>-</sym><def>solution</def> <sym>(</sym><def></def><kwa>car</kwa> <def>solutions</def><sym>))</sym><br />
<def></def>  <sym>(</sym><def></def><kwa>print</kwa><def></def><sym>-</sym><def>solution</def> <sym>(</sym><def></def><kwa>list</kwa><def></def><sym>-</sym><def>ref solutions</def> <sym>(</sym><def>sub1</def> <sym>(</sym><def></def><kwa>length</kwa> <def>solutions</def><sym>)))))</sym><def></def><br />
</source>
