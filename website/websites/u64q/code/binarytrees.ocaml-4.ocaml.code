<source>
<def></def><com>(* binarytrees.ml</com><br />
<com> *</com><br />
<com> * The Great Computer Language Shootout</com><br />
<com> * http://shootout.alioth.debian.org/</com><br />
<com> *</com><br />
<com> * Contributed by Troestler Christophe</com><br />
<com> * De-optimized by Isaac Gouy</com><br />
<com> *)</com><def></def><br />
<br />
<kwa>type</kwa> <def></def><kwb>'a</kwb> <def>tree</def> <sym>=</sym> <def></def><kwd>Empty</kwd> <def></def><sym>|</sym> <def></def><kwd>Node</kwd> <def></def><kwa>of</kwa> <def></def><kwb>'a</kwb> <def>tree</def> <sym>*</sym> <def></def><kwb>'a</kwb> <def></def><sym>*</sym> <def></def><kwb>'a</kwb> <def>tree</def><br />
<br />
<kwa>let rec</kwa> <def>make i d</def> <sym>=</sym><br />
<def></def><com>(* if d = 0 then Empty *)</com><def></def><br />
  <kwa>if</kwa> <def>d</def> <sym>=</sym> <def></def><num>0</num> <def></def><kwa>then</kwa> <def></def><kwd>Node</kwd><def></def><sym>(</sym><def></def><kwd>Empty</kwd><def></def><sym>,</sym> <def>i</def><sym>,</sym> <def></def><kwd>Empty</kwd><def></def><sym>)</sym><br />
<def></def>  <kwa>else let</kwa> <def>i2</def> <sym>=</sym> <def></def><num>2</num> <def></def><sym>*</sym> <def>i</def> <kwa>and</kwa> <def>d</def> <sym>=</sym> <def>d</def> <sym>-</sym> <def></def><num>1</num> <def></def><kwa>in</kwa> <def></def><kwd>Node</kwd><def></def><sym>(</sym><def>make</def> <sym>(</sym><def>i2</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>)</sym> <def>d</def><sym>,</sym> <def>i</def><sym>,</sym> <def>make i2 d</def><sym>)</sym><br />
<def></def><br />
<kwa>let rec</kwa> <def>check</def> <sym>=</sym> <def></def><kwa>function</kwa> <def></def><kwd>Empty</kwd> <def></def><sym>-&gt;</sym> <def></def><num>0</num> <def></def><sym>|</sym> <def></def><kwd>Node</kwd><def></def><sym>(</sym><def>l</def><sym>,</sym> <def>i</def><sym>,</sym> <def>r</def><sym>) -&gt;</sym> <def>i</def> <sym>+</sym> <def>check l</def> <sym>-</sym> <def>check r</def><br />
<br />
<br />
<kwa>let</kwa> <def>min_depth</def> <sym>=</sym> <def></def><num>4</num><br />
<def></def><kwa>let</kwa> <def>max_depth</def> <sym>= (</sym><def></def><kwa>let</kwa> <def>n</def> <sym>=</sym> <def></def><kwa>try</kwa> <def>int_of_string</def><sym>(</sym><def></def><kwc>Array</kwc><def></def><sym>.</sym><def>get</def> <kwc>Sys</kwc><def></def><sym>.</sym><def>argv</def> <num>1</num><def></def><sym>)</sym> <def></def><kwa>with</kwa> <def>_</def> <sym>-&gt;</sym> <def></def><num>10</num> <def></def><kwa>in</kwa><br />
<def>                 max</def> <sym>(</sym><def>min_depth</def> <sym>+</sym> <def></def><num>2</num><def></def><sym>)</sym> <def>n</def><sym>)</sym><br />
<def></def><kwa>let</kwa> <def>stretch_depth</def> <sym>=</sym> <def>max_depth</def> <sym>+</sym> <def></def><num>1</num><br />
<def></def><br />
<kwa>let</kwa> <def></def><sym>() =</sym><br />
<def></def>  <kwc>Gc</kwc><def></def><sym>.</sym><def>set</def> <sym>{ (</sym><def></def><kwc>Gc</kwc><def></def><sym>.</sym><def>get</def><sym>())</sym> <def></def><kwa>with</kwa> <def></def><kwc>Gc</kwc><def></def><sym>.</sym><def>minor_heap_size</def> <sym>=</sym> <def></def><num>1024</num> <def></def><sym>*</sym> <def></def><num>1024</num> <def></def><sym>};</sym><br />
<def></def>  <kwa>let</kwa> <def>c</def> <sym>=</sym> <def>check</def> <sym>(</sym><def>make</def> <num>0</num> <def>stretch_depth</def><sym>)</sym> <def></def><kwa>in</kwa><br />
<def></def>  <kwc>Printf</kwc><def></def><sym>.</sym><def>printf</def> <str>&quot;stretch tree of depth %i</str><esc>\t</esc> <str>check: %i</str><esc>\n</esc><str>&quot;</str><def> stretch_depth c</def><br />
<br />
<kwa>let</kwa> <def>long_lived_tree</def> <sym>=</sym> <def>make</def> <num>0</num> <def>max_depth</def><br />
<br />
<kwa>let rec</kwa> <def>loop_depths d</def> <sym>=</sym><br />
<def></def>  <kwa>if</kwa> <def>d</def> <sym>&lt;=</sym> <def>max_depth</def> <kwa>then</kwa><br />
<def></def>    <kwa>let</kwa> <def>niter</def> <sym>=</sym> <def></def><num>1</num> <def></def><kwa>lsl</kwa> <def></def><sym>(</sym><def>max_depth</def> <sym>-</sym> <def>d</def> <sym>+</sym> <def>min_depth</def><sym>)</sym> <def></def><kwa>and</kwa> <def>c</def> <sym>=</sym> <def></def><kwb>ref</kwb> <def></def><num>0</num> <def></def><kwa>in</kwa><br />
<def></def>    <kwa>for</kwa> <def>i</def> <sym>=</sym> <def></def><num>1</num> <def></def><kwa>to</kwa> <def>niter</def> <kwa>do</kwa> <def>c</def> <sym>:= !</sym><def>c</def> <sym>+</sym> <def>check</def><sym>(</sym><def>make i d</def><sym>) +</sym> <def>check</def><sym>(</sym><def>make</def> <sym>(-</sym><def>i</def><sym>)</sym> <def>d</def><sym>)</sym> <def></def><kwa>done</kwa><def></def><sym>;</sym><br />
<def></def>    <kwc>Printf</kwc><def></def><sym>.</sym><def>printf</def> <str>&quot;%i</str><esc>\t</esc> <str>trees of depth %i</str><esc>\t</esc> <str>check: %i</str><esc>\n</esc><str>&quot;</str><def></def> <sym>(</sym><def></def><num>2</num> <def></def><sym>*</sym> <def>niter</def><sym>)</sym> <def>d</def> <sym>!</sym><def>c</def><sym>;</sym><br />
<def>    loop_depths</def> <sym>(</sym><def>d</def> <sym>+</sym> <def></def><num>2</num><def></def><sym>)</sym><br />
<def></def><br />
<kwa>let</kwa> <def></def><sym>() =</sym><br />
<def>  loop_depths min_depth</def><sym>;</sym><br />
<def></def>  <kwc>Printf</kwc><def></def><sym>.</sym><def>printf</def> <str>&quot;long lived tree of depth %i</str><esc>\t</esc> <str>check: %i</str><esc>\n</esc><str>&quot;</str><def><br />
    max_depth</def> <sym>(</sym><def>check long_lived_tree</def><sym>)</sym><br />
<def></def><br />
</source>
