<span class="hl slc">// The Computer Language Shootout</span>
<span class="hl slc">// http://shootout.alioth.debian.org/</span>
<span class="hl slc">// contributed by Ben St. John</span>

<span class="hl dir">#include &lt;iostream&gt;</span>
<span class="hl dir">#include &lt;vector&gt;</span>
<span class="hl dir">#include &lt;string&gt;</span>

<span class="hl kwa">using namespace</span> std<span class="hl sym">;</span>

<span class="hl dir">#define FREE(p) {free(p); p = NULL;}</span>

<span class="hl kwb">enum</span> <span class="hl sym">{</span>X<span class="hl sym">,</span> Y<span class="hl sym">,</span> N_DIM<span class="hl sym">};</span>
<span class="hl kwb">enum</span> <span class="hl sym">{</span>EVEN<span class="hl sym">,</span> ODD<span class="hl sym">,</span> N_PARITY<span class="hl sym">};</span>

<span class="hl kwc">typedef</span> <span class="hl kwb">unsigned int</span> TUInt32<span class="hl sym">;</span>
<span class="hl kwc">typedef</span> <span class="hl kwb">unsigned long long</span> TUInt64<span class="hl sym">;</span>
<span class="hl kwc">typedef</span> <span class="hl kwb">signed char</span> TInt8<span class="hl sym">;</span>

<span class="hl kwc">typedef</span> TUInt64 BitVec<span class="hl sym">;</span>

<span class="hl kwa">namespace</span> Meteor
<span class="hl sym">{</span>
<span class="hl kwb">static const int</span> N_COL <span class="hl sym">=</span> <span class="hl num">5</span><span class="hl sym">;</span>
<span class="hl kwb">static const int</span> N_ROW <span class="hl sym">=</span> <span class="hl num">10</span><span class="hl sym">;</span>
<span class="hl kwb">static const int</span> N_CELL <span class="hl sym">=</span> N_COL <span class="hl sym">*</span> N_ROW<span class="hl sym">;</span>

<span class="hl kwc">class</span> Piece<span class="hl sym">;</span>

<span class="hl slc">//------------------------------------</span>

<span class="hl kwc">class</span> Solution
<span class="hl sym">{</span>
<span class="hl kwc">public</span><span class="hl sym">:</span>
   <span class="hl kwb">static const int</span> NO_PIECE <span class="hl sym">= -</span><span class="hl num">1</span><span class="hl sym">;</span>

   <span class="hl kwb">void</span> <span class="hl kwd">addPiece</span><span class="hl sym">(</span><span class="hl kwb">const</span> BitVec <span class="hl sym">&amp;</span> vec<span class="hl sym">,</span> <span class="hl kwb">int</span> iPiece<span class="hl sym">);</span>
   <span class="hl kwb">void</span> <span class="hl kwd">removeLastPiece</span><span class="hl sym">(</span><span class="hl kwb">void</span><span class="hl sym">);</span>
   <span class="hl kwb">void</span> <span class="hl kwd">setCells</span><span class="hl sym">(</span><span class="hl kwb">void</span><span class="hl sym">);</span>
   <span class="hl kwb">bool</span> <span class="hl kwd">lessThan</span><span class="hl sym">(</span>Solution <span class="hl sym">&amp;</span> r<span class="hl sym">);</span> <span class="hl slc">///&lt; I don't feel like operator overloading</span>
   string <span class="hl kwd">toString</span><span class="hl sym">(</span><span class="hl kwb">void</span><span class="hl sym">)</span> <span class="hl kwb">const</span><span class="hl sym">;</span>
   <span class="hl kwb">void</span> <span class="hl kwd">fill</span><span class="hl sym">(</span><span class="hl kwb">int</span> val<span class="hl sym">);</span>
   <span class="hl kwb">bool</span> <span class="hl kwd">isEmpty</span><span class="hl sym">(</span><span class="hl kwb">void</span><span class="hl sym">) {</span><span class="hl kwa">return</span> <span class="hl sym">(</span>m_pieces<span class="hl sym">.</span><span class="hl kwd">size</span><span class="hl sym">() ==</span> <span class="hl num">0</span><span class="hl sym">);}</span>
   <span class="hl kwb">void</span> <span class="hl kwd">spin</span><span class="hl sym">(</span>Solution <span class="hl sym">&amp;</span> spun<span class="hl sym">);</span>

   <span class="hl kwd">Solution</span><span class="hl sym">(</span><span class="hl kwb">int</span> fillVal<span class="hl sym">);</span>
   <span class="hl kwd">Solution</span><span class="hl sym">() {</span>m_synched <span class="hl sym">=</span> <span class="hl kwa">false</span><span class="hl sym">;}</span>

<span class="hl kwc">private</span><span class="hl sym">:</span>
   <span class="hl kwb">struct</span> SPiece <span class="hl sym">{</span>
      BitVec vec<span class="hl sym">;</span>
      TUInt32 iPiece<span class="hl sym">;</span>
   <span class="hl sym">};</span>
   vector<span class="hl sym">&lt;</span>SPiece<span class="hl sym">&gt;</span> m_pieces<span class="hl sym">;</span>
   TInt8 m_cells<span class="hl sym">[</span>N_ROW<span class="hl sym">][</span>N_COL<span class="hl sym">];</span>
   <span class="hl kwb">bool</span> m_synched<span class="hl sym">;</span>
<span class="hl sym">};</span>

<span class="hl slc">//------------------------------------</span>

<span class="hl kwc">class</span> Board
<span class="hl sym">{</span>
<span class="hl kwc">public</span><span class="hl sym">:</span>
   <span class="hl kwb">static const</span> BitVec L_EDGE_MASK <span class="hl sym">=</span>
      <span class="hl sym">(</span><span class="hl num">1L</span>L <span class="hl sym">&lt;&lt;</span>  <span class="hl num">0</span><span class="hl sym">) | (</span><span class="hl num">1L</span>L <span class="hl sym">&lt;&lt;</span>  <span class="hl num">5</span><span class="hl sym">) | (</span><span class="hl num">1L</span>L <span class="hl sym">&lt;&lt;</span> <span class="hl num">10</span><span class="hl sym">) | (</span><span class="hl num">1L</span>L <span class="hl sym">&lt;&lt;</span> <span class="hl num">15</span><span class="hl sym">) |</span>
      <span class="hl sym">(</span><span class="hl num">1L</span>L <span class="hl sym">&lt;&lt;</span> <span class="hl num">20</span><span class="hl sym">) | (</span><span class="hl num">1L</span>L <span class="hl sym">&lt;&lt;</span> <span class="hl num">25</span><span class="hl sym">) | (</span><span class="hl num">1L</span>L <span class="hl sym">&lt;&lt;</span> <span class="hl num">30</span><span class="hl sym">) | (</span><span class="hl num">1L</span>L <span class="hl sym">&lt;&lt;</span> <span class="hl num">35</span><span class="hl sym">) |</span>
      <span class="hl sym">(</span><span class="hl num">1L</span>L <span class="hl sym">&lt;&lt;</span> <span class="hl num">40</span><span class="hl sym">) | (</span><span class="hl num">1L</span>L <span class="hl sym">&lt;&lt;</span> <span class="hl num">45</span><span class="hl sym">) | (</span><span class="hl num">1L</span>L <span class="hl sym">&lt;&lt;</span> <span class="hl num">50</span><span class="hl sym">) | (</span><span class="hl num">1L</span>L <span class="hl sym">&lt;&lt;</span> <span class="hl num">55</span><span class="hl sym">);</span>
   <span class="hl kwb">static const</span> BitVec R_EDGE_MASK <span class="hl sym">=</span> L_EDGE_MASK <span class="hl sym">&lt;&lt;</span> <span class="hl num">4</span><span class="hl sym">;</span>
   <span class="hl kwb">static const</span> BitVec TOP_ROW <span class="hl sym">=</span> <span class="hl num">0x1f</span>LL<span class="hl sym">;</span>
   <span class="hl kwb">static const</span> BitVec ROW_0_MASK <span class="hl sym">=</span>
      <span class="hl sym">(</span> TOP_ROW        <span class="hl sym">| (</span>TOP_ROW <span class="hl sym">&lt;&lt;</span> <span class="hl num">10</span><span class="hl sym">) | (</span>TOP_ROW <span class="hl sym">&lt;&lt;</span> <span class="hl num">20</span><span class="hl sym">) | (</span>TOP_ROW <span class="hl sym">&lt;&lt;</span> <span class="hl num">30</span><span class="hl sym">) |</span>
       <span class="hl sym">(</span>TOP_ROW <span class="hl sym">&lt;&lt;</span> <span class="hl num">40</span><span class="hl sym">) | (</span>TOP_ROW <span class="hl sym">&lt;&lt;</span> <span class="hl num">50</span><span class="hl sym">));</span>
   <span class="hl kwb">static const</span> BitVec ROW_1_MASK <span class="hl sym">=</span> ROW_0_MASK <span class="hl sym">&lt;&lt;</span> <span class="hl num">5</span><span class="hl sym">;</span>
   <span class="hl kwb">static const</span> BitVec BOARD_MASK <span class="hl sym">= (</span><span class="hl num">1L</span>L <span class="hl sym">&lt;&lt;</span> N_CELL<span class="hl sym">) -</span> <span class="hl num">1</span><span class="hl sym">;</span>

   <span class="hl kwd">Board</span><span class="hl sym">();</span>

   <span class="hl kwb">static</span> TUInt32 <span class="hl kwd">getIndex</span><span class="hl sym">(</span>TUInt32 x<span class="hl sym">,</span> TUInt32 y<span class="hl sym">) {</span> <span class="hl kwa">return</span> y <span class="hl sym">*</span> N_COL <span class="hl sym">+</span> x<span class="hl sym">;    }</span>
   <span class="hl kwb">static bool</span> <span class="hl kwd">hasBadFirstRegion</span><span class="hl sym">(</span>BitVec <span class="hl sym">&amp;</span> toFill<span class="hl sym">);</span>
   <span class="hl kwb">static bool</span> <span class="hl kwd">hasBadIslands</span><span class="hl sym">(</span><span class="hl kwb">const</span> BitVec <span class="hl sym">&amp;</span> boardVec<span class="hl sym">);</span>

   <span class="hl kwb">void</span> <span class="hl kwd">genAllSolutions</span><span class="hl sym">(</span>BitVec boardVec<span class="hl sym">,</span> TUInt32 placedPieces<span class="hl sym">,</span> TUInt32 iNextFill<span class="hl sym">,</span> <span class="hl kwb">const</span> BitVec <span class="hl sym">&amp;</span> maskNextFill<span class="hl sym">);</span>
   <span class="hl kwb">void</span> <span class="hl kwd">recordSolution</span><span class="hl sym">(</span>Solution <span class="hl sym">&amp;</span> s<span class="hl sym">);</span>

   Solution m_curSolution<span class="hl sym">;</span>
   Solution m_minSolution<span class="hl sym">;</span>
   Solution m_maxSolution<span class="hl sym">;</span>
   TUInt32 m_nSolutionFound<span class="hl sym">;</span>
<span class="hl sym">};</span>

<span class="hl slc">//------------------------------------</span>

<span class="hl kwc">class</span> Piece
<span class="hl sym">{</span>
<span class="hl kwc">public</span><span class="hl sym">:</span>
   <span class="hl kwb">struct</span> Instance <span class="hl sym">{</span>
      BitVec m_vec<span class="hl sym">;</span>
      BitVec m_allowed<span class="hl sym">;</span>
      TUInt32 m_offset<span class="hl sym">;</span>
      TUInt32 m_w<span class="hl sym">;</span>
      TUInt32 m_h<span class="hl sym">;</span>
   <span class="hl sym">};</span>

   <span class="hl kwb">static const int</span> N_ELEM <span class="hl sym">=</span> <span class="hl num">5</span><span class="hl sym">;</span>
   <span class="hl kwb">static const int</span> N_ORIENT <span class="hl sym">=</span> <span class="hl num">12</span><span class="hl sym">;</span>
   <span class="hl kwb">static const int</span> N_TYPE <span class="hl sym">=</span> <span class="hl num">10</span><span class="hl sym">;</span>
   <span class="hl kwb">static const int</span> ALL_PIECE_MASK <span class="hl sym">= (</span><span class="hl num">1</span> <span class="hl sym">&lt;&lt;</span> N_TYPE<span class="hl sym">) -</span> <span class="hl num">1</span><span class="hl sym">;</span>
   <span class="hl kwb">static const</span> TUInt32 SKIP_PIECE <span class="hl sym">=</span> <span class="hl num">5</span><span class="hl sym">;</span> <span class="hl slc">// it's magic!</span>

   <span class="hl kwc">typedef</span> <span class="hl kwb">int</span> TCoordList<span class="hl sym">[</span>N_ELEM<span class="hl sym">][</span>N_DIM<span class="hl sym">];</span>

   <span class="hl kwb">static const</span> BitVec BaseDefinitions<span class="hl sym">[</span>N_TYPE<span class="hl sym">];</span>
   <span class="hl kwb">static</span> Piece s_basePiece<span class="hl sym">[</span>N_TYPE<span class="hl sym">][</span>N_ORIENT<span class="hl sym">];</span>

   <span class="hl kwb">static const</span> Instance <span class="hl sym">&amp;</span> <span class="hl kwd">getPiece</span><span class="hl sym">(</span>TUInt32 iPiece<span class="hl sym">,</span> TUInt32 iOrient<span class="hl sym">,</span> TUInt32 iParity<span class="hl sym">);</span>
   <span class="hl kwb">static bool</span> <span class="hl kwd">checkBaseDefinitions</span><span class="hl sym">(</span><span class="hl kwb">void</span><span class="hl sym">);</span>
   <span class="hl kwb">static</span> BitVec <span class="hl kwd">toBitVector</span><span class="hl sym">(</span><span class="hl kwb">const</span> TCoordList <span class="hl sym">&amp;</span> coords<span class="hl sym">);</span>
   <span class="hl kwb">static void</span> <span class="hl kwd">genOrientation</span><span class="hl sym">(</span><span class="hl kwb">const</span> BitVec <span class="hl sym">&amp;</span> vec<span class="hl sym">,</span> TUInt32 iOrient<span class="hl sym">,</span> Piece <span class="hl sym">&amp;</span> target<span class="hl sym">);</span>
   <span class="hl kwb">static void</span> <span class="hl kwd">setCoordList</span><span class="hl sym">(</span><span class="hl kwb">const</span> BitVec <span class="hl sym">&amp;</span> vec<span class="hl sym">,</span> TCoordList <span class="hl sym">&amp;</span> coords<span class="hl sym">);</span>
   <span class="hl kwb">static void</span> <span class="hl kwd">shiftUpLines</span><span class="hl sym">(</span>TCoordList <span class="hl sym">&amp;</span> coords<span class="hl sym">,</span> <span class="hl kwb">int</span> shift<span class="hl sym">);</span>
   <span class="hl kwb">static void</span> <span class="hl kwd">shiftToX0</span><span class="hl sym">(</span>TCoordList <span class="hl sym">&amp;</span> coords<span class="hl sym">,</span> Instance <span class="hl sym">&amp;</span> instance<span class="hl sym">,</span> <span class="hl kwb">int</span> offsetRow<span class="hl sym">);</span>
   <span class="hl kwb">static void</span> <span class="hl kwd">setAllowedPositions</span><span class="hl sym">(</span>Instance <span class="hl sym">&amp;</span> p<span class="hl sym">);</span>
   <span class="hl kwb">static void</span> <span class="hl kwd">genAllOrientations</span><span class="hl sym">(</span><span class="hl kwb">void</span><span class="hl sym">);</span>

   Instance m_instance<span class="hl sym">[</span>N_PARITY<span class="hl sym">];</span>
<span class="hl sym">};</span>

<span class="hl slc">//------------------------------------</span>
Solution<span class="hl sym">::</span><span class="hl kwd">Solution</span><span class="hl sym">(</span><span class="hl kwb">int</span> fillVal<span class="hl sym">)</span>
<span class="hl sym">{</span>
   <span class="hl kwd">fill</span><span class="hl sym">(</span>fillVal<span class="hl sym">);</span>
   m_pieces<span class="hl sym">.</span><span class="hl kwd">reserve</span><span class="hl sym">(</span>Piece<span class="hl sym">::</span>N_TYPE<span class="hl sym">);</span>
<span class="hl sym">}</span>

<span class="hl kwb">void</span> Solution<span class="hl sym">::</span><span class="hl kwd">fill</span><span class="hl sym">(</span><span class="hl kwb">int</span> val<span class="hl sym">)</span>
<span class="hl sym">{</span>
   m_synched <span class="hl sym">=</span> <span class="hl kwa">false</span><span class="hl sym">;</span>
   <span class="hl kwd">memset</span><span class="hl sym">(&amp;</span>m_cells<span class="hl sym">[</span><span class="hl num">0</span><span class="hl sym">][</span><span class="hl num">0</span><span class="hl sym">],</span> val<span class="hl sym">,</span> N_CELL<span class="hl sym">);</span>
<span class="hl sym">}</span>

string Solution<span class="hl sym">::</span><span class="hl kwd">toString</span><span class="hl sym">(</span><span class="hl kwb">void</span><span class="hl sym">)</span> <span class="hl kwb">const</span>
<span class="hl sym">{</span>
   string result<span class="hl sym">;</span>
   result<span class="hl sym">.</span><span class="hl kwd">reserve</span><span class="hl sym">(</span>N_CELL <span class="hl sym">*</span> <span class="hl num">2</span><span class="hl sym">);</span>

   <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> y <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> y <span class="hl sym">&lt;</span> N_ROW<span class="hl sym">;</span> y<span class="hl sym">++) {</span>
      <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> x <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> x <span class="hl sym">&lt;</span> N_COL<span class="hl sym">;</span> x<span class="hl sym">++) {</span>
         <span class="hl kwb">int</span> val <span class="hl sym">=</span> m_cells<span class="hl sym">[</span>y<span class="hl sym">][</span>x<span class="hl sym">];</span>
         result <span class="hl sym">+= ((</span>val <span class="hl sym">==</span> NO_PIECE<span class="hl sym">)</span> ? <span class="hl str">'.'</span> <span class="hl sym">:</span> <span class="hl kwb">char</span><span class="hl sym">(</span><span class="hl str">'0'</span> <span class="hl sym">+</span> val<span class="hl sym">));</span>
         result <span class="hl sym">+=</span> <span class="hl str">' '</span><span class="hl sym">;</span>
      <span class="hl sym">}</span>
      result <span class="hl sym">+=</span> <span class="hl str">'</span><span class="hl esc">\n</span><span class="hl str">'</span><span class="hl sym">;</span>

      <span class="hl slc">// indent every second line</span>
      <span class="hl kwa">if</span> <span class="hl sym">(</span>y <span class="hl sym">%</span> <span class="hl num">2</span> <span class="hl sym">==</span> <span class="hl num">0</span><span class="hl sym">)</span>
         result <span class="hl sym">+=</span> <span class="hl str">&quot; &quot;</span><span class="hl sym">;</span>
   <span class="hl sym">}</span>

   <span class="hl kwa">return</span> result<span class="hl sym">;</span> <span class="hl slc">// copies result. Oh well</span>
<span class="hl sym">}</span>

<span class="hl kwb">void</span> Solution<span class="hl sym">::</span><span class="hl kwd">setCells</span><span class="hl sym">(</span><span class="hl kwb">void</span><span class="hl sym">)</span>
<span class="hl sym">{</span>
   <span class="hl kwa">if</span> <span class="hl sym">(</span>m_synched<span class="hl sym">)</span>
      <span class="hl kwa">return</span><span class="hl sym">;</span>

   <span class="hl kwd">fill</span><span class="hl sym">(</span>NO_PIECE<span class="hl sym">);</span>

   <span class="hl slc">// could be more efficient</span>
   <span class="hl kwa">for</span> <span class="hl sym">(</span>TUInt32 iPiece <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> iPiece <span class="hl sym">&lt;</span> m_pieces<span class="hl sym">.</span><span class="hl kwd">size</span><span class="hl sym">();</span> iPiece<span class="hl sym">++) {</span>

      <span class="hl kwb">const</span> BitVec <span class="hl sym">&amp;</span> vec <span class="hl sym">=</span> m_pieces<span class="hl sym">[</span>iPiece<span class="hl sym">].</span>vec<span class="hl sym">;</span>
      <span class="hl kwb">int</span> pID <span class="hl sym">=</span> m_pieces<span class="hl sym">[</span>iPiece<span class="hl sym">].</span>iPiece<span class="hl sym">;</span>
      BitVec mask <span class="hl sym">=</span> <span class="hl num">1L</span>L<span class="hl sym">;</span>
      <span class="hl kwb">int</span> nNewCells <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span>

      <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> y <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> y <span class="hl sym">&lt;</span> N_ROW<span class="hl sym">;</span> y<span class="hl sym">++) {</span>
         <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> x <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> x <span class="hl sym">&lt;</span> N_COL<span class="hl sym">;</span> x<span class="hl sym">++) {</span>
            <span class="hl kwa">if</span> <span class="hl sym">(</span>mask <span class="hl sym">&amp;</span> vec<span class="hl sym">) {</span>
               m_cells<span class="hl sym">[</span>y<span class="hl sym">][</span>x<span class="hl sym">] = (</span>TInt8<span class="hl sym">)</span>pID<span class="hl sym">;</span>

               nNewCells<span class="hl sym">++;</span>
            <span class="hl sym">}</span>
            mask <span class="hl sym">&lt;&lt;=</span> <span class="hl num">1</span><span class="hl sym">;</span>
         <span class="hl sym">}</span>
         <span class="hl kwa">if</span> <span class="hl sym">(</span>nNewCells <span class="hl sym">==</span> Piece<span class="hl sym">::</span>N_ELEM<span class="hl sym">)</span>
            <span class="hl kwa">break</span><span class="hl sym">;</span>
      <span class="hl sym">}</span>
   <span class="hl sym">}</span>

   m_synched <span class="hl sym">=</span> <span class="hl kwa">true</span><span class="hl sym">;</span>
<span class="hl sym">}</span>

<span class="hl kwb">void</span> Solution<span class="hl sym">::</span><span class="hl kwd">addPiece</span><span class="hl sym">(</span><span class="hl kwb">const</span> BitVec <span class="hl sym">&amp;</span> vec<span class="hl sym">,</span> <span class="hl kwb">int</span> iPiece<span class="hl sym">) {</span>
   SPiece p <span class="hl sym">= {</span>vec<span class="hl sym">,</span> iPiece<span class="hl sym">};</span>
   m_pieces<span class="hl sym">.</span><span class="hl kwd">push_back</span><span class="hl sym">(</span>p<span class="hl sym">);</span>
<span class="hl sym">}</span>

<span class="hl kwb">void</span> Solution<span class="hl sym">::</span><span class="hl kwd">removeLastPiece</span><span class="hl sym">(</span><span class="hl kwb">void</span><span class="hl sym">) {</span>
   m_pieces<span class="hl sym">.</span><span class="hl kwd">pop_back</span><span class="hl sym">();</span>
   m_synched <span class="hl sym">=</span> <span class="hl kwa">false</span><span class="hl sym">;</span>
<span class="hl sym">}</span>

<span class="hl kwb">bool</span> Solution<span class="hl sym">::</span><span class="hl kwd">lessThan</span><span class="hl sym">(</span>Solution <span class="hl sym">&amp;</span> r<span class="hl sym">)</span>
<span class="hl sym">{</span>
   <span class="hl kwa">if</span> <span class="hl sym">(</span>m_pieces<span class="hl sym">[</span><span class="hl num">0</span><span class="hl sym">].</span>iPiece <span class="hl sym">!=</span> r<span class="hl sym">.</span>m_pieces<span class="hl sym">[</span><span class="hl num">0</span><span class="hl sym">].</span>iPiece<span class="hl sym">) {</span>
      <span class="hl kwa">return</span> m_pieces<span class="hl sym">[</span><span class="hl num">0</span><span class="hl sym">].</span>iPiece <span class="hl sym">&lt;</span> r<span class="hl sym">.</span>m_pieces<span class="hl sym">[</span><span class="hl num">0</span><span class="hl sym">].</span>iPiece<span class="hl sym">;</span>
   <span class="hl sym">}</span>

   <span class="hl kwd">setCells</span><span class="hl sym">();</span>
   r<span class="hl sym">.</span><span class="hl kwd">setCells</span><span class="hl sym">();</span>

   <span class="hl kwb">int</span> y<span class="hl sym">;</span>
   <span class="hl kwa">for</span> <span class="hl sym">(</span>y <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> y <span class="hl sym">&lt;</span> N_ROW<span class="hl sym">;</span> y<span class="hl sym">++) {</span>
      <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> x <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> x <span class="hl sym">&lt;</span> N_COL<span class="hl sym">;</span> x<span class="hl sym">++) {</span>
         <span class="hl kwb">int</span> lval <span class="hl sym">=</span> m_cells<span class="hl sym">[</span>y<span class="hl sym">][</span>x<span class="hl sym">];</span>
         <span class="hl kwb">int</span> rval <span class="hl sym">=</span> r<span class="hl sym">.</span>m_cells<span class="hl sym">[</span>y<span class="hl sym">][</span>x<span class="hl sym">];</span>

         <span class="hl kwa">if</span> <span class="hl sym">(</span>lval <span class="hl sym">!=</span> rval<span class="hl sym">)</span>
            <span class="hl kwa">return</span> <span class="hl sym">(</span>lval <span class="hl sym">&lt;</span> rval<span class="hl sym">);</span>
      <span class="hl sym">}</span>
   <span class="hl sym">}</span>

   <span class="hl kwa">return false</span><span class="hl sym">;</span> <span class="hl slc">// solutions are equal</span>
<span class="hl sym">}</span>

<span class="hl kwb">void</span> Solution<span class="hl sym">::</span><span class="hl kwd">spin</span><span class="hl sym">(</span>Solution <span class="hl sym">&amp;</span> spun<span class="hl sym">)</span>
<span class="hl sym">{</span>
   <span class="hl kwd">setCells</span><span class="hl sym">();</span>

   <span class="hl slc">// swap cells</span>
   <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> y <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> y <span class="hl sym">&lt;</span> N_ROW<span class="hl sym">;</span> y<span class="hl sym">++) {</span>
      <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> x <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> x <span class="hl sym">&lt;</span> N_COL<span class="hl sym">;</span> x<span class="hl sym">++) {</span>
         TInt8 flipped <span class="hl sym">=</span> m_cells<span class="hl sym">[</span>N_ROW <span class="hl sym">-</span> y <span class="hl sym">-</span> <span class="hl num">1</span><span class="hl sym">][</span>N_COL <span class="hl sym">-</span> x <span class="hl sym">-</span> <span class="hl num">1</span><span class="hl sym">];</span>
         spun<span class="hl sym">.</span>m_cells<span class="hl sym">[</span>y<span class="hl sym">][</span>x<span class="hl sym">] =</span> flipped<span class="hl sym">;</span>
      <span class="hl sym">}</span>
   <span class="hl sym">}</span>

   <span class="hl slc">// swap first and last pieces (the rest aren't used)</span>
   spun<span class="hl sym">.</span>m_pieces<span class="hl sym">.</span><span class="hl kwd">push_back</span><span class="hl sym">(</span>m_pieces<span class="hl sym">[</span>Piece<span class="hl sym">::</span>N_TYPE <span class="hl sym">-</span> <span class="hl num">1</span><span class="hl sym">]);</span>
   spun<span class="hl sym">.</span>m_synched <span class="hl sym">=</span> <span class="hl kwa">true</span><span class="hl sym">;</span>
<span class="hl sym">}</span>

<span class="hl slc">//------------------------------------</span>

Piece Piece<span class="hl sym">::</span>s_basePiece<span class="hl sym">[</span>N_TYPE<span class="hl sym">][</span>N_ORIENT<span class="hl sym">];</span>

<span class="hl kwb">const</span> BitVec Piece<span class="hl sym">::</span>BaseDefinitions<span class="hl sym">[] = {</span>
   <span class="hl num">0x010f</span><span class="hl sym">,</span>   <span class="hl num">0x00cb</span><span class="hl sym">,</span> <span class="hl num">0x1087</span><span class="hl sym">,</span> <span class="hl num">0x0427</span><span class="hl sym">,</span> <span class="hl num">0x0465</span><span class="hl sym">,</span>
   <span class="hl num">0x00c7</span><span class="hl sym">,</span> <span class="hl num">0x08423</span><span class="hl sym">,</span> <span class="hl num">0x00a7</span><span class="hl sym">,</span> <span class="hl num">0x0187</span><span class="hl sym">,</span> <span class="hl num">0x008f</span>
<span class="hl sym">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">floor</span><span class="hl sym">(</span><span class="hl kwb">int</span> top<span class="hl sym">,</span> <span class="hl kwb">int</span> bot<span class="hl sym">) {</span>
   <span class="hl kwb">int</span> toZero <span class="hl sym">=</span> top <span class="hl sym">/</span> bot<span class="hl sym">;</span>
   <span class="hl slc">// negative numbers should be rounded down, not towards zero</span>
   <span class="hl kwa">if</span> <span class="hl sym">((</span>toZero <span class="hl sym">*</span> bot <span class="hl sym">!=</span> top<span class="hl sym">) &amp;&amp; ((</span>top <span class="hl sym">&lt;</span> <span class="hl num">0</span><span class="hl sym">) != (</span>bot <span class="hl sym">&lt;=</span> <span class="hl num">0</span><span class="hl sym">)))</span>
      toZero<span class="hl sym">--;</span>

   <span class="hl kwa">return</span> toZero<span class="hl sym">;</span>
<span class="hl sym">}</span>

TUInt32 <span class="hl kwd">getFirstOne</span><span class="hl sym">(</span><span class="hl kwb">const</span> BitVec <span class="hl sym">&amp;</span> v<span class="hl sym">,</span> TUInt32 startPos <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">) {</span>
   <span class="hl kwa">if</span> <span class="hl sym">(</span>v <span class="hl sym">== (</span>BitVec<span class="hl sym">)</span><span class="hl num">0</span><span class="hl sym">)</span>
      <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl sym">;</span>

   <span class="hl kwb">static const</span> TUInt32 firstOne<span class="hl sym">[</span><span class="hl num">16</span><span class="hl sym">] =   {</span>
      <span class="hl num">0</span><span class="hl sym">,</span> <span class="hl num">0</span><span class="hl sym">,</span> <span class="hl num">1</span><span class="hl sym">,</span> <span class="hl num">0</span><span class="hl sym">,</span>
      <span class="hl num">2</span><span class="hl sym">,</span> <span class="hl num">0</span><span class="hl sym">,</span> <span class="hl num">1</span><span class="hl sym">,</span> <span class="hl num">0</span><span class="hl sym">,</span>
      <span class="hl num">3</span><span class="hl sym">,</span> <span class="hl num">0</span><span class="hl sym">,</span> <span class="hl num">1</span><span class="hl sym">,</span> <span class="hl num">0</span><span class="hl sym">,</span>
      <span class="hl num">2</span><span class="hl sym">,</span> <span class="hl num">0</span><span class="hl sym">,</span> <span class="hl num">1</span><span class="hl sym">,</span> <span class="hl num">0</span><span class="hl sym">,</span>
   <span class="hl sym">};</span>

   TUInt32 iPos <span class="hl sym">=</span> startPos<span class="hl sym">;</span>
   BitVec mask <span class="hl sym">=</span> <span class="hl num">0xff</span>LL <span class="hl sym">&lt;&lt;</span> startPos<span class="hl sym">;</span>
   <span class="hl kwa">while</span> <span class="hl sym">((</span>mask <span class="hl sym">&amp;</span> v<span class="hl sym">) ==</span> <span class="hl num">0</span><span class="hl sym">) {</span>
      mask <span class="hl sym">&lt;&lt;=</span> <span class="hl num">8</span><span class="hl sym">;</span>
      iPos <span class="hl sym">+=</span> <span class="hl num">8</span><span class="hl sym">;</span>
   <span class="hl sym">}</span>
   TUInt32 result <span class="hl sym">=</span> <span class="hl kwd">TUInt32</span><span class="hl sym">((</span>mask <span class="hl sym">&amp;</span> v<span class="hl sym">) &gt;&gt;</span> iPos<span class="hl sym">);</span>
   TUInt32 resultLow <span class="hl sym">=</span> result <span class="hl sym">&amp;</span> <span class="hl num">0x0f</span><span class="hl sym">;</span>
   <span class="hl kwa">if</span> <span class="hl sym">(</span>resultLow <span class="hl sym">!=</span> <span class="hl num">0</span><span class="hl sym">)</span>
      iPos <span class="hl sym">+=</span> firstOne<span class="hl sym">[</span>resultLow<span class="hl sym">];</span>
   <span class="hl kwa">else</span>
      iPos <span class="hl sym">+=</span> <span class="hl num">4</span> <span class="hl sym">+</span> firstOne<span class="hl sym">[</span>result <span class="hl sym">&gt;&gt;</span> <span class="hl num">4</span><span class="hl sym">];</span>

   <span class="hl kwa">return</span> iPos<span class="hl sym">;</span>
<span class="hl sym">}</span>

TUInt32 <span class="hl kwd">countOnes</span><span class="hl sym">(</span>BitVec v<span class="hl sym">) {</span>
   TUInt32 n <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span>
   <span class="hl kwa">while</span> <span class="hl sym">(</span>v<span class="hl sym">) {</span>
      n<span class="hl sym">++;</span>
      v <span class="hl sym">=</span> v <span class="hl sym">&amp; (</span>v <span class="hl sym">-</span> <span class="hl num">1</span><span class="hl sym">);</span>
   <span class="hl sym">}</span>

   <span class="hl kwa">return</span> n<span class="hl sym">;</span>
<span class="hl sym">}</span>

<span class="hl kwb">void</span> Piece<span class="hl sym">::</span><span class="hl kwd">genAllOrientations</span><span class="hl sym">(</span><span class="hl kwb">void</span><span class="hl sym">) {</span>
   <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> iPiece <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> iPiece <span class="hl sym">&lt;</span> N_TYPE<span class="hl sym">;</span> iPiece<span class="hl sym">++) {</span>
      <span class="hl kwb">const</span> BitVec <span class="hl sym">&amp;</span> refPiece <span class="hl sym">=</span> BaseDefinitions<span class="hl sym">[</span>iPiece<span class="hl sym">];</span>
      <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> iOrient <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> iOrient <span class="hl sym">&lt;</span> N_ORIENT<span class="hl sym">;</span> iOrient<span class="hl sym">++)</span>
         <span class="hl kwd">genOrientation</span><span class="hl sym">(</span>refPiece<span class="hl sym">,</span> iOrient<span class="hl sym">,</span> s_basePiece<span class="hl sym">[</span>iPiece<span class="hl sym">][</span>iOrient<span class="hl sym">]);</span>
   <span class="hl sym">}</span>
<span class="hl sym">}</span>

<span class="hl kwb">void</span> Piece<span class="hl sym">::</span><span class="hl kwd">setCoordList</span><span class="hl sym">(</span><span class="hl kwb">const</span> BitVec <span class="hl sym">&amp;</span> vec<span class="hl sym">,</span> TCoordList <span class="hl sym">&amp;</span> coords<span class="hl sym">) {</span>
   <span class="hl kwb">int</span> iCoord <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span>
   BitVec mask <span class="hl sym">=</span> <span class="hl num">1L</span>L<span class="hl sym">;</span>
   <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> y <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> y <span class="hl sym">&lt;</span> N_ROW<span class="hl sym">;</span> y<span class="hl sym">++) {</span>
      <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> x <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> x <span class="hl sym">&lt;</span> N_COL<span class="hl sym">;</span> x<span class="hl sym">++) {</span>
         <span class="hl kwa">if</span> <span class="hl sym">(</span>mask <span class="hl sym">&amp;</span> vec<span class="hl sym">) {</span>
            coords<span class="hl sym">[</span>iCoord<span class="hl sym">][</span>X<span class="hl sym">] =</span> x<span class="hl sym">;</span>
            coords<span class="hl sym">[</span>iCoord<span class="hl sym">][</span>Y<span class="hl sym">] =</span> y<span class="hl sym">;</span>

            iCoord<span class="hl sym">++;</span>
         <span class="hl sym">}</span>
         mask <span class="hl sym">&lt;&lt;=</span> <span class="hl num">1</span><span class="hl sym">;</span>
      <span class="hl sym">}</span>
   <span class="hl sym">}</span>
<span class="hl sym">}</span>

BitVec Piece<span class="hl sym">::</span><span class="hl kwd">toBitVector</span><span class="hl sym">(</span><span class="hl kwb">const</span> TCoordList <span class="hl sym">&amp;</span> coords<span class="hl sym">)</span>
<span class="hl sym">{</span>
   <span class="hl kwb">int</span> y<span class="hl sym">,</span> x<span class="hl sym">;</span>
   BitVec result <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span>
   <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> iCoord <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> iCoord <span class="hl sym">&lt;</span> N_ELEM<span class="hl sym">;</span> iCoord<span class="hl sym">++) {</span>
      x <span class="hl sym">=</span> coords<span class="hl sym">[</span>iCoord<span class="hl sym">][</span>X<span class="hl sym">];</span>
      y <span class="hl sym">=</span> coords<span class="hl sym">[</span>iCoord<span class="hl sym">][</span>Y<span class="hl sym">];</span>

      <span class="hl kwb">int</span> pos <span class="hl sym">=</span> Board<span class="hl sym">::</span><span class="hl kwd">getIndex</span><span class="hl sym">(</span>x<span class="hl sym">,</span> y<span class="hl sym">);</span>
      result <span class="hl sym">|= (</span><span class="hl num">1L</span>L <span class="hl sym">&lt;&lt;</span> pos<span class="hl sym">);</span> <span class="hl slc">// to generate a 64 bit representation of 1</span>
   <span class="hl sym">}</span>

   <span class="hl kwa">return</span> result<span class="hl sym">;</span>
<span class="hl sym">}</span>

<span class="hl kwb">void</span> Piece<span class="hl sym">::</span><span class="hl kwd">shiftUpLines</span><span class="hl sym">(</span>TCoordList <span class="hl sym">&amp;</span> coords<span class="hl sym">,</span> <span class="hl kwb">int</span> shift<span class="hl sym">)</span>
<span class="hl sym">{</span>
   <span class="hl slc">// apply shifts are not so simple in the vertical direction</span>
   <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> iCoord <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> iCoord <span class="hl sym">&lt;</span> N_ELEM<span class="hl sym">;</span> iCoord<span class="hl sym">++) {</span>
      <span class="hl kwb">int</span> <span class="hl sym">&amp;</span> rx <span class="hl sym">=</span> coords<span class="hl sym">[</span>iCoord<span class="hl sym">][</span>X<span class="hl sym">];</span>
      <span class="hl kwb">int</span> <span class="hl sym">&amp;</span> ry <span class="hl sym">=</span> coords<span class="hl sym">[</span>iCoord<span class="hl sym">][</span>Y<span class="hl sym">];</span>

      <span class="hl kwa">if</span> <span class="hl sym">(</span>ry <span class="hl sym">&amp;</span> shift <span class="hl sym">&amp;</span> <span class="hl num">0x1</span><span class="hl sym">)</span>
         rx<span class="hl sym">++;</span>
      ry <span class="hl sym">-=</span> shift<span class="hl sym">;</span>
   <span class="hl sym">}</span>
<span class="hl sym">}</span>

<span class="hl kwb">void</span> Piece<span class="hl sym">::</span><span class="hl kwd">shiftToX0</span><span class="hl sym">(</span>TCoordList <span class="hl sym">&amp;</span> coords<span class="hl sym">,</span> Piece<span class="hl sym">::</span>Instance <span class="hl sym">&amp;</span> instance<span class="hl sym">,</span> <span class="hl kwb">int</span> offsetRow<span class="hl sym">)</span>
<span class="hl sym">{</span>
   <span class="hl slc">// .. determine shift</span>
   <span class="hl kwb">int</span> x<span class="hl sym">,</span> y<span class="hl sym">;</span>
   <span class="hl kwb">int</span> xMin <span class="hl sym">=</span> coords<span class="hl sym">[</span><span class="hl num">0</span><span class="hl sym">][</span>X<span class="hl sym">];</span>
   <span class="hl kwb">int</span> xMax <span class="hl sym">=</span> xMin<span class="hl sym">;</span>
   <span class="hl kwb">int</span> iCoord<span class="hl sym">;</span>
   <span class="hl kwa">for</span> <span class="hl sym">(</span>iCoord <span class="hl sym">=</span> <span class="hl num">1</span><span class="hl sym">;</span> iCoord <span class="hl sym">&lt;</span> N_ELEM<span class="hl sym">;</span> iCoord<span class="hl sym">++) {</span>
      x <span class="hl sym">=</span> coords<span class="hl sym">[</span>iCoord<span class="hl sym">][</span>X<span class="hl sym">];</span>
      y <span class="hl sym">=</span> coords<span class="hl sym">[</span>iCoord<span class="hl sym">][</span>Y<span class="hl sym">];</span>

      <span class="hl kwa">if</span> <span class="hl sym">(</span>x <span class="hl sym">&lt;</span> xMin<span class="hl sym">)</span>
         xMin <span class="hl sym">=</span> x<span class="hl sym">;</span>
      <span class="hl kwa">else if</span> <span class="hl sym">(</span>x <span class="hl sym">&gt;</span> xMax<span class="hl sym">)</span>
         xMax <span class="hl sym">=</span> x<span class="hl sym">;</span>
   <span class="hl sym">}</span>

   <span class="hl slc">// I'm dying for a 'foreach' here</span>
   <span class="hl kwb">int</span> offset <span class="hl sym">=</span> N_ELEM<span class="hl sym">;</span>

   <span class="hl kwa">for</span> <span class="hl sym">(</span>iCoord <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> iCoord <span class="hl sym">&lt;</span> N_ELEM<span class="hl sym">;</span> iCoord<span class="hl sym">++) {</span>
      <span class="hl kwb">int</span> <span class="hl sym">&amp;</span> rx <span class="hl sym">=</span> coords<span class="hl sym">[</span>iCoord<span class="hl sym">][</span>X<span class="hl sym">];</span>
      <span class="hl kwb">int</span> <span class="hl sym">&amp;</span> ry <span class="hl sym">=</span> coords<span class="hl sym">[</span>iCoord<span class="hl sym">][</span>Y<span class="hl sym">];</span>

      rx <span class="hl sym">-=</span> xMin<span class="hl sym">;</span>

      <span class="hl slc">// check offset -- leftmost cell on top line</span>
      <span class="hl kwa">if</span> <span class="hl sym">((</span>ry <span class="hl sym">==</span> offsetRow<span class="hl sym">) &amp;&amp; (</span>rx <span class="hl sym">&lt;</span> offset<span class="hl sym">))</span>
         offset <span class="hl sym">=</span> rx<span class="hl sym">;</span>
   <span class="hl sym">}</span>

   instance<span class="hl sym">.</span>m_w <span class="hl sym">=</span> xMax <span class="hl sym">-</span> xMin<span class="hl sym">;</span>
   instance<span class="hl sym">.</span>m_offset <span class="hl sym">=</span> offset<span class="hl sym">;</span>
   instance<span class="hl sym">.</span>m_vec <span class="hl sym">=</span> <span class="hl kwd">toBitVector</span><span class="hl sym">(</span>coords<span class="hl sym">);</span>
<span class="hl sym">}</span>

<span class="hl kwb">void</span> Piece<span class="hl sym">::</span><span class="hl kwd">setAllowedPositions</span><span class="hl sym">(</span>Piece<span class="hl sym">::</span>Instance <span class="hl sym">&amp;</span> p<span class="hl sym">)</span>
<span class="hl sym">{</span>
   BitVec <span class="hl sym">&amp;</span> allowed <span class="hl sym">=</span> p<span class="hl sym">.</span>m_allowed <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span>
   BitVec posMask <span class="hl sym">=</span> <span class="hl num">1L</span>L<span class="hl sym">;</span>
   TUInt32 iPos <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span>
   <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> y <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> y <span class="hl sym">&lt;</span> N_ROW<span class="hl sym">;</span> y<span class="hl sym">++) {</span>
      <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> x <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> x <span class="hl sym">&lt;</span> N_COL<span class="hl sym">;</span> x<span class="hl sym">++,</span> iPos<span class="hl sym">++,</span> posMask <span class="hl sym">&lt;&lt;=</span> <span class="hl num">1</span><span class="hl sym">){</span>
         <span class="hl slc">// check if the new position is on the board</span>
         <span class="hl kwb">int</span> xPos <span class="hl sym">=</span> x <span class="hl sym">-</span> p<span class="hl sym">.</span>m_offset<span class="hl sym">;</span>
         <span class="hl kwa">if</span> <span class="hl sym">((</span>xPos <span class="hl sym">&lt;</span> <span class="hl num">0</span><span class="hl sym">) || (</span>y <span class="hl sym">+</span> p<span class="hl sym">.</span>m_h <span class="hl sym">&gt;=</span> N_ROW<span class="hl sym">) || (</span>xPos <span class="hl sym">+</span> p<span class="hl sym">.</span>m_w <span class="hl sym">&gt;=</span> N_COL<span class="hl sym">))</span>
            <span class="hl kwa">continue</span><span class="hl sym">;</span>

         <span class="hl slc">// move it to the desired location</span>
         BitVec pieceVec <span class="hl sym">=</span> p<span class="hl sym">.</span>m_vec <span class="hl sym">&lt;&lt; (</span>iPos <span class="hl sym">-</span> p<span class="hl sym">.</span>m_offset<span class="hl sym">);</span>

         <span class="hl kwa">if</span> <span class="hl sym">(</span>Board<span class="hl sym">::</span><span class="hl kwd">hasBadIslands</span><span class="hl sym">(</span>pieceVec<span class="hl sym">))</span>
            <span class="hl kwa">continue</span><span class="hl sym">;</span>

         <span class="hl slc">// position is allowed</span>
         allowed <span class="hl sym">|=</span> posMask<span class="hl sym">;</span>
      <span class="hl sym">}</span>
   <span class="hl sym">}</span>
<span class="hl sym">}</span>

<span class="hl kwb">void</span> Piece<span class="hl sym">::</span><span class="hl kwd">genOrientation</span><span class="hl sym">(</span><span class="hl kwb">const</span> BitVec <span class="hl sym">&amp;</span> vec<span class="hl sym">,</span> TUInt32 iOrient<span class="hl sym">,</span> Piece <span class="hl sym">&amp;</span> target<span class="hl sym">)</span>
<span class="hl sym">{</span>
   <span class="hl slc">// get (x,y) coordinates</span>
   TCoordList coords<span class="hl sym">;</span>
   <span class="hl kwd">setCoordList</span><span class="hl sym">(</span>vec<span class="hl sym">,</span> coords<span class="hl sym">);</span>

   <span class="hl kwb">int</span> y<span class="hl sym">,</span> x<span class="hl sym">;</span>
   <span class="hl kwb">int</span> iCoord <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span>
   <span class="hl kwb">int</span> rot <span class="hl sym">=</span> iOrient <span class="hl sym">%</span> <span class="hl num">6</span><span class="hl sym">;</span>
   <span class="hl kwb">int</span> flip <span class="hl sym">=</span> iOrient <span class="hl sym">&gt;=</span> <span class="hl num">6</span><span class="hl sym">;</span>
   <span class="hl kwa">if</span> <span class="hl sym">(</span>flip<span class="hl sym">) {</span>
      <span class="hl kwa">for</span> <span class="hl sym">(</span>iCoord <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> iCoord <span class="hl sym">&lt;</span> N_ELEM<span class="hl sym">;</span> iCoord<span class="hl sym">++)</span>
         coords<span class="hl sym">[</span>iCoord<span class="hl sym">][</span>Y<span class="hl sym">] = -</span>coords<span class="hl sym">[</span>iCoord<span class="hl sym">][</span>Y<span class="hl sym">];</span>
   <span class="hl sym">}</span>

   <span class="hl slc">// rotate (if necessary)</span>
   <span class="hl kwa">while</span> <span class="hl sym">(</span>rot<span class="hl sym">--) {</span>
      <span class="hl kwa">for</span> <span class="hl sym">(</span>iCoord <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> iCoord <span class="hl sym">&lt;</span> N_ELEM<span class="hl sym">;</span> iCoord<span class="hl sym">++) {</span>
         x <span class="hl sym">=</span> coords<span class="hl sym">[</span>iCoord<span class="hl sym">][</span>X<span class="hl sym">];</span>
         y <span class="hl sym">=</span> coords<span class="hl sym">[</span>iCoord<span class="hl sym">][</span>Y<span class="hl sym">];</span>

         <span class="hl slc">// I just worked this out by hand. Took a while.</span>
         <span class="hl kwb">int</span> xNew <span class="hl sym">=</span> <span class="hl kwd">floor</span><span class="hl sym">((</span><span class="hl num">2</span> <span class="hl sym">*</span> x <span class="hl sym">-</span> <span class="hl num">3</span> <span class="hl sym">*</span> y <span class="hl sym">+</span> <span class="hl num">1</span><span class="hl sym">),</span> <span class="hl num">4</span><span class="hl sym">);</span>
         <span class="hl kwb">int</span> yNew <span class="hl sym">=</span> <span class="hl kwd">floor</span><span class="hl sym">((</span><span class="hl num">2</span> <span class="hl sym">*</span> x <span class="hl sym">+</span> y <span class="hl sym">+</span> <span class="hl num">1</span><span class="hl sym">),</span> <span class="hl num">2</span><span class="hl sym">);</span>
         coords<span class="hl sym">[</span>iCoord<span class="hl sym">][</span>X<span class="hl sym">] =</span> xNew<span class="hl sym">;</span>
         coords<span class="hl sym">[</span>iCoord<span class="hl sym">][</span>Y<span class="hl sym">] =</span> yNew<span class="hl sym">;</span>
      <span class="hl sym">}</span>
   <span class="hl sym">}</span>

   <span class="hl slc">// shift vertically</span>
   <span class="hl slc">// .. determine shift</span>
   <span class="hl kwb">int</span> yMin <span class="hl sym">=</span> coords<span class="hl sym">[</span><span class="hl num">0</span><span class="hl sym">][</span>Y<span class="hl sym">];</span>
   <span class="hl kwb">int</span> yMax <span class="hl sym">=</span> yMin<span class="hl sym">;</span>
   <span class="hl kwa">for</span> <span class="hl sym">(</span>iCoord <span class="hl sym">=</span> <span class="hl num">1</span><span class="hl sym">;</span> iCoord <span class="hl sym">&lt;</span> N_ELEM<span class="hl sym">;</span> iCoord<span class="hl sym">++) {</span>
      y <span class="hl sym">=</span> coords<span class="hl sym">[</span>iCoord<span class="hl sym">][</span>Y<span class="hl sym">];</span>

      <span class="hl kwa">if</span> <span class="hl sym">(</span>y <span class="hl sym">&lt;</span> yMin<span class="hl sym">)</span>
         yMin <span class="hl sym">=</span> y<span class="hl sym">;</span>
      <span class="hl kwa">else if</span> <span class="hl sym">(</span>y <span class="hl sym">&gt;</span> yMax<span class="hl sym">)</span>
         yMax <span class="hl sym">=</span> y<span class="hl sym">;</span>
   <span class="hl sym">}</span>
   TUInt32 h <span class="hl sym">=</span> yMax <span class="hl sym">-</span> yMin<span class="hl sym">;</span>
   target<span class="hl sym">.</span>m_instance<span class="hl sym">[</span>EVEN<span class="hl sym">].</span>m_h <span class="hl sym">=</span> h<span class="hl sym">;</span>
   target<span class="hl sym">.</span>m_instance<span class="hl sym">[</span>ODD<span class="hl sym">].</span>m_h <span class="hl sym">=</span> h<span class="hl sym">;</span>

   <span class="hl kwd">shiftUpLines</span><span class="hl sym">(</span>coords<span class="hl sym">,</span> yMin<span class="hl sym">);</span>
   <span class="hl kwd">shiftToX0</span><span class="hl sym">(</span>coords<span class="hl sym">,</span> target<span class="hl sym">.</span>m_instance<span class="hl sym">[</span>EVEN<span class="hl sym">],</span> <span class="hl num">0</span><span class="hl sym">);</span>
   <span class="hl kwd">setAllowedPositions</span><span class="hl sym">(</span>target<span class="hl sym">.</span>m_instance<span class="hl sym">[</span>EVEN<span class="hl sym">]);</span>

   <span class="hl slc">// shift down one line</span>
   <span class="hl kwd">shiftUpLines</span><span class="hl sym">(</span>coords<span class="hl sym">, -</span><span class="hl num">1</span><span class="hl sym">);</span>
   <span class="hl kwd">shiftToX0</span><span class="hl sym">(</span>coords<span class="hl sym">,</span> target<span class="hl sym">.</span>m_instance<span class="hl sym">[</span>ODD<span class="hl sym">],</span> <span class="hl num">1</span><span class="hl sym">);</span>
   <span class="hl slc">// shift the bitmask back one line</span>
   target<span class="hl sym">.</span>m_instance<span class="hl sym">[</span>ODD<span class="hl sym">].</span>m_vec <span class="hl sym">&gt;&gt;=</span> N_COL<span class="hl sym">;</span>
   <span class="hl kwd">setAllowedPositions</span><span class="hl sym">(</span>target<span class="hl sym">.</span>m_instance<span class="hl sym">[</span>ODD<span class="hl sym">]);</span>
<span class="hl sym">}</span>

<span class="hl kwb">const</span> Piece<span class="hl sym">::</span>Instance <span class="hl sym">&amp;</span> Piece<span class="hl sym">::</span><span class="hl kwd">getPiece</span><span class="hl sym">(</span>TUInt32 iPiece<span class="hl sym">,</span> TUInt32 iOrient<span class="hl sym">,</span> TUInt32 iParity<span class="hl sym">) {</span>
   <span class="hl kwa">return</span> s_basePiece<span class="hl sym">[</span>iPiece<span class="hl sym">][</span>iOrient<span class="hl sym">].</span>m_instance<span class="hl sym">[</span>iParity<span class="hl sym">];</span>
<span class="hl sym">}</span>

<span class="hl slc">// ------------------------------------</span>

Board<span class="hl sym">::</span><span class="hl kwd">Board</span><span class="hl sym">() :</span>
   <span class="hl kwd">m_curSolution</span><span class="hl sym">(</span>Solution<span class="hl sym">::</span>NO_PIECE<span class="hl sym">),</span> <span class="hl kwd">m_minSolution</span><span class="hl sym">(</span>Piece<span class="hl sym">::</span>N_TYPE<span class="hl sym">),</span>
   <span class="hl kwd">m_maxSolution</span><span class="hl sym">(</span>Solution<span class="hl sym">::</span>NO_PIECE<span class="hl sym">),</span> <span class="hl kwd">m_nSolutionFound</span><span class="hl sym">(</span><span class="hl num">0</span><span class="hl sym">)</span>
<span class="hl sym">{</span>
<span class="hl sym">}</span>

<span class="hl kwb">bool</span> Board<span class="hl sym">::</span><span class="hl kwd">hasBadFirstRegion</span><span class="hl sym">(</span>BitVec <span class="hl sym">&amp;</span> toFill<span class="hl sym">)</span>
<span class="hl sym">{</span>
   <span class="hl kwb">int</span> iPos <span class="hl sym">=</span> <span class="hl kwd">getFirstOne</span><span class="hl sym">(</span>toFill<span class="hl sym">);</span>

   <span class="hl slc">// grow empty region, until it doesn't change any more</span>
   BitVec region<span class="hl sym">;</span>
   BitVec rNew <span class="hl sym">=</span> <span class="hl num">1L</span>L <span class="hl sym">&lt;&lt;</span> iPos<span class="hl sym">;</span>
   <span class="hl kwa">do</span> <span class="hl sym">{</span>
      region <span class="hl sym">=</span> rNew<span class="hl sym">;</span>

      <span class="hl slc">// grow right/left</span>
      rNew <span class="hl sym">|= (</span>region <span class="hl sym">&amp; ~</span>L_EDGE_MASK<span class="hl sym">) &gt;&gt;</span> <span class="hl num">1</span><span class="hl sym">;</span>
      rNew <span class="hl sym">|= (</span>region <span class="hl sym">&amp; ~</span>R_EDGE_MASK<span class="hl sym">) &lt;&lt;</span> <span class="hl num">1</span><span class="hl sym">;</span>

      <span class="hl slc">// simple grow up/down</span>
      rNew <span class="hl sym">|= (</span>region <span class="hl sym">&gt;&gt;</span> N_COL<span class="hl sym">);</span>
      rNew <span class="hl sym">|= (</span>region <span class="hl sym">&lt;&lt;</span> N_COL<span class="hl sym">);</span>

      <span class="hl slc">// tricky growth</span>
      BitVec evenRegion <span class="hl sym">=</span> region <span class="hl sym">&amp; (</span>ROW_0_MASK <span class="hl sym">&amp; ~</span>L_EDGE_MASK<span class="hl sym">);</span>
      rNew <span class="hl sym">|=</span> evenRegion <span class="hl sym">&gt;&gt; (</span>N_COL <span class="hl sym">+</span> <span class="hl num">1</span><span class="hl sym">);</span>
      rNew <span class="hl sym">|=</span> evenRegion <span class="hl sym">&lt;&lt; (</span>N_COL <span class="hl sym">-</span> <span class="hl num">1</span><span class="hl sym">);</span>

      BitVec oddRegion <span class="hl sym">=</span> region <span class="hl sym">&amp; (</span>ROW_1_MASK <span class="hl sym">&amp; ~</span>R_EDGE_MASK<span class="hl sym">);</span>
      rNew <span class="hl sym">|=</span> oddRegion <span class="hl sym">&gt;&gt; (</span>N_COL <span class="hl sym">-</span> <span class="hl num">1</span><span class="hl sym">);</span>
      rNew <span class="hl sym">|=</span> oddRegion <span class="hl sym">&lt;&lt; (</span>N_COL <span class="hl sym">+</span> <span class="hl num">1</span><span class="hl sym">);</span>

      <span class="hl slc">// clamp against existing pieces</span>
      rNew <span class="hl sym">&amp;=</span> toFill<span class="hl sym">;</span>
   <span class="hl sym">}</span>
   <span class="hl kwa">while</span> <span class="hl sym">((</span>rNew <span class="hl sym">!=</span> toFill<span class="hl sym">) &amp;&amp; (</span>rNew <span class="hl sym">!=</span> region<span class="hl sym">));</span>

   <span class="hl slc">// subtract empty region from board</span>
   toFill ^<span class="hl sym">=</span> rNew<span class="hl sym">;</span>

   TUInt32 nEmptyCells <span class="hl sym">=</span> <span class="hl kwd">countOnes</span><span class="hl sym">(</span>toFill<span class="hl sym">);</span>
   <span class="hl kwa">if</span> <span class="hl sym">(</span>nEmptyCells <span class="hl sym">%</span> <span class="hl num">5</span> <span class="hl sym">!=</span> <span class="hl num">0</span><span class="hl sym">)</span>
      <span class="hl kwa">return true</span><span class="hl sym">;</span>

   <span class="hl kwa">return false</span><span class="hl sym">;</span>
<span class="hl sym">}</span>

<span class="hl kwb">bool</span> Board<span class="hl sym">::</span><span class="hl kwd">hasBadIslands</span><span class="hl sym">(</span><span class="hl kwb">const</span> BitVec <span class="hl sym">&amp;</span> boardVec<span class="hl sym">)</span>
<span class="hl sym">{</span>
   BitVec toFill <span class="hl sym">= ~</span>boardVec <span class="hl sym">&amp;</span> BOARD_MASK<span class="hl sym">;</span>

   <span class="hl slc">// a little pre-work to speed things up</span>
   BitVec row <span class="hl sym">= (</span>Board<span class="hl sym">::</span>TOP_ROW <span class="hl sym">&lt;&lt; ((</span>N_ROW <span class="hl sym">-</span> <span class="hl num">1</span><span class="hl sym">) *</span> N_COL<span class="hl sym">));</span>
   <span class="hl kwb">bool</span> filled <span class="hl sym">= ((</span>row <span class="hl sym">&amp;</span> toFill<span class="hl sym">) ==</span> row<span class="hl sym">);</span>
   <span class="hl kwa">while</span> <span class="hl sym">((</span>row <span class="hl sym">&amp;</span> toFill<span class="hl sym">) ==</span> row<span class="hl sym">) {</span>
      toFill ^<span class="hl sym">=</span> row<span class="hl sym">;</span>
      row <span class="hl sym">&gt;&gt;=</span> N_COL<span class="hl sym">;</span>
   <span class="hl sym">}</span>
   <span class="hl slc">// undo the last row, so regions stay connected</span>
   <span class="hl kwa">if</span> <span class="hl sym">(</span>filled<span class="hl sym">)   {</span>
      row <span class="hl sym">&lt;&lt;=</span> N_COL<span class="hl sym">;</span>
      toFill <span class="hl sym">|=</span> row<span class="hl sym">;</span>
   <span class="hl sym">}</span>

   <span class="hl kwa">while</span> <span class="hl sym">(</span>toFill<span class="hl sym">)    {</span>
      <span class="hl kwa">if</span> <span class="hl sym">(</span><span class="hl kwd">hasBadFirstRegion</span><span class="hl sym">(</span>toFill<span class="hl sym">))</span>
         <span class="hl kwa">return true</span><span class="hl sym">;</span>
   <span class="hl sym">}</span>

   <span class="hl kwa">return false</span><span class="hl sym">;</span>
<span class="hl sym">}</span>

<span class="hl slc">// recursive vs iterative?</span>
<span class="hl kwb">void</span> Board<span class="hl sym">::</span><span class="hl kwd">genAllSolutions</span><span class="hl sym">(</span>BitVec boardVec<span class="hl sym">,</span> TUInt32 placedPieces<span class="hl sym">,</span> TUInt32 iNextFill<span class="hl sym">,</span> <span class="hl kwb">const</span> BitVec <span class="hl sym">&amp;</span> maskNextFill<span class="hl sym">)</span>
<span class="hl sym">{</span>
   BitVec pieceVec<span class="hl sym">;</span>
   <span class="hl kwb">int</span> pieceMask <span class="hl sym">=</span> <span class="hl num">1</span><span class="hl sym">;</span>
   <span class="hl kwb">int</span> y <span class="hl sym">=</span> iNextFill <span class="hl sym">/</span> N_COL<span class="hl sym">;</span>
   <span class="hl kwb">int</span> isOddLine <span class="hl sym">=</span> y <span class="hl sym">&amp;</span> <span class="hl num">1</span><span class="hl sym">;</span>

   <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> iPlacedPiece <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> iPlacedPiece <span class="hl sym">&lt;</span> Piece<span class="hl sym">::</span>N_TYPE<span class="hl sym">;</span> iPlacedPiece<span class="hl sym">++,</span> pieceMask <span class="hl sym">&lt;&lt;=</span> <span class="hl num">1</span><span class="hl sym">)</span>
   <span class="hl sym">{</span>
      TUInt32 iPiece <span class="hl sym">=</span> iPlacedPiece<span class="hl sym">;</span> <span class="hl slc">// leftover from when I remapped it</span>

      <span class="hl slc">// skip if we've already used this piece</span>
      <span class="hl kwa">if</span> <span class="hl sym">(</span>pieceMask <span class="hl sym">&amp;</span> placedPieces<span class="hl sym">)</span>
         <span class="hl kwa">continue</span><span class="hl sym">;</span>

      <span class="hl slc">// try to fit piece</span>
      <span class="hl kwb">bool</span> skipFlippedOdd <span class="hl sym">= (</span>iPiece <span class="hl sym">==</span> Piece<span class="hl sym">::</span>SKIP_PIECE<span class="hl sym">);</span>
      <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> iOrient <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> iOrient <span class="hl sym">&lt;</span> Piece<span class="hl sym">::</span>N_ORIENT<span class="hl sym">;</span> iOrient<span class="hl sym">++)</span>
      <span class="hl sym">{</span>
         <span class="hl kwa">if</span> <span class="hl sym">(</span>skipFlippedOdd <span class="hl sym">&amp;&amp; ((</span>iOrient <span class="hl sym">/</span> <span class="hl num">3</span><span class="hl sym">) &amp;</span> <span class="hl num">1</span><span class="hl sym">))</span>
            <span class="hl kwa">continue</span><span class="hl sym">;</span>

         <span class="hl slc">// get the particular piece in the particular orientation</span>
         <span class="hl kwb">const</span> Piece<span class="hl sym">::</span>Instance <span class="hl sym">&amp;</span> p <span class="hl sym">=</span> Piece<span class="hl sym">::</span><span class="hl kwd">getPiece</span><span class="hl sym">(</span>iPiece<span class="hl sym">,</span> iOrient<span class="hl sym">,</span> isOddLine<span class="hl sym">);</span>

         <span class="hl slc">// check if the new position is allowed on the board</span>
         <span class="hl kwa">if</span> <span class="hl sym">(!(</span>p<span class="hl sym">.</span>m_allowed <span class="hl sym">&amp;</span> maskNextFill<span class="hl sym">))</span>
            <span class="hl kwa">continue</span><span class="hl sym">;</span>

         <span class="hl slc">// move it to the desired location, if possible and</span>
         pieceVec <span class="hl sym">=</span> p<span class="hl sym">.</span>m_vec <span class="hl sym">&lt;&lt; (</span>iNextFill <span class="hl sym">-</span> p<span class="hl sym">.</span>m_offset<span class="hl sym">);</span>

         <span class="hl slc">// check if piece conflicts with other pieces</span>
         <span class="hl kwa">if</span> <span class="hl sym">(</span>pieceVec <span class="hl sym">&amp;</span> boardVec<span class="hl sym">)</span>
            <span class="hl kwa">continue</span><span class="hl sym">;</span>

         <span class="hl slc">// add the piece to the board</span>
         boardVec <span class="hl sym">|=</span> pieceVec<span class="hl sym">;</span>

         <span class="hl kwa">if</span> <span class="hl sym">((</span>boardVec <span class="hl sym">!=</span> pieceVec<span class="hl sym">) &amp;&amp;</span> <span class="hl kwd">hasBadIslands</span><span class="hl sym">(</span>boardVec<span class="hl sym">)) {</span>
            <span class="hl slc">// remove the piece from the board vector</span>
            boardVec ^<span class="hl sym">=</span> pieceVec<span class="hl sym">;</span>
            <span class="hl kwa">continue</span><span class="hl sym">;</span>
         <span class="hl sym">}</span>

         <span class="hl slc">// mark piece as placed</span>
         placedPieces <span class="hl sym">|=</span> pieceMask<span class="hl sym">;</span>
         m_curSolution<span class="hl sym">.</span><span class="hl kwd">addPiece</span><span class="hl sym">(</span>pieceVec<span class="hl sym">,</span> iPiece<span class="hl sym">);</span>

         <span class="hl slc">// recur if not done</span>
         <span class="hl kwa">if</span> <span class="hl sym">(</span>placedPieces <span class="hl sym">!=</span> Piece<span class="hl sym">::</span>ALL_PIECE_MASK<span class="hl sym">)   {</span>
            <span class="hl slc">// need to find the next unfilled cell</span>
            TUInt32 iCell <span class="hl sym">=</span> <span class="hl kwd">getFirstOne</span><span class="hl sym">(~</span>boardVec<span class="hl sym">,</span> iNextFill <span class="hl sym">+</span> <span class="hl num">1</span><span class="hl sym">);</span>
            BitVec mNextFill <span class="hl sym">= (</span>maskNextFill <span class="hl sym">&lt;&lt; (</span>iCell <span class="hl sym">-</span> iNextFill<span class="hl sym">));</span>

            <span class="hl kwd">genAllSolutions</span><span class="hl sym">(</span>boardVec<span class="hl sym">,</span> placedPieces<span class="hl sym">,</span> iCell<span class="hl sym">,</span> mNextFill<span class="hl sym">);</span>
         <span class="hl sym">}</span>
         <span class="hl kwa">else</span> <span class="hl sym">{</span>
            <span class="hl slc">// done, record piece/solution and end recursion</span>
            <span class="hl kwd">recordSolution</span><span class="hl sym">(</span>m_curSolution<span class="hl sym">);</span>
         <span class="hl sym">}</span>

         <span class="hl slc">// remove the piece before continuing with a new piece</span>
         boardVec ^<span class="hl sym">=</span> pieceVec<span class="hl sym">;</span>
         m_curSolution<span class="hl sym">.</span><span class="hl kwd">removeLastPiece</span><span class="hl sym">();</span>
      <span class="hl sym">}</span>

      placedPieces <span class="hl sym">&amp;= ~</span>pieceMask<span class="hl sym">;</span>
   <span class="hl sym">}</span>
<span class="hl sym">}</span>

<span class="hl kwb">void</span> Board<span class="hl sym">::</span><span class="hl kwd">recordSolution</span><span class="hl sym">(</span>Solution <span class="hl sym">&amp;</span> s<span class="hl sym">)</span>
<span class="hl sym">{</span>
   m_nSolutionFound <span class="hl sym">+=</span> <span class="hl num">2</span><span class="hl sym">;</span> <span class="hl slc">// we add the solution and its rotation</span>

   <span class="hl kwa">if</span> <span class="hl sym">(</span>m_minSolution<span class="hl sym">.</span><span class="hl kwd">isEmpty</span><span class="hl sym">()) {</span>
      m_minSolution <span class="hl sym">=</span> m_maxSolution <span class="hl sym">=</span> s<span class="hl sym">;</span>
      <span class="hl kwa">return</span><span class="hl sym">;</span>
   <span class="hl sym">}</span>

   <span class="hl kwa">if</span> <span class="hl sym">(</span>s<span class="hl sym">.</span><span class="hl kwd">lessThan</span><span class="hl sym">(</span>m_minSolution<span class="hl sym">))</span>
      m_minSolution <span class="hl sym">=</span> s<span class="hl sym">;</span>
   <span class="hl kwa">else if</span> <span class="hl sym">(</span>m_maxSolution<span class="hl sym">.</span><span class="hl kwd">lessThan</span><span class="hl sym">(</span>s<span class="hl sym">))</span>
      m_maxSolution <span class="hl sym">=</span> s<span class="hl sym">;</span>

   Solution spun<span class="hl sym">;</span>
   s<span class="hl sym">.</span><span class="hl kwd">spin</span><span class="hl sym">(</span>spun<span class="hl sym">);</span>
   <span class="hl kwa">if</span> <span class="hl sym">(</span>spun<span class="hl sym">.</span><span class="hl kwd">lessThan</span><span class="hl sym">(</span>m_minSolution<span class="hl sym">))</span>
      m_minSolution <span class="hl sym">=</span> spun<span class="hl sym">;</span>
   <span class="hl kwa">else if</span> <span class="hl sym">(</span>m_maxSolution<span class="hl sym">.</span><span class="hl kwd">lessThan</span><span class="hl sym">(</span>s<span class="hl sym">))</span>
      m_maxSolution <span class="hl sym">=</span> spun<span class="hl sym">;</span>
<span class="hl sym">}</span>

<span class="hl sym">}</span> <span class="hl slc">// namespace</span>

<span class="hl kwa">using namespace</span> Meteor<span class="hl sym">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl sym">(</span><span class="hl kwb">int</span> argc<span class="hl sym">,</span> <span class="hl kwb">char</span> <span class="hl sym">*</span> argv <span class="hl sym">[])</span>
<span class="hl sym">{</span>
   <span class="hl kwb">const int</span> N_SOLUTION <span class="hl sym">=</span> <span class="hl num">2098</span><span class="hl sym">;</span>
   TUInt32 nSolMax <span class="hl sym">=</span> N_SOLUTION<span class="hl sym">;</span>
   <span class="hl kwa">if</span> <span class="hl sym">(</span>argc <span class="hl sym">&gt;</span> <span class="hl num">2</span><span class="hl sym">)</span>
      <span class="hl kwa">return</span> <span class="hl num">1</span><span class="hl sym">;</span> <span class="hl slc">// spec says this is an error</span>
   <span class="hl kwa">else if</span> <span class="hl sym">(</span>argc <span class="hl sym">==</span> <span class="hl num">2</span><span class="hl sym">)</span>
      nSolMax <span class="hl sym">= *((</span>TUInt32 <span class="hl sym">*)</span>argv<span class="hl sym">[</span><span class="hl num">1</span><span class="hl sym">]);</span>

   Board board<span class="hl sym">;</span>
   Piece<span class="hl sym">::</span><span class="hl kwd">genAllOrientations</span><span class="hl sym">();</span>
   board<span class="hl sym">.</span><span class="hl kwd">genAllSolutions</span><span class="hl sym">(</span><span class="hl num">0</span><span class="hl sym">,</span> <span class="hl num">0</span><span class="hl sym">,</span> <span class="hl num">0</span><span class="hl sym">,</span> <span class="hl num">1L</span>L<span class="hl sym">);</span>

   cout <span class="hl sym">&lt;&lt;</span> board<span class="hl sym">.</span>m_nSolutionFound <span class="hl sym">&lt;&lt;</span> <span class="hl str">&quot; solutions found</span><span class="hl esc">\n\n</span><span class="hl str">&quot;</span><span class="hl sym">;</span>
   cout <span class="hl sym">&lt;&lt;</span> board<span class="hl sym">.</span>m_minSolution<span class="hl sym">.</span><span class="hl kwd">toString</span><span class="hl sym">() &lt;&lt;</span> <span class="hl str">'</span><span class="hl esc">\n</span><span class="hl str">'</span><span class="hl sym">;</span>
   cout <span class="hl sym">&lt;&lt;</span> board<span class="hl sym">.</span>m_maxSolution<span class="hl sym">.</span><span class="hl kwd">toString</span><span class="hl sym">() &lt;&lt;</span> endl<span class="hl sym">;</span>

<span class="hl slc">//   if (nSolMax != N_SOLUTION)</span>
<span class="hl slc">//      return 1;</span>

   <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl sym">;</span>
<span class="hl sym">}</span>
