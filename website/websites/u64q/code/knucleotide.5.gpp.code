<span class="hl com">/* The Computer Language Benchmarks Game</span>
<span class="hl com">   http://shootout.alioth.debian.org/</span>
<span class="hl com"></span>
<span class="hl com">   Contributed by Andrew Moon</span>
<span class="hl com">*/</span>


<span class="hl dir">#include &lt;stdio.h&gt;</span>
<span class="hl dir">#include &lt;stdlib.h&gt;</span>
<span class="hl dir">#include &lt;string.h&gt;</span>
<span class="hl dir">#include &lt;cstdlib&gt;</span>
<span class="hl dir">#include &lt;iostream&gt;</span>
<span class="hl dir">#include &lt;iomanip&gt;</span>
<span class="hl dir">#include &lt;vector&gt;</span>
<span class="hl dir">#include &lt;algorithm&gt;</span>

<span class="hl dir">#include &lt;sched.h&gt;</span>
<span class="hl dir">#include &lt;pthread.h&gt;</span>
<span class="hl dir">#include &lt;ext/pb_ds/assoc_container.hpp&gt;</span>
<span class="hl dir">#include &lt;ext/pb_ds/hash_policy.hpp&gt;</span>

<span class="hl kwc">typedef</span> <span class="hl kwb">unsigned long long</span> u64<span class="hl sym">;</span>
<span class="hl kwc">typedef</span> <span class="hl kwb">unsigned int</span> u32<span class="hl sym">;</span>
<span class="hl kwc">typedef</span> <span class="hl kwb">signed int</span> s32<span class="hl sym">;</span>
<span class="hl kwc">typedef</span> <span class="hl kwb">unsigned short</span> u16<span class="hl sym">;</span>
<span class="hl kwc">typedef</span> <span class="hl kwb">unsigned char</span> u8<span class="hl sym">;</span>

<span class="hl kwa">using namespace</span> std<span class="hl sym">;</span>

<span class="hl kwb">struct</span> CPUs <span class="hl sym">{</span>
  <span class="hl kwd">CPUs</span><span class="hl sym">() {</span>
    cpu_set_t cs<span class="hl sym">;</span>
    <span class="hl kwd">CPU_ZERO</span><span class="hl sym">( &amp;</span>cs <span class="hl sym">);</span>
    <span class="hl kwd">sched_getaffinity</span><span class="hl sym">(</span> <span class="hl num">0</span><span class="hl sym">,</span> <span class="hl kwa">sizeof</span><span class="hl sym">(</span>cs<span class="hl sym">), &amp;</span>cs <span class="hl sym">);</span>
    count <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span>
    <span class="hl kwa">for</span> <span class="hl sym">(</span> <span class="hl kwb">size_t</span> i <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> i <span class="hl sym">&lt;</span> CPU_SETSIZE<span class="hl sym">;</span> i<span class="hl sym">++ )</span>
      count <span class="hl sym">+=</span> <span class="hl kwd">CPU_ISSET</span><span class="hl sym">(</span> i<span class="hl sym">, &amp;</span>cs <span class="hl sym">)</span> ? <span class="hl num">1</span> <span class="hl sym">:</span> <span class="hl num">0</span><span class="hl sym">;</span>
    count <span class="hl sym">=</span> std<span class="hl sym">::</span><span class="hl kwd">max</span><span class="hl sym">(</span> count<span class="hl sym">,</span> <span class="hl kwd">u32</span><span class="hl sym">(</span><span class="hl num">1</span><span class="hl sym">) );</span>
  <span class="hl sym">}</span>

  u32 count<span class="hl sym">;</span>
<span class="hl sym">}</span> cpus<span class="hl sym">;</span>


<span class="hl com">/*</span>
<span class="hl com">  Smart selection of u32 or u64 based on storage needs</span>
<span class="hl com"></span>
<span class="hl com">  PreferU64 will use u32 if (size == 4 &amp;&amp; system = 32bit), otherwise u64.</span>
<span class="hl com">*/</span>

<span class="hl kwc">template</span><span class="hl sym">&lt;</span> <span class="hl kwb">int</span> N <span class="hl sym">&gt;</span> <span class="hl kwb">struct</span> TypeSelector<span class="hl sym">;</span>
<span class="hl kwc">template</span><span class="hl sym">&lt;&gt;</span> <span class="hl kwb">struct</span> TypeSelector<span class="hl sym">&lt;</span><span class="hl num">4</span><span class="hl sym">&gt; {</span> <span class="hl kwb">enum</span> <span class="hl sym">{</span> bits <span class="hl sym">=</span> <span class="hl num">32</span><span class="hl sym">, };</span> <span class="hl kwc">typedef</span> u32 tint<span class="hl sym">; };</span>
<span class="hl kwc">template</span><span class="hl sym">&lt;&gt;</span> <span class="hl kwb">struct</span> TypeSelector<span class="hl sym">&lt;</span><span class="hl num">8</span><span class="hl sym">&gt; {</span> <span class="hl kwb">enum</span> <span class="hl sym">{</span> bits <span class="hl sym">=</span> <span class="hl num">64</span><span class="hl sym">, };</span> <span class="hl kwc">typedef</span> u64 tint<span class="hl sym">; };</span>

<span class="hl kwc">template</span><span class="hl sym">&lt;</span> <span class="hl kwb">int</span> N <span class="hl sym">&gt;</span> <span class="hl kwb">struct</span> PreferU64 <span class="hl sym">{</span>
  <span class="hl kwb">enum</span> <span class="hl sym">{</span> bits <span class="hl sym">=</span> TypeSelector<span class="hl sym">&lt;</span><span class="hl num">8</span><span class="hl sym">&gt;::</span>bits <span class="hl sym">};</span>
  <span class="hl kwc">typedef</span> typename TypeSelector<span class="hl sym">&lt;</span><span class="hl num">8</span><span class="hl sym">&gt;::</span>tint tint<span class="hl sym">;</span>
<span class="hl sym">};</span>

<span class="hl kwc">template</span><span class="hl sym">&lt;&gt;</span> <span class="hl kwb">struct</span> PreferU64<span class="hl sym">&lt;</span><span class="hl num">4</span><span class="hl sym">&gt; {</span>
  <span class="hl kwb">enum</span> <span class="hl sym">{</span> selector <span class="hl sym">=</span> <span class="hl kwa">sizeof</span><span class="hl sym">(</span>u32 <span class="hl sym">*) };</span>
  <span class="hl kwb">enum</span> <span class="hl sym">{</span> bits <span class="hl sym">=</span> TypeSelector<span class="hl sym">&lt;</span>selector<span class="hl sym">&gt;::</span>bits <span class="hl sym">};</span>
  <span class="hl kwc">typedef</span> TypeSelector<span class="hl sym">&lt;</span>selector<span class="hl sym">&gt;::</span>tint tint<span class="hl sym">;</span>
<span class="hl sym">};</span>

<span class="hl kwc">typedef</span> TypeSelector<span class="hl sym">&lt;</span><span class="hl kwa">sizeof</span><span class="hl sym">(</span><span class="hl kwb">int</span> <span class="hl sym">*)&gt;::</span>tint tint<span class="hl sym">;</span>

<span class="hl com">/*</span>
<span class="hl com">  DNASource handles enum defs we're interested in and extracting</span>
<span class="hl com">  DNA sequences from a packed DNA stream (2 bits per nucleotide)</span>
<span class="hl com"></span>
<span class="hl com">  Will use 64 bits for the state on 64bit machines, otherwise</span>
<span class="hl com">  32/64 bits depending on the size of the DNA sequence</span>
<span class="hl com"></span>
<span class="hl com">  left0 = # of nucleotides left in state</span>
<span class="hl com">  left1 = # of nucleotides left in the upcoming tstore, lower[1]</span>
<span class="hl com">*/</span>

<span class="hl kwc">template</span><span class="hl sym">&lt;</span> <span class="hl kwb">int</span> N <span class="hl sym">&gt;</span>
<span class="hl kwb">struct</span> DNASource <span class="hl sym">{</span>
  <span class="hl kwb">enum</span> <span class="hl sym">{</span>
    completedwords <span class="hl sym">=</span> N <span class="hl sym">/</span> <span class="hl num">4</span><span class="hl sym">,</span>
    partialbytes <span class="hl sym">=</span> N <span class="hl sym">&amp;</span> <span class="hl num">3</span><span class="hl sym">,</span>
    storagedwords <span class="hl sym">= (</span> N <span class="hl sym">+</span> <span class="hl num">15</span> <span class="hl sym">) /</span> <span class="hl num">16</span><span class="hl sym">,</span>
    storagebytes <span class="hl sym">=</span> storagedwords <span class="hl sym">*</span> <span class="hl num">4</span><span class="hl sym">,</span>

    bits <span class="hl sym">=</span> PreferU64<span class="hl sym">&lt;</span>storagebytes<span class="hl sym">&gt;::</span>bits<span class="hl sym">,</span>
    maxsequences <span class="hl sym">=</span> bits <span class="hl sym">/</span> <span class="hl num">2</span><span class="hl sym">,</span>
    sequencebits <span class="hl sym">=</span> N <span class="hl sym">*</span> <span class="hl num">2</span><span class="hl sym">,</span>
  <span class="hl sym">};</span>
  <span class="hl kwc">typedef</span> typename TypeSelector<span class="hl sym">&lt;</span>storagebytes<span class="hl sym">&gt;::</span>tint tint<span class="hl sym">;</span>
  <span class="hl kwc">typedef</span> typename PreferU64<span class="hl sym">&lt;</span>storagebytes<span class="hl sym">&gt;::</span>tint tstore<span class="hl sym">;</span>

  <span class="hl kwd">DNASource</span><span class="hl sym">(</span> <span class="hl kwb">const char</span> <span class="hl sym">*</span>data<span class="hl sym">,</span> u32 offset <span class="hl sym">) :</span> <span class="hl kwd">in</span><span class="hl sym">(</span>data<span class="hl sym">) {</span>
    <span class="hl kwb">const</span> u32 partial <span class="hl sym">=</span> offset <span class="hl sym">&amp; (</span> maxsequences <span class="hl sym">-</span> <span class="hl num">1</span> <span class="hl sym">);</span>
    lower <span class="hl sym">= (</span>tstore <span class="hl sym">*)</span>data <span class="hl sym">+ (</span> offset <span class="hl sym">/</span> maxsequences <span class="hl sym">);</span>
    <span class="hl kwb">const</span> u32 rshift <span class="hl sym">=</span> partial <span class="hl sym">*</span> <span class="hl num">2</span><span class="hl sym">,</span> lshift <span class="hl sym">=</span> bits <span class="hl sym">-</span> rshift<span class="hl sym">;</span>
    state <span class="hl sym">= (</span> partial <span class="hl sym">)</span> ? <span class="hl sym">(</span> lower<span class="hl sym">[</span><span class="hl num">0</span><span class="hl sym">] &gt;&gt;</span> rshift <span class="hl sym">) | (</span> lower<span class="hl sym">[</span><span class="hl num">1</span><span class="hl sym">] &lt;&lt;</span> lshift <span class="hl sym">) :</span> lower<span class="hl sym">[</span><span class="hl num">0</span><span class="hl sym">];</span>
    left0 <span class="hl sym">=</span> maxsequences<span class="hl sym">;</span>
    left1 <span class="hl sym">=</span> lshift <span class="hl sym">/</span> <span class="hl num">2</span><span class="hl sym">;</span>
  <span class="hl sym">}</span>

  <span class="hl kwc">inline</span> <span class="hl kwb">void</span> <span class="hl kwd">extractto</span><span class="hl sym">(</span> tint <span class="hl sym">&amp;</span>out <span class="hl sym">) {</span>
    <span class="hl slc">// reload if needed</span>
    <span class="hl kwa">if</span> <span class="hl sym">( (</span> N <span class="hl sym">&gt;</span> maxsequences <span class="hl sym">/</span> <span class="hl num">2</span> <span class="hl sym">) || (</span> left0 <span class="hl sym">&lt;</span> N <span class="hl sym">) ) {</span>
      s32 want <span class="hl sym">=</span> maxsequences <span class="hl sym">-</span> left0<span class="hl sym">;</span>
      state <span class="hl sym">|= (</span> lower<span class="hl sym">[</span><span class="hl num">1</span><span class="hl sym">] &gt;&gt; ( (</span> maxsequences <span class="hl sym">-</span> left1 <span class="hl sym">) *</span> <span class="hl num">2</span> <span class="hl sym">) ) &lt;&lt; (</span> left0 <span class="hl sym">*</span> <span class="hl num">2</span> <span class="hl sym">);</span>
      <span class="hl kwa">if</span> <span class="hl sym">(</span> left1 <span class="hl sym">&gt;</span> want <span class="hl sym">) {</span>
        left1 <span class="hl sym">-=</span> want<span class="hl sym">;</span>
      <span class="hl sym">}</span> <span class="hl kwa">else</span> <span class="hl sym">{</span>
        lower<span class="hl sym">++;</span>
        left1 <span class="hl sym">+=</span> left0<span class="hl sym">;</span>
      <span class="hl sym">}</span>
      <span class="hl kwa">if</span> <span class="hl sym">(</span> left1 <span class="hl sym">!=</span> maxsequences <span class="hl sym">)</span>
        state <span class="hl sym">|= (</span> lower<span class="hl sym">[</span><span class="hl num">1</span><span class="hl sym">] &lt;&lt; (</span> left1 <span class="hl sym">*</span> <span class="hl num">2</span> <span class="hl sym">) );</span>
      left0 <span class="hl sym">=</span> maxsequences<span class="hl sym">;</span>
    <span class="hl sym">}</span>

    <span class="hl slc">// load the nucleotides</span>
    <span class="hl kwa">if</span> <span class="hl sym">(</span> sequencebits <span class="hl sym">!=</span> bits <span class="hl sym">) {</span>
      tstore shift <span class="hl sym">=</span> sequencebits<span class="hl sym">,</span> mask <span class="hl sym">= (</span> <span class="hl kwd">tstore</span><span class="hl sym">(</span><span class="hl num">1</span><span class="hl sym">) &lt;&lt;</span> shift <span class="hl sym">) -</span> <span class="hl num">1</span><span class="hl sym">;</span>
      out <span class="hl sym">=</span> <span class="hl kwd">tint</span><span class="hl sym">(</span>state <span class="hl sym">&amp;</span> mask<span class="hl sym">);</span>
    <span class="hl sym">}</span> <span class="hl kwa">else</span> <span class="hl sym">{</span>
      out <span class="hl sym">=</span> <span class="hl kwd">tint</span><span class="hl sym">(</span>state<span class="hl sym">);</span>
    <span class="hl sym">}</span>
    state <span class="hl sym">&gt;&gt;= (</span> N <span class="hl sym">*</span> <span class="hl num">2</span> <span class="hl sym">);</span>
    left0 <span class="hl sym">-=</span> N<span class="hl sym">;</span>
  <span class="hl sym">}</span>

<span class="hl kwc">protected</span><span class="hl sym">:</span>
  <span class="hl kwb">const char</span> <span class="hl sym">*</span>in<span class="hl sym">;</span>
  s32 left0<span class="hl sym">,</span> left1<span class="hl sym">;</span>
  tstore state<span class="hl sym">, *</span>lower<span class="hl sym">;</span>
<span class="hl sym">};</span>

<span class="hl com">/*</span>
<span class="hl com">  A packed DNA key. Each nucleotide is packed down to 2 bits (we only have</span>
<span class="hl com">  4 to keep track of).</span>
<span class="hl com"></span>
<span class="hl com">  0000:0xx0 are the bits we want. A,C,G,T and a,c,g,t both map to the same</span>
<span class="hl com">  four values with this bitmask, but not in alphabetical order. Convert</span>
<span class="hl com">  the key to a string to sort!</span>
<span class="hl com">*/</span>

<span class="hl kwc">template</span><span class="hl sym">&lt;</span> <span class="hl kwb">int</span> N <span class="hl sym">&gt;</span>
<span class="hl kwb">struct</span> Key <span class="hl sym">{</span>
  <span class="hl kwc">typedef</span> typename DNASource<span class="hl sym">&lt;</span>N<span class="hl sym">&gt;::</span>tint tint<span class="hl sym">;</span>

  <span class="hl kwb">struct</span> Ops <span class="hl sym">{</span>
    <span class="hl kwb">enum</span> <span class="hl sym">{</span> bucket_size <span class="hl sym">=</span> <span class="hl num">4</span><span class="hl sym">,</span> min_buckets <span class="hl sym">=</span> <span class="hl num">8</span> <span class="hl sym">};</span>
    <span class="hl slc">// hash</span>
    u32 <span class="hl kwc">operator</span><span class="hl sym">() (</span> <span class="hl kwb">const</span> Key <span class="hl sym">&amp;</span>k <span class="hl sym">)</span> <span class="hl kwb">const</span> <span class="hl sym">{</span>
      <span class="hl kwa">if</span> <span class="hl sym">(</span> N <span class="hl sym">&lt;=</span> <span class="hl num">4</span> <span class="hl sym">) {</span>
        <span class="hl kwa">return</span> <span class="hl kwd">u32</span><span class="hl sym">(~</span>k<span class="hl sym">);</span>
      <span class="hl sym">}</span> <span class="hl kwa">else if</span> <span class="hl sym">(</span> N <span class="hl sym">&lt;=</span> <span class="hl num">16</span> <span class="hl sym">) {</span>
        u8 shift <span class="hl sym">=</span> N <span class="hl sym">/</span> <span class="hl num">2</span><span class="hl sym">;</span>
        <span class="hl kwa">return</span> <span class="hl kwd">u32</span><span class="hl sym">(~</span>k <span class="hl sym">+ ( ~</span>k <span class="hl sym">&gt;&gt;</span> shift <span class="hl sym">));</span>
      <span class="hl sym">}</span> <span class="hl kwa">else</span> <span class="hl sym">{</span>
        u8 shift <span class="hl sym">=</span> N <span class="hl sym">/</span> <span class="hl num">2</span><span class="hl sym">;</span>
        <span class="hl kwa">return</span> <span class="hl kwd">u32</span><span class="hl sym">(~</span>k <span class="hl sym">+ ( ~</span>k <span class="hl sym">&gt;&gt;</span> <span class="hl num">13</span> <span class="hl sym">) + ( ~</span>k <span class="hl sym">&gt;&gt;</span> shift <span class="hl sym">));</span>
      <span class="hl sym">}</span>
    <span class="hl sym">}</span>

    <span class="hl slc">// equals</span>
    <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl sym">() (</span> <span class="hl kwb">const</span> Key <span class="hl sym">&amp;</span>a<span class="hl sym">,</span> <span class="hl kwb">const</span> Key <span class="hl sym">&amp;</span>b <span class="hl sym">)</span> <span class="hl kwb">const</span> <span class="hl sym">{</span> <span class="hl kwa">return</span> <span class="hl sym">~</span>a <span class="hl sym">== ~</span>b<span class="hl sym">; }</span>
  <span class="hl sym">};</span>

  <span class="hl kwd">Key</span><span class="hl sym">() {}</span>

  <span class="hl slc">// packing this way isn't efficient, but called rarely</span>
  <span class="hl kwd">Key</span><span class="hl sym">(</span> <span class="hl kwb">const char</span> <span class="hl sym">*</span>in <span class="hl sym">) :</span> <span class="hl kwd">packed</span><span class="hl sym">(</span><span class="hl num">0</span><span class="hl sym">) {</span>
    u8 <span class="hl sym">*</span>bytes <span class="hl sym">= (</span>u8 <span class="hl sym">*)&amp;</span>packed<span class="hl sym">;</span>
    <span class="hl kwa">for</span> <span class="hl sym">(</span> <span class="hl kwb">int</span> i <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> i <span class="hl sym">&lt;</span> N<span class="hl sym">;</span> i<span class="hl sym">++ )</span>
      bytes<span class="hl sym">[</span>i<span class="hl sym">/</span><span class="hl num">4</span><span class="hl sym">] |= ( ( *</span>in<span class="hl sym">++ &gt;&gt;</span> <span class="hl num">1</span> <span class="hl sym">) &amp;</span> <span class="hl num">0x3</span> <span class="hl sym">) &lt;&lt; ( (</span> i <span class="hl sym">%</span> <span class="hl num">4</span> <span class="hl sym">) *</span> <span class="hl num">2</span> <span class="hl sym">);</span>
  <span class="hl sym">}</span>

  <span class="hl slc">// up to 2 instances active at once</span>
  <span class="hl kwb">const char</span> <span class="hl sym">*</span><span class="hl kwd">tostring</span><span class="hl sym">()</span> <span class="hl kwb">const</span> <span class="hl sym">{</span>
    <span class="hl kwb">static char</span> names<span class="hl sym">[</span><span class="hl num">2</span><span class="hl sym">][</span>N<span class="hl sym">+</span><span class="hl num">1</span><span class="hl sym">],</span> table<span class="hl sym">[</span><span class="hl num">4</span><span class="hl sym">] = {</span> <span class="hl str">'A'</span><span class="hl sym">,</span> <span class="hl str">'C'</span><span class="hl sym">,</span> <span class="hl str">'T'</span><span class="hl sym">,</span> <span class="hl str">'G'</span> <span class="hl sym">};</span>
    <span class="hl kwb">static</span> u32 on <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span>
    u64 bits <span class="hl sym">=</span> packed<span class="hl sym">;</span>
    on ^<span class="hl sym">=</span> <span class="hl num">1</span><span class="hl sym">;</span>
    <span class="hl kwa">for</span> <span class="hl sym">(</span> <span class="hl kwb">int</span> i <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> i <span class="hl sym">&lt;</span> N<span class="hl sym">;</span> i<span class="hl sym">++,</span> bits <span class="hl sym">&gt;&gt;=</span> <span class="hl num">2</span> <span class="hl sym">)</span>
      names<span class="hl sym">[</span>on<span class="hl sym">][</span>i<span class="hl sym">] =</span> table<span class="hl sym">[</span>bits <span class="hl sym">&amp;</span> <span class="hl num">3</span><span class="hl sym">];</span>
    names<span class="hl sym">[</span>on<span class="hl sym">][</span>N<span class="hl sym">] =</span> <span class="hl num">0</span><span class="hl sym">;</span>
    <span class="hl kwa">return</span> names<span class="hl sym">[</span>on<span class="hl sym">];</span>
  <span class="hl sym">}</span>

  <span class="hl slc">// for sorting</span>
  <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl sym">&lt; (</span> <span class="hl kwb">const</span> Key <span class="hl sym">&amp;</span>b <span class="hl sym">)</span> <span class="hl kwb">const</span> <span class="hl sym">{</span>
    <span class="hl kwa">return</span> <span class="hl kwd">strcmp</span><span class="hl sym">(</span> <span class="hl kwd">tostring</span><span class="hl sym">(),</span> b<span class="hl sym">.</span><span class="hl kwd">tostring</span><span class="hl sym">() ) &lt;</span> <span class="hl num">0</span><span class="hl sym">;</span>
  <span class="hl sym">}</span>

  <span class="hl slc">// direct access</span>
  tint <span class="hl sym">&amp;</span><span class="hl kwc">operator</span><span class="hl sym">~ () {</span> <span class="hl kwa">return</span> packed<span class="hl sym">; }</span>
  <span class="hl kwb">const</span> tint <span class="hl sym">&amp;</span><span class="hl kwc">operator</span><span class="hl sym">~ ()</span> <span class="hl kwb">const</span> <span class="hl sym">{</span> <span class="hl kwa">return</span> packed<span class="hl sym">; }</span>

<span class="hl kwc">protected</span><span class="hl sym">:</span>
  tint packed<span class="hl sym">;</span>
<span class="hl sym">};</span>

<span class="hl slc">// hash table wrapper</span>
<span class="hl kwc">template</span><span class="hl sym">&lt;</span> <span class="hl kwb">int</span> N <span class="hl sym">&gt;</span>
  <span class="hl kwc">class</span> KeyHash <span class="hl sym">:</span>
    <span class="hl kwc">public</span> __gnu_pbds<span class="hl sym">::</span>cc_hash_table <span class="hl sym">&lt;</span>
      Key<span class="hl sym">&lt;</span>N<span class="hl sym">&gt;,</span> <span class="hl slc">// key</span>
      u32<span class="hl sym">,</span> <span class="hl slc">// value</span>
      typename Key<span class="hl sym">&lt;</span>N<span class="hl sym">&gt;::</span>Ops<span class="hl sym">,</span> <span class="hl slc">// hash</span>
      typename Key<span class="hl sym">&lt;</span>N<span class="hl sym">&gt;::</span>Ops <span class="hl slc">// equality</span>
    <span class="hl sym">&gt; {};</span>

<span class="hl kwb">static const</span> u32 lengths<span class="hl sym">[] = {</span> <span class="hl num">18</span><span class="hl sym">,</span> <span class="hl num">12</span><span class="hl sym">,</span> <span class="hl num">6</span><span class="hl sym">,</span> <span class="hl num">4</span><span class="hl sym">,</span> <span class="hl num">3</span><span class="hl sym">,</span> <span class="hl num">2</span><span class="hl sym">,</span> <span class="hl num">1</span> <span class="hl sym">},</span> numLengths <span class="hl sym">=</span> <span class="hl num">7</span><span class="hl sym">;</span>
<span class="hl kwb">static const</span> u32 lineLength <span class="hl sym">=</span> <span class="hl num">60</span><span class="hl sym">;</span>

<span class="hl com">/*</span>
<span class="hl com">  A DNA block to analyze. Requires a single block of memory to</span>
<span class="hl com">  hold the block for efficiency. Block starts at 32mb and grows</span>
<span class="hl com">  exponentially</span>
<span class="hl com">*/</span>

<span class="hl kwb">struct</span> Block <span class="hl sym">{</span>
  <span class="hl kwd">Block</span><span class="hl sym">() :</span> <span class="hl kwd">data</span><span class="hl sym">(</span>NULL<span class="hl sym">),</span> <span class="hl kwd">count</span><span class="hl sym">(</span><span class="hl num">0</span><span class="hl sym">),</span> <span class="hl kwd">alloc</span><span class="hl sym">(</span><span class="hl num">32</span> <span class="hl sym">*</span> <span class="hl num">1048576</span><span class="hl sym">) {</span>
    data <span class="hl sym">= (</span><span class="hl kwb">char</span> <span class="hl sym">*)</span><span class="hl kwd">realloc</span><span class="hl sym">(</span> data<span class="hl sym">,</span> alloc <span class="hl sym">);</span>
  <span class="hl sym">}</span>

  <span class="hl sym">~</span><span class="hl kwd">Block</span><span class="hl sym">() {</span> <span class="hl kwd">free</span><span class="hl sym">(</span> data <span class="hl sym">); }</span>

  <span class="hl slc">// read the block in until the end of the sequence or a new sequence starts</span>
  <span class="hl kwb">void</span> <span class="hl kwd">read</span><span class="hl sym">() {</span>
    <span class="hl kwb">char</span> buffer<span class="hl sym">[</span>lineLength <span class="hl sym">+</span> <span class="hl num">2</span><span class="hl sym">];</span>
    buffer<span class="hl sym">[</span>lineLength<span class="hl sym">] = -</span><span class="hl num">1</span><span class="hl sym">;</span>
    <span class="hl kwa">while</span> <span class="hl sym">(</span> <span class="hl kwd">fgets_unlocked</span><span class="hl sym">(</span> buffer<span class="hl sym">,</span> lineLength <span class="hl sym">+</span> <span class="hl num">2</span><span class="hl sym">,</span> stdin <span class="hl sym">) ) {</span>
      <span class="hl kwa">if</span> <span class="hl sym">(</span> buffer<span class="hl sym">[</span><span class="hl num">0</span><span class="hl sym">] ==</span> <span class="hl str">'&gt;'</span> <span class="hl sym">)</span>
        <span class="hl kwa">return</span><span class="hl sym">;</span>
      <span class="hl slc">// -1 trick should keep us from calling strlen</span>
      <span class="hl kwa">if</span> <span class="hl sym">(</span> buffer<span class="hl sym">[</span>lineLength<span class="hl sym">] !=</span> <span class="hl num">0xa</span> <span class="hl sym">)</span>
        <span class="hl kwa">return</span> <span class="hl kwd">addline</span><span class="hl sym">(</span> buffer<span class="hl sym">,</span> <span class="hl kwb">int</span><span class="hl sym">(</span><span class="hl kwd">strlen</span><span class="hl sym">(</span> buffer <span class="hl sym">)) -</span> <span class="hl num">1</span> <span class="hl sym">);</span>
      <span class="hl kwd">addline</span><span class="hl sym">(</span> buffer<span class="hl sym">,</span> lineLength <span class="hl sym">);</span>
      buffer<span class="hl sym">[</span>lineLength<span class="hl sym">] = -</span><span class="hl num">1</span><span class="hl sym">;</span>
    <span class="hl sym">}</span>
  <span class="hl sym">}</span>

  <span class="hl slc">// read lines until we get a match</span>
  <span class="hl kwb">bool</span> <span class="hl kwd">untilheader</span><span class="hl sym">(</span> <span class="hl kwb">const char</span> <span class="hl sym">*</span>match <span class="hl sym">) {</span>
    <span class="hl kwb">size_t</span> len <span class="hl sym">=</span> <span class="hl kwd">strlen</span><span class="hl sym">(</span> match <span class="hl sym">);</span>
    <span class="hl kwb">const</span> u32 <span class="hl sym">*</span>in <span class="hl sym">= (</span><span class="hl kwb">const</span> u32 <span class="hl sym">*)</span>data<span class="hl sym">, *</span>want <span class="hl sym">= (</span><span class="hl kwb">const</span> u32 <span class="hl sym">*)</span>match<span class="hl sym">;</span>
    <span class="hl kwa">while</span> <span class="hl sym">(</span> <span class="hl kwd">fgets_unlocked</span><span class="hl sym">(</span> data<span class="hl sym">,</span> alloc<span class="hl sym">,</span> stdin <span class="hl sym">) )</span>
      <span class="hl kwa">if</span> <span class="hl sym">( ( *</span>in <span class="hl sym">== *</span>want <span class="hl sym">) &amp;&amp; (</span> <span class="hl kwd">memcmp</span><span class="hl sym">(</span> data<span class="hl sym">,</span> match<span class="hl sym">,</span> len <span class="hl sym">) ==</span> <span class="hl num">0</span> <span class="hl sym">) )</span>
        <span class="hl kwa">return true</span><span class="hl sym">;</span>
    <span class="hl kwa">return false</span><span class="hl sym">;</span>
  <span class="hl sym">}</span>

  <span class="hl kwb">int</span> <span class="hl kwd">getcount</span><span class="hl sym">()</span> <span class="hl kwb">const</span> <span class="hl sym">{</span> <span class="hl kwa">return</span> count<span class="hl sym">; }</span>
  <span class="hl kwb">char</span> <span class="hl sym">*</span><span class="hl kwd">getdata</span><span class="hl sym">() {</span> <span class="hl kwa">return</span> data<span class="hl sym">; }</span>

<span class="hl kwc">protected</span><span class="hl sym">:</span>
  <span class="hl slc">// convert a string of input to packed DNA</span>
  <span class="hl kwb">void</span> <span class="hl kwd">addline</span><span class="hl sym">(</span> <span class="hl kwb">const char</span> <span class="hl sym">*</span>buffer<span class="hl sym">,</span> <span class="hl kwb">int</span> bytes <span class="hl sym">) {</span>
    <span class="hl kwa">if</span> <span class="hl sym">( ( (</span> count <span class="hl sym">+</span> bytes <span class="hl sym">) /</span> <span class="hl num">4</span> <span class="hl sym">) &gt;</span> alloc <span class="hl sym">) {</span>
      alloc <span class="hl sym">*=</span> <span class="hl num">2</span><span class="hl sym">;</span>
      data <span class="hl sym">= (</span><span class="hl kwb">char</span> <span class="hl sym">*)</span><span class="hl kwd">realloc</span><span class="hl sym">(</span> data<span class="hl sym">,</span> alloc <span class="hl sym">);</span>
    <span class="hl sym">}</span>
    <span class="hl kwb">const</span> u32 <span class="hl sym">*</span>in <span class="hl sym">= (</span><span class="hl kwb">const</span> u32 <span class="hl sym">*)</span>buffer<span class="hl sym">;</span>
    u8 <span class="hl sym">*</span>out <span class="hl sym">= (</span>u8 <span class="hl sym">*)(</span> data <span class="hl sym">+</span> count <span class="hl sym">/</span> <span class="hl num">4</span> <span class="hl sym">);</span>
    <span class="hl slc">// 00000dd0:00000cc0-00000bb0:00000aa0 -&gt; ddccbbaa</span>
    <span class="hl kwa">for</span> <span class="hl sym">(</span> <span class="hl kwb">int</span> i <span class="hl sym">=</span> bytes <span class="hl sym">/</span> <span class="hl num">4</span><span class="hl sym">;</span> i<span class="hl sym">;</span> i<span class="hl sym">-- ) {</span>
      u32 conv <span class="hl sym">= ( *</span>in<span class="hl sym">++ &gt;&gt;</span> <span class="hl num">1</span> <span class="hl sym">) &amp;</span> <span class="hl num">0x03030303</span><span class="hl sym">;</span>
      <span class="hl sym">*</span>out<span class="hl sym">++ =</span> conv <span class="hl sym">| (</span> conv <span class="hl sym">&gt;&gt;</span> <span class="hl num">6</span> <span class="hl sym">) | (</span> conv <span class="hl sym">&gt;&gt;</span> <span class="hl num">12</span> <span class="hl sym">) | (</span> conv <span class="hl sym">&gt;&gt;</span> <span class="hl num">18</span> <span class="hl sym">);</span>
    <span class="hl sym">}</span>
    buffer <span class="hl sym">= (</span><span class="hl kwb">const char</span> <span class="hl sym">*)</span>in<span class="hl sym">;</span>
    <span class="hl kwa">for</span> <span class="hl sym">(</span> <span class="hl kwb">int</span> i <span class="hl sym">=</span> bytes <span class="hl sym">&amp;</span> <span class="hl num">3</span><span class="hl sym">,</span> shift <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> i<span class="hl sym">;</span> i<span class="hl sym">--,</span> shift <span class="hl sym">+=</span> <span class="hl num">2</span> <span class="hl sym">)</span>
      <span class="hl sym">*</span>out <span class="hl sym">|= ( (</span><span class="hl kwb">unsigned</span> <span class="hl sym">)( *</span>buffer<span class="hl sym">++ &amp;</span> <span class="hl num">6</span> <span class="hl sym">) &gt;&gt;</span> <span class="hl num">1</span> <span class="hl sym">) &lt;&lt; (</span>shift <span class="hl sym">&amp;</span> <span class="hl num">7</span><span class="hl sym">);</span>
    count <span class="hl sym">+=</span> bytes<span class="hl sym">;</span>
  <span class="hl sym">}</span>

  <span class="hl kwb">char</span> <span class="hl sym">*</span>data<span class="hl sym">;</span>
  <span class="hl kwb">int</span> count<span class="hl sym">,</span> alloc<span class="hl sym">;</span>
<span class="hl sym">};</span>

<span class="hl com">/*</span>
<span class="hl com">  Queue hands out work states to process</span>
<span class="hl com"></span>
<span class="hl com">  st holds two u16 values, the current offset in the sequence, and the</span>
<span class="hl com">  current length of the sequence</span>
<span class="hl com">*/</span>

<span class="hl kwb">struct</span> Queue <span class="hl sym">{</span>
  <span class="hl kwd">Queue</span><span class="hl sym">() :</span> <span class="hl kwd">st</span><span class="hl sym">(</span><span class="hl num">0</span><span class="hl sym">) {}</span>

  <span class="hl kwb">bool</span> <span class="hl kwd">get</span><span class="hl sym">(</span> u32 <span class="hl sym">&amp;</span>sequence<span class="hl sym">,</span> u32 <span class="hl sym">&amp;</span>offset <span class="hl sym">) {</span>
    <span class="hl kwa">while</span> <span class="hl sym">(</span> <span class="hl kwa">true</span> <span class="hl sym">) {</span>
      u32 cur <span class="hl sym">=</span> st<span class="hl sym">;</span>
      <span class="hl kwa">if</span> <span class="hl sym">( (</span> cur <span class="hl sym">&gt;&gt;</span> <span class="hl num">16</span> <span class="hl sym">) ==</span> numLengths <span class="hl sym">)</span>
        <span class="hl kwa">return false</span><span class="hl sym">;</span>

      <span class="hl slc">// try to claim the next set</span>
      <span class="hl kwa">if</span> <span class="hl sym">(</span> <span class="hl kwd">__sync_val_compare_and_swap</span><span class="hl sym">( &amp;</span>st<span class="hl sym">,</span> cur<span class="hl sym">,</span> <span class="hl kwd">nextstate</span><span class="hl sym">(</span> cur <span class="hl sym">) ) !=</span> cur <span class="hl sym">)</span>
        <span class="hl kwa">continue</span><span class="hl sym">;</span>

      <span class="hl slc">// it's ours</span>
      sequence <span class="hl sym">=</span> lengths<span class="hl sym">[</span>cur <span class="hl sym">&gt;&gt;</span> <span class="hl num">16</span><span class="hl sym">];</span>
      offset <span class="hl sym">=</span> cur <span class="hl sym">&amp;</span> <span class="hl num">0xffff</span><span class="hl sym">;</span>
      <span class="hl kwa">return true</span><span class="hl sym">;</span>
    <span class="hl sym">}</span>
  <span class="hl sym">}</span>

  u32 <span class="hl kwd">nextstate</span><span class="hl sym">(</span> u32 cur <span class="hl sym">) {</span>
    u16 offset <span class="hl sym">= (</span> cur <span class="hl sym">&amp;</span> <span class="hl num">0xffff</span> <span class="hl sym">),</span> length <span class="hl sym">= (</span> cur <span class="hl sym">&gt;&gt;</span> <span class="hl num">16</span> <span class="hl sym">);</span>
    <span class="hl kwa">if</span> <span class="hl sym">( ++</span>offset <span class="hl sym">==</span> lengths<span class="hl sym">[</span>length<span class="hl sym">] ) {</span>
      offset <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span>
      length<span class="hl sym">++;</span>
    <span class="hl sym">}</span>
    <span class="hl kwa">return</span> <span class="hl sym">(</span> length <span class="hl sym">&lt;&lt;</span> <span class="hl num">16</span> <span class="hl sym">) |</span> offset<span class="hl sym">;</span>
  <span class="hl sym">}</span>

<span class="hl kwc">protected</span><span class="hl sym">:</span>
  <span class="hl kwc">volatile</span> u32 st<span class="hl sym">;</span>
<span class="hl sym">};</span>


<span class="hl kwb">struct</span> Worker <span class="hl sym">{</span>
  <span class="hl kwd">Worker</span><span class="hl sym">() {}</span>

  <span class="hl kwc">template</span><span class="hl sym">&lt;</span> <span class="hl kwb">int</span> N<span class="hl sym">,</span> <span class="hl kwc">class</span> Hash <span class="hl sym">&gt;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">process</span><span class="hl sym">(</span> Hash <span class="hl sym">&amp;</span>hash <span class="hl sym">) {</span>
    Key<span class="hl sym">&lt;</span>N<span class="hl sym">&gt;</span> key<span class="hl sym">;</span>
    DNASource<span class="hl sym">&lt;</span>N<span class="hl sym">&gt;</span> <span class="hl kwd">source</span><span class="hl sym">(</span> block<span class="hl sym">-&gt;</span><span class="hl kwd">getdata</span><span class="hl sym">(),</span> offset <span class="hl sym">);</span>
    <span class="hl kwa">for</span> <span class="hl sym">(</span> <span class="hl kwb">int</span> i <span class="hl sym">=</span> block<span class="hl sym">-&gt;</span><span class="hl kwd">getcount</span><span class="hl sym">() -</span> offset<span class="hl sym">;</span> i <span class="hl sym">&gt;=</span> N<span class="hl sym">;</span> i <span class="hl sym">-=</span> N <span class="hl sym">) {</span>
      source<span class="hl sym">.</span><span class="hl kwd">extractto</span><span class="hl sym">( ~</span>key <span class="hl sym">);</span>
      hash<span class="hl sym">[</span>key<span class="hl sym">]++;</span>
    <span class="hl sym">}</span>
  <span class="hl sym">}</span>

  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl sym">() {</span>
    <span class="hl kwa">while</span> <span class="hl sym">(</span> workQueue<span class="hl sym">-&gt;</span><span class="hl kwd">get</span><span class="hl sym">(</span> length<span class="hl sym">,</span> offset <span class="hl sym">) ) {</span>
      <span class="hl kwa">switch</span> <span class="hl sym">(</span> length <span class="hl sym">) {</span>
        <span class="hl kwa">case</span> <span class="hl num">1</span><span class="hl sym">:</span> process<span class="hl sym">&lt;</span><span class="hl num">1</span><span class="hl sym">&gt;(</span> hash1 <span class="hl sym">);</span> <span class="hl kwa">break</span><span class="hl sym">;</span>
        <span class="hl kwa">case</span> <span class="hl num">2</span><span class="hl sym">:</span> process<span class="hl sym">&lt;</span><span class="hl num">2</span><span class="hl sym">&gt;(</span> hash2 <span class="hl sym">);</span> <span class="hl kwa">break</span><span class="hl sym">;</span>
        <span class="hl kwa">case</span> <span class="hl num">3</span><span class="hl sym">:</span> process<span class="hl sym">&lt;</span><span class="hl num">3</span><span class="hl sym">&gt;(</span> hash3 <span class="hl sym">);</span> <span class="hl kwa">break</span><span class="hl sym">;</span>
        <span class="hl kwa">case</span> <span class="hl num">4</span><span class="hl sym">:</span> process<span class="hl sym">&lt;</span><span class="hl num">4</span><span class="hl sym">&gt;(</span> hash4 <span class="hl sym">);</span> <span class="hl kwa">break</span><span class="hl sym">;</span>
        <span class="hl kwa">case</span> <span class="hl num">6</span><span class="hl sym">:</span> process<span class="hl sym">&lt;</span><span class="hl num">6</span><span class="hl sym">&gt;(</span> hash6 <span class="hl sym">);</span> <span class="hl kwa">break</span><span class="hl sym">;</span>
        <span class="hl kwa">case</span> <span class="hl num">12</span><span class="hl sym">:</span> process<span class="hl sym">&lt;</span><span class="hl num">12</span><span class="hl sym">&gt;(</span> hash12 <span class="hl sym">);</span> <span class="hl kwa">break</span><span class="hl sym">;</span>
        <span class="hl kwa">case</span> <span class="hl num">18</span><span class="hl sym">:</span> process<span class="hl sym">&lt;</span><span class="hl num">18</span><span class="hl sym">&gt;(</span> hash18 <span class="hl sym">);</span> <span class="hl kwa">break</span><span class="hl sym">;</span>
        <span class="hl kwa">default</span><span class="hl sym">:</span> <span class="hl kwa">break</span><span class="hl sym">;</span>
      <span class="hl sym">}</span>
    <span class="hl sym">}</span>
  <span class="hl sym">}</span>

  <span class="hl kwb">void</span> <span class="hl kwd">join</span><span class="hl sym">() {</span> <span class="hl kwd">pthread_join</span><span class="hl sym">(</span> handle<span class="hl sym">,</span> <span class="hl num">0</span> <span class="hl sym">); }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">start</span><span class="hl sym">(</span> Queue <span class="hl sym">*</span>queue<span class="hl sym">,</span> Block <span class="hl sym">*</span>in <span class="hl sym">) {</span>
    workQueue <span class="hl sym">=</span> queue<span class="hl sym">;</span>
    block <span class="hl sym">=</span> in<span class="hl sym">;</span>
    <span class="hl kwd">pthread_create</span><span class="hl sym">( &amp;</span>handle<span class="hl sym">,</span> <span class="hl num">0</span><span class="hl sym">,</span> Worker<span class="hl sym">::</span>thread<span class="hl sym">,</span> <span class="hl kwa">this</span> <span class="hl sym">);</span>
  <span class="hl sym">}</span>
  <span class="hl kwb">static void</span> <span class="hl sym">*</span><span class="hl kwd">thread</span><span class="hl sym">(</span> <span class="hl kwb">void</span> <span class="hl sym">*</span>arg <span class="hl sym">) { ((</span>Worker <span class="hl sym">*)</span>arg<span class="hl sym">)-&gt;</span><span class="hl kwd">run</span><span class="hl sym">();</span> <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl sym">; }</span>

  pthread_t handle<span class="hl sym">;</span>
  Block <span class="hl sym">*</span>block<span class="hl sym">;</span>
  Queue <span class="hl sym">*</span>workQueue<span class="hl sym">;</span>
  u32 length<span class="hl sym">,</span> offset<span class="hl sym">;</span>

  KeyHash<span class="hl sym">&lt;</span><span class="hl num">18</span><span class="hl sym">&gt;</span> hash18<span class="hl sym">;</span>
  KeyHash<span class="hl sym">&lt;</span><span class="hl num">12</span><span class="hl sym">&gt;</span> hash12<span class="hl sym">;</span>
  KeyHash<span class="hl sym">&lt;</span><span class="hl num">6</span><span class="hl sym">&gt;</span> hash6<span class="hl sym">;</span>
  KeyHash<span class="hl sym">&lt;</span><span class="hl num">4</span><span class="hl sym">&gt;</span> hash4<span class="hl sym">;</span>
  KeyHash<span class="hl sym">&lt;</span><span class="hl num">3</span><span class="hl sym">&gt;</span> hash3<span class="hl sym">;</span>
  KeyHash<span class="hl sym">&lt;</span><span class="hl num">2</span><span class="hl sym">&gt;</span> hash2<span class="hl sym">;</span>
  KeyHash<span class="hl sym">&lt;</span><span class="hl num">1</span><span class="hl sym">&gt;</span> hash1<span class="hl sym">;</span>
<span class="hl sym">};</span>

<span class="hl kwc">template</span><span class="hl sym">&lt;</span> <span class="hl kwb">int</span> N<span class="hl sym">,</span> <span class="hl kwc">class</span> W <span class="hl sym">&gt;</span> KeyHash<span class="hl sym">&lt;</span>N<span class="hl sym">&gt; &amp;</span><span class="hl kwd">Get</span><span class="hl sym">(</span> W <span class="hl sym">&amp;</span>w <span class="hl sym">);</span>

<span class="hl kwc">template</span><span class="hl sym">&lt;&gt;</span> KeyHash<span class="hl sym">&lt;</span><span class="hl num">1</span><span class="hl sym">&gt; &amp;</span><span class="hl kwd">Get</span><span class="hl sym">(</span> Worker <span class="hl sym">&amp;</span>w <span class="hl sym">) {</span> <span class="hl kwa">return</span> w<span class="hl sym">.</span>hash1<span class="hl sym">; }</span>
<span class="hl kwc">template</span><span class="hl sym">&lt;&gt;</span> KeyHash<span class="hl sym">&lt;</span><span class="hl num">2</span><span class="hl sym">&gt; &amp;</span><span class="hl kwd">Get</span><span class="hl sym">(</span> Worker <span class="hl sym">&amp;</span>w <span class="hl sym">) {</span> <span class="hl kwa">return</span> w<span class="hl sym">.</span>hash2<span class="hl sym">; }</span>
<span class="hl kwc">template</span><span class="hl sym">&lt;&gt;</span> KeyHash<span class="hl sym">&lt;</span><span class="hl num">3</span><span class="hl sym">&gt; &amp;</span><span class="hl kwd">Get</span><span class="hl sym">(</span> Worker <span class="hl sym">&amp;</span>w <span class="hl sym">) {</span> <span class="hl kwa">return</span> w<span class="hl sym">.</span>hash3<span class="hl sym">; }</span>
<span class="hl kwc">template</span><span class="hl sym">&lt;&gt;</span> KeyHash<span class="hl sym">&lt;</span><span class="hl num">4</span><span class="hl sym">&gt; &amp;</span><span class="hl kwd">Get</span><span class="hl sym">(</span> Worker <span class="hl sym">&amp;</span>w <span class="hl sym">) {</span> <span class="hl kwa">return</span> w<span class="hl sym">.</span>hash4<span class="hl sym">; }</span>
<span class="hl kwc">template</span><span class="hl sym">&lt;&gt;</span> KeyHash<span class="hl sym">&lt;</span><span class="hl num">6</span><span class="hl sym">&gt; &amp;</span><span class="hl kwd">Get</span><span class="hl sym">(</span> Worker <span class="hl sym">&amp;</span>w <span class="hl sym">) {</span> <span class="hl kwa">return</span> w<span class="hl sym">.</span>hash6<span class="hl sym">; }</span>
<span class="hl kwc">template</span><span class="hl sym">&lt;&gt;</span> KeyHash<span class="hl sym">&lt;</span><span class="hl num">12</span><span class="hl sym">&gt; &amp;</span><span class="hl kwd">Get</span><span class="hl sym">(</span> Worker <span class="hl sym">&amp;</span>w <span class="hl sym">) {</span> <span class="hl kwa">return</span> w<span class="hl sym">.</span>hash12<span class="hl sym">; }</span>
<span class="hl kwc">template</span><span class="hl sym">&lt;&gt;</span> KeyHash<span class="hl sym">&lt;</span><span class="hl num">18</span><span class="hl sym">&gt; &amp;</span><span class="hl kwd">Get</span><span class="hl sym">(</span> Worker <span class="hl sym">&amp;</span>w <span class="hl sym">) {</span> <span class="hl kwa">return</span> w<span class="hl sym">.</span>hash18<span class="hl sym">; }</span>

<span class="hl kwc">template</span><span class="hl sym">&lt;</span> <span class="hl kwb">int</span> N <span class="hl sym">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">printcount</span><span class="hl sym">(</span> Worker <span class="hl sym">*</span>workers<span class="hl sym">,</span> <span class="hl kwb">const char</span> <span class="hl sym">*</span>key <span class="hl sym">) {</span>
  Key<span class="hl sym">&lt;</span>N<span class="hl sym">&gt;</span> <span class="hl kwd">find</span><span class="hl sym">(</span> key <span class="hl sym">);</span>
  u32 count <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span>
  <span class="hl kwa">for</span> <span class="hl sym">(</span> u32 i <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> i <span class="hl sym">&lt;</span> cpus<span class="hl sym">.</span>count<span class="hl sym">;</span> i<span class="hl sym">++ )</span>
    count <span class="hl sym">+=</span> Get<span class="hl sym">&lt;</span>N<span class="hl sym">&gt;(</span> workers<span class="hl sym">[</span>i<span class="hl sym">] )[</span>find<span class="hl sym">];</span>
  cout <span class="hl sym">&lt;&lt;</span> count <span class="hl sym">&lt;&lt;</span> <span class="hl str">'</span><span class="hl esc">\t</span><span class="hl str">'</span> <span class="hl sym">&lt;&lt;</span> find<span class="hl sym">.</span><span class="hl kwd">tostring</span><span class="hl sym">() &lt;&lt;</span> endl<span class="hl sym">;</span>
<span class="hl sym">}</span>

<span class="hl kwc">template</span><span class="hl sym">&lt;</span><span class="hl kwc">class</span> T<span class="hl sym">&gt;</span>
<span class="hl kwb">struct</span> CompareFirst <span class="hl sym">{</span>
  <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl sym">() (</span> <span class="hl kwb">const</span> T <span class="hl sym">&amp;</span>a<span class="hl sym">,</span> <span class="hl kwb">const</span> T <span class="hl sym">&amp;</span>b <span class="hl sym">) {</span> <span class="hl kwa">return</span> a<span class="hl sym">.</span>first <span class="hl sym">&lt;</span> b<span class="hl sym">.</span>first<span class="hl sym">; }</span>
<span class="hl sym">};</span>

<span class="hl kwc">template</span><span class="hl sym">&lt;</span><span class="hl kwc">class</span> T<span class="hl sym">&gt;</span>
<span class="hl kwb">struct</span> CompareSecond <span class="hl sym">{</span>
  <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl sym">() (</span> <span class="hl kwb">const</span> T <span class="hl sym">&amp;</span>a<span class="hl sym">,</span> <span class="hl kwb">const</span> T <span class="hl sym">&amp;</span>b <span class="hl sym">) {</span> <span class="hl kwa">return</span> a<span class="hl sym">.</span>second <span class="hl sym">&gt;</span> b<span class="hl sym">.</span>second<span class="hl sym">; }</span>
<span class="hl sym">};</span>


<span class="hl kwc">template</span><span class="hl sym">&lt;</span> <span class="hl kwb">int</span> N <span class="hl sym">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">printfreq</span><span class="hl sym">(</span> Worker <span class="hl sym">*</span>workers <span class="hl sym">) {</span>
  cout<span class="hl sym">.</span><span class="hl kwd">setf</span><span class="hl sym">(</span> ios<span class="hl sym">::</span>fixed<span class="hl sym">,</span> ios<span class="hl sym">::</span>floatfield <span class="hl sym">);</span>
  cout<span class="hl sym">.</span><span class="hl kwd">precision</span><span class="hl sym">(</span> <span class="hl num">3</span> <span class="hl sym">);</span>

  u32 count <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span>
  KeyHash<span class="hl sym">&lt;</span>N<span class="hl sym">&gt;</span> sum<span class="hl sym">;</span>
  <span class="hl kwa">for</span> <span class="hl sym">(</span> u32 i <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> i <span class="hl sym">&lt;</span> cpus<span class="hl sym">.</span>count<span class="hl sym">;</span> i<span class="hl sym">++ ) {</span>
    KeyHash<span class="hl sym">&lt;</span>N<span class="hl sym">&gt; &amp;</span>hash <span class="hl sym">=</span> Get<span class="hl sym">&lt;</span>N<span class="hl sym">&gt;(</span> workers<span class="hl sym">[</span>i<span class="hl sym">] );</span>
    typename KeyHash<span class="hl sym">&lt;</span>N<span class="hl sym">&gt;::</span>iterator iter <span class="hl sym">=</span> hash<span class="hl sym">.</span><span class="hl kwd">begin</span><span class="hl sym">(),</span> end <span class="hl sym">=</span> hash<span class="hl sym">.</span><span class="hl kwd">end</span><span class="hl sym">();</span>
    <span class="hl kwa">for</span> <span class="hl sym">( ;</span> iter <span class="hl sym">!=</span> end<span class="hl sym">; ++</span>iter <span class="hl sym">) {</span>
      count <span class="hl sym">+=</span> iter<span class="hl sym">-&gt;</span>second<span class="hl sym">;</span>
      sum<span class="hl sym">[</span>iter<span class="hl sym">-&gt;</span>first<span class="hl sym">] +=</span> iter<span class="hl sym">-&gt;</span>second<span class="hl sym">;</span>
    <span class="hl sym">}</span>
  <span class="hl sym">}</span>

  <span class="hl kwc">typedef</span> pair<span class="hl sym">&lt;</span> Key<span class="hl sym">&lt;</span>N<span class="hl sym">&gt;,</span> u32 <span class="hl sym">&gt;</span> sequence<span class="hl sym">;</span>
  vector<span class="hl sym">&lt;</span>sequence<span class="hl sym">&gt;</span> <span class="hl kwd">seqs</span><span class="hl sym">(</span> sum<span class="hl sym">.</span><span class="hl kwd">begin</span><span class="hl sym">(),</span> sum<span class="hl sym">.</span><span class="hl kwd">end</span><span class="hl sym">() );</span>
  <span class="hl kwd">stable_sort</span><span class="hl sym">(</span> seqs<span class="hl sym">.</span><span class="hl kwd">begin</span><span class="hl sym">(),</span> seqs<span class="hl sym">.</span><span class="hl kwd">end</span><span class="hl sym">(),</span> CompareFirst<span class="hl sym">&lt;</span>sequence<span class="hl sym">&gt;() );</span> <span class="hl slc">// by name</span>
  <span class="hl kwd">stable_sort</span><span class="hl sym">(</span> seqs<span class="hl sym">.</span><span class="hl kwd">begin</span><span class="hl sym">(),</span> seqs<span class="hl sym">.</span><span class="hl kwd">end</span><span class="hl sym">(),</span> CompareSecond<span class="hl sym">&lt;</span>sequence<span class="hl sym">&gt;() );</span> <span class="hl slc">// by count</span>

  typename vector<span class="hl sym">&lt;</span>sequence<span class="hl sym">&gt;::</span>iterator iter <span class="hl sym">=</span> seqs<span class="hl sym">.</span><span class="hl kwd">begin</span><span class="hl sym">(),</span> end <span class="hl sym">=</span> seqs<span class="hl sym">.</span><span class="hl kwd">end</span><span class="hl sym">();</span>
  <span class="hl kwa">for</span> <span class="hl sym">( ;</span> iter <span class="hl sym">!=</span> end<span class="hl sym">; ++</span>iter <span class="hl sym">)</span>
    cout <span class="hl sym">&lt;&lt;</span>  iter<span class="hl sym">-&gt;</span>first<span class="hl sym">.</span><span class="hl kwd">tostring</span><span class="hl sym">() &lt;&lt;</span> <span class="hl str">&quot; &quot;</span> <span class="hl sym">&lt;&lt; (</span><span class="hl num">100.0</span>f <span class="hl sym">*</span> iter<span class="hl sym">-&gt;</span>second <span class="hl sym">/</span> count<span class="hl sym">) &lt;&lt;</span> endl<span class="hl sym">;</span>
  cout <span class="hl sym">&lt;&lt;</span> endl<span class="hl sym">;</span>
<span class="hl sym">}</span>


<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl sym">(</span> <span class="hl kwb">int</span> argc<span class="hl sym">,</span> <span class="hl kwb">const char</span> <span class="hl sym">*</span>argv<span class="hl sym">[] ) {</span>
  Block <span class="hl sym">*</span>block <span class="hl sym">=</span> <span class="hl kwa">new</span> <span class="hl kwd">Block</span><span class="hl sym">();</span>
  <span class="hl kwa">if</span> <span class="hl sym">( !</span>block<span class="hl sym">-&gt;</span><span class="hl kwd">untilheader</span><span class="hl sym">(</span> <span class="hl str">&quot;&gt;THREE&quot;</span> <span class="hl sym">) )</span>
    <span class="hl kwa">return</span> <span class="hl sym">-</span><span class="hl num">1</span><span class="hl sym">;</span>
  block<span class="hl sym">-&gt;</span><span class="hl kwd">read</span><span class="hl sym">();</span>

  Queue workQueue<span class="hl sym">;</span>
  Worker <span class="hl sym">*</span>workers <span class="hl sym">=</span> <span class="hl kwa">new</span> Worker<span class="hl sym">[</span>cpus<span class="hl sym">.</span>count<span class="hl sym">];</span>
  <span class="hl kwa">for</span> <span class="hl sym">(</span> u32 i <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> i <span class="hl sym">&lt;</span> cpus<span class="hl sym">.</span>count<span class="hl sym">;</span> i<span class="hl sym">++ )</span>
    workers<span class="hl sym">[</span>i<span class="hl sym">].</span><span class="hl kwd">start</span><span class="hl sym">( &amp;</span>workQueue<span class="hl sym">,</span> block <span class="hl sym">);</span>
  <span class="hl kwa">for</span> <span class="hl sym">(</span> u32 i <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> i <span class="hl sym">&lt;</span> cpus<span class="hl sym">.</span>count<span class="hl sym">;</span> i<span class="hl sym">++ )</span>
    workers<span class="hl sym">[</span>i<span class="hl sym">].</span><span class="hl kwd">join</span><span class="hl sym">();</span>

  printfreq<span class="hl sym">&lt;</span><span class="hl num">1</span><span class="hl sym">&gt;(</span> workers <span class="hl sym">);</span>
  printfreq<span class="hl sym">&lt;</span><span class="hl num">2</span><span class="hl sym">&gt;(</span> workers <span class="hl sym">);</span>

  printcount<span class="hl sym">&lt;</span><span class="hl num">3</span><span class="hl sym">&gt;(</span> workers<span class="hl sym">,</span> <span class="hl str">&quot;ggt&quot;</span> <span class="hl sym">);</span>
  printcount<span class="hl sym">&lt;</span><span class="hl num">4</span><span class="hl sym">&gt;(</span> workers<span class="hl sym">,</span> <span class="hl str">&quot;ggta&quot;</span> <span class="hl sym">);</span>
  printcount<span class="hl sym">&lt;</span><span class="hl num">6</span><span class="hl sym">&gt;(</span> workers<span class="hl sym">,</span> <span class="hl str">&quot;ggtatt&quot;</span> <span class="hl sym">);</span>
  printcount<span class="hl sym">&lt;</span><span class="hl num">12</span><span class="hl sym">&gt;(</span> workers<span class="hl sym">,</span> <span class="hl str">&quot;ggtattttaatt&quot;</span> <span class="hl sym">);</span>
  printcount<span class="hl sym">&lt;</span><span class="hl num">18</span><span class="hl sym">&gt;(</span> workers<span class="hl sym">,</span> <span class="hl str">&quot;ggtattttaatttatagt&quot;</span> <span class="hl sym">);</span>

  <span class="hl kwa">delete</span><span class="hl sym">[]</span> workers<span class="hl sym">;</span>
  <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl sym">;</span>
<span class="hl sym">}</span>
