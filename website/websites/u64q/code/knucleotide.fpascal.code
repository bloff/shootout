<source>
<def></def><com>(* The Computer Language Shootout</com><br />
<com>   http://shootout.alioth.debian.org/</com><br />
<com></com><br />
<com>   contributed by Josh Goldfoot</com><br />
<com>   modified by Vincent Snijders</com><br />
<com>*)</com><def></def><br />
<br />
<kwa>program</kwa> <def>knucleotide</def><sym>;</sym><br />
<def></def><br />
<com>{$mode objfpc}</com><def></def><com>{$I-}</com><def></def><com>{$INLINE ON}</com><def></def><br />
<br />
<com>(* simple_hash available from CVS *)</com><def></def><br />
<br />
<kwa>const</kwa><br />
<def>  ht_num_primes</def> <sym>=</sym> <def></def><num>28</num><def></def><sym>;</sym><br />
<def><br />
  ht_prime_list</def><sym>:</sym> <def></def><kwa>array</kwa><def></def><sym>[</sym><def></def><num>0</num> <def></def><sym>..</sym> <def>ht_num_primes</def><sym>-</sym><def></def><num>1</num><def></def><sym>]</sym> <def></def><kwa>of</kwa> <def>dword</def> <sym>=</sym><br />
<def></def>  <sym>(</sym> <def></def><num>53</num><def></def><sym>,</sym>         <def></def><num>97</num><def></def><sym>,</sym>         <def></def><num>193</num><def></def><sym>,</sym>       <def></def><num>389</num><def></def><sym>,</sym>       <def></def><num>769</num><def></def><sym>,</sym><br />
<def></def>    <num>1543</num><def></def><sym>,</sym>       <def></def><num>3079</num><def></def><sym>,</sym>       <def></def><num>6151</num><def></def><sym>,</sym>      <def></def><num>12289</num><def></def><sym>,</sym>     <def></def><num>24593</num><def></def><sym>,</sym><br />
<def></def>    <num>49157</num><def></def><sym>,</sym>      <def></def><num>98317</num><def></def><sym>,</sym>      <def></def><num>196613</num><def></def><sym>,</sym>    <def></def><num>393241</num><def></def><sym>,</sym>    <def></def><num>786433</num><def></def><sym>,</sym><br />
<def></def>    <num>1572869</num><def></def><sym>,</sym>    <def></def><num>3145739</num><def></def><sym>,</sym>    <def></def><num>6291469</num><def></def><sym>,</sym>   <def></def><num>12582917</num><def></def><sym>,</sym>  <def></def><num>25165843</num><def></def><sym>,</sym><br />
<def></def>    <num>50331653</num><def></def><sym>,</sym>   <def></def><num>100663319</num><def></def><sym>,</sym>  <def></def><num>201326611</num><def></def><sym>,</sym> <def></def><num>402653189</num><def></def><sym>,</sym> <def></def><num>805306457</num><def></def><sym>,</sym><br />
<def></def>    <num>1610612741</num><def></def><sym>,</sym> <def></def><num>3221225473</num><def></def><sym>,</sym> <def></def><num>4294967291</num> <def></def><sym>);</sym><br />
<def></def><br />
<kwa>type</kwa><br />
<def></def>  <com>{ TNonFreePooledMemManager - a memory manager for records without freeing }</com><def><br />
<br />
  PMemChunk</def> <sym>= ^</sym><def>TMemChunk</def><sym>;</sym><br />
<def>  TMemChunk</def> <sym>=</sym> <def></def><kwa>record</kwa><br />
<def>    data</def><sym>:</sym> <def></def><kwb>pointer</kwb><def></def><sym>;</sym><br />
<def>    next</def><sym>:</sym> <def>PMemChunk</def><sym>;</sym><br />
<def></def>  <kwa>end</kwa><def></def><sym>;</sym><br />
<def><br />
  TNonFreePooledMemManager</def> <sym>=</sym> <def></def><kwa>class</kwa><br />
<def></def>  <kwa>private</kwa><br />
<def>    FItemSize</def><sym>:</sym> <def></def><kwb>integer</kwb><def></def><sym>;</sym><br />
<def>    FItems</def><sym>:</sym> <def>PMemChunk</def><sym>;</sym><br />
<def>    FCurItem</def><sym>:</sym> <def></def><kwb>Pointer</kwb><def></def><sym>;</sym><br />
<def>    FEndItem</def><sym>:</sym> <def></def><kwb>Pointer</kwb><def></def><sym>;</sym><br />
<def>    FCurSize</def><sym>:</sym> <def></def><kwb>integer</kwb><def></def><sym>;</sym><br />
<def></def>    <kwa>procedure</kwa> <def>Grow</def><sym>;</sym><br />
<def></def>  <kwa>public</kwa><br />
<def></def>    <kwa>property</kwa> <def>ItemSize</def><sym>:</sym> <def></def><kwb>integer</kwb> <def>read FItemSize</def><sym>;</sym><br />
<def></def>    <kwa>constructor</kwa> <def></def><kwd>Create</kwd><def></def><sym>(</sym><def>TheItemSize</def><sym>:</sym> <def></def><kwb>integer</kwb><def></def><sym>);</sym><br />
<def></def>    <kwa>destructor</kwa> <def>Destroy</def><sym>;</sym> <def></def><kwa>override</kwa><def></def><sym>;</sym><br />
<def></def>    <kwa>function</kwa> <def>NewItem</def><sym>:</sym> <def></def><kwb>Pointer</kwb><def></def><sym>;</sym> <def></def><kwa>inline</kwa><def></def><sym>;</sym><br />
<def></def>  <kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><br />
  <com>{ THashTable }</com><def><br />
<br />
  ht_ppnode</def> <sym>= ^</sym><def>ht_pnode</def><sym>;</sym><br />
<def>  ht_pnode</def> <sym>= ^</sym><def>ht_node</def><sym>;</sym><br />
<def>  ht_node</def> <sym>=</sym> <def></def><kwa>record</kwa><br />
<def>    val</def><sym>:</sym> <def></def><kwb>integer</kwb><def></def><sym>;</sym><br />
<def>    next</def><sym>:</sym> <def>ht_pnode</def><sym>;</sym><br />
<def>    keydata</def><sym>:</sym> <def></def><kwa>array</kwa><def></def><sym>[</sym><def></def><num>0</num><def></def><sym>.</sym><def></def><num>.0</num><def></def><sym>]</sym> <def></def><kwa>of</kwa> <def></def><kwb>char</kwb><def></def><sym>;</sym><br />
<def></def>  <kwa>end</kwa><def></def><sym>;</sym><br />
<def><br />
  THashTable</def><sym>=</sym><def></def><kwa>class</kwa><br />
<def></def>  <kwa>private</kwa><br />
<def>    FSize</def><sym>:</sym> <def>dword</def><sym>;</sym><br />
<def>    FKeysize</def><sym>:</sym> <def>dword</def><sym>;</sym><br />
<def>    FTbl</def><sym>:</sym> <def>ht_ppnode</def><sym>;</sym><br />
<def>    FIter_index</def><sym>:</sym> <def>dword</def><sym>;</sym><br />
<def>    FIter_next</def><sym>:</sym> <def>ht_pnode</def><sym>;</sym><br />
<def>    FNodeMemManager</def><sym>:</sym> <def>TNonFreePooledMemManager</def><sym>;</sym><br />
<def></def>  <kwa>public</kwa><br />
<def></def>    <kwa>constructor</kwa> <def></def><kwd>Create</kwd><def></def><sym>(</sym><def>size</def><sym>:</sym> <def>dword</def><sym>;</sym> <def>keysize</def><sym>:</sym> <def>dword</def><sym>);</sym><br />
<def></def>    <kwa>destructor</kwa> <def>Destroy</def><sym>;</sym> <def></def><kwa>override</kwa><def></def><sym>;</sym><br />
<def></def>    <kwa>function</kwa> <def></def><kwd>Find</kwd><def></def><sym>(</sym><def>key</def><sym>:</sym> <def>pchar</def><sym>):</sym> <def>ht_pnode</def><sym>;</sym><br />
<def></def>    <kwa>function</kwa> <def></def><kwd>FindNew</kwd><def></def><sym>(</sym><def>key</def><sym>:</sym> <def>pchar</def><sym>):</sym> <def>ht_pnode</def><sym>;</sym><br />
<def></def>    <kwa>function</kwa> <def>First</def><sym>:</sym> <def>ht_pnode</def><sym>;</sym><br />
<def></def>    <kwa>function</kwa> <def>Next</def><sym>:</sym> <def>ht_pnode</def><sym>;</sym><br />
<def></def>  <kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><br />
<com>{ TNonFreePooledMemManager }</com><def></def><br />
<br />
<kwa>procedure</kwa> <def>TNonFreePooledMemManager</def><sym>.</sym><def>Grow</def><sym>;</sym><br />
<def></def><kwa>var</kwa><br />
<def>  memchunk</def><sym>:</sym> <def>PMemChunk</def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def></def>  <kwa>if</kwa> <def>FCurSize</def><sym>&lt;</sym><def></def><num>256</num><def></def><sym>*</sym><def></def><num>1024</num> <def></def><kwa>then</kwa><br />
<def></def>  <slc>// each item has double the size of its predecessor</slc><br />
<def></def>    <kwd>inc</kwd><def></def><sym>(</sym><def>FCurSize</def><sym>,</sym> <def>FCurSize</def><sym>);</sym><br />
<def></def>  <kwd>GetMem</kwd><def></def><sym>(</sym><def>FCurItem</def><sym>,</sym><def>FCurSize</def><sym>);</sym><br />
<def></def>  <kwd>FillChar</kwd><def></def><sym>(</sym><def>FCurItem</def><sym>^,</sym> <def>FCurSize</def><sym>,</sym> <def></def><num>0</num><def></def><sym>);</sym><br />
<def></def>  <kwd>new</kwd><def></def><sym>(</sym><def>MemChunk</def><sym>);</sym><br />
<def>  MemChunk</def><sym>^.</sym><def>next</def> <sym>:=</sym> <def>FItems</def><sym>;</sym><br />
<def>  MemChunk</def><sym>^.</sym><def>Data</def> <sym>:=</sym> <def>FCurItem</def><sym>;</sym><br />
<def>  FItems</def> <sym>:=</sym> <def>MemChunk</def><sym>;</sym><br />
<def>  FEndItem</def> <sym>:=</sym> <def>FCurItem</def><sym>;</sym><br />
<def></def>  <kwd>Inc</kwd><def></def><sym>(</sym><def>FEndItem</def><sym>,</sym> <def>FCurSize</def><sym>);</sym><br />
<def></def><kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><br />
<kwa>constructor</kwa> <def>TNonFreePooledMemManager</def><sym>.</sym><def></def><kwd>Create</kwd><def></def><sym>(</sym><def>TheItemSize</def><sym>:</sym> <def></def><kwb>integer</kwb><def></def><sym>);</sym><br />
<def></def><kwa>begin</kwa><br />
<def>  FItemSize</def><sym>:=</sym><def>TheItemSize</def><sym>;</sym><br />
<def>  FCurSize</def><sym>:=</sym><def>FItemSize</def><sym>*</sym><def></def><num>4</num><def></def><sym>;</sym> <def></def><slc>// 4 items =&gt; the first item has 8 entries</slc><br />
<def></def><kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><br />
<kwa>destructor</kwa> <def>TNonFreePooledMemManager</def><sym>.</sym><def>Destroy</def><sym>;</sym><br />
<def></def><kwa>var</kwa><br />
<def>  p</def><sym>:</sym> <def>PMemChunk</def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def></def>  <kwa>while</kwa> <def>FItems</def><sym>&lt;&gt;</sym><def></def><kwa>nil do begin</kwa><br />
<def>    p</def> <sym>:=</sym> <def>FItems</def><sym>;</sym><br />
<def>    FItems</def> <sym>:=</sym> <def>Fitems</def><sym>^.</sym><def>next</def><sym>;</sym><br />
<def></def>    <kwd>FreeMem</kwd><def></def><sym>(</sym><def>p</def><sym>^.</sym><def>Data</def><sym>);</sym><br />
<def></def>    <kwd>Dispose</kwd><def></def><sym>(</sym><def>p</def><sym>);</sym><br />
<def></def>  <kwa>end</kwa><def></def><sym>;</sym><br />
<def></def>  <kwa>inherited</kwa> <def>Destroy</def><sym>;</sym><br />
<def></def><kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><br />
<kwa>function</kwa> <def>TNonFreePooledMemManager</def><sym>.</sym><def>NewItem</def><sym>:</sym> <def></def><kwb>Pointer</kwb><def></def><sym>;</sym> <def></def><kwa>inline</kwa><def></def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def></def>  <kwa>if</kwa> <def></def><sym>(</sym><def>FCurItem</def><sym>=</sym><def>FEndItem</def><sym>)</sym> <def></def><kwa>then</kwa><br />
<def>   Grow</def><sym>;</sym><br />
<def>  Result</def><sym>:=</sym><def>FCurItem</def><sym>;</sym><br />
<def></def>  <kwd>Inc</kwd><def></def><sym>(</sym><def>FCurItem</def><sym>,</sym> <def>FItemSize</def><sym>);</sym><br />
<def></def><kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><br />
<com>{ THashTable }</com><def></def><br />
<br />
<kwa>constructor</kwa> <def>THashTable</def><sym>.</sym><def></def><kwd>Create</kwd><def></def><sym>(</sym><def>size</def><sym>:</sym> <def>dword</def><sym>;</sym> <def>keysize</def><sym>:</sym> <def>dword</def><sym>);</sym><br />
<def></def><kwa>var</kwa><br />
<def>  i</def><sym>:</sym> <def></def><kwb>integer</kwb><def></def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def>  i</def> <sym>:=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>  <kwa>while</kwa> <def></def><sym>(</sym><def>i</def><sym>&lt;</sym><def></def><kwd>high</kwd><def></def><sym>(</sym><def>ht_prime_list</def><sym>))</sym> <def></def><kwa>and</kwa> <def></def><sym>(</sym><def>size</def><sym>&gt;</sym><def>ht_prime_list</def><sym>[</sym><def>i</def><sym>])</sym> <def></def><kwa>do</kwa><br />
<def></def>    <kwd>inc</kwd><def></def><sym>(</sym><def>i</def><sym>);</sym><br />
<def>  FSize</def> <sym>:=</sym> <def>ht_prime_list</def><sym>[</sym><def>i</def><sym>];</sym><br />
<def>  fkeysize</def> <sym>:=</sym> <def>keysize</def><sym>;</sym><br />
<def>  ftbl</def> <sym>:=</sym> <def></def><kwd>allocmem</kwd><def></def><sym>(</sym><def></def><kwd>sizeof</kwd><def></def><sym>(</sym><def>ht_pnode</def><sym>) *</sym> <def>FSize</def><sym>);</sym><br />
<def>  fiter_index</def> <sym>:=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def>  fiter_next</def> <sym>:=</sym> <def></def><kwa>nil</kwa><def></def><sym>;</sym><br />
<def>  FNodeMemManager</def> <sym>:=</sym> <def>TNonFreePooledMemManager</def><sym>.</sym><def></def><kwd>Create</kwd><def></def><sym>(</sym><def></def><kwd>SizeOf</kwd><def></def><sym>(</sym><def>ht_node</def><sym>)+</sym><def>FKeySize</def><sym>);</sym><br />
<def></def><kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><br />
<kwa>destructor</kwa> <def>THashTable</def><sym>.</sym><def>Destroy</def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def>  FNodeMemManager</def><sym>.</sym><def>Free</def><sym>;</sym><br />
<def></def>  <kwd>freemem</kwd><def></def><sym>(</sym><def>Ftbl</def><sym>);</sym><br />
<def></def>  <kwa>inherited</kwa><def></def><sym>;</sym><br />
<def></def><kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><br />
<kwa>function</kwa> <def></def><kwd>ht_hashcode</kwd><def></def><sym>(</sym><def>key</def><sym>:</sym> <def>pchar</def><sym>;</sym> <def>keysize</def><sym>:</sym> <def>dword</def><sym>):</sym> <def>dword</def><sym>;</sym> <def></def><slc>//inline;</slc><br />
<def></def><kwa>var</kwa><br />
<def>  val</def><sym>:</sym> <def>dword</def><sym>;</sym><br />
<def>  i</def><sym>:</sym> <def></def><kwb>integer</kwb><def></def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def>  val</def> <sym>:=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def><br />
  <kwa>for</kwa> <def>i</def> <sym>:=</sym> <def></def><num>0</num> <def></def><kwa>to</kwa> <def>Keysize</def> <sym>-</sym><def></def><num>1</num> <def></def><kwa>do</kwa><br />
<def></def>  <kwa>begin</kwa><br />
<def>    val</def> <sym>:=</sym> <def>val</def> <sym>*</sym> <def></def><num>4</num><def></def><sym>;</sym><br />
<def></def>    <kwd>inc</kwd><def></def><sym>(</sym><def>val</def><sym>,</sym> <def></def><kwd>dword</kwd><def></def><sym>(</sym><def></def><kwb>byte</kwb><def></def><sym>(</sym><def>key</def><sym>^)</sym> <def></def><kwa>and</kwa> <def></def><num>6</num><def></def><sym>)</sym> <def></def><kwa>shr</kwa> <def></def><num>1</num><def></def><sym>);</sym><br />
<def></def>    <kwd>inc</kwd><def></def><sym>(</sym><def>key</def><sym>);</sym><br />
<def></def>  <kwa>end</kwa><def></def><sym>;</sym><br />
<def>  result</def> <sym>:=</sym> <def>val</def><sym>;</sym><br />
<def></def><kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><br />
<kwa>function</kwa> <def>THashTable</def><sym>.</sym><def></def><kwd>Find</kwd><def></def><sym>(</sym><def>key</def><sym>:</sym> <def>pchar</def><sym>):</sym> <def>ht_pnode</def><sym>;</sym><br />
<def></def><kwa>var</kwa><br />
<def>  hash_code</def><sym>:</sym> <def>dword</def><sym>;</sym><br />
<def>  node</def><sym>:</sym> <def>ht_pnode</def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def>  hash_code</def> <sym>:=</sym> <def></def><kwd>ht_hashcode</kwd><def></def><sym>(</sym><def>key</def><sym>,</sym> <def>FKeySize</def><sym>)</sym> <def></def><kwa>mod</kwa> <def>FSize</def><sym>;</sym><br />
<def>  node</def> <sym>:=</sym> <def>FTbl</def><sym>[</sym><def>hash_code</def><sym>];</sym><br />
<def></def>  <kwa>while</kwa> <def>node</def> <sym>&lt;&gt;</sym> <def></def><kwa>nil do</kwa><br />
<def></def>  <kwa>begin</kwa><br />
<def></def>    <kwa>if</kwa> <def></def><kwd>comparebyte</kwd><def></def><sym>(</sym><def>key</def><sym>^,</sym> <def>node</def><sym>^.</sym><def>keydata</def><sym>,</sym> <def>FKeysize</def><sym>) =</sym> <def></def><num>0</num> <def></def><kwa>then</kwa><br />
<def></def>    <kwa>begin</kwa><br />
<def>      result</def> <sym>:=</sym> <def>node</def><sym>;</sym><br />
<def>      exit</def><sym>;</sym><br />
<def></def>    <kwa>end</kwa><def></def><sym>;</sym><br />
<def>    node</def> <sym>:=</sym> <def>node</def><sym>^.</sym><def>next</def><sym>;</sym><br />
<def></def>  <kwa>end</kwa><def></def><sym>;</sym><br />
<def>  result</def> <sym>:=</sym> <def></def><kwa>nil</kwa><def></def><sym>;</sym><br />
<def></def><kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><br />
<kwa>function</kwa> <def>THashTable</def><sym>.</sym><def></def><kwd>FindNew</kwd><def></def><sym>(</sym><def>key</def><sym>:</sym> <def>pchar</def><sym>):</sym> <def>ht_pnode</def><sym>;</sym><br />
<def></def><kwa>var</kwa><br />
<def>  hash_code</def><sym>:</sym> <def></def><kwb>integer</kwb><def></def><sym>;</sym><br />
<def>  prev</def><sym>,</sym> <def>node</def><sym>:</sym> <def>ht_pnode</def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def>  prev</def> <sym>:=</sym> <def></def><kwa>nil</kwa><def></def><sym>;</sym><br />
<def>  hash_code</def> <sym>:=</sym> <def></def><kwd>ht_hashcode</kwd><def></def><sym>(</sym><def>key</def><sym>,</sym> <def>FKeysize</def><sym>)</sym> <def></def><kwa>mod</kwa> <def>FSize</def><sym>;</sym><br />
<def>  node</def> <sym>:=</sym> <def>FTbl</def><sym>[</sym><def>hash_code</def><sym>];</sym><br />
<def></def>  <kwa>while</kwa> <def>node</def> <sym>&lt;&gt;</sym> <def></def><kwa>nil do</kwa><br />
<def></def>  <kwa>begin</kwa><br />
<def></def>    <kwa>if</kwa> <def></def><kwd>CompareByte</kwd><def></def><sym>(</sym><def>key</def><sym>^,</sym> <def>node</def><sym>^.</sym><def>keydata</def><sym>,</sym> <def>FKeysize</def><sym>) =</sym> <def></def><num>0</num> <def></def><kwa>then</kwa><br />
<def></def>    <kwa>begin</kwa><br />
<def>      result</def> <sym>:=</sym> <def>node</def><sym>;</sym><br />
<def>      exit</def><sym>;</sym><br />
<def></def>    <kwa>end</kwa><def></def><sym>;</sym><br />
<def>    prev</def> <sym>:=</sym> <def>node</def><sym>;</sym><br />
<def>    node</def> <sym>:=</sym> <def>node</def><sym>^.</sym><def>next</def><sym>;</sym><br />
<def></def>  <kwa>end</kwa><def></def><sym>;</sym><br />
<def>  result</def> <sym>:=</sym> <def>FNodeMemManager</def><sym>.</sym><def>NewItem</def><sym>;</sym><br />
<def></def>  <kwd>move</kwd><def></def><sym>(</sym><def>key</def><sym>^,</sym><def>Result</def><sym>^.</sym><def>keydata</def><sym>,</sym><def>FKeysize</def><sym>);</sym><br />
<def></def>  <kwa>if</kwa> <def>prev</def> <sym>&lt;&gt;</sym> <def></def><kwa>nil then</kwa><br />
<def></def>  <kwa>begin</kwa><br />
<def>    prev</def><sym>^.</sym><def>next</def> <sym>:=</sym> <def>result</def><sym>;</sym><br />
<def></def>  <kwa>end else begin</kwa><br />
<def>    FTbl</def><sym>[</sym><def>hash_code</def><sym>] :=</sym> <def>result</def><sym>;</sym><br />
<def></def>  <kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><br />
<com>{</com><br />
<com>  Hash Table iterator data / functions</com><br />
<com>}</com><def></def><br />
<br />
<kwa>function</kwa> <def>THashTable</def><sym>.</sym><def>First</def><sym>:</sym> <def>ht_pnode</def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def>  FIter_index</def> <sym>:=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def>  FIter_next</def> <sym>:=</sym> <def></def><kwa>nil</kwa><def></def><sym>;</sym><br />
<def>  result</def> <sym>:=</sym> <def>next</def><sym>;</sym><br />
<def></def><kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><br />
<kwa>function</kwa> <def>THashTable</def><sym>.</sym><def>Next</def><sym>:</sym> <def>ht_pnode</def><sym>;</sym><br />
<def></def><kwa>var</kwa><br />
<def>  index</def><sym>:</sym> <def>dword</def><sym>;</sym><br />
<def>  node</def><sym>:</sym> <def>ht_pnode</def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def>  node</def> <sym>:=</sym> <def>FIter_next</def><sym>;</sym><br />
<def></def>  <kwa>if</kwa> <def>node</def> <sym>&lt;&gt;</sym> <def></def><kwa>nil then</kwa><br />
<def></def>  <kwa>begin</kwa><br />
<def>    FIter_next</def> <sym>:=</sym> <def>node</def><sym>^.</sym><def>next</def><sym>;</sym><br />
<def>    result</def> <sym>:=</sym> <def>node</def><sym>;</sym><br />
<def>    exit</def><sym>;</sym><br />
<def></def>  <kwa>end else begin</kwa><br />
<def></def>    <kwa>while</kwa> <def>FIter_index</def> <sym>&lt;</sym> <def>FSize</def> <kwa>do</kwa><br />
<def></def>    <kwa>begin</kwa><br />
<def>      index</def> <sym>:=</sym> <def>FIter_index</def><sym>;</sym><br />
<def></def>      <kwd>inc</kwd><def></def><sym>(</sym><def>FIter_index</def><sym>);</sym><br />
<def></def>      <kwa>if</kwa> <def>FTbl</def><sym>[</sym><def>index</def><sym>] &lt;&gt;</sym> <def></def><kwa>nil then</kwa><br />
<def></def>      <kwa>begin</kwa><br />
<def>        FIter_next</def> <sym>:=</sym> <def>FTbl</def><sym>[</sym><def>index</def><sym>]^.</sym><def>next</def><sym>;</sym><br />
<def>        result</def> <sym>:=</sym> <def>FTbl</def><sym>[</sym><def>index</def><sym>];</sym><br />
<def>        exit</def><sym>;</sym><br />
<def></def>      <kwa>end</kwa><def></def><sym>;</sym><br />
<def></def>    <kwa>end</kwa><def></def><sym>;</sym><br />
<def></def>  <kwa>end</kwa><def></def><sym>;</sym><br />
<def>  result</def> <sym>:=</sym> <def></def><kwa>nil</kwa><def></def><sym>;</sym><br />
<def></def><kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><br />
<com>{==============================================================================}</com><def></def><br />
<br />
<kwa>type</kwa><br />
<def>   sorter</def>      <sym>=</sym> <def></def><kwa>record</kwa><br />
<def>		   sequence</def> <sym>:</sym> <def>ansistring</def><sym>;</sym><br />
<def>		   num</def>	     <sym>:</sym> <def></def><kwb>longint</kwb><def></def><sym>;</sym><br />
<def></def>		 <kwa>end</kwa><def></def><sym>;</sym><br />
<def>   sorterArray</def> <sym>=</sym> <def></def><kwa>array of</kwa> <def>sorter</def><sym>;</sym><br />
<def></def><br />
<kwa>function</kwa> <def></def><kwd>hash_table_size</kwd> <def></def><sym>(</sym><def>fl</def> <sym>:</sym> <def>dword</def><sym>):</sym> <def>dword</def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def></def>  <kwa>if</kwa> <def>fl</def><sym>&lt;</sym><def></def><num>8</num> <def></def><kwa>then</kwa><br />
<def>   hash_table_size</def> <sym>:=</sym> <def></def><num>1</num> <def></def><kwa>shl</kwa> <def></def><sym>(</sym><def></def><num>2</num> <def></def><sym>*</sym> <def>fl</def><sym>)</sym><br />
<def></def>  <kwa>else</kwa><br />
<def>   hash_table_size</def> <sym>:=</sym> <def></def><num>$10000</num><def></def><sym>;</sym><br />
<def></def><kwa>end</kwa><def></def><sym>;</sym> <def></def><com>{ hash_table_size }</com><def></def><br />
<br />
<kwa>function</kwa> <def></def><kwd>generate_frequencies</kwd><def></def><sym>(</sym><def>fl</def><sym>:</sym> <def></def><kwb>integer</kwb><def></def><sym>;</sym> <def>buffer</def><sym>:</sym> <def>PChar</def><sym>;</sym> <def>buflen</def> <sym>:</sym> <def></def><kwb>longint</kwb><def></def><sym>):</sym> <def>THashTable</def><sym>;</sym><br />
<def></def><kwa>var</kwa><br />
<def>   reader</def> <sym>:</sym> <def>PChar</def><sym>;</sym><br />
<def>   i</def> <sym>:</sym> <def></def><kwb>longint</kwb><def></def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def></def>   <kwa>if</kwa> <def>fl</def> <sym>&lt;=</sym> <def>buflen</def> <kwa>then</kwa><br />
<def></def>   <kwa>begin</kwa><br />
<def>      result</def> <sym>:=</sym> <def>THashTable</def><sym>.</sym><def></def><kwd>Create</kwd><def></def><sym>(</sym><def></def><kwd>hash_table_size</kwd> <def></def><sym>(</sym><def>fl</def><sym>),</sym> <def>fl</def><sym>);</sym><br />
<def>      reader</def> <sym>:=</sym> <def>buffer</def><sym>;</sym><br />
<def></def>      <kwa>for</kwa> <def>i</def> <sym>:=</sym> <def></def><num>0</num> <def></def><kwa>to</kwa> <def>buflen</def><sym>-</sym><def>fl</def> <kwa>do</kwa><br />
<def></def>      <kwa>begin</kwa><br />
<def></def>         <kwd>inc</kwd><def></def><sym>(</sym><def>Result</def><sym>.</sym><def></def><kwd>FindNew</kwd><def></def><sym>(</sym><def>reader</def><sym>)^.</sym><def>val</def><sym>);</sym><br />
<def></def>         <kwd>inc</kwd><def></def><sym>(</sym><def>reader</def><sym>);</sym><br />
<def></def>      <kwa>end</kwa><def></def><sym>;</sym><br />
<def></def>   <kwa>end else</kwa><br />
<def>      result</def> <sym>:=</sym> <def></def><kwa>nil</kwa><def></def><sym>;</sym><br />
<def></def><kwa>end</kwa><def></def><sym>;</sym> <def></def><com>{ generate_frequencies }</com><def></def><br />
<br />
<kwa>procedure</kwa> <def></def><kwd>sortArray</kwd><def></def><sym>(</sym><def></def><kwa>var</kwa> <def>s</def> <sym>:</sym> <def>sorterArray</def><sym>;</sym> <def>size</def><sym>:</sym><def></def><kwb>longint</kwb><def></def><sym>);</sym><br />
<def></def><kwa>var</kwa><br />
<def>   i</def><sym>,</sym><def>j</def> <sym>:</sym> <def></def><kwb>longint</kwb><def></def><sym>;</sym><br />
<def>   tmp</def> <sym>:</sym> <def>sorter</def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def></def>   <kwa>for</kwa> <def>i</def> <sym>:=</sym> <def></def><num>0</num> <def></def><kwa>to</kwa> <def>size</def><sym>-</sym><def></def><num>2</num> <def></def><kwa>do</kwa><br />
<def></def>      <kwa>for</kwa> <def>j</def> <sym>:=</sym> <def>i</def><sym>+</sym><def></def><num>1</num> <def></def><kwa>to</kwa> <def>size</def><sym>-</sym><def></def><num>1</num> <def></def><kwa>do</kwa><br />
<def></def>         <kwa>if</kwa> <def>s</def><sym>[</sym><def>i</def><sym>].</sym><def>num</def> <sym>&lt;</sym> <def>s</def><sym>[</sym><def>j</def><sym>].</sym><def>num</def> <kwa>then</kwa><br />
<def></def>	 <kwa>begin</kwa><br />
<def>	    tmp</def> <sym>:=</sym> <def>s</def><sym>[</sym><def>i</def><sym>];</sym><br />
<def>	    s</def><sym>[</sym><def>i</def><sym>] :=</sym> <def>s</def><sym>[</sym><def>j</def><sym>];</sym><br />
<def>	    s</def><sym>[</sym><def>j</def><sym>] :=</sym> <def>tmp</def><sym>;</sym><br />
<def></def>	 <kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><kwa>end</kwa><def></def><sym>;</sym> <def></def><com>{ sortArray }</com><def></def><br />
<br />
<kwa>procedure</kwa> <def></def><kwd>write_frequencies</kwd><def></def><sym>(</sym><def>fl</def> <sym>:</sym> <def></def><kwb>integer</kwb><def></def><sym>;</sym> <def>buffer</def> <sym>:</sym> <def>PChar</def><sym>;</sym> <def>buflen</def> <sym>:</sym> <def></def><kwb>longint</kwb><def></def><sym>);</sym><br />
<def></def><kwa>var</kwa><br />
<def>  ht</def>	   <sym>:</sym> <def>THashTable</def><sym>;</sym><br />
<def>  i</def><sym>,</sym> <def>size</def> <sym>:</sym> <def></def><kwb>longint</kwb><def></def><sym>;</sym><br />
<def>  total</def>   <sym>:</sym> <def></def><kwb>real</kwb><def></def><sym>;</sym><br />
<def>  nd</def>	   <sym>:</sym> <def>ht_pnode</def><sym>;</sym><br />
<def>  s</def>	   <sym>:</sym> <def>sorterArray</def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def>  ht</def> <sym>:=</sym> <def></def><kwd>generate_frequencies</kwd><def></def><sym>(</sym><def>fl</def><sym>,</sym> <def>buffer</def><sym>,</sym> <def>buflen</def><sym>);</sym><br />
<def>  total</def> <sym>:=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def>  size</def> <sym>:=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def>  nd</def> <sym>:=</sym> <def>ht</def><sym>.</sym><def>First</def><sym>;</sym><br />
<def></def>  <kwa>while</kwa> <def></def><sym>(</sym><def>nd</def> <sym>&lt;&gt;</sym> <def></def><kwa>nil</kwa><def></def><sym>)</sym> <def></def><kwa>do</kwa><br />
<def></def>  <kwa>begin</kwa><br />
<def>    total</def> <sym>:=</sym> <def>total</def> <sym>+</sym> <def>nd</def><sym>^.</sym><def>val</def><sym>;</sym><br />
<def>    size</def> <sym>:=</sym> <def>size</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def>    nd</def> <sym>:=</sym> <def>ht</def><sym>.</sym><def>Next</def><sym>;</sym><br />
<def></def>  <kwa>end</kwa><def></def><sym>;</sym><br />
<def></def>  <kwd>SetLength</kwd><def></def><sym>(</sym><def>s</def><sym>,</sym> <def>size</def><sym>);</sym><br />
<def><br />
  nd</def> <sym>:=</sym> <def>ht</def><sym>.</sym><def>First</def><sym>;</sym><br />
<def>  size</def> <sym>:=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>  <kwa>while</kwa> <def></def><sym>(</sym><def>nd</def> <sym>&lt;&gt;</sym> <def></def><kwa>nil</kwa><def></def><sym>)</sym> <def></def><kwa>do</kwa><br />
<def></def>  <kwa>begin</kwa><br />
<def>    s</def><sym>[</sym><def>size</def><sym>].</sym><def>sequence</def> <sym>:=</sym> <def></def><kwd>upcase</kwd><def></def><sym>(</sym><def></def><kwd>pchar</kwd><def></def><sym>(@</sym><def>nd</def><sym>^.</sym><def>keydata</def><sym>));</sym><br />
<def>    s</def><sym>[</sym><def>size</def><sym>].</sym><def>num</def> <sym>:=</sym> <def>nd</def><sym>^.</sym><def>val</def><sym>;</sym><br />
<def>    size</def> <sym>:=</sym> <def>size</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def>    nd</def> <sym>:=</sym> <def>ht</def><sym>.</sym><def>Next</def><sym>;</sym><br />
<def></def>  <kwa>end</kwa><def></def><sym>;</sym><br />
<def></def><br />
  <kwd>sortArray</kwd><def></def><sym>(</sym><def>s</def><sym>,</sym> <def>size</def><sym>);</sym><br />
<def></def>  <kwa>for</kwa> <def>i</def> <sym>:=</sym> <def></def><num>0</num> <def></def><kwa>to</kwa> <def>size</def> <sym>-</sym> <def></def><num>1</num> <def></def><kwa>do</kwa><br />
<def></def>    <kwd>writeln</kwd><def></def><sym>(</sym><def>s</def><sym>[</sym><def>i</def><sym>].</sym><def>sequence</def><sym>,</sym><def></def><str>' '</str><def></def><sym>, (</sym><def></def><num>100</num> <def></def><sym>*</sym> <def>s</def><sym>[</sym><def>i</def><sym>].</sym><def>num</def> <sym>/</sym> <def>total</def><sym>):</sym><def></def><num>3</num><def></def><sym>:</sym><def></def><num>3</num><def></def><sym>);</sym><br />
<def>  writeln</def><sym>;</sym><br />
<def><br />
  ht</def><sym>.</sym><def>Free</def><sym>;</sym><br />
<def></def><kwa>end</kwa><def></def><sym>;</sym> <def></def><com>{ write_frequencies }</com><def></def><br />
<br />
<kwa>procedure</kwa> <def></def><kwd>write_count</kwd><def></def><sym>(</sym><def>searchFor</def> <sym>:</sym> <def>ansistring</def><sym>;</sym> <def>buffer</def> <sym>:</sym> <def>PChar</def><sym>;</sym> <def>buflen</def> <sym>:</sym> <def></def><kwb>longint</kwb><def></def><sym>);</sym><br />
<def></def><kwa>var</kwa><br />
<def>   ht</def> <sym>:</sym> <def>THashTable</def><sym>;</sym><br />
<def>   nd</def> <sym>:</sym> <def>ht_pnode</def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def>   ht</def> <sym>:=</sym> <def></def><kwd>generate_frequencies</kwd> <def></def><sym>(</sym><def></def><kwd>length</kwd><def></def><sym>(</sym><def>searchFor</def><sym>),</sym> <def>buffer</def><sym>,</sym> <def>buflen</def><sym>);</sym><br />
<def>   nd</def> <sym>:=</sym> <def>ht</def><sym>.</sym><def></def><kwd>Find</kwd><def></def><sym>(</sym><def></def><kwd>pchar</kwd><def></def><sym>(</sym><def>searchFor</def><sym>));</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>nd</def> <sym>&lt;&gt;</sym> <def></def><kwa>nil</kwa><def></def><sym>)</sym> <def></def><kwa>then</kwa><br />
<def></def>      <kwd>write</kwd><def></def><sym>(</sym><def>nd</def><sym>^.</sym><def>val</def><sym>)</sym><br />
<def></def>   <kwa>else</kwa><br />
<def></def>      <kwd>write</kwd><def></def><sym>(</sym><def></def><num>0</num><def></def><sym>);</sym><br />
<def>   searchfor</def> <sym>:=</sym> <def></def><kwd>UpCase</kwd><def></def><sym>(</sym><def>searchFor</def><sym>);</sym><br />
<def></def>   <kwd>writeln</kwd><def></def><sym>(</sym><def></def><esc>#9</esc><def></def><sym>,</sym> <def>searchFor</def><sym>);</sym><br />
<def><br />
   ht</def><sym>.</sym><def>Free</def><sym>;</sym><br />
<def></def><kwa>end</kwa><def></def><sym>;</sym> <def></def><com>{ write_count }</com><def></def><br />
<br />
<kwa>procedure</kwa> <def>main</def><sym>;</sym><br />
<def></def><kwa>var</kwa><br />
<def>   buffer</def> <sym>:</sym> <def>PChar</def><sym>;</sym><br />
<def>   len</def><sym>,</sym> <def>seqlen</def> <sym>:</sym> <def></def><kwb>longint</kwb><def></def><sym>;</sym><br />
<def>   buffersize</def><sym>,</sym> <def>bufferptr</def><sym>:</sym> <def></def><kwb>longint</kwb><def></def><sym>;</sym><br />
<def>   s</def> <sym>:</sym> <def></def><kwa>String</kwa><def></def><sym>;</sym><br />
<def></def><kwa>begin</kwa><br />
<def>   seqlen</def> <sym>:=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>   <kwa>repeat</kwa><br />
<def></def>      <kwd>readln</kwd><def></def><sym>(</sym><def>s</def><sym>)</sym><br />
<def></def>   <kwa>until</kwa> <def></def><sym>(</sym><def>s</def><sym>[</sym><def></def><num>1</num><def></def><sym>] =</sym> <def></def><str>'&gt;'</str><def></def><sym>)</sym> <def></def><kwa>and</kwa> <def></def><sym>(</sym><def>s</def><sym>[</sym><def></def><num>2</num><def></def><sym>] =</sym> <def></def><str>'T'</str><def></def><sym>)</sym> <def></def><kwa>and</kwa> <def></def><sym>(</sym><def>s</def><sym>[</sym><def></def><num>3</num><def></def><sym>] =</sym> <def></def><str>'H'</str><def></def><sym>);</sym><br />
<def>   buffersize</def><sym>:=</sym><def></def><num>1024</num><def></def><sym>;</sym><br />
<def>   buffer</def><sym>:=</sym><def></def><kwd>getmem</kwd><def></def><sym>(</sym><def>buffersize</def><sym>);</sym><br />
<def>   bufferptr</def> <sym>:=</sym><def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>   <kwa>while not</kwa> <def>eof</def> <kwa>do begin</kwa><br />
<def></def>     <kwd>readln</kwd><def></def><sym>(</sym><def>s</def><sym>);</sym><br />
<def></def>     <kwa>if</kwa> <def></def><sym>(</sym><def>s</def><sym>[</sym><def></def><num>1</num><def></def><sym>] &lt;&gt;</sym> <def></def><str>'&gt;'</str><def></def><sym>)</sym> <def></def><kwa>and</kwa> <def></def><sym>(</sym><def>s</def><sym>[</sym><def></def><num>1</num><def></def><sym>] &lt;&gt;</sym> <def></def><str>';'</str><def></def><sym>)</sym> <def></def><kwa>then begin</kwa><br />
<def>       len</def><sym>:=</sym><def></def><kwd>length</kwd><def></def><sym>(</sym><def>s</def><sym>);</sym><br />
<def></def>       <kwa>if</kwa> <def></def><sym>(</sym><def>bufferptr</def><sym>+</sym><def>len</def><sym>+</sym><def></def><num>1</num><def></def><sym>)&gt;</sym><def>buffersize</def> <kwa>then  begin</kwa><br />
<def></def>         <kwd>inc</kwd><def></def><sym>(</sym><def>buffersize</def><sym>,</sym><def>buffersize</def><sym>);</sym><br />
<def></def>         <kwd>reallocmem</kwd><def></def><sym>(</sym><def>buffer</def><sym>,</sym><def>buffersize</def><sym>);</sym><br />
<def></def>       <kwa>end</kwa><def></def><sym>;</sym><br />
<def></def>       <kwd>move</kwd> <def></def><sym>(</sym><def>s</def><sym>[</sym><def></def><num>1</num><def></def><sym>],</sym><def>buffer</def><sym>[</sym><def>bufferptr</def><sym>],</sym><def>len</def><sym>);</sym><br />
<def></def>       <kwd>inc</kwd><def></def><sym>(</sym><def>bufferptr</def><sym>,</sym><def>len</def><sym>);</sym><br />
<def></def>     <kwa>end</kwa><def></def><sym>;</sym><br />
<def></def>   <kwa>end</kwa><def></def><sym>;</sym><br />
<def>   buffer</def><sym>[</sym><def>bufferptr</def><sym>] :=</sym> <def></def><esc>#0</esc><def></def><sym>;</sym><br />
<def>   seqlen</def> <sym>:=</sym> <def></def><kwd>strlen</kwd><def></def><sym>(</sym><def>buffer</def><sym>);</sym><br />
<def></def><br />
   <kwd>write_frequencies</kwd><def></def><sym>(</sym><def></def><num>1</num><def></def><sym>,</sym> <def>buffer</def><sym>,</sym> <def>seqlen</def><sym>);</sym><br />
<def></def>   <kwd>write_frequencies</kwd><def></def><sym>(</sym><def></def><num>2</num><def></def><sym>,</sym> <def>buffer</def><sym>,</sym> <def>seqlen</def><sym>);</sym><br />
<def></def>   <kwd>write_count</kwd><def></def><sym>(</sym><def></def><str>'ggt'</str><def></def><sym>,</sym> <def>buffer</def><sym>,</sym> <def>seqlen</def><sym>);</sym><br />
<def></def>   <kwd>write_count</kwd><def></def><sym>(</sym><def></def><str>'ggta'</str><def></def><sym>,</sym> <def>buffer</def><sym>,</sym> <def>seqlen</def><sym>);</sym><br />
<def></def>   <kwd>write_count</kwd><def></def><sym>(</sym><def></def><str>'ggtatt'</str><def></def><sym>,</sym> <def>buffer</def><sym>,</sym> <def>seqlen</def><sym>);</sym><br />
<def></def>   <kwd>write_count</kwd><def></def><sym>(</sym><def></def><str>'ggtattttaatt'</str><def></def><sym>,</sym> <def>buffer</def><sym>,</sym> <def>seqlen</def><sym>);</sym><br />
<def></def>   <kwd>write_count</kwd><def></def><sym>(</sym><def></def><str>'ggtattttaatttatagt'</str><def></def><sym>,</sym> <def>buffer</def><sym>,</sym> <def>seqlen</def><sym>);</sym><br />
<def></def>   <kwd>freemem</kwd><def></def><sym>(</sym><def>buffer</def><sym>);</sym><br />
<def></def><kwa>end</kwa><def></def><sym>;</sym> <def></def><com>{ main }</com><def></def><br />
<br />
<br />
<kwa>begin</kwa><br />
<def></def>   <slc>//SetPrecisionMode(pmDouble);</slc><br />
<def>   main</def><sym>;</sym><br />
<def></def><kwa>end</kwa><def></def><sym>.</sym><def></def><br />
</source>
