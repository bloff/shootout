<source>
<def></def><slc>-- The Great Computer Language Shootout</slc><br />
<def></def><slc>-- http://shootout.alioth.debian.org/</slc><br />
<def></def><slc>-- contributed by Jeff Newbern</slc><br />
<def></def><br />
<slc>-- Note: This code has not been optimized *at all*.  It is written to be clear</slc><br />
<def></def><slc>-- and concise, using standard Haskell idioms.  Performance is decent with</slc><br />
<def></def><slc>-- ghc -O2, but if it can be improved without sacrificing the clarity of the</slc><br />
<def></def><slc>-- code, by all means go for it!</slc><br />
<def></def><br />
<kwa>import</kwa> <def>Data.</def><kwb>Char</kwb><def></def><sym>(</sym><def>toLower</def><sym>)</sym><br />
<def></def><br />
<kwa>type</kwa> <def>Base</def> <sym>=</sym> <def></def><kwb>Char</kwb><br />
<def></def><kwa>type</kwa> <def>Sequence</def> <sym>= [</sym><def>Base</def><sym>]</sym><br />
<def><br />
complement</def> <sym>::</sym> <def>Base</def> <sym>-&gt;</sym> <def>Base<br />
complement 'A'</def> <sym>=</sym> <def>'T'<br />
complement 'a'</def> <sym>=</sym> <def>'T'<br />
complement 'C'</def> <sym>=</sym> <def>'G'<br />
complement 'c'</def> <sym>=</sym> <def>'G'<br />
complement 'G'</def> <sym>=</sym> <def>'C'<br />
complement 'g'</def> <sym>=</sym> <def>'C'<br />
complement 'T'</def> <sym>=</sym> <def>'A'<br />
complement 't'</def> <sym>=</sym> <def>'A'<br />
complement 'U'</def> <sym>=</sym> <def>'A'<br />
complement 'u'</def> <sym>=</sym> <def>'A'<br />
complement 'M'</def> <sym>=</sym> <def>'K'<br />
complement 'm'</def> <sym>=</sym> <def>'K'<br />
complement 'R'</def> <sym>=</sym> <def>'Y'<br />
complement 'r'</def> <sym>=</sym> <def>'Y'<br />
complement 'Y'</def> <sym>=</sym> <def>'R'<br />
complement 'y'</def> <sym>=</sym> <def>'R'<br />
complement 'K'</def> <sym>=</sym> <def>'M'<br />
complement 'k'</def> <sym>=</sym> <def>'M'<br />
complement 'V'</def> <sym>=</sym> <def>'B'<br />
complement 'v'</def> <sym>=</sym> <def>'B'<br />
complement 'H'</def> <sym>=</sym> <def>'D'<br />
complement 'h'</def> <sym>=</sym> <def>'D'<br />
complement 'D'</def> <sym>=</sym> <def>'H'<br />
complement 'd'</def> <sym>=</sym> <def>'H'<br />
complement 'B'</def> <sym>=</sym> <def>'V'<br />
complement 'b'</def> <sym>=</sym> <def>'V'<br />
complement  x</def>  <sym>=</sym> <def>x</def><br />
<br />
<slc>-- write a sequence in Fasta format</slc><br />
<def>writeFasta</def> <sym>::</sym> <def>String</def> <sym>-&gt;</sym> <def>Sequence</def> <sym>-&gt;</sym> <def>IO</def> <sym>()</sym><br />
<def>writeFasta</def> <sym>[]</sym>     <def>_</def>        <sym>=</sym> <def></def><kwa>do</kwa> <def>return</def> <sym>()</sym><br />
<def>writeFasta header sequence</def> <sym>=</sym><br />
<def></def>  <kwa>do</kwa> <def>putStrLn header<br />
     writeWrapped</def> <num>60</num> <def>sequence</def><br />
  <kwa>where</kwa> <def>writeWrapped _</def>   <sym>[]  =</sym> <def></def><kwa>do</kwa> <def>return</def> <sym>()</sym><br />
<def>        writeWrapped len str</def> <sym>=</sym> <def></def><kwa>do let</kwa> <def></def><sym>(</sym><def>s1</def><sym>,</sym><def>s2</def><sym>) =</sym> <def>splitAt len str<br />
                                  putStrLn s1<br />
                                  writeWrapped len s2</def><br />
<br />
<slc>-- recurse over input stream, accumulating and writing processed sequences</slc><br />
<def>process</def> <sym>:: (</sym><def>String</def><sym>,[</sym><def>Base</def><sym>],</sym><def>String</def><sym>) -&gt;</sym> <def>IO</def><sym>()</sym><br />
<def>process</def> <sym>(</sym><def>header</def><sym>,</sym><def>bases</def><sym>,[])         =</sym> <def>writeFasta header bases<br />
process</def> <sym>(</sym><def>header</def><sym>,</sym><def>bases</def><sym>,</sym><def>c</def><sym>@(</sym><def>'</def><sym>&gt;</sym><def>'</def><sym>:</sym><def>cs</def><sym>)) =</sym> <def></def><kwa>do</kwa> <def>writeFasta header bases</def><br />
                                       <kwa>let</kwa> <def></def><sym>(</sym><def>header'</def><sym>,</sym><def>cs'</def><sym>) =</sym> <def>break</def> <sym>(</sym><def>\c</def><sym>-&gt;</sym><def>c</def> <sym>==</sym> <def>'\n'</def><sym>)</sym> <def>c<br />
                                       process</def> <sym>(</sym><def>header'</def><sym>,[],</sym><def>cs'</def><sym>)</sym><br />
<def>process</def> <sym>(</sym><def>header</def><sym>,</sym><def>bases</def><sym>,(</sym><def>'\n'</def><sym>:</sym><def>cs</def><sym>))  =</sym> <def>process</def> <sym>(</sym><def>header</def><sym>,</sym><def>bases</def><sym>,</sym><def>cs</def><sym>)</sym><br />
<def>process</def> <sym>(</sym><def>header</def><sym>,</sym><def>bases</def><sym>,(</sym><def>c</def><sym>:</sym><def>cs</def><sym>))     =</sym> <def>process</def> <sym>(</sym><def>header</def><sym>,((</sym><def>complement c</def><sym>):</sym><def>bases</def><sym>),</sym><def>cs</def><sym>)</sym><br />
<def><br />
main</def> <sym>=</sym> <def></def><kwa>do</kwa> <def>cs</def> <sym>&lt;-</sym> <def>getContents<br />
          process</def> <sym>([],[],</sym><def>cs</def><sym>)</sym><br />
<def></def><br />
</source>
