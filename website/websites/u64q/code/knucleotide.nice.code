<source>
<def></def><com>/* The Computer Language Shootout</com><br />
<com>   http://shootout.alioth.debian.org/</com><br />
<com>   contributed by Isaac Gouy, following James McIlree's Java program</com><br />
<com>*/</com><def></def><br />
<br />
<kwa>import</kwa> <def>java</def><sym>.</sym><def>io</def><sym>.*;</sym><br />
<def></def><kwa>import</kwa> <def>Include</def><sym>;</sym><br />
<def></def><br />
<kwb>void</kwb> <def>main</def><sym>(</sym><def>String</def><sym>[]</sym> <def>args</def><sym>){</sym><br />
<def></def>   <kwa>let</kwa> <def>r</def> <sym>=</sym> <def></def><kwa>new</kwa> <def>BufferedReader</def><sym>(</sym><def></def><kwa>new</kwa> <def>InputStreamReader</def><sym>(</sym><def>System</def><sym>.</sym><def>in</def><sym>));</sym><br />
<def></def>   <kwa>let</kwa> <def>buffer</def> <sym>=</sym> <def></def><kwa>new</kwa> <def>StringBuffer</def><sym>();</sym><br />
<def></def>   <kwa>var</kwa> <def></def><sym>?</sym><def>String line</def><sym>;</sym><br />
<def></def><br />
   <kwa>while</kwa> <def></def><sym>((</sym><def>line</def> <sym>=</sym> <def>r</def><sym>.</sym><def>readLine</def><sym>()) !=</sym> <def></def><kwa>null</kwa><def></def><sym>){</sym><br />
<def></def>      <kwa>if</kwa> <def></def><sym>(</sym><def>line</def><sym>.</sym><def>startsWith</def><sym>(</sym><def></def><str>&quot;&gt;THREE&quot;</str><def></def><sym>))</sym> <def></def><kwa>break</kwa><def></def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>while</kwa> <def></def><sym>((</sym><def>line</def> <sym>=</sym> <def>r</def><sym>.</sym><def>readLine</def><sym>()) !=</sym> <def></def><kwa>null</kwa><def></def><sym>){</sym><br />
<def></def>      <kwa>let</kwa> <def>c</def> <sym>=</sym> <def>line</def><sym>[</sym><def></def><num>0</num><def></def><sym>];</sym><br />
<def></def>      <kwa>if</kwa> <def></def><sym>(</sym><def>c</def> <sym>==</sym> <def></def><str>'&gt;'</str><def></def><sym>)</sym><br />
<def></def>         <kwa>break</kwa><def></def><sym>;</sym><br />
<def></def>      <kwa>else if</kwa> <def></def><sym>(</sym><def>c</def> <sym>!=</sym> <def></def><str>';'</str><def></def><sym>)</sym><br />
<def>         buffer</def><sym>.</sym><def>append</def><sym>(</sym><def>line</def><sym>.</sym><def>toUpperCase</def><sym>());</sym><br />
<def></def>   <sym>}</sym><br />
<def>   r</def><sym>.</sym><def>close</def><sym>;</sym><br />
<def></def><br />
   <kwa>let</kwa> <def>kn</def> <sym>=</sym> <def></def><kwa>new</kwa> <def>KNucleotide</def><sym>(</sym><def>sequence</def><sym>:</sym> <def>buffer</def><sym>.</sym><def>toString</def><sym>());</sym><br />
<def>   kn</def><sym>.</sym><def>writeFrequencies</def><sym>(</sym><def></def><num>1</num><def></def><sym>);</sym><br />
<def>   kn</def><sym>.</sym><def>writeFrequencies</def><sym>(</sym><def></def><num>2</num><def></def><sym>);</sym><br />
<def><br />
   kn</def><sym>.</sym><def>writeCount</def><sym>(</sym><def></def><str>&quot;GGT&quot;</str><def></def><sym>);</sym><br />
<def>   kn</def><sym>.</sym><def>writeCount</def><sym>(</sym><def></def><str>&quot;GGTA&quot;</str><def></def><sym>);</sym><br />
<def>   kn</def><sym>.</sym><def>writeCount</def><sym>(</sym><def></def><str>&quot;GGTATT&quot;</str><def></def><sym>);</sym><br />
<def>   kn</def><sym>.</sym><def>writeCount</def><sym>(</sym><def></def><str>&quot;GGTATTTTAATT&quot;</str><def></def><sym>);</sym><br />
<def>   kn</def><sym>.</sym><def>writeCount</def><sym>(</sym><def></def><str>&quot;GGTATTTTAATTTATAGT&quot;</str><def></def><sym>);</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<br />
<kwa>class</kwa> <def>KNucleotide</def> <sym>{</sym><br />
<def>   String sequence</def><sym>;</sym><br />
<def></def>   <kwb>int</kwb> <def>count</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def><br />
<br />
   <kwb>void</kwb> <def>writeFrequencies</def><sym>(</sym><def></def><kwb>int</kwb> <def>k</def><sym>) {</sym><br />
<def></def>      <kwa>let</kwa> <def>frequencies</def> <sym>=</sym> <def>this</def><sym>.</sym><def>generateFrequencies</def><sym>(</sym><def>k</def><sym>);</sym><br />
<def></def><br />
      <kwa>let</kwa> <def>list</def> <sym>=</sym> <def></def><kwa>new</kwa> <def>ArrayList</def><sym>(</sym><def>frequencies</def><sym>.</sym><def>values</def><sym>);</sym><br />
<def>      sort</def><sym>(</sym><def>list</def><sym>,</sym><br />
<def></def>            <sym>(</sym><def>KNucleotide k1</def><sym>,</sym> <def>KNucleotide k2</def><sym>) =&gt; {</sym><br />
<def></def>               <kwa>let</kwa> <def>i</def> <sym>=</sym> <def>k2</def><sym>.</sym><def>count</def> <sym>-</sym> <def>k1</def><sym>.</sym><def>count</def><sym>;</sym><br />
<def></def>               <kwa>return</kwa> <def>i</def> <sym>!=</sym> <def></def><num>0</num> <def></def><sym>?</sym> <def>i</def> <sym>:</sym> <def>k2</def><sym>.</sym><def>sequence</def><sym>.</sym><def>compareTo</def><sym>(</sym><def>k1</def><sym>.</sym><def>sequence</def><sym>);</sym><br />
<def></def>               <sym>}</sym><br />
<def></def>            <sym>);</sym><br />
<def></def><br />
      <kwa>let</kwa> <def>sum</def> <sym>=</sym> <def>sequence</def><sym>.</sym><def>length</def> <sym>-</sym> <def>k</def> <sym>+</sym> <def></def><num>1.0</num><def></def><sym>;</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def>kn</def> <sym>:</sym> <def>list</def><sym>)</sym><br />
<def>         println</def><sym>(</sym><def>kn</def><sym>.</sym><def>sequence</def> <sym>+</sym> <def></def><str>&quot; &quot;</str><def></def> <sym>+ (</sym><def>kn</def><sym>.</sym><def>count</def><sym>/</sym><def>sum</def> <sym>*</sym> <def></def><num>100.0</num><def></def><sym>).</sym><def>toStringWith</def><sym>(</sym><def></def><num>3</num><def></def><sym>));</sym><br />
<def><br />
      println</def><sym>();</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
<br />
   <kwb>void</kwb> <def>writeCount</def><sym>(</sym><def>String nucleotideFragment</def><sym>) {</sym><br />
<def></def>      <kwa>let</kwa> <def>frequencies</def> <sym>=</sym> <def>this</def><sym>.</sym><def>generateFrequencies</def><sym>(</sym><def>nucleotideFragment</def><sym>.</sym><def>length</def><sym>);</sym><br />
<def></def>      <kwa>var</kwa> <def>count</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>      <kwa>let</kwa> <def>item</def> <sym>=</sym> <def>frequencies</def><sym>[</sym><def>nucleotideFragment</def><sym>];</sym><br />
<def></def>      <kwa>if</kwa> <def></def><sym>(</sym><def>item</def> <sym>!=</sym> <def></def><kwa>null</kwa><def></def><sym>)</sym> <def>count</def> <sym>=</sym> <def>item</def><sym>.</sym><def>count</def><sym>;</sym><br />
<def>      println</def><sym>(</sym><def>count</def> <sym>+</sym> <def></def><str>&quot;\t&quot;</str><def></def> <sym>+</sym> <def>nucleotideFragment</def><sym>);</sym><br />
<def></def>   <sym>}</sym><br />
<def><br />
   Map</def><sym>&lt;</sym><def>String</def><sym>,</sym><def>KNucleotide</def><sym>&gt;</sym> <def>generateFrequencies</def><sym>(</sym><def></def><kwb>int</kwb> <def>length</def><sym>) {</sym><br />
<def></def>      <kwa>let</kwa> <def>HashMap</def><sym>&lt;</sym><def>String</def><sym>,</sym><def>KNucleotide</def><sym>&gt;</sym> <def>frequencies</def> <sym>=</sym> <def></def><kwa>new</kwa> <def>HashMap</def><sym>();</sym><br />
<def></def><br />
      <kwb>void</kwb> <def>kFrequency</def><sym>(</sym><def></def><kwb>int</kwb> <def>offset</def><sym>,</sym> <def></def><kwb>int</kwb> <def>k</def><sym>) {</sym><br />
<def></def>         <kwa>let</kwa> <def>n</def> <sym>=</sym> <def>sequence</def><sym>.</sym><def>length</def> <sym>-</sym> <def>k</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>         <kwa>for</kwa><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i</def><sym>=</sym><def>offset</def><sym>;</sym> <def>i</def><sym>&lt;</sym><def>n</def><sym>;</sym> <def>i</def><sym>+=</sym><def>k</def><sym>) {</sym><br />
<def></def>            <kwa>let</kwa> <def>fragment</def> <sym>=</sym> <def>sequence</def><sym>.</sym><def>substring</def><sym>(</sym><def>i</def><sym>,</sym><def>i</def><sym>+</sym><def>k</def><sym>);</sym><br />
<def></def>            <kwa>let</kwa> <def>item</def> <sym>=</sym> <def>frequencies</def><sym>[</sym><def>fragment</def><sym>];</sym><br />
<def></def>            <kwa>if</kwa> <def></def><sym>(</sym><def>item</def> <sym>!=</sym> <def></def><kwa>null</kwa><def></def><sym>)</sym><br />
<def>               item</def><sym>.</sym><def>count</def><sym>++;</sym><br />
<def></def>            <kwa>else</kwa><br />
<def>               frequencies</def><sym>[</sym><def>fragment</def><sym>] =</sym> <def></def><kwa>new</kwa> <def>KNucleotide</def><sym>(</sym><def>sequence</def><sym>:</sym> <def>fragment</def><sym>);</sym><br />
<def></def>         <sym>}</sym><br />
<def></def>      <sym>}</sym><br />
<def></def><br />
      <kwa>for</kwa><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>offset</def><sym>=</sym><def></def><num>0</num><def></def><sym>;</sym> <def>offset</def><sym>&lt;</sym><def>length</def><sym>;</sym> <def>offset</def><sym>++)</sym> <def>kFrequency</def><sym>(</sym><def>offset</def><sym>,</sym><def>length</def><sym>);</sym><br />
<def></def>      <kwa>return</kwa> <def>frequencies</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><sym>}</sym><def></def><br />
</source>
