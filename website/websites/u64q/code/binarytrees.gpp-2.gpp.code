<source>
<def></def><com>/* binarytrees.cpp</com><br />
<com> *</com><br />
<com> * The Great Computer Language Shootout</com><br />
<com> * http://shootout.alioth.debian.org/</com><br />
<com> *</com><br />
<com> * Contributed by Jon Harrop</com><br />
<com> * Modified by Alex Mizrahi</com><br />
<com> */</com><def></def><br />
<br />
<dir>#include &lt;iostream&gt;</dir><br />
<def></def><br />
<kwb>struct</kwb> <def>Node</def> <sym>{</sym><br />
<def>  Node</def> <sym>*</sym><def>l</def><sym>, *</sym><def>r</def><sym>;</sym><br />
<def></def>  <kwb>int</kwb> <def>i</def><sym>;</sym><br />
<def></def>  <kwd>Node</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i2</def><sym>) :</sym> <def></def><kwd>l</kwd><def></def><sym>(</sym><def></def><num>0</num><def></def><sym>),</sym> <def></def><kwd>r</kwd><def></def><sym>(</sym><def></def><num>0</num><def></def><sym>),</sym> <def></def><kwd>i</kwd><def></def><sym>(</sym><def>i2</def><sym>) {}</sym><br />
<def></def>  <kwd>Node</kwd><def></def><sym>(</sym><def>Node</def> <sym>*</sym><def>l2</def><sym>,</sym> <def></def><kwb>int</kwb> <def>i2</def><sym>,</sym> <def>Node</def> <sym>*</sym><def>r2</def><sym>) :</sym> <def></def><kwd>l</kwd><def></def><sym>(</sym><def>l2</def><sym>),</sym> <def></def><kwd>r</kwd><def></def><sym>(</sym><def>r2</def><sym>),</sym> <def></def><kwd>i</kwd><def></def><sym>(</sym><def>i2</def><sym>) {}</sym><br />
<def></def>  <sym>~</sym><def></def><kwd>Node</kwd><def></def><sym>() {</sym> <def></def><kwa>delete</kwa> <def>l</def><sym>;</sym> <def></def><kwa>delete</kwa> <def>r</def><sym>; }</sym><br />
<def></def>  <kwb>int</kwb> <def></def><kwd>check</kwd><def></def><sym>()</sym> <def></def><kwb>const</kwb> <def></def><sym>{</sym><br />
<def></def>	  <kwa>if</kwa> <def></def><sym>(</sym><def>l</def><sym>)</sym><br />
<def></def>		<kwa>return</kwa> <def>l</def><sym>-&gt;</sym><def></def><kwd>check</kwd><def></def><sym>() +</sym> <def>i</def> <sym>-</sym> <def>r</def><sym>-&gt;</sym><def></def><kwd>check</kwd><def></def><sym>();</sym><br />
<def></def>	  <kwa>else return</kwa> <def>i</def><sym>;</sym><br />
<def></def>  <sym>}</sym><br />
<def></def><sym>};</sym><br />
<def><br />
Node</def> <sym>*</sym><def></def><kwd>make</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i</def><sym>,</sym> <def></def><kwb>int</kwb> <def>d</def><sym>) {</sym><br />
<def></def>  <kwa>if</kwa> <def></def><sym>(</sym><def>d</def> <sym>==</sym> <def></def><num>0</num><def></def><sym>)</sym> <def></def><kwa>return new</kwa> <def></def><kwd>Node</kwd><def></def><sym>(</sym><def>i</def><sym>);</sym><br />
<def></def>  <kwa>return new</kwa> <def></def><kwd>Node</kwd><def></def><sym>(</sym><def></def><kwd>make</kwd><def></def><sym>(</sym><def></def><num>2</num><def></def><sym>*</sym><def>i</def><sym>-</sym><def></def><num>1</num><def></def><sym>,</sym> <def>d</def><sym>-</sym><def></def><num>1</num><def></def><sym>),</sym> <def>i</def><sym>,</sym> <def></def><kwd>make</kwd><def></def><sym>(</sym><def></def><num>2</num><def></def><sym>*</sym><def>i</def><sym>,</sym> <def>d</def><sym>-</sym><def></def><num>1</num><def></def><sym>));</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>int</kwb> <def></def><kwd>main</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>argc</def><sym>,</sym> <def></def><kwb>char</kwb> <def></def><sym>*</sym><def>argv</def><sym>[]) {</sym><br />
<def></def>  <kwb>int</kwb> <def>min_depth</def> <sym>=</sym> <def></def><num>4</num><def></def><sym>,</sym><br />
<def>    max_depth</def> <sym>=</sym> <def>std</def><sym>::</sym><def></def><kwd>max</kwd><def></def><sym>(</sym><def>min_depth</def><sym>+</sym><def></def><num>2</num><def></def><sym>,</sym><br />
<def></def>			 <sym>(</sym><def>argc</def> <sym>==</sym> <def></def><num>2</num> <def>?</def> <kwd>atoi</kwd><def></def><sym>(</sym><def>argv</def><sym>[</sym><def></def><num>1</num><def></def><sym>]) :</sym> <def></def><num>10</num><def></def><sym>)),</sym><br />
<def>    stretch_depth</def> <sym>=</sym> <def>max_depth</def><sym>+</sym><def></def><num>1</num><def></def><sym>;</sym><br />
<def></def><br />
  <sym>{</sym><br />
<def>    Node</def> <sym>*</sym><def>c</def> <sym>=</sym> <def></def><kwd>make</kwd><def></def><sym>(</sym><def></def><num>0</num><def></def><sym>,</sym> <def>stretch_depth</def><sym>);</sym><br />
<def>    std</def><sym>::</sym><def>cout</def> <sym>&lt;&lt;</sym> <def></def><str>&quot;stretch tree of depth &quot;</str><def></def> <sym>&lt;&lt;</sym> <def>stretch_depth</def> <sym>&lt;&lt;</sym> <def></def><str>&quot;</str><esc>\t</esc> <str>&quot;</str><def></def><br />
      <sym>&lt;&lt;</sym> <def></def><str>&quot;check: &quot;</str><def></def> <sym>&lt;&lt;</sym> <def>c</def><sym>-&gt;</sym><def></def><kwd>check</kwd><def></def><sym>() &lt;&lt;</sym> <def>std</def><sym>::</sym><def>endl</def><sym>;</sym><br />
<def></def>    <kwa>delete</kwa> <def>c</def><sym>;</sym><br />
<def></def>  <sym>}</sym><br />
<def><br />
  Node</def> <sym>*</sym><def>long_lived_tree</def><sym>=</sym><def></def><kwd>make</kwd><def></def><sym>(</sym><def></def><num>0</num><def></def><sym>,</sym> <def>max_depth</def><sym>);</sym><br />
<def></def><br />
  <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>d</def><sym>=</sym><def>min_depth</def><sym>;</sym> <def>d</def><sym>&lt;=</sym><def>max_depth</def><sym>;</sym> <def>d</def><sym>+=</sym><def></def><num>2</num><def></def><sym>) {</sym><br />
<def></def>    <kwb>int</kwb> <def>iterations</def> <sym>=</sym> <def></def><num>1</num> <def></def><sym>&lt;&lt; (</sym><def>max_depth</def> <sym>-</sym> <def>d</def> <sym>+</sym> <def>min_depth</def><sym>),</sym> <def>c</def><sym>=</sym><def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>    <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i</def><sym>=</sym><def></def><num>1</num><def></def><sym>;</sym> <def>i</def><sym>&lt;=</sym><def>iterations</def><sym>; ++</sym><def>i</def><sym>) {</sym><br />
<def>      Node</def> <sym>*</sym><def>a</def> <sym>=</sym> <def></def><kwd>make</kwd><def></def><sym>(</sym><def>i</def><sym>,</sym> <def>d</def><sym>), *</sym><def>b</def> <sym>=</sym> <def></def><kwd>make</kwd><def></def><sym>(-</sym><def>i</def><sym>,</sym> <def>d</def><sym>);</sym><br />
<def>      c</def> <sym>+=</sym> <def>a</def><sym>-&gt;</sym><def></def><kwd>check</kwd><def></def><sym>() +</sym> <def>b</def><sym>-&gt;</sym><def></def><kwd>check</kwd><def></def><sym>();</sym><br />
<def></def>      <kwa>delete</kwa> <def>a</def><sym>;</sym><br />
<def></def>      <kwa>delete</kwa> <def>b</def><sym>;</sym><br />
<def></def>    <sym>}</sym><br />
<def>    std</def><sym>::</sym><def>cout</def> <sym>&lt;&lt; (</sym><def></def><num>2</num><def></def><sym>*</sym><def>iterations</def><sym>) &lt;&lt;</sym> <def></def><str>&quot;</str><esc>\t</esc> <str>trees of depth &quot;</str><def></def> <sym>&lt;&lt;</sym> <def>d</def> <sym>&lt;&lt;</sym> <def></def><str>&quot;</str><esc>\t</esc> <str>&quot;</str><def></def><br />
	      <sym>&lt;&lt;</sym> <def></def><str>&quot;check: &quot;</str><def></def> <sym>&lt;&lt;</sym> <def>c</def> <sym>&lt;&lt;</sym> <def>std</def><sym>::</sym><def>endl</def><sym>;</sym><br />
<def></def>  <sym>}</sym><br />
<def><br />
  std</def><sym>::</sym><def>cout</def> <sym>&lt;&lt;</sym> <def></def><str>&quot;long lived tree of depth &quot;</str><def></def> <sym>&lt;&lt;</sym> <def>max_depth</def> <sym>&lt;&lt;</sym> <def></def><str>&quot;</str><esc>\t</esc> <str>&quot;</str><def></def><br />
	    <sym>&lt;&lt;</sym> <def></def><str>&quot;check: &quot;</str><def></def> <sym>&lt;&lt; (</sym><def>long_lived_tree</def><sym>-&gt;</sym><def></def><kwd>check</kwd><def></def><sym>()) &lt;&lt;</sym> <def></def><str>&quot;</str><esc>\n</esc><str>&quot;</str><def></def><sym>;</sym><br />
<def></def><br />
  <kwa>delete</kwa> <def>long_lived_tree</def><sym>;</sym><br />
<def></def><br />
  <kwa>return</kwa> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
</source>
