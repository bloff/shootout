<source>
<def></def><com>/* The Computer Language Benchmarks Game</com><br />
<com>   http://shootout.alioth.debian.org/</com><br />
<com>   transliterated from C++ (Ben St. John) and D (Michael Deardeuff) by Amir K aka Razii</com><br />
<com>*/</com><def></def><br />
<br />
<br />
<kwa>import</kwa> <def>java</def><sym>.</sym><def>util</def><sym>.*;</sym><br />
<def></def><br />
<kwa>public final class</kwa> <def>meteor</def><br />
<sym>{</sym><br />
<def></def>    <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>X</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>    <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>Y</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>    <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>N_DIM</def> <sym>=</sym> <def></def><num>2</num><def></def><sym>;</sym><br />
<def></def><br />
    <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>EVEN</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>    <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>ODD</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>    <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>N_PARITY</def> <sym>=</sym> <def></def><num>2</num><def></def><sym>;</sym><br />
<def></def><br />
    <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>GOOD</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>    <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>BAD</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>    <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>ALWAYS_BAD</def> <sym>=</sym> <def></def><num>2</num><def></def><sym>;</sym><br />
<def></def><br />
    <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>OPEN</def>    <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>    <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>CLOSED</def>  <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>    <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>N_FIXED</def> <sym>=</sym> <def></def><num>2</num><def></def><sym>;</sym><br />
<def></def><br />
    <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>MAX_ISLAND_OFFSET</def> <sym>=</sym> <def></def><num>1024</num><def></def><sym>;</sym><br />
<def></def>    <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>N_COL</def> <sym>=</sym> <def></def><num>5</num><def></def><sym>;</sym><br />
<def></def>    <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>N_ROW</def> <sym>=</sym> <def></def><num>10</num><def></def><sym>;</sym><br />
<def></def>    <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>N_CELL</def> <sym>=</sym> <def>N_COL</def> <sym>*</sym> <def>N_ROW</def><sym>;</sym><br />
<def></def>    <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>N_PIECE_TYPE</def> <sym>=</sym> <def></def><num>10</num><def></def><sym>;</sym><br />
<def></def>    <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>N_ORIENT</def> <sym>=</sym> <def></def><num>12</num><def></def><sym>;</sym><br />
<def></def><br />
<br />
<slc>//-- Globals -------------------------</slc><br />
<def></def>    <kwa>static</kwa> <def>IslandInfo</def><sym>[]</sym> <def>g_islandInfo</def> <sym>=</sym> <def></def><kwa>new</kwa> <def>IslandInfo</def> <sym>[</sym><def>MAX_ISLAND_OFFSET</def><sym>];</sym><br />
<def></def>    <kwa>static</kwa> <def></def><kwb>int</kwb> <def>g_nIslandInfo</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>    <kwa>static</kwa> <def>OkPieces</def><sym>[][]</sym> <def>g_okPieces</def> <sym>=</sym> <def></def><kwa>new</kwa> <def>OkPieces</def> <sym>[</sym><def>N_ROW</def><sym>][</sym><def>N_COL</def><sym>];</sym><br />
<def></def><br />
    <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>g_firstRegion</def><sym>[] = {</sym><br />
<def></def>        <num>0x00</num><def></def><sym>,</sym> <def></def><num>0x01</num><def></def><sym>,</sym> <def></def><num>0x02</num><def></def><sym>,</sym> <def></def><num>0x03</num><def></def><sym>,</sym>   <def></def><num>0x04</num><def></def><sym>,</sym> <def></def><num>0x01</num><def></def><sym>,</sym> <def></def><num>0x06</num><def></def><sym>,</sym> <def></def><num>0x07</num><def></def><sym>,</sym><br />
<def></def>        <num>0x08</num><def></def><sym>,</sym> <def></def><num>0x01</num><def></def><sym>,</sym> <def></def><num>0x02</num><def></def><sym>,</sym> <def></def><num>0x03</num><def></def><sym>,</sym>   <def></def><num>0x0c</num><def></def><sym>,</sym> <def></def><num>0x01</num><def></def><sym>,</sym> <def></def><num>0x0e</num><def></def><sym>,</sym> <def></def><num>0x0f</num><def></def><sym>,</sym><br />
<def></def><br />
        <num>0x10</num><def></def><sym>,</sym> <def></def><num>0x01</num><def></def><sym>,</sym> <def></def><num>0x02</num><def></def><sym>,</sym> <def></def><num>0x03</num><def></def><sym>,</sym>   <def></def><num>0x04</num><def></def><sym>,</sym> <def></def><num>0x01</num><def></def><sym>,</sym> <def></def><num>0x06</num><def></def><sym>,</sym> <def></def><num>0x07</num><def></def><sym>,</sym><br />
<def></def>        <num>0x18</num><def></def><sym>,</sym> <def></def><num>0x01</num><def></def><sym>,</sym> <def></def><num>0x02</num><def></def><sym>,</sym> <def></def><num>0x03</num><def></def><sym>,</sym>   <def></def><num>0x1c</num><def></def><sym>,</sym> <def></def><num>0x01</num><def></def><sym>,</sym> <def></def><num>0x1e</num><def></def><sym>,</sym> <def></def><num>0x1f</num><br />
<def></def>    <sym>};</sym><br />
<def></def><br />
    <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>g_flip</def><sym>[] = {</sym><br />
<def></def>        <num>0x00</num><def></def><sym>,</sym> <def></def><num>0x10</num><def></def><sym>,</sym> <def></def><num>0x08</num><def></def><sym>,</sym> <def></def><num>0x18</num><def></def><sym>,</sym> <def></def><num>0x04</num><def></def><sym>,</sym> <def></def><num>0x14</num><def></def><sym>,</sym> <def></def><num>0x0c</num><def></def><sym>,</sym> <def></def><num>0x1c</num><def></def><sym>,</sym><br />
<def></def>        <num>0x02</num><def></def><sym>,</sym> <def></def><num>0x12</num><def></def><sym>,</sym> <def></def><num>0x0a</num><def></def><sym>,</sym> <def></def><num>0x1a</num><def></def><sym>,</sym> <def></def><num>0x06</num><def></def><sym>,</sym> <def></def><num>0x16</num><def></def><sym>,</sym> <def></def><num>0x0e</num><def></def><sym>,</sym> <def></def><num>0x1e</num><def></def><sym>,</sym><br />
<def></def><br />
        <num>0x01</num><def></def><sym>,</sym> <def></def><num>0x11</num><def></def><sym>,</sym> <def></def><num>0x09</num><def></def><sym>,</sym> <def></def><num>0x19</num><def></def><sym>,</sym> <def></def><num>0x05</num><def></def><sym>,</sym> <def></def><num>0x15</num><def></def><sym>,</sym> <def></def><num>0x0d</num><def></def><sym>,</sym> <def></def><num>0x1d</num><def></def><sym>,</sym><br />
<def></def>        <num>0x03</num><def></def><sym>,</sym> <def></def><num>0x13</num><def></def><sym>,</sym> <def></def><num>0x0b</num><def></def><sym>,</sym> <def></def><num>0x1b</num><def></def><sym>,</sym> <def></def><num>0x07</num><def></def><sym>,</sym> <def></def><num>0x17</num><def></def><sym>,</sym> <def></def><num>0x0f</num><def></def><sym>,</sym> <def></def><num>0x1f</num><def></def><sym>,</sym><br />
<def></def>    <sym>};</sym><br />
<def></def><br />
    <kwa>static final</kwa> <def></def><kwb>int</kwb><def></def><sym>[]</sym> <def>s_firstOne</def> <sym>= {</sym><br />
<def></def>        <num>0</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym>   <def></def><num>2</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym><br />
<def></def>        <num>3</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym>   <def></def><num>2</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym><br />
<def></def><br />
        <num>4</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym>   <def></def><num>2</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym><br />
<def></def>        <num>3</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym>   <def></def><num>2</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym><br />
<def></def>    <sym>};</sym><br />
<def></def><br />
    <kwa>static</kwa> <def></def><kwb>int</kwb> <def></def><kwd>getMask</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iPos</def><sym>) {</sym><br />
<def></def>        <kwa>return</kwa> <def></def><sym>(</sym><def></def><num>1</num> <def></def><sym>&lt;&lt; (</sym><def>iPos</def><sym>));</sym><br />
<def></def>    <sym>}</sym><br />
<def></def><br />
    <kwa>static</kwa> <def></def><kwb>int</kwb> <def></def><kwd>floor</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>top</def><sym>,</sym> <def></def><kwb>int</kwb> <def>bot</def><sym>) {</sym><br />
<def></def>        <kwb>int</kwb> <def>toZero</def> <sym>=</sym> <def>top</def> <sym>/</sym> <def>bot</def><sym>;</sym><br />
<def></def>        <slc>// negative numbers should be rounded down, not towards zero;</slc><br />
<def></def>        <kwa>if</kwa> <def></def><sym>((</sym><def>toZero</def> <sym>*</sym> <def>bot</def> <sym>!=</sym> <def>top</def><sym>) &amp;&amp; ((</sym><def>top</def> <sym>&lt;</sym> <def></def><num>0</num><def></def><sym>) != (</sym><def>bot</def> <sym>&lt;=</sym> <def></def><num>0</num><def></def><sym>)))</sym><br />
<def>            toZero</def><sym>--;</sym><br />
<def></def><br />
        <kwa>return</kwa> <def>toZero</def><sym>;</sym><br />
<def></def>    <sym>}</sym><br />
<def></def><br />
    <kwa>static</kwa> <def></def><kwb>int</kwb> <def></def><kwd>getFirstOne</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>v</def><sym>) {</sym><br />
<def></def>        <kwb>int</kwb> <def>startPos</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>        <kwa>if</kwa> <def></def><sym>(</sym><def>v</def> <sym>==</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def></def>            <kwa>return</kwa> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def><br />
        <kwb>int</kwb> <def>iPos</def> <sym>=</sym> <def>startPos</def><sym>;</sym><br />
<def></def>        <kwb>int</kwb> <def>mask</def> <sym>=</sym> <def></def><num>0xff</num> <def></def><sym>&lt;&lt;</sym> <def>startPos</def><sym>;</sym><br />
<def></def>        <kwa>while</kwa> <def></def><sym>((</sym><def>mask</def> <sym>&amp;</sym> <def>v</def><sym>) ==</sym> <def></def><num>0</num><def></def><sym>) {</sym><br />
<def>            mask</def> <sym>&lt;&lt;=</sym> <def></def><num>8</num><def></def><sym>;</sym><br />
<def>            iPos</def> <sym>+=</sym> <def></def><num>8</num><def></def><sym>;</sym><br />
<def></def>        <sym>}</sym><br />
<def></def>        <kwb>int</kwb> <def>result</def> <sym>= (</sym><def>mask</def> <sym>&amp;</sym> <def>v</def><sym>) &gt;&gt;</sym> <def>iPos</def><sym>;</sym><br />
<def></def>        <kwb>int</kwb> <def>resultLow</def> <sym>=</sym> <def>result</def> <sym>&amp;</sym> <def></def><num>0x0f</num><def></def><sym>;</sym><br />
<def></def>        <kwa>if</kwa> <def></def><sym>(</sym><def>resultLow</def> <sym>!=</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def>            iPos</def> <sym>+=</sym> <def>s_firstOne</def><sym>[</sym><def>resultLow</def><sym>];</sym><br />
<def></def>        <kwa>else</kwa><br />
<def>            iPos</def> <sym>+=</sym> <def></def><num>4</num> <def></def><sym>+</sym> <def>s_firstOne</def><sym>[</sym><def>result</def> <sym>&gt;&gt;</sym> <def></def><num>4</num><def></def><sym>];</sym><br />
<def></def><br />
        <kwa>return</kwa> <def>iPos</def><sym>;</sym><br />
<def></def>    <sym>}</sym><br />
<def></def><br />
    <kwa>static</kwa> <def></def><kwb>int</kwb> <def></def><kwd>countOnes</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>v</def><sym>) {</sym><br />
<def></def>        <kwb>int</kwb> <def>n</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>        <kwa>while</kwa> <def></def><sym>(</sym><def>v</def> <sym>!=</sym> <def></def><num>0</num><def></def><sym>) {</sym><br />
<def>            n</def><sym>++;</sym><br />
<def>            v</def> <sym>=</sym> <def>v</def> <sym>&amp; (</sym><def>v</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def></def>        <sym>}</sym><br />
<def></def><br />
        <kwa>return</kwa> <def>n</def><sym>;</sym><br />
<def></def>    <sym>}</sym><br />
<def></def><br />
<br />
    <kwa>static</kwa> <def></def><kwb>int</kwb> <def></def><kwd>flipTwoRows</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>bits</def><sym>) {</sym><br />
<def></def>        <kwb>int</kwb> <def>flipped</def> <sym>=</sym> <def>g_flip</def><sym>[</sym><def>bits</def> <sym>&gt;&gt;</sym> <def>N_COL</def><sym>] &lt;&lt;</sym> <def>N_COL</def><sym>;</sym><br />
<def></def>        <kwa>return</kwa> <def></def><sym>(</sym><def>flipped</def> <sym>|</sym> <def>g_flip</def><sym>[</sym><def>bits</def> <sym>&amp;</sym> <def>Board</def><sym>.</sym><def>TOP_ROW</def><sym>]);</sym><br />
<def></def>    <sym>}</sym><br />
<def></def><br />
    <kwa>static</kwa> <def></def><kwb>void</kwb> <def></def><kwd>markBad</kwd><def></def><sym>(</sym><def>IslandInfo info</def><sym>,</sym> <def></def><kwb>int</kwb> <def>mask</def><sym>,</sym> <def></def><kwb>int</kwb> <def>eo</def><sym>,</sym> <def></def><kwb>boolean</kwb> <def>always</def><sym>) {</sym><br />
<def>        info</def><sym>.</sym><def>hasBad</def><sym>[</sym><def>eo</def><sym>][</sym><def>OPEN</def><sym>] |=</sym> <def>mask</def><sym>;</sym><br />
<def>        info</def><sym>.</sym><def>hasBad</def><sym>[</sym><def>eo</def><sym>][</sym><def>CLOSED</def><sym>] |=</sym> <def>mask</def><sym>;</sym><br />
<def></def><br />
        <kwa>if</kwa> <def></def><sym>(</sym><def>always</def><sym>)</sym><br />
<def>            info</def><sym>.</sym><def>alwaysBad</def><sym>[</sym><def>eo</def><sym>] |=</sym> <def>mask</def><sym>;</sym><br />
<def></def>    <sym>}</sym><br />
<def></def><br />
    <kwa>static</kwa> <def></def><kwb>void</kwb> <def></def><kwd>initGlobals</kwd><def></def><sym>() {</sym><br />
<def></def>        <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>i</def> <sym>&lt;</sym> <def>MAX_ISLAND_OFFSET</def><sym>;</sym> <def>i</def><sym>++)</sym><br />
<def></def>        <sym>{</sym><br />
<def>            g_islandInfo</def><sym>[</sym><def>i</def><sym>] =</sym> <def></def><kwa>new</kwa> <def></def><kwd>IslandInfo</kwd><def></def><sym>();</sym><br />
<def></def>        <sym>}</sym><br />
<def></def><br />
        <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>i</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>i</def><sym>++)</sym><br />
<def></def>        <sym>{</sym><br />
<def></def>            <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>j</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>j</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>j</def><sym>++)</sym><br />
<def>                g_okPieces</def><sym>[</sym><def>i</def><sym>][</sym><def>j</def><sym>] =</sym> <def></def><kwa>new</kwa> <def></def><kwd>OkPieces</kwd><def></def><sym>();</sym><br />
<def></def>        <sym>}</sym><br />
<def></def>    <sym>}</sym><br />
<def></def><br />
<br />
<slc>//-- Classes -------------------------;</slc><br />
<def></def><br />
    <kwa>static class</kwa> <def>OkPieces</def> <sym>{</sym><br />
<def></def>        <kwb>byte</kwb><def></def><sym>[]</sym> <def>nPieces</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwb>byte</kwb><def></def><sym>[</sym><def>N_PIECE_TYPE</def><sym>];</sym><br />
<def></def>        <kwb>int</kwb><def></def><sym>[][]</sym> <def>pieceVec</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwb>int</kwb><def></def><sym>[</sym><def>N_PIECE_TYPE</def><sym>][</sym><def>N_ORIENT</def><sym>];</sym><br />
<def></def>    <sym>}</sym><br />
<def></def><br />
<br />
    <kwa>static class</kwa> <def>IslandInfo</def> <sym>{</sym><br />
<def></def>        <kwb>int</kwb><def></def><sym>[][]</sym> <def>hasBad</def>  <sym>=</sym>  <def></def><kwa>new</kwa> <def></def><kwb>int</kwb><def></def><sym>[</sym><def>N_FIXED</def><sym>][</sym><def>N_PARITY</def><sym>];</sym><br />
<def></def>        <kwb>int</kwb><def></def><sym>[][]</sym> <def>isKnown</def> <sym>=</sym>  <def></def><kwa>new</kwa> <def></def><kwb>int</kwb><def></def><sym>[</sym><def>N_FIXED</def><sym>][</sym><def>N_PARITY</def><sym>];</sym><br />
<def></def>        <kwb>int</kwb><def></def><sym>[]</sym> <def>alwaysBad</def> <sym>=</sym>  <def></def><kwa>new</kwa> <def></def><kwb>int</kwb><def></def><sym>[</sym><def>N_PARITY</def><sym>];</sym><br />
<def></def>    <sym>}</sym><br />
<def></def><br />
<br />
    <kwa>static class</kwa> <def>Soln</def> <sym>{</sym><br />
<def></def>        <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>NO_PIECE</def> <sym>= -</sym><def></def><num>1</num><def></def><sym>;</sym><br />
<def></def><br />
        <kwb>boolean</kwb> <def></def><kwd>isEmpty</kwd><def></def><sym>() {</sym><br />
<def></def>            <kwa>return</kwa> <def></def><sym>(</sym><def>m_nPiece</def> <sym>==</sym> <def></def><num>0</num><def></def><sym>);</sym><br />
<def></def>        <sym>}</sym><br />
<def></def>        <kwb>void</kwb> <def></def><kwd>popPiece</kwd><def></def><sym>() {</sym><br />
<def>            m_nPiece</def><sym>--;</sym><br />
<def>            m_synched</def> <sym>=</sym> <def>false</def><sym>;</sym><br />
<def></def>        <sym>}</sym><br />
<def></def>        <kwb>void</kwb> <def></def><kwd>pushPiece</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>vec</def><sym>,</sym> <def></def><kwb>int</kwb> <def>iPiece</def><sym>,</sym> <def></def><kwb>int</kwb> <def>row</def><sym>) {</sym><br />
<def>            SPiece p</def> <sym>=</sym> <def>m_pieces</def><sym>[</sym><def>m_nPiece</def><sym>++];</sym><br />
<def>            p</def><sym>.</sym><def>vec</def> <sym>=</sym> <def>vec</def><sym>;</sym><br />
<def>            p</def><sym>.</sym><def>iPiece</def> <sym>= (</sym><def></def><kwb>short</kwb><def></def><sym>)</sym> <def>iPiece</def><sym>;</sym><br />
<def>            p</def><sym>.</sym><def>row</def> <sym>= (</sym><def></def><kwb>short</kwb><def></def><sym>)</sym> <def>row</def><sym>;</sym><br />
<def></def>        <sym>}</sym><br />
<def></def><br />
        <kwd>Soln</kwd><def></def><sym>() {</sym><br />
<def>            m_synched</def> <sym>=</sym> <def>false</def><sym>;</sym><br />
<def>            m_nPiece</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>            <kwd>init</kwd><def></def><sym>();</sym><br />
<def></def>        <sym>}</sym><br />
<def></def><br />
        <kwa>class</kwa> <def>SPiece</def> <sym>{</sym><br />
<def></def>            <kwb>int</kwb> <def>vec</def><sym>;</sym><br />
<def></def>            <kwb>short</kwb> <def>iPiece</def><sym>;</sym><br />
<def></def>            <kwb>short</kwb> <def>row</def><sym>;</sym><br />
<def></def>            <kwd>SPiece</kwd><def></def><sym>() {}</sym><br />
<def></def>            <kwd>SPiece</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>avec</def><sym>,</sym> <def></def><kwb>int</kwb> <def>apiece</def><sym>,</sym> <def></def><kwb>int</kwb> <def>arow</def><sym>) {</sym><br />
<def>                vec</def> <sym>=</sym> <def>avec</def><sym>;</sym><br />
<def>                iPiece</def> <sym>= (</sym><def></def><kwb>short</kwb><def></def><sym>)</sym><def>apiece</def><sym>;</sym><br />
<def>                row</def> <sym>= (</sym><def></def><kwb>short</kwb><def></def><sym>)</sym><def>arow</def><sym>;</sym><br />
<def></def>            <sym>}</sym><br />
<def></def>            <kwd>SPiece</kwd><def></def><sym>(</sym><def>SPiece other</def><sym>) {</sym><br />
<def>                vec</def> <sym>=</sym> <def>other</def><sym>.</sym><def>vec</def><sym>;</sym><br />
<def>                iPiece</def> <sym>=</sym> <def>other</def><sym>.</sym><def>iPiece</def><sym>;</sym><br />
<def>                row</def> <sym>=</sym> <def>other</def><sym>.</sym><def>row</def><sym>;</sym><br />
<def></def>            <sym>}</sym><br />
<def></def>        <sym>}</sym><br />
<def><br />
        SPiece</def><sym>[]</sym> <def>m_pieces</def> <sym>=</sym> <def></def><kwa>new</kwa> <def>SPiece</def> <sym>[</sym><def>N_PIECE_TYPE</def><sym>];</sym><br />
<def></def>        <kwb>int</kwb> <def>m_nPiece</def><sym>;</sym><br />
<def></def>        <kwb>byte</kwb><def></def><sym>[][]</sym> <def>m_cells</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwb>byte</kwb> <def></def><sym>[</sym><def>N_ROW</def><sym>][</sym><def>N_COL</def><sym>];</sym><br />
<def></def>        <kwb>boolean</kwb> <def>m_synched</def><sym>;</sym><br />
<def></def><br />
        <kwb>void</kwb> <def></def><kwd>init</kwd><def></def><sym>() {</sym><br />
<def></def>            <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>i</def> <sym>&lt;</sym> <def>N_PIECE_TYPE</def><sym>;</sym> <def>i</def><sym>++)</sym><br />
<def>                m_pieces</def><sym>[</sym><def>i</def><sym>] =</sym> <def></def><kwa>new</kwa> <def></def><kwd>SPiece</kwd><def></def><sym>();</sym><br />
<def></def>        <sym>}</sym><br />
<def></def>        <kwd>Soln</kwd> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>fillVal</def><sym>) {</sym><br />
<def></def>            <kwd>init</kwd><def></def><sym>();</sym><br />
<def>            m_nPiece</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>            <kwd>fill</kwd><def></def><sym>(</sym><def>fillVal</def><sym>);</sym><br />
<def></def>        <sym>}</sym><br />
<def></def>        <kwa>public</kwa> <def>Soln</def> <kwd>clone2</kwd><def></def><sym>() {</sym><br />
<def>            Soln s</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>Soln</kwd><def></def><sym>();</sym><br />
<def></def>            <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>i</def> <sym>&lt;</sym> <def>m_pieces</def><sym>.</sym><def>length</def><sym>;</sym> <def>i</def><sym>++)</sym><br />
<def>                s</def><sym>.</sym><def>m_pieces</def><sym>[</sym><def>i</def><sym>] =</sym> <def></def><kwa>new</kwa> <def></def><kwd>SPiece</kwd><def></def><sym>(</sym><def>m_pieces</def><sym>[</sym><def>i</def><sym>]);</sym><br />
<def><br />
            s</def><sym>.</sym><def>m_nPiece</def> <sym>=</sym> <def>m_nPiece</def><sym>;</sym><br />
<def></def>            <slc>//System.arraycopy(m_cells, 0, s.m_cells, 0, N_CELL);</slc><br />
<def></def>            <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>i</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>i</def><sym>++)</sym><br />
<def></def>            <sym>{</sym><br />
<def></def>                <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>j</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>j</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>j</def> <sym>++)</sym><br />
<def></def>                <sym>{</sym><br />
<def>                    s</def><sym>.</sym><def>m_cells</def><sym>[</sym><def>i</def><sym>][</sym><def>j</def><sym>] =</sym> <def>m_cells</def><sym>[</sym><def>i</def><sym>][</sym><def>j</def><sym>];</sym><br />
<def></def>                <sym>}</sym><br />
<def></def>            <sym>}</sym><br />
<def><br />
            s</def><sym>.</sym><def>m_synched</def> <sym>=</sym> <def>m_synched</def><sym>;</sym><br />
<def></def>            <kwa>return</kwa> <def>s</def><sym>;</sym><br />
<def></def>        <sym>}</sym><br />
<def></def><br />
        <kwb>void</kwb> <def></def><kwd>fill</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>val</def><sym>) {</sym><br />
<def>            m_synched</def> <sym>=</sym> <def>false</def><sym>;</sym><br />
<def></def>            <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>i</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>i</def><sym>++)</sym><br />
<def></def>            <sym>{</sym><br />
<def></def>                <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>j</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>j</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>j</def><sym>++)</sym><br />
<def>                    m_cells</def><sym>[</sym><def>i</def><sym>][</sym><def>j</def><sym>] = (</sym><def></def><kwb>byte</kwb><def></def><sym>)</sym> <def>val</def><sym>;</sym><br />
<def></def>            <sym>}</sym><br />
<def></def>        <sym>}</sym><br />
<def></def><br />
        <kwa>public</kwa> <def></def><kwc>String</kwc> <def></def><kwd>toString</kwd><def></def><sym>()  {</sym><br />
<def></def>            <kwc>StringBuffer</kwc> <def>result</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwc>StringBuffer</kwc><def></def><sym>(</sym><def>N_CELL</def> <sym>*</sym> <def></def><num>2</num><def></def><sym>);</sym><br />
<def></def><br />
            <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>y</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>y</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>y</def><sym>++) {</sym><br />
<def></def>                <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>x</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>x</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>x</def><sym>++) {</sym><br />
<def></def>                    <kwb>int</kwb> <def>val</def> <sym>=</sym> <def>m_cells</def><sym>[</sym><def>y</def><sym>][</sym><def>x</def><sym>];</sym><br />
<def></def>                    <slc>//if (val == NO_PIECE) result.append('.');</slc><br />
<def></def>                    <sym>{</sym><br />
<def>                        result</def><sym>.</sym><def></def><kwd>append</kwd><def></def><sym>(</sym><def>val</def><sym>);</sym><br />
<def></def>                    <sym>}</sym><br />
<def>                    result</def><sym>.</sym><def></def><kwd>append</kwd><def></def><sym>(</sym><def></def><str>' '</str><def></def><sym>);</sym><br />
<def></def>                <sym>}</sym><br />
<def>                result</def><sym>.</sym><def></def><kwd>append</kwd><def></def><sym>(</sym><def></def><str>'</str><esc>\n</esc><str>'</str><def></def><sym>);</sym><br />
<def></def><br />
                <slc>// indent every second line</slc><br />
<def></def>                <kwa>if</kwa> <def></def><sym>(</sym><def>y</def> <sym>%</sym> <def></def><num>2</num> <def></def><sym>==</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def>                    result</def><sym>.</sym><def></def><kwd>append</kwd><def></def><sym>(</sym><def></def><str>&quot; &quot;</str><def></def><sym>);</sym><br />
<def></def>            <sym>}</sym><br />
<def></def>            <kwa>return</kwa> <def>result</def><sym>.</sym><def></def><kwd>toString</kwd><def></def><sym>();</sym><br />
<def></def>        <sym>}</sym><br />
<def></def><br />
        <kwb>void</kwb> <def></def><kwd>setCells</kwd><def></def><sym>() {</sym><br />
<def></def>            <kwa>if</kwa> <def></def><sym>(</sym><def>m_synched</def><sym>)</sym><br />
<def></def>                <kwa>return</kwa><def></def><sym>;</sym><br />
<def></def><br />
            <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iPiece</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iPiece</def> <sym>&lt;</sym> <def>m_nPiece</def><sym>;</sym> <def>iPiece</def><sym>++) {</sym><br />
<def>                SPiece p</def> <sym>=</sym> <def>m_pieces</def><sym>[</sym><def>iPiece</def><sym>];</sym><br />
<def></def>                <kwb>int</kwb> <def>vec</def> <sym>=</sym> <def>p</def><sym>.</sym><def>vec</def><sym>;</sym><br />
<def></def>                <kwb>byte</kwb> <def>pID</def> <sym>= (</sym><def></def><kwb>byte</kwb><def></def><sym>)</sym> <def>p</def><sym>.</sym><def>iPiece</def><sym>;</sym><br />
<def></def>                <kwb>int</kwb> <def>rowOffset</def> <sym>=</sym> <def>p</def><sym>.</sym><def>row</def><sym>;</sym><br />
<def></def><br />
                <kwb>int</kwb> <def>nNewCells</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>                <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>y</def> <sym>=</sym> <def>rowOffset</def><sym>;</sym> <def>y</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>y</def><sym>++) {</sym><br />
<def></def>                    <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>x</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>x</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>x</def><sym>++) {</sym><br />
<def></def>                        <kwa>if</kwa> <def></def><sym>((</sym><def>vec</def> <sym>&amp;</sym> <def></def><num>1</num><def></def><sym>) !=</sym> <def></def><num>0</num><def></def><sym>) {</sym><br />
<def>                            m_cells</def><sym>[</sym><def>y</def><sym>][</sym><def>x</def><sym>] =</sym> <def>pID</def><sym>;</sym><br />
<def>                            nNewCells</def><sym>++;</sym><br />
<def></def>                        <sym>}</sym><br />
<def>                        vec</def> <sym>&gt;&gt;=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>                    <sym>}</sym><br />
<def></def>                    <kwa>if</kwa> <def></def><sym>(</sym><def>nNewCells</def> <sym>==</sym> <def>Piece</def><sym>.</sym><def>N_ELEM</def><sym>)</sym><br />
<def></def>                        <kwa>break</kwa><def></def><sym>;</sym><br />
<def></def>                <sym>}</sym><br />
<def></def>            <sym>}</sym><br />
<def>            m_synched</def> <sym>=</sym> <def>true</def><sym>;</sym><br />
<def></def>        <sym>}</sym><br />
<def></def><br />
        <kwb>boolean</kwb> <def></def><kwd>lessThan</kwd><def></def><sym>(</sym><def>Soln r</def><sym>) {</sym><br />
<def></def>            <kwa>if</kwa> <def></def><sym>(</sym><def>m_pieces</def><sym>[</sym><def></def><num>0</num><def></def><sym>].</sym><def>iPiece</def> <sym>!=</sym> <def>r</def><sym>.</sym><def>m_pieces</def><sym>[</sym><def></def><num>0</num><def></def><sym>].</sym><def>iPiece</def><sym>) {</sym><br />
<def></def>                <kwa>return</kwa> <def>m_pieces</def><sym>[</sym><def></def><num>0</num><def></def><sym>].</sym><def>iPiece</def> <sym>&lt;</sym> <def>r</def><sym>.</sym><def>m_pieces</def><sym>[</sym><def></def><num>0</num><def></def><sym>].</sym><def>iPiece</def><sym>;</sym><br />
<def></def>            <sym>}</sym><br />
<def></def><br />
            <kwd>setCells</kwd><def></def><sym>();</sym><br />
<def>            r</def><sym>.</sym><def></def><kwd>setCells</kwd><def></def><sym>();</sym><br />
<def></def><br />
            <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>y</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>y</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>y</def><sym>++) {</sym><br />
<def></def>                <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>x</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>x</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>x</def><sym>++) {</sym><br />
<def></def>                    <kwb>int</kwb> <def>lval</def> <sym>=</sym> <def>m_cells</def><sym>[</sym><def>y</def><sym>][</sym><def>x</def><sym>];</sym><br />
<def></def>                    <kwb>int</kwb> <def>rval</def> <sym>=</sym> <def>r</def><sym>.</sym><def>m_cells</def><sym>[</sym><def>y</def><sym>][</sym><def>x</def><sym>];</sym><br />
<def></def><br />
                    <kwa>if</kwa> <def></def><sym>(</sym><def>lval</def> <sym>!=</sym> <def>rval</def><sym>)</sym><br />
<def></def>                        <kwa>return</kwa> <def></def><sym>(</sym><def>lval</def> <sym>&lt;</sym> <def>rval</def><sym>);</sym><br />
<def></def>                <sym>}</sym><br />
<def></def>            <sym>}</sym><br />
<def></def><br />
            <kwa>return</kwa> <def>false</def><sym>;</sym><br />
<def></def>        <sym>}</sym><br />
<def></def><br />
        <kwb>void</kwb> <def></def><kwd>spin</kwd><def></def><sym>(</sym><def>Soln spun</def><sym>) {</sym><br />
<def></def>            <kwd>setCells</kwd><def></def><sym>();</sym><br />
<def></def><br />
            <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>y</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>y</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>y</def><sym>++) {</sym><br />
<def></def>                <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>x</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>x</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>x</def><sym>++) {</sym><br />
<def></def>                    <kwb>byte</kwb> <def>flipped</def> <sym>=</sym> <def>m_cells</def><sym>[</sym><def>N_ROW</def> <sym>-</sym> <def>y</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>][</sym><def>N_COL</def> <sym>-</sym> <def>x</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>];</sym><br />
<def>                    spun</def><sym>.</sym><def>m_cells</def><sym>[</sym><def>y</def><sym>][</sym><def>x</def><sym>] =</sym> <def>flipped</def><sym>;</sym><br />
<def></def>                <sym>}</sym><br />
<def></def>            <sym>}</sym><br />
<def><br />
<br />
            spun</def><sym>.</sym><def>m_pieces</def><sym>[</sym><def></def><num>0</num><def></def><sym>].</sym><def>iPiece</def> <sym>=</sym> <def>m_pieces</def><sym>[</sym><def>N_PIECE_TYPE</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>].</sym><def>iPiece</def><sym>;</sym><br />
<def>            spun</def><sym>.</sym><def>m_synched</def> <sym>=</sym> <def>true</def><sym>;</sym><br />
<def></def>        <sym>}</sym><br />
<def></def>    <sym>}</sym><br />
<def></def><br />
<br />
<slc>//-----------------------</slc><br />
<def></def>    <kwa>static class</kwa> <def>Board</def> <sym>{</sym><br />
<def></def>        <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>L_EDGE_MASK</def> <sym>=</sym><br />
<def></def>                                       <sym>((</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym>  <def></def><num>0</num><def></def><sym>) | (</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym>  <def></def><num>5</num><def></def><sym>) | (</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def></def><num>10</num><def></def><sym>) | (</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def></def><num>15</num><def></def><sym>) |</sym><br />
<def></def>                                        <sym>(</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def></def><num>20</num><def></def><sym>) | (</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def></def><num>25</num><def></def><sym>) | (</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def></def><num>30</num><def></def><sym>));</sym><br />
<def></def>        <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>R_EDGE_MASK</def> <sym>=</sym> <def>L_EDGE_MASK</def> <sym>&lt;&lt;</sym> <def></def><num>4</num><def></def><sym>;</sym><br />
<def></def>        <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>TOP_ROW</def> <sym>= (</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def>N_COL</def><sym>) -</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>        <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>ROW_0_MASK</def> <sym>=</sym><br />
<def>            TOP_ROW</def> <sym>| (</sym><def>TOP_ROW</def> <sym>&lt;&lt;</sym> <def></def><num>10</num><def></def><sym>) | (</sym><def>TOP_ROW</def> <sym>&lt;&lt;</sym> <def></def><num>20</num><def></def><sym>) | (</sym><def>TOP_ROW</def> <sym>&lt;&lt;</sym> <def></def><num>30</num><def></def><sym>);</sym><br />
<def></def>        <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>ROW_1_MASK</def> <sym>=</sym> <def>ROW_0_MASK</def> <sym>&lt;&lt;</sym> <def></def><num>5</num><def></def><sym>;</sym><br />
<def></def>        <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>BOARD_MASK</def> <sym>= (</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def></def><num>30</num><def></def><sym>) -</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def><br />
        <kwa>static</kwa> <def></def><kwb>int</kwb> <def></def><kwd>getIndex</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>x</def><sym>,</sym> <def></def><kwb>int</kwb> <def>y</def><sym>) {</sym><br />
<def></def>            <kwa>return</kwa> <def>y</def> <sym>*</sym> <def>N_COL</def> <sym>+</sym> <def>x</def><sym>;</sym><br />
<def></def>        <sym>}</sym><br />
<def><br />
        Soln m_curSoln</def><sym>;</sym><br />
<def>        Soln m_minSoln</def><sym>;</sym><br />
<def>        Soln m_maxSoln</def><sym>;</sym><br />
<def></def>        <kwb>int</kwb> <def>m_nSoln</def><sym>;</sym><br />
<def></def><br />
        <kwd>Board</kwd> <def></def><sym>() {</sym><br />
<def>            m_curSoln</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>Soln</kwd><def></def><sym>(</sym><def>Soln</def><sym>.</sym><def>NO_PIECE</def><sym>);</sym><br />
<def>            m_minSoln</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>Soln</kwd><def></def><sym>(</sym><def>N_PIECE_TYPE</def><sym>);</sym><br />
<def>            m_maxSoln</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>Soln</kwd><def></def><sym>(</sym><def>Soln</def><sym>.</sym><def>NO_PIECE</def><sym>);</sym><br />
<def>            m_nSoln</def> <sym>= (</sym><def></def><num>0</num><def></def><sym>);</sym><br />
<def></def>        <sym>}</sym><br />
<def></def><br />
        <kwa>static</kwa> <def></def><kwb>boolean</kwb> <def></def><kwd>badRegion</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb><def></def><sym>[]</sym> <def>toFill</def><sym>,</sym> <def></def><kwb>int</kwb> <def>rNew</def><sym>)</sym><br />
<def></def>        <sym>{</sym><br />
<def></def>            <slc>// grow empty region, until it doesn't change any more;</slc><br />
<def></def>            <kwb>int</kwb> <def>region</def><sym>;</sym><br />
<def></def>            <kwa>do</kwa> <def></def><sym>{</sym><br />
<def>                region</def> <sym>=</sym> <def>rNew</def><sym>;</sym><br />
<def></def><br />
                <slc>// simple grow up/down</slc><br />
<def>                rNew</def> <sym>|= (</sym><def>region</def> <sym>&gt;&gt;</sym> <def>N_COL</def><sym>);</sym><br />
<def>                rNew</def> <sym>|= (</sym><def>region</def> <sym>&lt;&lt;</sym> <def>N_COL</def><sym>);</sym><br />
<def></def><br />
                <slc>// grow right/left</slc><br />
<def>                rNew</def> <sym>|= (</sym><def>region</def> <sym>&amp;</sym> <def>~L_EDGE_MASK</def><sym>) &gt;&gt;</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def>                rNew</def> <sym>|= (</sym><def>region</def> <sym>&amp;</sym> <def>~R_EDGE_MASK</def><sym>) &lt;&lt;</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def><br />
                <slc>// tricky growth</slc><br />
<def></def>                <kwb>int</kwb> <def>evenRegion</def> <sym>=</sym> <def>region</def> <sym>&amp; (</sym><def>ROW_0_MASK</def> <sym>&amp;</sym> <def>~L_EDGE_MASK</def><sym>);</sym><br />
<def>                rNew</def> <sym>|=</sym> <def>evenRegion</def> <sym>&gt;&gt; (</sym><def>N_COL</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def>                rNew</def> <sym>|=</sym> <def>evenRegion</def> <sym>&lt;&lt; (</sym><def>N_COL</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def></def>                <kwb>int</kwb> <def>oddRegion</def> <sym>=</sym> <def>region</def> <sym>&amp; (</sym><def>ROW_1_MASK</def> <sym>&amp;</sym> <def>~R_EDGE_MASK</def><sym>);</sym><br />
<def>                rNew</def> <sym>|=</sym> <def>oddRegion</def> <sym>&gt;&gt; (</sym><def>N_COL</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def>                rNew</def> <sym>|=</sym> <def>oddRegion</def> <sym>&lt;&lt; (</sym><def>N_COL</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def></def><br />
                <slc>// clamp against existing pieces</slc><br />
<def>                rNew</def> <sym>&amp;=</sym> <def>toFill</def><sym>[</sym><def></def><num>0</num><def></def><sym>];</sym><br />
<def></def>            <sym>}</sym><br />
<def></def>            <kwa>while</kwa> <def></def><sym>((</sym><def>rNew</def> <sym>!=</sym> <def>toFill</def><sym>[</sym><def></def><num>0</num><def></def><sym>]) &amp;&amp; (</sym><def>rNew</def> <sym>!=</sym> <def>region</def><sym>));</sym><br />
<def></def><br />
            <slc>// subtract empty region from board</slc><br />
<def>            toFill</def><sym>[</sym><def></def><num>0</num><def></def><sym>]</sym> <def>^</def><sym>=</sym> <def>rNew</def><sym>;</sym><br />
<def></def><br />
            <kwb>int</kwb> <def>nCells</def> <sym>=</sym> <def></def><kwd>countOnes</kwd><def></def><sym>(</sym><def>toFill</def><sym>[</sym><def></def><num>0</num><def></def><sym>]);</sym><br />
<def></def>            <kwa>return</kwa> <def></def><sym>(</sym><def>nCells</def> <sym>%</sym> <def>Piece</def><sym>.</sym><def>N_ELEM</def> <sym>!=</sym> <def></def><num>0</num><def></def><sym>);</sym><br />
<def></def>        <sym>}</sym><br />
<def></def><br />
        <kwa>static</kwa> <def></def><kwb>int</kwb> <def></def><kwd>hasBadIslands</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>boardVec</def><sym>,</sym> <def></def><kwb>int</kwb> <def>row</def><sym>)</sym><br />
<def></def>        <sym>{</sym><br />
<def></def>            <slc>// skip over any filled rows</slc><br />
<def></def>            <kwa>while</kwa> <def></def><sym>((</sym><def>boardVec</def> <sym>&amp;</sym> <def>TOP_ROW</def><sym>) ==</sym> <def>TOP_ROW</def><sym>) {</sym><br />
<def>                boardVec</def> <sym>&gt;&gt;=</sym> <def>N_COL</def><sym>;</sym><br />
<def>                row</def><sym>++;</sym><br />
<def></def>            <sym>}</sym><br />
<def></def><br />
            <kwb>int</kwb> <def>iInfo</def> <sym>=</sym> <def>boardVec</def> <sym>&amp; ((</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def></def><num>2</num> <def></def><sym>*</sym> <def>N_COL</def><sym>) -</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def>            IslandInfo info</def> <sym>=</sym> <def>g_islandInfo</def><sym>[</sym><def>iInfo</def><sym>];</sym><br />
<def></def><br />
            <kwb>int</kwb> <def>lastRow</def> <sym>= (</sym><def>boardVec</def> <sym>&gt;&gt; (</sym><def></def><num>2</num> <def></def><sym>*</sym> <def>N_COL</def><sym>)) &amp;</sym> <def>TOP_ROW</def><sym>;</sym><br />
<def></def>            <kwb>int</kwb> <def>mask</def> <sym>=</sym> <def></def><kwd>getMask</kwd><def></def><sym>(</sym><def>lastRow</def><sym>);</sym><br />
<def></def>            <kwb>int</kwb> <def>isOdd</def> <sym>=</sym> <def>row</def> <sym>&amp;</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def><br />
            <kwa>if</kwa> <def></def><sym>((</sym><def>info</def><sym>.</sym><def>alwaysBad</def><sym>[</sym><def>isOdd</def><sym>] &amp;</sym> <def>mask</def><sym>) !=</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def></def>                <kwa>return</kwa> <def>BAD</def><sym>;</sym><br />
<def></def><br />
            <kwa>if</kwa> <def></def><sym>((</sym><def>boardVec</def> <sym>&amp; (</sym><def>TOP_ROW</def> <sym>&lt;&lt;</sym> <def>N_COL</def> <sym>*</sym> <def></def><num>3</num><def></def><sym>)) !=</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def></def>                <kwa>return</kwa> <def></def><kwd>calcBadIslands</kwd><def></def><sym>(</sym><def>boardVec</def><sym>,</sym> <def>row</def><sym>);</sym><br />
<def></def><br />
            <kwb>int</kwb> <def>isClosed</def> <sym>= (</sym><def>row</def> <sym>&gt;</sym> <def></def><num>6</num><def></def><sym>)</sym> <def>?</def> <num>1</num> <def></def><sym>:</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def><br />
            <kwa>if</kwa> <def></def><sym>((</sym><def>info</def><sym>.</sym><def>isKnown</def><sym>[</sym><def>isOdd</def><sym>][</sym><def>isClosed</def><sym>] &amp;</sym> <def>mask</def><sym>) !=</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def></def>                <kwa>return</kwa> <def></def><sym>(</sym><def>info</def><sym>.</sym><def>hasBad</def><sym>[</sym><def>isOdd</def><sym>][</sym><def>isClosed</def><sym>] &amp;</sym> <def>mask</def><sym>);</sym><br />
<def></def><br />
            <kwa>if</kwa> <def></def><sym>(</sym><def>boardVec</def> <sym>==</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def></def>                <kwa>return</kwa> <def>GOOD</def><sym>;</sym><br />
<def></def><br />
            <kwb>int</kwb> <def>hasBad</def> <sym>=</sym> <def></def><kwd>calcBadIslands</kwd><def></def><sym>(</sym><def>boardVec</def><sym>,</sym> <def>row</def><sym>);</sym><br />
<def><br />
            info</def><sym>.</sym><def>isKnown</def><sym>[</sym><def>isOdd</def><sym>][</sym><def>isClosed</def><sym>] |=</sym> <def>mask</def><sym>;</sym><br />
<def></def>            <kwa>if</kwa> <def></def><sym>(</sym><def>hasBad</def> <sym>!=</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def>                info</def><sym>.</sym><def>hasBad</def><sym>[</sym><def>isOdd</def><sym>][</sym><def>isClosed</def><sym>] |=</sym> <def>mask</def><sym>;</sym><br />
<def></def><br />
            <kwa>return</kwa> <def>hasBad</def><sym>;</sym><br />
<def></def>        <sym>}</sym><br />
<def></def>        <kwa>static</kwa> <def></def><kwb>int</kwb> <def></def><kwd>calcBadIslands</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>boardVec</def><sym>,</sym> <def></def><kwb>int</kwb> <def>row</def><sym>)</sym><br />
<def></def>        <sym>{</sym><br />
<def></def>            <kwb>int</kwb><def></def><sym>[]</sym> <def>toFill</def> <sym>= {</sym><def>~boardVec</def><sym>};</sym><br />
<def></def>            <kwa>if</kwa> <def></def><sym>((</sym><def>row</def> <sym>&amp;</sym> <def></def><num>1</num><def></def><sym>) !=</sym> <def></def><num>0</num><def></def><sym>) {</sym><br />
<def>                row</def><sym>--;</sym><br />
<def>                toFill</def><sym>[</sym><def></def><num>0</num><def></def><sym>] &lt;&lt;=</sym> <def>N_COL</def><sym>;</sym><br />
<def></def>            <sym>}</sym><br />
<def></def><br />
            <kwb>int</kwb> <def>boardMask</def> <sym>=</sym> <def>BOARD_MASK</def><sym>;</sym><br />
<def></def>            <kwa>if</kwa> <def></def><sym>(</sym><def>row</def> <sym>&gt;</sym> <def></def><num>4</num><def></def><sym>) {</sym><br />
<def></def>                <kwb>int</kwb> <def>boardMaskShift</def> <sym>= (</sym><def>row</def> <sym>-</sym> <def></def><num>4</num><def></def><sym>) *</sym> <def>N_COL</def><sym>;</sym><br />
<def>                boardMask</def> <sym>&gt;&gt;=</sym> <def>boardMaskShift</def><sym>;</sym><br />
<def></def>            <sym>}</sym><br />
<def>            toFill</def><sym>[</sym><def></def><num>0</num><def></def><sym>] &amp;=</sym> <def>boardMask</def><sym>;</sym><br />
<def></def><br />
            <slc>// a little pre-work to speed things up</slc><br />
<def></def>            <kwb>int</kwb> <def>bottom</def> <sym>= (</sym><def>TOP_ROW</def> <sym>&lt;&lt; (</sym><def></def><num>5</num> <def></def><sym>*</sym> <def>N_COL</def><sym>));</sym><br />
<def></def>            <kwb>boolean</kwb> <def>filled</def> <sym>= ((</sym><def>bottom</def> <sym>&amp;</sym> <def>toFill</def><sym>[</sym><def></def><num>0</num><def></def><sym>]) ==</sym> <def>bottom</def><sym>);</sym><br />
<def></def>            <kwa>while</kwa> <def></def><sym>((</sym><def>bottom</def> <sym>&amp;</sym> <def>toFill</def><sym>[</sym><def></def><num>0</num><def></def><sym>]) ==</sym> <def>bottom</def><sym>) {</sym><br />
<def>                toFill</def><sym>[</sym><def></def><num>0</num><def></def><sym>]</sym> <def>^</def><sym>=</sym> <def>bottom</def><sym>;</sym><br />
<def>                bottom</def> <sym>&gt;&gt;=</sym> <def>N_COL</def><sym>;</sym><br />
<def></def>            <sym>}</sym><br />
<def></def><br />
            <kwb>int</kwb> <def>startRegion</def><sym>;</sym><br />
<def></def>            <kwa>if</kwa> <def></def><sym>(</sym><def>filled</def> <sym>|| (</sym><def>row</def> <sym>&lt;</sym> <def></def><num>4</num><def></def><sym>))</sym><br />
<def>                startRegion</def> <sym>=</sym> <def>bottom</def> <sym>&amp;</sym> <def>toFill</def><sym>[</sym><def></def><num>0</num><def></def><sym>];</sym><br />
<def></def>            <kwa>else</kwa> <def></def><sym>{</sym><br />
<def>                startRegion</def> <sym>=</sym> <def>g_firstRegion</def><sym>[</sym><def>toFill</def><sym>[</sym><def></def><num>0</num><def></def><sym>] &amp;</sym> <def>TOP_ROW</def><sym>];</sym><br />
<def></def>                <kwa>if</kwa> <def></def><sym>(</sym><def>startRegion</def> <sym>==</sym> <def></def><num>0</num><def></def><sym>)  {</sym><br />
<def>                    startRegion</def> <sym>= (</sym><def>toFill</def><sym>[</sym><def></def><num>0</num><def></def><sym>] &gt;&gt;</sym> <def>N_COL</def><sym>) &amp;</sym> <def>TOP_ROW</def><sym>;</sym><br />
<def>                    startRegion</def> <sym>=</sym> <def>g_firstRegion</def><sym>[</sym><def>startRegion</def><sym>];</sym><br />
<def>                    startRegion</def> <sym>&lt;&lt;=</sym> <def>N_COL</def><sym>;</sym><br />
<def></def>                <sym>}</sym><br />
<def>                startRegion</def> <sym>|= (</sym><def>startRegion</def> <sym>&lt;&lt;</sym> <def>N_COL</def><sym>) &amp;</sym> <def>toFill</def><sym>[</sym><def></def><num>0</num><def></def><sym>];</sym><br />
<def></def>            <sym>}</sym><br />
<def></def><br />
            <kwa>while</kwa> <def></def><sym>(</sym><def>toFill</def><sym>[</sym><def></def><num>0</num><def></def><sym>] !=</sym> <def></def><num>0</num><def></def><sym>)    {</sym><br />
<def></def>                <kwa>if</kwa> <def></def><sym>(</sym><def></def><kwd>badRegion</kwd><def></def><sym>(</sym><def>toFill</def><sym>,</sym> <def>startRegion</def><sym>))</sym><br />
<def></def>                    <kwa>return</kwa> <def></def><sym>((</sym><def>toFill</def><sym>[</sym><def></def><num>0</num><def></def><sym>]!=</sym><def></def><num>0</num><def></def><sym>)</sym> <def>? ALWAYS_BAD</def> <sym>:</sym> <def>BAD</def><sym>);</sym><br />
<def></def>                <kwb>int</kwb> <def>iPos</def> <sym>=</sym> <def></def><kwd>getFirstOne</kwd><def></def><sym>(</sym><def>toFill</def><sym>[</sym><def></def><num>0</num><def></def><sym>]);</sym><br />
<def>                startRegion</def> <sym>=</sym> <def></def><kwd>getMask</kwd><def></def><sym>(</sym><def>iPos</def><sym>);</sym><br />
<def></def>            <sym>}</sym><br />
<def></def><br />
            <kwa>return</kwa> <def>GOOD</def><sym>;</sym><br />
<def></def>        <sym>}</sym><br />
<def></def>        <kwa>static</kwa> <def></def><kwb>void</kwb> <def></def><kwd>calcAlwaysBad</kwd><def></def><sym>() {</sym><br />
<def></def>            <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iWord</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym> <def>iWord</def> <sym>&lt;</sym> <def>MAX_ISLAND_OFFSET</def><sym>;</sym> <def>iWord</def><sym>++) {</sym><br />
<def>                IslandInfo isleInfo</def> <sym>=</sym> <def>g_islandInfo</def><sym>[</sym><def>iWord</def><sym>];</sym><br />
<def>                IslandInfo flipped</def> <sym>=</sym> <def>g_islandInfo</def><sym>[</sym><def></def><kwd>flipTwoRows</kwd><def></def><sym>(</sym><def>iWord</def><sym>)];</sym><br />
<def></def><br />
                <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>,</sym> <def>mask</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym> <def>i</def> <sym>&lt;</sym> <def></def><num>32</num><def></def><sym>;</sym> <def>i</def><sym>++,</sym> <def>mask</def> <sym>&lt;&lt;=</sym> <def></def><num>1</num><def></def><sym>) {</sym><br />
<def></def>                    <kwb>int</kwb> <def>boardVec</def> <sym>= (</sym><def>i</def> <sym>&lt;&lt; (</sym><def></def><num>2</num> <def></def><sym>*</sym> <def>N_COL</def><sym>)) |</sym> <def>iWord</def><sym>;</sym><br />
<def></def>                    <kwa>if</kwa> <def></def><sym>((</sym><def>isleInfo</def><sym>.</sym><def>isKnown</def><sym>[</sym><def></def><num>0</num><def></def><sym>][</sym><def>OPEN</def><sym>] &amp;</sym> <def>mask</def><sym>) !=</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def></def>                        <kwa>continue</kwa><def></def><sym>;</sym><br />
<def></def><br />
                    <kwb>int</kwb> <def>hasBad</def> <sym>=</sym> <def></def><kwd>calcBadIslands</kwd><def></def><sym>(</sym><def>boardVec</def><sym>,</sym> <def></def><num>0</num><def></def><sym>);</sym><br />
<def></def>                    <kwa>if</kwa> <def></def><sym>(</sym><def>hasBad</def> <sym>!=</sym> <def>GOOD</def><sym>) {</sym><br />
<def></def>                        <kwb>boolean</kwb> <def>always</def> <sym>= (</sym><def>hasBad</def><sym>==</sym><def>ALWAYS_BAD</def><sym>);</sym><br />
<def></def>                        <kwd>markBad</kwd><def></def><sym>(</sym><def>isleInfo</def><sym>,</sym> <def>mask</def><sym>,</sym> <def>EVEN</def><sym>,</sym> <def>always</def><sym>);</sym><br />
<def></def><br />
                        <kwb>int</kwb> <def>flipMask</def> <sym>=</sym> <def></def><kwd>getMask</kwd><def></def><sym>(</sym><def>g_flip</def><sym>[</sym><def>i</def><sym>]);</sym><br />
<def></def>                        <kwd>markBad</kwd><def></def><sym>(</sym><def>flipped</def><sym>,</sym> <def>flipMask</def><sym>,</sym> <def>ODD</def><sym>,</sym> <def>always</def><sym>);</sym><br />
<def></def>                    <sym>}</sym><br />
<def></def>                <sym>}</sym><br />
<def>                flipped</def><sym>.</sym><def>isKnown</def><sym>[</sym><def></def><num>1</num><def></def><sym>][</sym><def>OPEN</def><sym>] =  -</sym><def></def><num>1</num><def></def><sym>;</sym><br />
<def>                isleInfo</def><sym>.</sym><def>isKnown</def><sym>[</sym><def></def><num>0</num><def></def><sym>][</sym><def>OPEN</def><sym>] = -</sym><def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>            <sym>}</sym><br />
<def></def>        <sym>}</sym><br />
<def></def><br />
        <kwa>static</kwa> <def></def><kwb>boolean</kwb> <def></def><kwd>hasBadIslandsSingle</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>boardVec</def><sym>,</sym> <def></def><kwb>int</kwb> <def>row</def><sym>)</sym><br />
<def></def>        <sym>{</sym><br />
<def></def>            <kwb>int</kwb><def></def><sym>[]</sym> <def>toFill</def> <sym>= {</sym><def>~boardVec</def><sym>};</sym><br />
<def></def>            <kwb>boolean</kwb> <def>isOdd</def> <sym>= ((</sym><def>row</def> <sym>&amp;</sym> <def></def><num>1</num><def></def><sym>) !=</sym> <def></def><num>0</num><def></def><sym>);</sym><br />
<def></def>            <kwa>if</kwa> <def></def><sym>(</sym><def>isOdd</def><sym>) {</sym><br />
<def>                row</def><sym>--;</sym><br />
<def>                toFill</def><sym>[</sym><def></def><num>0</num><def></def><sym>] &lt;&lt;=</sym> <def>N_COL</def><sym>;</sym> <def></def><slc>// shift to even aligned</slc><br />
<def>                toFill</def><sym>[</sym><def></def><num>0</num><def></def><sym>] |=</sym> <def>TOP_ROW</def><sym>;</sym><br />
<def></def>            <sym>}</sym><br />
<def></def><br />
            <kwb>int</kwb> <def>startRegion</def> <sym>=</sym> <def>TOP_ROW</def><sym>;</sym><br />
<def></def>            <kwb>int</kwb> <def>lastRow</def> <sym>=</sym> <def>TOP_ROW</def> <sym>&lt;&lt; (</sym><def></def><num>5</num> <def></def><sym>*</sym> <def>N_COL</def><sym>);</sym><br />
<def></def>            <kwb>int</kwb> <def>boardMask</def> <sym>=</sym> <def>BOARD_MASK</def><sym>;</sym> <def></def><slc>// all but the first two bits</slc><br />
<def></def>            <kwa>if</kwa> <def></def><sym>(</sym><def>row</def> <sym>&gt;=</sym> <def></def><num>4</num><def></def><sym>)</sym><br />
<def>                boardMask</def> <sym>&gt;&gt;= ((</sym><def>row</def> <sym>-</sym> <def></def><num>4</num><def></def><sym>) *</sym> <def>N_COL</def><sym>);</sym><br />
<def></def>            <kwa>else if</kwa> <def></def><sym>(</sym><def>isOdd</def> <sym>|| (</sym><def>row</def> <sym>==</sym> <def></def><num>0</num><def></def><sym>))</sym><br />
<def>                startRegion</def> <sym>=</sym> <def>lastRow</def><sym>;</sym><br />
<def><br />
            toFill</def><sym>[</sym><def></def><num>0</num><def></def><sym>] &amp;=</sym> <def>boardMask</def><sym>;</sym><br />
<def>            startRegion</def> <sym>&amp;=</sym> <def>toFill</def><sym>[</sym><def></def><num>0</num><def></def><sym>];</sym><br />
<def></def><br />
            <kwa>while</kwa> <def></def><sym>(</sym><def>toFill</def><sym>[</sym><def></def><num>0</num><def></def><sym>] !=</sym> <def></def><num>0</num><def></def><sym>)    {</sym><br />
<def></def>                <kwa>if</kwa> <def></def><sym>(</sym><def></def><kwd>badRegion</kwd><def></def><sym>(</sym><def>toFill</def><sym>,</sym> <def>startRegion</def><sym>))</sym><br />
<def></def>                    <kwa>return</kwa> <def>true</def><sym>;</sym><br />
<def></def>                <kwb>int</kwb> <def>iPos</def> <sym>=</sym> <def></def><kwd>getFirstOne</kwd><def></def><sym>(</sym><def>toFill</def><sym>[</sym><def></def><num>0</num><def></def><sym>]);</sym><br />
<def>                startRegion</def> <sym>=</sym> <def></def><kwd>getMask</kwd><def></def><sym>(</sym><def>iPos</def><sym>);</sym><br />
<def></def>            <sym>}</sym><br />
<def></def><br />
            <kwa>return</kwa> <def>false</def><sym>;</sym><br />
<def></def>        <sym>}</sym><br />
<def></def><br />
        <kwb>void</kwb> <def></def><kwd>genAllSolutions</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>boardVec</def><sym>,</sym> <def></def><kwb>int</kwb> <def>placedPieces</def><sym>,</sym> <def></def><kwb>int</kwb> <def>row</def><sym>)</sym><br />
<def></def>        <sym>{</sym><br />
<def></def>            <kwa>while</kwa> <def></def><sym>((</sym><def>boardVec</def> <sym>&amp;</sym> <def>TOP_ROW</def><sym>) ==</sym> <def>TOP_ROW</def><sym>) {</sym><br />
<def>                boardVec</def> <sym>&gt;&gt;=</sym> <def>N_COL</def><sym>;</sym><br />
<def>                row</def><sym>++;</sym><br />
<def></def>            <sym>}</sym><br />
<def></def>            <kwb>int</kwb> <def>iNextFill</def> <sym>=</sym> <def>s_firstOne</def><sym>[</sym><def>~boardVec</def> <sym>&amp;</sym> <def>TOP_ROW</def><sym>];</sym><br />
<def>            OkPieces allowed</def> <sym>=</sym> <def>g_okPieces</def><sym>[</sym><def>row</def><sym>][</sym><def>iNextFill</def><sym>];</sym><br />
<def></def><br />
            <kwb>int</kwb> <def>iPiece</def> <sym>=</sym> <def></def><kwd>getFirstOne</kwd><def></def><sym>(</sym><def>~placedPieces</def><sym>);</sym><br />
<def></def>            <kwb>int</kwb> <def>pieceMask</def> <sym>=</sym> <def></def><kwd>getMask</kwd><def></def><sym>(</sym><def>iPiece</def><sym>);</sym><br />
<def></def>            <kwa>for</kwa> <def></def><sym>(;</sym> <def>iPiece</def> <sym>&lt;</sym> <def>N_PIECE_TYPE</def><sym>;</sym> <def>iPiece</def><sym>++,</sym> <def>pieceMask</def> <sym>&lt;&lt;=</sym> <def></def><num>1</num><def></def><sym>)</sym><br />
<def></def>            <sym>{</sym><br />
<def></def>                <kwa>if</kwa> <def></def><sym>((</sym><def>pieceMask</def> <sym>&amp;</sym> <def>placedPieces</def><sym>) !=</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def></def>                    <kwa>continue</kwa><def></def><sym>;</sym><br />
<def><br />
                placedPieces</def> <sym>|=</sym> <def>pieceMask</def><sym>;</sym><br />
<def></def>                <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iOrient</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iOrient</def> <sym>&lt;</sym> <def>allowed</def><sym>.</sym><def>nPieces</def><sym>[</sym><def>iPiece</def><sym>];</sym> <def>iOrient</def><sym>++) {</sym><br />
<def></def>                    <kwb>int</kwb> <def>pieceVec</def> <sym>=</sym> <def>allowed</def><sym>.</sym><def>pieceVec</def><sym>[</sym><def>iPiece</def><sym>][</sym><def>iOrient</def><sym>];</sym><br />
<def></def><br />
                    <kwa>if</kwa> <def></def><sym>((</sym><def>pieceVec</def> <sym>&amp;</sym> <def>boardVec</def><sym>) !=</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def></def>                        <kwa>continue</kwa><def></def><sym>;</sym><br />
<def><br />
                    boardVec</def> <sym>|=</sym> <def>pieceVec</def><sym>;</sym><br />
<def></def><br />
                    <kwa>if</kwa> <def></def><sym>((</sym><def></def><kwd>hasBadIslands</kwd><def></def><sym>(</sym><def>boardVec</def><sym>,</sym> <def>row</def><sym>)) !=</sym> <def></def><num>0</num><def></def><sym>) {</sym><br />
<def>                        boardVec ^</def><sym>=</sym> <def>pieceVec</def><sym>;</sym><br />
<def></def>                        <kwa>continue</kwa><def></def><sym>;</sym><br />
<def></def>                    <sym>}</sym><br />
<def><br />
                    m_curSoln</def><sym>.</sym><def></def><kwd>pushPiece</kwd><def></def><sym>(</sym><def>pieceVec</def><sym>,</sym> <def>iPiece</def><sym>,</sym> <def>row</def><sym>);</sym><br />
<def></def><br />
                    <slc>// recur or record solution</slc><br />
<def></def>                    <kwa>if</kwa> <def></def><sym>(</sym><def>placedPieces</def> <sym>!=</sym> <def>Piece</def><sym>.</sym><def>ALL_PIECE_MASK</def><sym>)</sym><br />
<def></def>                        <kwd>genAllSolutions</kwd><def></def><sym>(</sym><def>boardVec</def><sym>,</sym> <def>placedPieces</def><sym>,</sym> <def>row</def><sym>);</sym><br />
<def></def>                    <kwa>else</kwa><br />
<def></def>                        <kwd>recordSolution</kwd><def></def><sym>(</sym><def>m_curSoln</def><sym>);</sym><br />
<def><br />
                    boardVec ^</def><sym>=</sym> <def>pieceVec</def><sym>;</sym><br />
<def>                    m_curSoln</def><sym>.</sym><def></def><kwd>popPiece</kwd><def></def><sym>();</sym><br />
<def></def>                <sym>}</sym><br />
<def><br />
                placedPieces ^</def><sym>=</sym> <def>pieceMask</def><sym>;</sym><br />
<def></def>            <sym>}</sym><br />
<def></def>        <sym>}</sym><br />
<def></def><br />
        <kwb>void</kwb> <def></def><kwd>recordSolution</kwd><def></def><sym>(</sym><def>Soln s</def><sym>) {</sym><br />
<def>            m_nSoln</def> <sym>+=</sym> <def></def><num>2</num><def></def><sym>;</sym><br />
<def></def><br />
            <kwa>if</kwa> <def></def><sym>(</sym><def>m_minSoln</def><sym>.</sym><def></def><kwd>isEmpty</kwd><def></def><sym>()) {</sym><br />
<def>                m_minSoln</def> <sym>=</sym> <def>m_maxSoln</def> <sym>=</sym> <def>s</def><sym>.</sym><def></def><kwd>clone2</kwd><def></def><sym>();</sym><br />
<def></def>                <kwa>return</kwa><def></def><sym>;</sym><br />
<def></def>            <sym>}</sym><br />
<def></def><br />
            <kwa>if</kwa> <def></def><sym>(</sym><def>s</def><sym>.</sym><def></def><kwd>lessThan</kwd><def></def><sym>(</sym><def>m_minSoln</def><sym>))</sym><br />
<def>                m_minSoln</def> <sym>=</sym> <def>s</def><sym>.</sym><def></def><kwd>clone2</kwd><def></def><sym>();</sym><br />
<def></def>            <kwa>else if</kwa> <def></def><sym>(</sym><def>m_maxSoln</def><sym>.</sym><def></def><kwd>lessThan</kwd><def></def><sym>(</sym><def>s</def><sym>))</sym><br />
<def>                m_maxSoln</def> <sym>=</sym> <def>s</def><sym>.</sym><def></def><kwd>clone2</kwd><def></def><sym>();</sym><br />
<def><br />
            Soln spun</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>Soln</kwd><def></def><sym>();</sym><br />
<def>            s</def><sym>.</sym><def></def><kwd>spin</kwd><def></def><sym>(</sym><def>spun</def><sym>);</sym><br />
<def></def>            <kwa>if</kwa> <def></def><sym>(</sym><def>spun</def><sym>.</sym><def></def><kwd>lessThan</kwd><def></def><sym>(</sym><def>m_minSoln</def><sym>))</sym><br />
<def>                m_minSoln</def> <sym>=</sym> <def>spun</def><sym>;</sym><br />
<def></def>            <kwa>else if</kwa> <def></def><sym>(</sym><def>m_maxSoln</def><sym>.</sym><def></def><kwd>lessThan</kwd><def></def><sym>(</sym><def>spun</def><sym>))</sym><br />
<def>                m_maxSoln</def> <sym>=</sym> <def>spun</def><sym>;</sym><br />
<def></def>        <sym>}</sym><br />
<def></def>    <sym>}</sym><br />
<def></def><br />
<slc>//----------------------</slc><br />
<def></def>    <kwa>static class</kwa> <def>Piece</def> <sym>{</sym><br />
<def></def>        <kwa>class</kwa> <def>Instance</def> <sym>{</sym><br />
<def></def>            <kwb>long</kwb> <def>m_allowed</def><sym>;</sym><br />
<def></def>            <kwb>int</kwb> <def>m_vec</def><sym>;</sym><br />
<def></def>            <kwb>int</kwb> <def>m_offset</def><sym>;</sym><br />
<def></def>        <sym>}</sym><br />
<def></def><br />
        <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>N_ELEM</def> <sym>=</sym> <def></def><num>5</num><def></def><sym>;</sym><br />
<def></def>        <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>ALL_PIECE_MASK</def> <sym>= (</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def>N_PIECE_TYPE</def><sym>) -</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>        <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>SKIP_PIECE</def> <sym>=</sym> <def></def><num>5</num><def></def><sym>;</sym><br />
<def></def><br />
        <kwa>static final</kwa> <def></def><kwb>int</kwb> <def>BaseVecs</def><sym>[] = {</sym><br />
<def></def>            <num>0x10f</num><def></def><sym>,</sym> <def></def><num>0x0cb</num><def></def><sym>,</sym> <def></def><num>0x1087</num><def></def><sym>,</sym> <def></def><num>0x427</num><def></def><sym>,</sym> <def></def><num>0x465</num><def></def><sym>,</sym><br />
<def></def>            <num>0x0c7</num><def></def><sym>,</sym> <def></def><num>0x8423</num><def></def><sym>,</sym> <def></def><num>0x0a7</num><def></def><sym>,</sym> <def></def><num>0x187</num><def></def><sym>,</sym> <def></def><num>0x08f</num><br />
<def></def>        <sym>};</sym><br />
<def></def><br />
        <kwa>static</kwa> <def>Piece</def><sym>[][]</sym> <def>s_basePiece</def> <sym>=</sym> <def></def><kwa>new</kwa> <def>Piece</def> <sym>[</sym><def>N_PIECE_TYPE</def><sym>][</sym><def>N_ORIENT</def><sym>];</sym><br />
<def><br />
        Instance</def><sym>[]</sym> <def>m_instance</def> <sym>=</sym> <def></def><kwa>new</kwa> <def>Instance</def> <sym>[</sym><def>N_PARITY</def><sym>];</sym><br />
<def></def><br />
        <kwb>void</kwb> <def></def><kwd>init</kwd><def></def><sym>() {</sym><br />
<def></def>            <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>i</def> <sym>&lt;</sym> <def>N_PARITY</def><sym>;</sym> <def>i</def><sym>++)</sym><br />
<def>                m_instance</def><sym>[</sym><def>i</def><sym>] =</sym> <def></def><kwa>new</kwa> <def></def><kwd>Instance</kwd><def></def><sym>();</sym><br />
<def></def>        <sym>}</sym><br />
<def></def>        <kwd>Piece</kwd><def></def><sym>() {</sym><br />
<def></def>            <kwd>init</kwd><def></def><sym>();</sym><br />
<def></def>        <sym>}</sym><br />
<def></def><br />
        <kwa>static</kwa> <def></def><sym>{</sym><br />
<def></def>            <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>i</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>i</def> <sym>&lt;</sym> <def>N_PIECE_TYPE</def><sym>;</sym> <def>i</def><sym>++) {</sym><br />
<def></def>                <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>j</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>j</def> <sym>&lt;</sym> <def>N_ORIENT</def><sym>;</sym> <def>j</def><sym>++)</sym><br />
<def>                    s_basePiece</def><sym>[</sym><def>i</def><sym>][</sym><def>j</def><sym>] =</sym> <def></def><kwa>new</kwa> <def></def><kwd>Piece</kwd><def></def><sym>();</sym><br />
<def></def>            <sym>}</sym><br />
<def></def>        <sym>}</sym><br />
<def></def>        <kwa>static</kwa> <def></def><kwb>void</kwb> <def></def><kwd>setCoordList</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>vec</def><sym>,</sym> <def></def><kwb>int</kwb><def></def><sym>[][]</sym> <def>pts</def><sym>) {</sym><br />
<def></def>            <kwb>int</kwb> <def>iPt</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>            <kwb>int</kwb> <def>mask</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>            <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>y</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>y</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>y</def><sym>++) {</sym><br />
<def></def>                <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>x</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>x</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>x</def><sym>++) {</sym><br />
<def></def>                    <kwa>if</kwa> <def></def><sym>((</sym><def>mask</def> <sym>&amp;</sym> <def>vec</def><sym>) !=</sym> <def></def><num>0</num><def></def><sym>) {</sym><br />
<def>                        pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>X</def><sym>] =</sym> <def>x</def><sym>;</sym><br />
<def>                        pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>Y</def><sym>] =</sym> <def>y</def><sym>;</sym><br />
<def><br />
                        iPt</def><sym>++;</sym><br />
<def></def>                    <sym>}</sym><br />
<def>                    mask</def> <sym>&lt;&lt;=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>                <sym>}</sym><br />
<def></def>            <sym>}</sym><br />
<def></def>        <sym>}</sym><br />
<def></def><br />
        <kwa>static</kwa> <def></def><kwb>int</kwb> <def></def><kwd>toBitVector</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb><def></def><sym>[][]</sym> <def>pts</def><sym>) {</sym><br />
<def></def>            <kwb>int</kwb> <def>y</def><sym>,</sym> <def>x</def><sym>;</sym><br />
<def></def>            <kwb>int</kwb> <def>result</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>            <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iPt</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iPt</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iPt</def><sym>++) {</sym><br />
<def>                x</def> <sym>=</sym> <def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>X</def><sym>];</sym><br />
<def>                y</def> <sym>=</sym> <def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def><br />
                <kwb>int</kwb> <def>pos</def> <sym>=</sym> <def>Board</def><sym>.</sym><def></def><kwd>getIndex</kwd><def></def><sym>(</sym><def>x</def><sym>,</sym> <def>y</def><sym>);</sym><br />
<def>                result</def> <sym>|= (</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def>pos</def><sym>);</sym><br />
<def></def>            <sym>}</sym><br />
<def></def><br />
            <kwa>return</kwa> <def>result</def><sym>;</sym><br />
<def></def>        <sym>}</sym><br />
<def></def><br />
        <kwa>static</kwa> <def></def><kwb>void</kwb> <def></def><kwd>shiftUpLines</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb><def></def><sym>[][]</sym> <def>pts</def><sym>,</sym> <def></def><kwb>int</kwb> <def>shift</def><sym>) {</sym><br />
<def></def><br />
            <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iPt</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iPt</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iPt</def><sym>++) {</sym><br />
<def></def>                <kwa>if</kwa> <def></def><sym>((</sym><def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>Y</def><sym>] &amp;</sym> <def>shift</def> <sym>&amp;</sym> <def></def><num>0x1</num><def></def><sym>) !=</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def></def>                    <sym>(</sym><def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>X</def><sym>])++;</sym><br />
<def>                pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>Y</def><sym>] -=</sym> <def>shift</def><sym>;</sym><br />
<def></def>            <sym>}</sym><br />
<def></def>        <sym>}</sym><br />
<def></def><br />
        <kwa>static</kwa> <def></def><kwb>int</kwb> <def></def><kwd>shiftToX0</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb><def></def><sym>[][]</sym> <def>pts</def><sym>,</sym> <def>Instance instance</def><sym>,</sym> <def></def><kwb>int</kwb> <def>offsetRow</def><sym>)</sym><br />
<def></def>        <sym>{</sym><br />
<def></def>            <kwb>int</kwb> <def>x</def><sym>,</sym> <def>y</def><sym>,</sym> <def>iPt</def><sym>;</sym><br />
<def></def>            <kwb>int</kwb> <def>xMin</def> <sym>=</sym> <def>pts</def><sym>[</sym><def></def><num>0</num><def></def><sym>][</sym><def>X</def><sym>];</sym><br />
<def></def>            <kwb>int</kwb> <def>xMax</def> <sym>=</sym> <def>xMin</def><sym>;</sym><br />
<def></def>            <kwa>for</kwa> <def></def><sym>(</sym><def>iPt</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym> <def>iPt</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iPt</def><sym>++) {</sym><br />
<def>                x</def> <sym>=</sym> <def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>X</def><sym>];</sym><br />
<def>                y</def> <sym>=</sym> <def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def><br />
                <kwa>if</kwa> <def></def><sym>(</sym><def>x</def> <sym>&lt;</sym> <def>xMin</def><sym>)</sym><br />
<def>                    xMin</def> <sym>=</sym> <def>x</def><sym>;</sym><br />
<def></def>                <kwa>else if</kwa> <def></def><sym>(</sym><def>x</def> <sym>&gt;</sym> <def>xMax</def><sym>)</sym><br />
<def>                    xMax</def> <sym>=</sym> <def>x</def><sym>;</sym><br />
<def></def>            <sym>}</sym><br />
<def></def><br />
            <kwb>int</kwb> <def>offset</def> <sym>=</sym> <def>N_ELEM</def><sym>;</sym><br />
<def></def>            <kwa>for</kwa> <def></def><sym>(</sym><def>iPt</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iPt</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iPt</def><sym>++) {</sym><br />
<def><br />
                pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>X</def><sym>] -=</sym> <def>xMin</def><sym>;</sym><br />
<def></def><br />
                <kwa>if</kwa> <def></def><sym>((</sym><def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>Y</def><sym>] ==</sym> <def>offsetRow</def><sym>) &amp;&amp; (</sym><def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>X</def><sym>] &lt;</sym> <def>offset</def><sym>))</sym><br />
<def>                    offset</def> <sym>=</sym> <def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>X</def><sym>];</sym><br />
<def></def>            <sym>}</sym><br />
<def><br />
            instance</def><sym>.</sym><def>m_offset</def> <sym>=</sym> <def>offset</def><sym>;</sym><br />
<def>            instance</def><sym>.</sym><def>m_vec</def> <sym>=</sym> <def></def><kwd>toBitVector</kwd><def></def><sym>(</sym><def>pts</def><sym>);</sym><br />
<def></def>            <kwa>return</kwa> <def>xMax</def> <sym>-</sym> <def>xMin</def><sym>;</sym><br />
<def></def>        <sym>}</sym><br />
<def></def><br />
        <kwb>void</kwb> <def></def><kwd>setOkPos</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>isOdd</def><sym>,</sym> <def></def><kwb>int</kwb> <def>w</def><sym>,</sym> <def></def><kwb>int</kwb> <def>h</def><sym>) {</sym><br />
<def>            Instance p</def> <sym>=</sym> <def>m_instance</def><sym>[</sym><def>isOdd</def><sym>];</sym><br />
<def>            p</def><sym>.</sym><def>m_allowed</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>            <kwb>long</kwb> <def>posMask</def> <sym>=</sym> <def></def><num>1L</num> <def></def><sym>&lt;&lt; (</sym><def>isOdd</def> <sym>*</sym> <def>N_COL</def><sym>);</sym><br />
<def></def><br />
            <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>y</def> <sym>=</sym> <def>isOdd</def><sym>;</sym> <def>y</def> <sym>&lt;</sym> <def>N_ROW</def> <sym>-</sym> <def>h</def><sym>;</sym> <def>y</def><sym>+=</sym><def></def><num>2</num><def></def><sym>,</sym> <def>posMask</def> <sym>&lt;&lt;=</sym> <def>N_COL</def><sym>) {</sym><br />
<def></def>                <kwa>if</kwa> <def></def><sym>((</sym><def>p</def><sym>.</sym><def>m_offset</def><sym>) !=</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def>                    posMask</def> <sym>&lt;&lt;=</sym> <def>p</def><sym>.</sym><def>m_offset</def><sym>;</sym><br />
<def></def><br />
                <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>xPos</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>xPos</def> <sym>&lt;</sym> <def>N_COL</def> <sym>-</sym> <def>p</def><sym>.</sym><def>m_offset</def><sym>;</sym> <def>xPos</def><sym>++,</sym> <def>posMask</def> <sym>&lt;&lt;=</sym> <def></def><num>1</num><def></def><sym>) {</sym><br />
<def></def><br />
                    <kwa>if</kwa> <def></def><sym>(</sym><def>xPos</def> <sym>&gt;=</sym> <def>N_COL</def> <sym>-</sym> <def>w</def><sym>)</sym><br />
<def></def>                        <kwa>continue</kwa><def></def><sym>;</sym><br />
<def></def><br />
                    <kwb>int</kwb> <def>pieceVec</def> <sym>=</sym> <def>p</def><sym>.</sym><def>m_vec</def> <sym>&lt;&lt;</sym> <def>xPos</def><sym>;</sym><br />
<def></def><br />
                    <kwa>if</kwa> <def></def><sym>(</sym><def>Board</def><sym>.</sym><def></def><kwd>hasBadIslandsSingle</kwd><def></def><sym>(</sym><def>pieceVec</def><sym>,</sym> <def>y</def><sym>))</sym><br />
<def></def>                        <kwa>continue</kwa><def></def><sym>;</sym><br />
<def><br />
                    p</def><sym>.</sym><def>m_allowed</def> <sym>|=</sym> <def>posMask</def><sym>;</sym><br />
<def></def>                <sym>}</sym><br />
<def></def>            <sym>}</sym><br />
<def></def>        <sym>}</sym><br />
<def></def><br />
        <kwa>static</kwa> <def></def><kwb>void</kwb> <def></def><kwd>genOrientation</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>vec</def><sym>,</sym> <def></def><kwb>int</kwb> <def>iOrient</def><sym>,</sym> <def>Piece target</def><sym>)</sym><br />
<def></def>        <sym>{</sym><br />
<def></def>            <kwb>int</kwb><def></def><sym>[][]</sym> <def>pts</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwb>int</kwb><def></def><sym>[</sym><def>N_ELEM</def><sym>][</sym><def>N_DIM</def><sym>];</sym><br />
<def></def>            <kwd>setCoordList</kwd><def></def><sym>(</sym><def>vec</def><sym>,</sym> <def>pts</def><sym>);</sym><br />
<def></def><br />
            <kwb>int</kwb> <def>y</def><sym>,</sym> <def>x</def><sym>,</sym> <def>iPt</def><sym>;</sym><br />
<def></def>            <kwb>int</kwb> <def>rot</def> <sym>=</sym> <def>iOrient</def> <sym>%</sym> <def></def><num>6</num><def></def><sym>;</sym><br />
<def></def>            <kwb>int</kwb> <def>flip</def> <sym>=</sym> <def>iOrient</def> <sym>&gt;=</sym> <def></def><num>6</num> <def>?</def> <num>1</num> <def></def><sym>:</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>            <kwa>if</kwa> <def></def><sym>(</sym><def>flip</def> <sym>!=</sym> <def></def><num>0</num><def></def><sym>) {</sym><br />
<def></def>                <kwa>for</kwa> <def></def><sym>(</sym><def>iPt</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iPt</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iPt</def><sym>++)</sym><br />
<def>                    pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>Y</def><sym>] = -</sym><def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def>            <sym>}</sym><br />
<def></def><br />
            <kwa>while</kwa> <def></def><sym>((</sym><def>rot</def><sym>--) !=</sym> <def></def><num>0</num><def></def><sym>) {</sym><br />
<def></def>                <kwa>for</kwa> <def></def><sym>(</sym><def>iPt</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iPt</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iPt</def><sym>++) {</sym><br />
<def>                    x</def> <sym>=</sym> <def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>X</def><sym>];</sym><br />
<def>                    y</def> <sym>=</sym> <def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def><br />
                    <kwb>int</kwb> <def>xNew</def> <sym>=</sym> <def></def><kwd>floor</kwd><def></def><sym>((</sym><def></def><num>2</num> <def></def><sym>*</sym> <def>x</def> <sym>-</sym> <def></def><num>3</num> <def></def><sym>*</sym> <def>y</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>),</sym> <def></def><num>4</num><def></def><sym>);</sym><br />
<def></def>                    <kwb>int</kwb> <def>yNew</def> <sym>=</sym> <def></def><kwd>floor</kwd><def></def><sym>((</sym><def></def><num>2</num> <def></def><sym>*</sym> <def>x</def> <sym>+</sym> <def>y</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>),</sym> <def></def><num>2</num><def></def><sym>);</sym><br />
<def>                    pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>X</def><sym>] =</sym> <def>xNew</def><sym>;</sym><br />
<def>                    pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>Y</def><sym>] =</sym> <def>yNew</def><sym>;</sym><br />
<def></def>                <sym>}</sym><br />
<def></def>            <sym>}</sym><br />
<def></def><br />
            <kwb>int</kwb> <def>yMin</def> <sym>=</sym> <def>pts</def><sym>[</sym><def></def><num>0</num><def></def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def>            <kwb>int</kwb> <def>yMax</def> <sym>=</sym> <def>yMin</def><sym>;</sym><br />
<def></def>            <kwa>for</kwa> <def></def><sym>(</sym><def>iPt</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym> <def>iPt</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iPt</def><sym>++) {</sym><br />
<def>                y</def> <sym>=</sym> <def>pts</def><sym>[</sym><def>iPt</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def><br />
                <kwa>if</kwa> <def></def><sym>(</sym><def>y</def> <sym>&lt;</sym> <def>yMin</def><sym>)</sym><br />
<def>                    yMin</def> <sym>=</sym> <def>y</def><sym>;</sym><br />
<def></def>                <kwa>else if</kwa> <def></def><sym>(</sym><def>y</def> <sym>&gt;</sym> <def>yMax</def><sym>)</sym><br />
<def>                    yMax</def> <sym>=</sym> <def>y</def><sym>;</sym><br />
<def></def>            <sym>}</sym><br />
<def></def>            <kwb>int</kwb> <def>h</def> <sym>=</sym> <def>yMax</def> <sym>-</sym> <def>yMin</def><sym>;</sym><br />
<def>            Instance even</def> <sym>=</sym> <def>target</def><sym>.</sym><def>m_instance</def><sym>[</sym><def>EVEN</def><sym>];</sym><br />
<def>            Instance odd</def> <sym>=</sym> <def>target</def><sym>.</sym><def>m_instance</def><sym>[</sym><def>ODD</def><sym>];</sym><br />
<def></def><br />
            <kwd>shiftUpLines</kwd><def></def><sym>(</sym><def>pts</def><sym>,</sym> <def>yMin</def><sym>);</sym><br />
<def></def>            <kwb>int</kwb> <def>w</def> <sym>=</sym> <def></def><kwd>shiftToX0</kwd><def></def><sym>(</sym><def>pts</def><sym>,</sym> <def>even</def><sym>,</sym> <def></def><num>0</num><def></def><sym>);</sym><br />
<def>            target</def><sym>.</sym><def></def><kwd>setOkPos</kwd><def></def><sym>(</sym><def>EVEN</def><sym>,</sym> <def>w</def><sym>,</sym> <def>h</def><sym>);</sym><br />
<def>            even</def><sym>.</sym><def>m_vec</def> <sym>&gt;&gt;=</sym> <def>even</def><sym>.</sym><def>m_offset</def><sym>;</sym><br />
<def></def><br />
            <kwd>shiftUpLines</kwd><def></def><sym>(</sym><def>pts</def><sym>, -</sym><def></def><num>1</num><def></def><sym>);</sym><br />
<def>            w</def> <sym>=</sym> <def></def><kwd>shiftToX0</kwd><def></def><sym>(</sym><def>pts</def><sym>,</sym> <def>odd</def><sym>,</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def>            odd</def><sym>.</sym><def>m_vec</def> <sym>&gt;&gt;=</sym> <def>N_COL</def><sym>;</sym><br />
<def>            target</def><sym>.</sym><def></def><kwd>setOkPos</kwd><def></def><sym>(</sym><def>ODD</def><sym>,</sym> <def>w</def><sym>,</sym> <def>h</def><sym>);</sym><br />
<def>            odd</def><sym>.</sym><def>m_vec</def> <sym>&gt;&gt;=</sym> <def>odd</def><sym>.</sym><def>m_offset</def><sym>;</sym><br />
<def></def>        <sym>}</sym><br />
<def></def><br />
        <kwa>static</kwa> <def></def><kwb>void</kwb> <def></def><kwd>genAllOrientations</kwd><def></def><sym>() {</sym><br />
<def></def>            <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iPiece</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iPiece</def> <sym>&lt;</sym> <def>N_PIECE_TYPE</def><sym>;</sym> <def>iPiece</def><sym>++) {</sym><br />
<def></def>                <kwb>int</kwb> <def>refPiece</def> <sym>=</sym> <def>BaseVecs</def><sym>[</sym><def>iPiece</def><sym>];</sym><br />
<def></def>                <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iOrient</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iOrient</def> <sym>&lt;</sym> <def>N_ORIENT</def><sym>;</sym> <def>iOrient</def><sym>++) {</sym><br />
<def>                    Piece p</def> <sym>=</sym> <def>s_basePiece</def><sym>[</sym><def>iPiece</def><sym>][</sym><def>iOrient</def><sym>];</sym><br />
<def></def>                    <kwd>genOrientation</kwd><def></def><sym>(</sym><def>refPiece</def><sym>,</sym> <def>iOrient</def><sym>,</sym> <def>p</def><sym>);</sym><br />
<def></def>                    <kwa>if</kwa> <def></def><sym>((</sym><def>iPiece</def> <sym>==</sym> <def>SKIP_PIECE</def><sym>)  &amp;&amp; (((</sym><def>iOrient</def> <sym>/</sym> <def></def><num>3</num><def></def><sym>) &amp;</sym> <def></def><num>1</num><def></def><sym>) !=</sym> <def></def><num>0</num><def></def><sym>))</sym><br />
<def>                        p</def><sym>.</sym><def>m_instance</def><sym>[</sym><def></def><num>0</num><def></def><sym>].</sym><def>m_allowed</def> <sym>=</sym> <def>p</def><sym>.</sym><def>m_instance</def><sym>[</sym><def></def><num>1</num><def></def><sym>].</sym><def>m_allowed</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>                <sym>}</sym><br />
<def></def>            <sym>}</sym><br />
<def></def>            <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iPiece</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iPiece</def> <sym>&lt;</sym> <def>N_PIECE_TYPE</def><sym>;</sym> <def>iPiece</def><sym>++) {</sym><br />
<def></def>                <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iOrient</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iOrient</def> <sym>&lt;</sym> <def>N_ORIENT</def><sym>;</sym> <def>iOrient</def><sym>++) {</sym><br />
<def></def>                    <kwb>long</kwb> <def>mask</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>                    <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iRow</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iRow</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>iRow</def><sym>++) {</sym><br />
<def>                        Instance p</def> <sym>=</sym> <def></def><kwd>getPiece</kwd><def></def><sym>(</sym><def>iPiece</def><sym>,</sym> <def>iOrient</def><sym>, (</sym><def>iRow</def> <sym>&amp;</sym> <def></def><num>1</num><def></def><sym>));</sym><br />
<def></def>                        <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iCol</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iCol</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>iCol</def><sym>++) {</sym><br />
<def>                            OkPieces allowed</def> <sym>=</sym> <def>g_okPieces</def><sym>[</sym><def>iRow</def><sym>][</sym><def>iCol</def><sym>];</sym><br />
<def></def>                            <kwa>if</kwa> <def></def><sym>((</sym><def>p</def><sym>.</sym><def>m_allowed</def> <sym>&amp;</sym> <def>mask</def><sym>) !=</sym> <def></def><num>0</num><def></def><sym>) {</sym><br />
<def>                                allowed</def><sym>.</sym><def>pieceVec</def><sym>[</sym><def>iPiece</def><sym>][</sym><def>allowed</def><sym>.</sym><def>nPieces</def><sym>[</sym><def>iPiece</def><sym>]] =</sym> <def>p</def><sym>.</sym><def>m_vec</def> <sym>&lt;&lt;</sym> <def>iCol</def><sym>;</sym><br />
<def></def>                                <sym>(</sym><def>allowed</def><sym>.</sym><def>nPieces</def><sym>[</sym><def>iPiece</def><sym>])++;</sym><br />
<def></def>                            <sym>}</sym><br />
<def><br />
                            mask</def> <sym>&lt;&lt;=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>                        <sym>}</sym><br />
<def></def>                    <sym>}</sym><br />
<def></def>                <sym>}</sym><br />
<def></def>            <sym>}</sym><br />
<def></def>        <sym>}</sym><br />
<def></def><br />
        <kwa>static</kwa> <def>Instance</def> <kwd>getPiece</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iPiece</def><sym>,</sym> <def></def><kwb>int</kwb> <def>iOrient</def><sym>,</sym> <def></def><kwb>int</kwb> <def>iParity</def><sym>) {</sym><br />
<def></def>            <kwa>return</kwa> <def>s_basePiece</def><sym>[</sym><def>iPiece</def><sym>][</sym><def>iOrient</def><sym>].</sym><def>m_instance</def><sym>[</sym><def>iParity</def><sym>];</sym><br />
<def></def>        <sym>}</sym><br />
<def></def>    <sym>}</sym><br />
<def></def><br />
<br />
<slc>//-- Main ---------------------------</slc><br />
<def></def>    <kwa>public static</kwa> <def></def><kwb>void</kwb> <def></def><kwd>main</kwd><def></def><sym>(</sym><def></def><kwc>String</kwc><def></def><sym>[]</sym> <def>args</def><sym>) {</sym><br />
<def></def>        <kwa>if</kwa> <def></def><sym>(</sym><def>args</def><sym>.</sym><def>length</def> <sym>&gt;</sym> <def></def><num>2</num><def></def><sym>)</sym><br />
<def></def>            <kwc>System</kwc><def></def><sym>.</sym><def></def><kwd>exit</kwd><def></def><sym>(-</sym><def></def><num>1</num><def></def><sym>);</sym> <def></def><slc>// spec says this is an error;</slc><br />
<def></def><br />
        <kwd>initGlobals</kwd><def></def><sym>();</sym><br />
<def>        Board b</def> <sym>=</sym> <def></def><kwa>new</kwa> <def></def><kwd>Board</kwd><def></def><sym>();</sym><br />
<def>        Piece</def><sym>.</sym><def></def><kwd>genAllOrientations</kwd><def></def><sym>();</sym><br />
<def>        Board</def><sym>.</sym><def></def><kwd>calcAlwaysBad</kwd><def></def><sym>();</sym><br />
<def>        b</def><sym>.</sym><def></def><kwd>genAllSolutions</kwd><def></def><sym>(</sym><def></def><num>0</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>);</sym><br />
<def></def><br />
        <kwc>System</kwc><def></def><sym>.</sym><def>out</def><sym>.</sym><def></def><kwd>println</kwd><def></def><sym>(</sym><def>b</def><sym>.</sym><def>m_nSoln</def> <sym>+</sym> <def></def><str>&quot; solutions found</str><esc>\n</esc><str>&quot;</str><def></def><sym>);</sym><br />
<def></def>        <kwc>System</kwc><def></def><sym>.</sym><def>out</def><sym>.</sym><def></def><kwd>println</kwd><def></def><sym>(</sym><def>b</def><sym>.</sym><def>m_minSoln</def><sym>);</sym><br />
<def></def>        <kwc>System</kwc><def></def><sym>.</sym><def>out</def><sym>.</sym><def></def><kwd>println</kwd><def></def><sym>(</sym><def>b</def><sym>.</sym><def>m_maxSoln</def><sym>);</sym><br />
<def></def>    <sym>}</sym><br />
<def></def><sym>}</sym><def></def><br />
</source>
