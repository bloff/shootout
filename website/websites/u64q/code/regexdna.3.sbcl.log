
Tue, 03 Mar 2009 00:50:55 GMT

MAKE:
cp: `regexdna.sbcl-3.sbcl' and `./regexdna.sbcl-3.sbcl' are the same file
SBCL built with: /usr/local/bin/sbcl --userinit /dev/null --batch --eval '(load "regexdna.sbcl-3.sbcl_compile")'
### START regexdna.sbcl-3.sbcl_compile
(proclaim '(optimize (speed 3) (safety 0) (debug 0) (compilation-speed 0) (space 0)))
(handler-bind ((sb-ext:defconstant-uneql      (lambda (c) (abort c))))      (load (compile-file "regexdna.sbcl-3.sbcl" ))) (save-lisp-and-die "sbcl.core" :purify t)
### END regexdna.sbcl-3.sbcl_compile


; compiling file "/home/dunham/shootout/bench/regexdna/regexdna.sbcl-3.sbcl" (written 02 MAR 2009 04:28:51 PM):
; compiling (REQUIRE :ASDF)
; compiling (REQUIRE :CL-PPCRE)
; compiling (DEFINE-ALIEN-ROUTINE SYSCONF ...)
; file: /home/dunham/shootout/bench/regexdna/regexdna.sbcl-3.sbcl
; in: DEFINE-ALIEN-ROUTINE SYSCONF
;     (DEFINE-ALIEN-ROUTINE SYSCONF LONG (NAME INT))
; --> PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK WITH-ALIEN 
; --> SYMBOL-MACROLET SYMBOL-MACROLET LET SYMBOL-MACROLET VALUES PROG1 LET 
; --> ALIEN-FUNCALL SB-C::INVOKE-WITH-SAVED-FP-AND-PC BLOCK LET* 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%CALLER-FRAME-AND-PC)
; 
; note: doing SAP to pointer coercion (cost 20)

; --> PROGN DEFUN PROGN EVAL-WHEN 
; ==>
;   (SB-IMPL::%DEFUN 'SYSCONF
;                    (SB-INT:NAMED-LAMBDA SYSCONF (NAME)
;                                         (BLOCK SYSCONF
;                                           (WITH-ALIEN (#) (VALUES #))))
;                    NIL 'NIL (SB-C:SOURCE-LOCATION))
; 
; note: doing signed word to integer coercion (cost 20) to "<return value>"

; compiling (USE-PACKAGE :SB-THREAD)
; compiling (DEFCONSTANT +REGEX-LIST+ ...)
; compiling (DEFCONSTANT +ALTERNATIVES+ ...)
; compiling (DEFCONSTANT +CPU-COUNT+ ...)
; compiling (DEFMACRO BG ...)
; compiling (DEFPARAMETER *SEMAPHORES* ...)
; compiling (DEFPARAMETER *SEMAPHORE* ...)
; compiling (DEFUN JOIN ...)
; file: /home/dunham/shootout/bench/regexdna/regexdna.sbcl-3.sbcl
; in: DEFUN JOIN
;     (MAPCAR #'LENGTH STRINGS)
; --> LET LET SB-INT:DO-ANONYMOUS BLOCK LET TAGBODY TAGBODY RPLACD LET PROGN 
; --> SETF SB-KERNEL:%RPLACD SETQ THE LIST CONS 
; ==>
;   (SB-C::%FUNCALL #:G116 (CAR #:G115))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFUN LENGTH-TO-REPLACE ...)
; compiling (DEFUN REPLACE-AUX ...)
; file: /home/dunham/shootout/bench/regexdna/regexdna.sbcl-3.sbcl
; in: DEFUN REPLACE-AUX
;     (SETF (SUBSEQ RESULT-STRING I)
;             (SUBSEQ TARGET-STRING J (CAR PAIR))
;           I
;             (+ I (- (THE FIXNUM (CAR PAIR)) J))
;           (SUBSEQ RESULT-STRING I)
;             REPLACEMENT
;           J
;             (CDR PAIR)
;           I
;             (+ I LEN))
; --> PROGN SETF LET* MULTIPLE-VALUE-BIND LET PROGN 
; ==>
;   (REPLACE #:G211 #:G213 :START1 #:G212 :END1 NIL)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a VECTOR, not a SIMPLE-BASE-STRING.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a VECTOR, not a (SIMPLE-ARRAY CHARACTER (*)).

; compiling (DEFUN PARTS ...)
; file: /home/dunham/shootout/bench/regexdna/regexdna.sbcl-3.sbcl
; in: DEFUN PARTS
;     (FLOOR LEN PARTS-NUM)
; --> BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   (VALUES SB-KERNEL::TRU REM)
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (VALUES (1- SB-KERNEL::TRU) (+ REM SB-KERNEL::DIVISOR))
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DEFUN REPLACE-ALL ...)
; file: /home/dunham/shootout/bench/regexdna/regexdna.sbcl-3.sbcl
; in: DEFUN REPLACE-ALL
;     (CL-PPCRE:DO-SCANS
;      (MATCH-START MATCH-END REG-STARTS REG-ENDS REGEXP TARGET-STRING NIL)
;      (PUSH (CONS MATCH-START MATCH-END) RMATCH))
; --> LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==>
;   (= MATCH-START MATCH-END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ MATCH-END 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

; --> LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==>
;   (= MATCH-START MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.

; --> LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ MATCH-END 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN READ-ALL ...)
; compiling (DEFUN MAIN ...)
; file: /home/dunham/shootout/bench/regexdna/regexdna.sbcl-3.sbcl
; in: DEFUN MAIN
;     (CL-PPCRE:ALL-MATCHES REG SEQUENCE :ELEMENT-TYPE 'BASE-CHAR)
; 
; caught STYLE-WARNING:
;   :ELEMENT-TYPE is not a known argument keyword.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
;   printed 24 notes


; /home/dunham/Documents/benchmarksgame/regexdna/tmp/regexdna.sbcl-3.fasl written
; compilation finished in 0:00:00.681
[undoing binding stack and other enclosing state... done]
[saving current Lisp image into /home/dunham/Documents/benchmarksgame/regexdna/tmp/sbcl.core:
writing 6272 bytes from the read-only space at 0x20000000
writing 3872 bytes from the static space at 0x20100000
writing 44974080 bytes from the dynamic space at 0x1000000000
done]
### START regexdna.sbcl-3.sbcl_run
(proclaim '(optimize (speed 3) (safety 0) (debug 0) (compilation-speed 0) (space 0)))
(main) (quit)
### END regexdna.sbcl-3.sbcl_run

1.86s to complete and log all make actions

COMMAND LINE:
/usr/local/bin/sbcl --dynamic-space-size 800 --noinform --core sbcl.core --userinit /dev/null --load regexdna.sbcl-3.sbcl_run 0 < regexdna-input50000.txt

UNEXPECTED OUTPUT 

3,6c3,6
< a[act]ggtaaa|tttacc[agt]t 40
< ag[act]gtaaa|tttac[agt]ct 25
< agg[act]taaa|ttta[agt]cct 50
< aggg[acg]aaa|ttt[cgt]ccct 15
---
> a[act]ggtaaa|tttacc[agt]t 43
> ag[act]gtaaa|tttac[agt]ct 27
> agg[act]taaa|ttta[agt]cct 58
> aggg[acg]aaa|ttt[cgt]ccct 16
9c9
< agggtaa[cgt]|[acg]ttaccct 19
---
> agggtaa[cgt]|[acg]ttaccct 20
13c13
< 516976
---
> 668262

PROGRAM OUTPUT:
agggtaaa|tttaccct 3
[cgt]gggtaaa|tttaccc[acg] 12
a[act]ggtaaa|tttacc[agt]t 40
ag[act]gtaaa|tttac[agt]ct 25
agg[act]taaa|ttta[agt]cct 50
aggg[acg]aaa|ttt[cgt]ccct 15
agggt[cgt]aa|tt[acg]accct 15
agggta[cgt]a|t[acg]taccct 18
agggtaa[cgt]|[acg]ttaccct 19

508411
500000
516976
