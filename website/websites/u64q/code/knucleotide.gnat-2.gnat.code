<source>
<def></def><slc>-------------------------------------------------------------------------------</slc><br />
<def></def><slc>--  The Computer Language Benchmarks Game</slc><br />
<def></def><slc>--  http://shootout.alioth.debian.org/</slc><br />
<def></def><slc>--</slc><br />
<def></def><slc>--  Contributed by Martin Krischik</slc><br />
<def></def><slc>-------------------------------------------------------------------------------</slc><br />
<def></def><br />
<kwa>pragma</kwa> <def>Ada_2005</def><sym>;</sym><br />
<def></def><br />
<slc>--  Standart set of performance improving pragmas as suggested by the GNAT users manual.</slc><br />
<def></def><kwa>pragma</kwa> <def>Restrictions</def> <sym>(</sym><def>Max_Asynchronous_Select_Nesting</def> <sym>=&gt;</sym> <def></def><num>0</num><def></def><sym>);</sym><br />
<def></def><kwa>pragma</kwa> <def>Restrictions</def> <sym>(</sym><def>No_Abort_Statements</def><sym>);</sym><br />
<def></def><br />
<kwa>with</kwa> <def>Ada.Characters.Handling</def><sym>;</sym><br />
<def></def><kwa>with</kwa> <def>Ada.Characters.Latin_1</def><sym>;</sym><br />
<def></def><kwa>with</kwa> <def>Ada.Containers.Generic_Constrained_Array_Sort</def><sym>;</sym><br />
<def></def><kwa>with</kwa> <def>Ada.Containers.Hashed_Maps</def><sym>;</sym><br />
<def></def><kwa>with</kwa> <def>Ada.Float_Text_IO</def><sym>;</sym><br />
<def></def><kwa>with</kwa> <def>Ada.IO_Exceptions</def><sym>;</sym><br />
<def></def><kwa>with</kwa> <def>Ada.Integer_Text_IO</def><sym>;</sym><br />
<def></def><kwa>with</kwa> <def>Ada.Strings.Bounded</def><sym>;</sym><br />
<def></def><kwa>with</kwa> <def>Ada.Text_IO</def><sym>;</sym><br />
<def></def><br />
<kwa>procedure</kwa> <def>KNucleotide_3</def> <kwa>is</kwa><br />
<def></def>   <slc>--  Appox. gain 0.3s for N=250.000 - that realy proves that runtime checks are bad for you</slc><br />
<def></def>   <slc>--  ;-).</slc><br />
<def></def>   <kwa>pragma</kwa> <def>Suppress</def> <sym>(</sym><def>All_Checks</def><sym>);</sym><br />
<def></def><br />
   <kwa>subtype</kwa> <def>Frequencies</def> <kwa>is</kwa> <def></def><kwb>Natural</kwb> <def></def><kwa>range</kwa> <def></def><num>1</num> <def>..</def> <num>18</num><def></def><sym>;</sym><br />
<def></def><br />
   <kwa>package</kwa> <def>Fragments</def> <kwa>is new</kwa> <def>Ada.Strings.Bounded.Generic_Bounded_Length</def> <sym>(</sym><def>Frequencies</def><sym>'</sym><def>Last</def><sym>);</sym><br />
<def></def><br />
   <kwa>use type</kwa> <def>Fragments.Bounded_String</def><sym>;</sym><br />
<def></def><br />
   <kwa>subtype</kwa> <def>Fragment</def> <kwa>is</kwa> <def>Fragments.Bounded_String</def><sym>;</sym><br />
<def></def><br />
   <kwa>package</kwa> <def>Reader</def> <kwa>is</kwa><br />
<def></def>      <slc>----------------------------------------------------------------------------</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <slc>--  Read data from Standart_Input and return the section THREE as String</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <kwa>function</kwa> <def>Read</def> <kwa>return</kwa> <def></def><kwb>String</kwb><def></def><sym>;</sym><br />
<def></def>      <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def>Read</def><sym>);</sym><br />
<def></def>   <kwa>end</kwa> <def>Reader</def><sym>;</sym><br />
<def></def><br />
   <slc>------------------------------------------------------------------------</slc><br />
<def></def>   <slc>--</slc><br />
<def></def>   <slc>--  The Calculator package calculates the nucleotide frequencies and keeps the result inside</slc><br />
<def></def>   <slc>--  a hash table as requested by the shootout rules.</slc><br />
<def></def>   <slc>--</slc><br />
<def></def>   <kwa>package</kwa> <def>Calculator</def> <kwa>is</kwa><br />
<def></def>      <slc>---------------------------------------------------------------------</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <slc>--  Elements used to store inside hash table</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <kwa>type</kwa> <def>Element_Type</def> <kwa>is private</kwa><def></def><sym>;</sym><br />
<def></def>      <kwa>type</kwa> <def>Element_Array</def> <kwa>is array</kwa> <def></def><sym>(</sym><def></def><kwb>Natural</kwb> <def></def><kwa>range</kwa> <def></def><sym>&lt;&gt;)</sym> <def></def><kwa>of</kwa> <def>Element_Type</def><sym>;</sym><br />
<def></def><br />
      <slc>---------------------------------------------------------------------</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <slc>--  Calculate the calculates the nucleotide frequencies</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <kwa>procedure</kwa> <def>Calculate_Frequencies</def> <sym>(</sym><def>Length</def> <sym>:</sym> <def></def><kwa>in</kwa> <def>Frequencies</def><sym>);</sym><br />
<def></def><br />
      <kwa>function</kwa> <def>Hash</def> <sym>(</sym><def>Key</def> <sym>:</sym> <def></def><kwa>in</kwa> <def>Fragment</def><sym>)</sym> <def></def><kwa>return</kwa> <def>Ada.Containers.Hash_Type</def><sym>;</sym><br />
<def></def><br />
      <slc>---------------------------------------------------------------------</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <slc>--  Calculate the calculates the nucleotide frequencies</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <kwa>function</kwa> <def>Get</def> <sym>(</sym><def>Nucleotide_Fragment</def> <sym>:</sym> <def></def><kwa>in</kwa> <def>Fragment</def><sym>)</sym> <def></def><kwa>return</kwa> <def></def><kwb>Natural</kwb><def></def><sym>;</sym><br />
<def></def><br />
      <slc>---------------------------------------------------------------------</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <slc>--  Get count for element</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <kwa>function</kwa> <def>Key</def> <sym>(</sym><def>Element</def> <sym>:</sym> <def></def><kwa>in</kwa> <def>Element_Type</def><sym>)</sym> <def></def><kwa>return</kwa> <def>Fragment</def><sym>;</sym><br />
<def></def><br />
      <slc>---------------------------------------------------------------------</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <slc>--  Get count for element</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <kwa>function</kwa> <def>Count</def> <sym>(</sym><def>Element</def> <sym>:</sym> <def></def><kwa>in</kwa> <def>Element_Type</def><sym>)</sym> <def></def><kwa>return</kwa> <def></def><kwb>Natural</kwb><def></def><sym>;</sym><br />
<def></def>      <slc>---------------------------------------------------------------------</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <slc>--  Get total count over all elements - as well as the count of elements</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <kwa>procedure</kwa> <def>Get_Total</def> <sym>(</sym><def>Total</def> <sym>:</sym> <def></def><kwa>out</kwa> <def></def><kwb>Natural</kwb><def></def><sym>;</sym> <def>Count</def> <sym>:</sym> <def></def><kwa>out</kwa> <def></def><kwb>Natural</kwb><def></def><sym>);</sym><br />
<def></def>      <kwa>function</kwa> <def>Get_Array</def> <sym>(</sym><def>Count</def> <sym>:</sym> <def></def><kwa>in</kwa> <def></def><kwb>Natural</kwb><def></def><sym>)</sym> <def></def><kwa>return</kwa> <def>Element_Array</def><sym>;</sym><br />
<def></def>      <kwa>function</kwa> <def></def><str>&quot;&gt;&quot;</str><def></def> <sym>(</sym><def>Left</def> <sym>:</sym> <def></def><kwa>in</kwa> <def>Element_Type</def><sym>;</sym> <def>Right</def> <sym>:</sym> <def></def><kwa>in</kwa> <def>Element_Type</def><sym>)</sym> <def></def><kwa>return</kwa> <def></def><kwb>Boolean</kwb><def></def><sym>;</sym><br />
<def></def><br />
      <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def></def><str>&quot;&gt;&quot;</str><def></def><sym>);</sym><br />
<def></def>      <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def>Calculate_Frequencies</def><sym>);</sym><br />
<def></def>      <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def>Count</def><sym>);</sym><br />
<def></def>      <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def>Get</def><sym>);</sym><br />
<def></def>      <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def>Get_Total</def><sym>);</sym><br />
<def></def>      <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def>Hash</def><sym>);</sym><br />
<def></def>      <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def>Key</def><sym>);</sym><br />
<def></def>   <kwa>private</kwa><br />
<def></def>      <slc>---------------------------------------------------------------------</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <slc>--  Elements used to store inside hash table.</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <kwa>type</kwa> <def>Element_Type</def> <kwa>is record</kwa><br />
<def>         Count</def> <sym>:</sym> <def></def><kwb>Natural</kwb>  <def></def><sym>:=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def>         Key</def>   <sym>:</sym> <def>Fragment</def> <sym>:=</sym> <def>Fragments.Null_Bounded_String</def><sym>;</sym><br />
<def></def>      <kwa>end record</kwa><def></def><sym>;</sym><br />
<def></def>   <kwa>end</kwa> <def>Calculator</def><sym>;</sym><br />
<def></def><br />
   <slc>----------------------------------------------------------------------------</slc><br />
<def></def>   <slc>--</slc><br />
<def></def>   <slc>--  Calculate and write data - either a percentage for all fragments found or - when</slc><br />
<def></def>   <slc>--  Nucleotide_Fragment is given - the count for that fragment.</slc><br />
<def></def>   <slc>--</slc><br />
<def></def>   <kwa>procedure</kwa> <def>Write</def> <sym>(</sym><def>Nucleotide_Length</def> <sym>:</sym> <def></def><kwa>in</kwa> <def>Frequencies</def><sym>);</sym><br />
<def></def>   <kwa>procedure</kwa> <def>Write</def> <sym>(</sym><def>Nucleotide_Fragment</def> <sym>:</sym> <def></def><kwa>in</kwa> <def>Fragment</def><sym>);</sym><br />
<def></def><br />
   <slc>----------------------------------------------------------------------------</slc><br />
<def></def>   <slc>--</slc><br />
<def></def>   <slc>--  List of fragments to be analyzed for this test</slc><br />
<def></def>   <slc>--</slc><br />
<def>   Fragment_3</def>  <sym>:</sym> <def></def><kwa>constant</kwa> <def>Fragment</def> <sym>:=</sym> <def>Fragments.To_Bounded_String</def> <sym>(</sym><def></def><str>&quot;GGT&quot;</str><def></def><sym>);</sym><br />
<def>   Fragment_4</def>  <sym>:</sym> <def></def><kwa>constant</kwa> <def>Fragment</def> <sym>:=</sym> <def>Fragments.To_Bounded_String</def> <sym>(</sym><def></def><str>&quot;GGTA&quot;</str><def></def><sym>);</sym><br />
<def>   Fragment_6</def>  <sym>:</sym> <def></def><kwa>constant</kwa> <def>Fragment</def> <sym>:=</sym> <def>Fragments.To_Bounded_String</def> <sym>(</sym><def></def><str>&quot;GGTATT&quot;</str><def></def><sym>);</sym><br />
<def>   Fragment_12</def> <sym>:</sym> <def></def><kwa>constant</kwa> <def>Fragment</def> <sym>:=</sym> <def>Fragments.To_Bounded_String</def> <sym>(</sym><def></def><str>&quot;GGTATTTTAATT&quot;</str><def></def><sym>);</sym><br />
<def>   Fragment_18</def> <sym>:</sym> <def></def><kwa>constant</kwa> <def>Fragment</def> <sym>:=</sym> <def>Fragments.To_Bounded_String</def> <sym>(</sym><def></def><str>&quot;GGTATTTTAATTTATAGT&quot;</str><def></def><sym>);</sym><br />
<def></def><br />
   <kwa>package body</kwa> <def>Reader</def> <kwa>is</kwa><br />
<def></def>      <slc>-------------------------------------------------------------------------</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <slc>--  Skip data on Standart_Input until &quot;&gt;THREE&quot; is found</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <kwa>procedure</kwa> <def>Skip_To_Section</def><sym>;</sym><br />
<def></def><br />
      <slc>-------------------------------------------------------------------------</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <slc>--  Read next data section - until EOF oder a line beginning with &gt; is found</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <kwa>function</kwa> <def>Read_Section</def> <kwa>return</kwa> <def></def><kwb>String</kwb><def></def><sym>;</sym><br />
<def></def><br />
      <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def>Read_Section</def><sym>);</sym><br />
<def></def>      <kwa>pragma</kwa> <def>Inline</def> <sym>(</sym><def>Skip_To_Section</def><sym>);</sym><br />
<def><br />
      Section_Marker</def> <sym>:</sym> <def></def><kwa>constant</kwa> <def></def><kwb>Character</kwb> <def></def><sym>:= '&gt;';</sym><br />
<def>      Section</def>        <sym>:</sym> <def></def><kwa>constant</kwa> <def></def><kwb>String</kwb>    <def></def><sym>:=</sym> <def>Section_Marker</def> <sym>&amp;</sym> <def></def><str>&quot;THREE&quot;</str><def></def><sym>;</sym><br />
<def></def><br />
      <kwa>function</kwa> <def>Read</def> <kwa>return</kwa> <def></def><kwb>String</kwb> <def></def><kwa>is</kwa><br />
<def></def>      <kwa>begin</kwa><br />
<def>         Skip_To_Section</def><sym>;</sym><br />
<def></def>         <kwa>return</kwa> <def>Ada.Characters.Handling.To_Upper</def> <sym>(</sym><def>Read_Section</def><sym>);</sym><br />
<def></def>      <kwa>end</kwa> <def>Read</def><sym>;</sym><br />
<def></def><br />
      <slc>-------------------------------------------------------------------------</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <slc>--  Read next data section - until EOF oder a line beginning with &gt; is found</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <kwa>function</kwa> <def>Read_Section</def> <kwa>return</kwa> <def></def><kwb>String</kwb> <def></def><kwa>is</kwa><br />
<def>         Buffer</def>     <sym>:</sym> <def></def><kwb>String</kwb> <def></def><sym>(</sym><def></def><num>1</num> <def>..</def> <num>10240</num><def></def><sym>);</sym><br />
<def>         Read_First</def> <sym>:</sym> <def></def><kwb>Natural</kwb> <def></def><sym>:=</sym> <def>Buffer</def><sym>'</sym><def>First</def><sym>;</sym><br />
<def>         Read_Last</def>  <sym>:</sym> <def></def><kwb>Natural</kwb> <def></def><sym>:=</sym> <def>Buffer</def><sym>'</sym><def>First</def><sym>;</sym><br />
<def></def>      <kwa>begin</kwa><br />
<def></def>         <kwa>loop</kwa><br />
<def>            Ada.Text_IO.Get_Line</def><br />
              <sym>(</sym><def>Item</def> <sym>=&gt;</sym> <def>Buffer</def> <sym>(</sym><def>Read_First .. Buffer</def><sym>'</sym><def>Last</def><sym>),</sym><br />
<def>               Last</def> <sym>=&gt;</sym> <def>Read_Last</def><sym>);</sym><br />
<def></def>            <kwa>exit when</kwa> <def>Buffer</def> <sym>(</sym><def>Read_First</def><sym>) =</sym> <def>Section_Marker</def><sym>;</sym><br />
<def></def>            <kwa>if</kwa> <def>Read_Last</def> <sym>=</sym> <def>Buffer</def><sym>'</sym><def>Last</def> <kwa>then</kwa><br />
<def></def>               <kwa>return</kwa> <def>Buffer</def> <sym>&amp;</sym> <def>Read_Section</def><sym>;</sym><br />
<def></def>            <kwa>end if</kwa><def></def><sym>;</sym><br />
<def>            Read_First</def> <sym>:=</sym> <def>Read_Last</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>         <kwa>end loop</kwa><def></def><sym>;</sym><br />
<def></def>         <kwa>return</kwa> <def>Buffer</def> <sym>(</sym><def></def><num>1</num> <def>.. Read_Last</def><sym>);</sym><br />
<def></def>      <kwa>exception</kwa><br />
<def></def>         <kwa>when</kwa> <def>Ada.IO_Exceptions.End_Error</def> <sym>=&gt;</sym><br />
<def></def>            <kwa>return</kwa> <def>Buffer</def> <sym>(</sym><def></def><num>1</num> <def>.. Read_Last</def><sym>);</sym><br />
<def></def>      <kwa>end</kwa> <def>Read_Section</def><sym>;</sym><br />
<def></def><br />
      <slc>-------------------------------------------------------------------------</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <slc>--  Skip data on Standart_Input until &quot;&gt;THREE&quot; is found</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <kwa>procedure</kwa> <def>Skip_To_Section</def> <kwa>is</kwa><br />
<def></def>         <slc>--</slc><br />
<def></def>         <slc>--  The line lenght of the test data is 60 character. Note: Get_Line would survive</slc><br />
<def></def>         <slc>--  longer lines as well - they would just be read in two parts.</slc><br />
<def></def>         <slc>--</slc><br />
<def>         Line</def>      <sym>:</sym> <def></def><kwb>String</kwb> <def></def><sym>(</sym><def></def><num>1</num> <def>..</def> <num>60</num><def></def><sym>);</sym><br />
<def>         Read_Last</def> <sym>:</sym> <def></def><kwb>Natural</kwb><def></def><sym>;</sym><br />
<def></def>      <kwa>begin</kwa><br />
<def></def>         <kwa>loop</kwa><br />
<def>            Ada.Text_IO.Get_Line</def> <sym>(</sym><def>Item</def> <sym>=&gt;</sym> <def>Line</def><sym>,</sym> <def>Last</def> <sym>=&gt;</sym> <def>Read_Last</def><sym>);</sym><br />
<def></def>            <kwa>exit when</kwa> <def>Line</def> <sym>(</sym><def></def><num>1</num> <def>..</def> <num>6</num><def></def><sym>) =</sym> <def>Section</def><sym>;</sym><br />
<def></def>         <kwa>end loop</kwa><def></def><sym>;</sym><br />
<def></def>      <kwa>end</kwa> <def>Skip_To_Section</def><sym>;</sym><br />
<def></def>   <kwa>end</kwa> <def>Reader</def><sym>;</sym><br />
<def></def><br />
   <slc>---------------------------------------------------------------------------</slc><br />
<def></def>   <slc>--</slc><br />
<def></def>   <slc>--  Data read as single String</slc><br />
<def></def>   <slc>--</slc><br />
<def>   Buffer</def> <sym>:</sym> <def></def><kwa>constant</kwa> <def></def><kwb>String</kwb> <def></def><sym>:=</sym> <def>Reader.Read</def><sym>;</sym><br />
<def></def><br />
   <slc>------------------------------------------------------------------------</slc><br />
<def></def>   <slc>--</slc><br />
<def></def>   <slc>--  The Calculator package calculates the nucleotide frequencies and keeps the result inside</slc><br />
<def></def>   <slc>--  a hash table as requested by the shootout rules.</slc><br />
<def></def>   <slc>--</slc><br />
<def></def>   <kwa>package body</kwa> <def>Calculator</def> <kwa>is</kwa><br />
<def></def><br />
      <kwa>procedure</kwa> <def>Increment</def> <sym>(</sym><def>Key</def> <sym>:</sym> <def></def><kwa>in</kwa> <def>Fragment</def><sym>;</sym> <def>Element</def> <sym>:</sym> <def></def><kwa>in out</kwa> <def>Element_Type</def><sym>);</sym><br />
<def></def><br />
      <kwa>package</kwa> <def>Element_Maps</def> <kwa>is new</kwa> <def>Ada.Containers.Hashed_Maps</def> <sym>(</sym><br />
<def>         Key_Type</def> <sym>=&gt;</sym> <def>Fragment</def><sym>,</sym><br />
<def>         Element_Type</def> <sym>=&gt;</sym> <def>Element_Type</def><sym>,</sym><br />
<def>         Hash</def> <sym>=&gt;</sym> <def>Hash</def><sym>,</sym><br />
<def>         Equivalent_Keys</def> <sym>=&gt;</sym> <def></def><str>&quot;=&quot;</str><def></def><sym>,</sym><br />
<def></def>         <str>&quot;=&quot;</str><def></def> <sym>=&gt;</sym> <def>Calculator.</def> <str>&quot;=&quot;</str><def></def><sym>);</sym><br />
<def><br />
      Table</def> <sym>:</sym> <def>Element_Maps.Map</def><sym>;</sym><br />
<def></def><br />
      <kwa>function</kwa> <def></def><str>&quot;&gt;&quot;</str><def></def> <sym>(</sym><def>Left</def> <sym>:</sym> <def></def><kwa>in</kwa> <def>Element_Type</def><sym>;</sym> <def>Right</def> <sym>:</sym> <def></def><kwa>in</kwa> <def>Element_Type</def><sym>)</sym> <def></def><kwa>return</kwa> <def></def><kwb>Boolean</kwb> <def></def><kwa>is</kwa><br />
<def></def>      <kwa>begin</kwa><br />
<def></def>         <kwa>return</kwa> <def>Left.Count</def> <sym>&gt;</sym> <def>Right.Count</def><sym>;</sym><br />
<def></def>      <kwa>end</kwa> <def></def><str>&quot;&gt;&quot;</str><def></def><sym>;</sym><br />
<def></def><br />
      <slc>---------------------------------------------------------------------</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <slc>--  Calculate the calculates the nucleotide frequencies</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <kwa>procedure</kwa> <def>Calculate_Frequencies</def> <sym>(</sym><def>Length</def> <sym>:</sym> <def>Frequencies</def><sym>)</sym> <def></def><kwa>is</kwa><br />
<def></def><br />
      <kwa>begin</kwa><br />
<def>         Table.Clear</def><sym>;</sym><br />
<def>         Table.Reserve_Capacity</def> <sym>(</sym><def>Ada.Containers.Count_Type</def> <sym>(</sym><def></def><num>4</num> <def></def><sym>**</sym> <def>Length</def><sym>));</sym><br />
<def></def>         <kwa>for</kwa> <def>I</def> <kwa>in</kwa> <def></def><num>1</num> <def>.. Buffer</def><sym>'</sym><def>Last</def> <sym>-</sym> <def></def><kwb>Integer</kwb> <def></def><sym>(</sym><def>Length</def><sym>) +</sym> <def></def><num>1</num> <def></def><kwa>loop</kwa><br />
<def></def>            <kwa>declare</kwa><br />
<def></def>               <kwa>use type</kwa> <def>Element_Maps.Cursor</def><sym>;</sym><br />
<def><br />
               Key</def>     <sym>:</sym> <def></def><kwa>constant</kwa> <def>Fragment</def>            <sym>:=</sym><br />
<def>                  Fragments.To_Bounded_String</def> <sym>(</sym><def>Buffer</def> <sym>(</sym><def>I .. I</def> <sym>+</sym> <def></def><kwb>Integer</kwb> <def></def><sym>(</sym><def>Length</def><sym>) -</sym> <def></def><num>1</num><def></def><sym>));</sym><br />
<def>               Element</def> <sym>:</sym> <def></def><kwa>constant</kwa> <def>Element_Maps.Cursor</def> <sym>:=</sym> <def>Table.Find</def> <sym>(</sym><def>Key</def><sym>);</sym><br />
<def></def>            <kwa>begin</kwa><br />
<def></def>               <kwa>if</kwa> <def>Element</def> <sym>/=</sym> <def>Element_Maps.No_Element</def> <kwa>then</kwa><br />
<def>                  Table.Update_Element</def> <sym>(</sym><def>Position</def> <sym>=&gt;</sym> <def>Element</def><sym>,</sym> <def>Process</def> <sym>=&gt;</sym> <def>Increment</def><sym>'</sym><def></def><kwa>Access</kwa><def></def><sym>);</sym><br />
<def></def>               <kwa>else</kwa><br />
<def>                  Table.Insert</def><br />
                    <sym>(</sym><def>Key</def>      <sym>=&gt;</sym> <def>Key</def><sym>,</sym><br />
<def>                     New_Item</def> <sym>=&gt;</sym> <def>Element_Type</def><sym>'(</sym><def>Count</def> <sym>=&gt;</sym> <def></def><num>1</num><def></def><sym>,</sym> <def>Key</def> <sym>=&gt;</sym> <def>Key</def><sym>));</sym><br />
<def></def>               <kwa>end if</kwa><def></def><sym>;</sym><br />
<def></def>            <kwa>end</kwa><def></def><sym>;</sym><br />
<def></def>         <kwa>end loop</kwa><def></def><sym>;</sym><br />
<def></def>         <kwa>return</kwa><def></def><sym>;</sym><br />
<def></def>      <kwa>end</kwa> <def>Calculate_Frequencies</def><sym>;</sym><br />
<def></def><br />
      <slc>---------------------------------------------------------------------</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <slc>--  Get count for element</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <kwa>function</kwa> <def>Count</def> <sym>(</sym><def>Element</def> <sym>:</sym> <def></def><kwa>in</kwa> <def>Element_Type</def><sym>)</sym> <def></def><kwa>return</kwa> <def></def><kwb>Natural</kwb> <def></def><kwa>is</kwa><br />
<def></def>      <kwa>begin</kwa><br />
<def></def>         <kwa>return</kwa> <def>Element.Count</def><sym>;</sym><br />
<def></def>      <kwa>end</kwa> <def>Count</def><sym>;</sym><br />
<def></def><br />
      <slc>---------------------------------------------------------------------</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <slc>--  Calculate the calculates the nucleotide frequencies</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <kwa>function</kwa> <def>Get</def> <sym>(</sym><def>Nucleotide_Fragment</def> <sym>:</sym> <def></def><kwa>in</kwa> <def>Fragment</def><sym>)</sym> <def></def><kwa>return</kwa> <def></def><kwb>Natural</kwb> <def></def><kwa>is</kwa><br />
<def></def>         <kwa>use type</kwa> <def>Element_Maps.Cursor</def><sym>;</sym><br />
<def>         The_Element</def> <sym>:</sym> <def></def><kwa>constant</kwa> <def>Element_Maps.Cursor</def> <sym>:=</sym> <def>Table.Find</def> <sym>(</sym><def>Nucleotide_Fragment</def><sym>);</sym><br />
<def></def>      <kwa>begin</kwa><br />
<def></def>         <kwa>if</kwa> <def>The_Element</def> <sym>/=</sym> <def>Element_Maps.No_Element</def> <kwa>then</kwa><br />
<def></def>            <kwa>return</kwa> <def>Element_Maps.Element</def> <sym>(</sym><def>The_Element</def><sym>)</sym><def>.Count</def><sym>;</sym><br />
<def></def>         <kwa>else</kwa><br />
<def></def>            <kwa>return</kwa> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>         <kwa>end if</kwa><def></def><sym>;</sym><br />
<def></def>      <kwa>end</kwa> <def>Get</def><sym>;</sym><br />
<def></def><br />
      <kwa>function</kwa> <def>Get_Array</def> <sym>(</sym><def>Count</def> <sym>:</sym> <def></def><kwa>in</kwa> <def></def><kwb>Natural</kwb><def></def><sym>)</sym> <def></def><kwa>return</kwa> <def>Element_Array</def> <kwa>is</kwa><br />
<def></def>         <kwa>subtype</kwa> <def>Retval_Index</def> <kwa>is</kwa> <def></def><kwb>Natural</kwb> <def></def><kwa>range</kwa> <def></def><num>1</num> <def>.. Count</def><sym>;</sym><br />
<def></def>         <kwa>subtype</kwa> <def>Retval_Type</def> <kwa>is</kwa> <def>Element_Array</def> <sym>(</sym><def>Retval_Index</def><sym>);</sym><br />
<def>         Retval</def> <sym>:</sym> <def>Retval_Type</def><sym>;</sym><br />
<def></def><br />
         <kwa>use type</kwa> <def>Calculator.Element_Type</def><sym>;</sym><br />
<def></def><br />
         <kwa>procedure</kwa> <def>Sort</def> <kwa>is new</kwa> <def>Ada.Containers.Generic_Constrained_Array_Sort</def> <sym>(</sym><br />
<def>            Index_Type</def> <sym>=&gt;</sym> <def>Retval_Index</def><sym>,</sym><br />
<def>            Element_Type</def> <sym>=&gt;</sym> <def>Element_Type</def><sym>,</sym><br />
<def>            Array_Type</def> <sym>=&gt;</sym> <def>Retval_Type</def><sym>,</sym><br />
<def></def>            <str>&quot;&lt;&quot;</str><def></def> <sym>=&gt;</sym> <def></def><str>&quot;&gt;&quot;</str><def></def><sym>);</sym><br />
<def><br />
         The_Element</def> <sym>:</sym> <def>Element_Maps.Cursor</def> <sym>:=</sym> <def>Table.First</def><sym>;</sym><br />
<def></def>      <kwa>begin</kwa><br />
<def></def>         <kwa>for</kwa> <def>I</def> <kwa>in</kwa> <def>Retval</def><sym>'</sym><def></def><kwa>Range loop</kwa><br />
<def>            Retval</def> <sym>(</sym><def>I</def><sym>) :=</sym> <def>Element_Maps.Element</def> <sym>(</sym><def>The_Element</def><sym>);</sym><br />
<def>            Element_Maps.Next</def> <sym>(</sym><def>The_Element</def><sym>);</sym><br />
<def></def>         <kwa>end loop</kwa><def></def><sym>;</sym><br />
<def><br />
         Sort</def> <sym>(</sym><def>Retval</def><sym>);</sym><br />
<def></def><br />
         <kwa>return</kwa> <def>Retval</def><sym>;</sym><br />
<def></def>      <kwa>end</kwa> <def>Get_Array</def><sym>;</sym><br />
<def></def><br />
      <slc>---------------------------------------------------------------------</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <slc>--  Get total count over all elements - as well as the count of elements</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <kwa>procedure</kwa> <def>Get_Total</def> <sym>(</sym><def>Total</def> <sym>:</sym> <def></def><kwa>out</kwa> <def></def><kwb>Natural</kwb><def></def><sym>;</sym> <def>Count</def> <sym>:</sym> <def></def><kwa>out</kwa> <def></def><kwb>Natural</kwb><def></def><sym>)</sym> <def></def><kwa>is</kwa><br />
<def></def>         <kwa>use type</kwa> <def>Element_Maps.Cursor</def><sym>;</sym><br />
<def>         The_Element</def> <sym>:</sym> <def>Element_Maps.Cursor</def> <sym>:=</sym> <def>Table.First</def><sym>;</sym><br />
<def></def>      <kwa>begin</kwa><br />
<def>         Total</def> <sym>:=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def>         Count</def> <sym>:=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>         <kwa>while</kwa> <def>The_Element</def> <sym>/=</sym> <def>Element_Maps.No_Element</def> <kwa>loop</kwa><br />
<def>            Total</def> <sym>:=</sym> <def>Total</def> <sym>+</sym> <def>Element_Maps.Element</def> <sym>(</sym><def>The_Element</def><sym>)</sym><def>.Count</def><sym>;</sym><br />
<def>            Count</def> <sym>:=</sym> <def>Count</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def>            Element_Maps.Next</def> <sym>(</sym><def>The_Element</def><sym>);</sym><br />
<def></def>         <kwa>end loop</kwa><def></def><sym>;</sym><br />
<def></def>      <kwa>end</kwa> <def>Get_Total</def><sym>;</sym><br />
<def></def><br />
      <kwa>function</kwa> <def>Hash</def> <sym>(</sym><def>Key</def> <sym>:</sym> <def>Fragment</def><sym>)</sym> <def></def><kwa>return</kwa> <def>Ada.Containers.Hash_Type</def> <kwa>is</kwa><br />
<def></def>         <kwa>use type</kwa> <def>Ada.Containers.Hash_Type</def><sym>;</sym><br />
<def></def><br />
         <kwa>function</kwa> <def>Rotate_Left</def><br />
           <sym>(</sym><def>Value</def>  <sym>:</sym> <def>Ada.Containers.Hash_Type</def><sym>;</sym><br />
<def>            Amount</def> <sym>:</sym> <def></def><kwb>Natural</kwb><def></def><sym>)</sym><br />
<def></def>            <kwa>return</kwa>   <def>Ada.Containers.Hash_Type</def><sym>;</sym><br />
<def></def>         <kwa>pragma</kwa> <def>Import</def> <sym>(</sym><def>Intrinsic</def><sym>,</sym> <def>Rotate_Left</def><sym>);</sym><br />
<def><br />
         Hash_Value</def> <sym>:</sym> <def>Ada.Containers.Hash_Type</def><sym>;</sym><br />
<def></def><br />
      <kwa>begin</kwa><br />
<def>         Hash_Value</def> <sym>:=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>         <kwa>for</kwa> <def>J</def> <kwa>in</kwa> <def></def><num>1</num> <def>.. Fragments.Length</def> <sym>(</sym><def>Key</def><sym>)</sym> <def></def><kwa>loop</kwa><br />
<def>            Hash_Value</def> <sym>:=</sym> <def>Rotate_Left</def> <sym>(</sym><def>Hash_Value</def><sym>,</sym> <def></def><num>3</num><def></def><sym>) +</sym><br />
<def></def>                          <kwb>Character</kwb><def></def><sym>'</sym><def>Pos</def> <sym>(</sym><def>Fragments.Element</def> <sym>(</sym><def>Key</def><sym>,</sym> <def>J</def><sym>));</sym><br />
<def></def>         <kwa>end loop</kwa><def></def><sym>;</sym><br />
<def></def><br />
         <kwa>return</kwa> <def>Hash_Value</def><sym>;</sym><br />
<def></def>      <kwa>end</kwa> <def>Hash</def><sym>;</sym><br />
<def></def><br />
      <kwa>procedure</kwa> <def>Increment</def> <sym>(</sym><def>Key</def> <sym>:</sym> <def></def><kwa>in</kwa> <def>Fragment</def><sym>;</sym> <def>Element</def> <sym>:</sym> <def></def><kwa>in out</kwa> <def>Element_Type</def><sym>)</sym> <def></def><kwa>is</kwa><br />
<def></def>         <kwa>pragma</kwa> <def>Unreferenced</def> <sym>(</sym><def>Key</def><sym>);</sym><br />
<def></def>      <kwa>begin</kwa><br />
<def>         Element.Count</def> <sym>:=</sym> <def></def><kwb>Natural</kwb><def></def><sym>'</sym><def>Succ</def> <sym>(</sym><def>Element.Count</def><sym>);</sym><br />
<def></def>      <kwa>end</kwa> <def>Increment</def><sym>;</sym><br />
<def></def><br />
      <slc>---------------------------------------------------------------------</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <slc>--  Get count for element</slc><br />
<def></def>      <slc>--</slc><br />
<def></def>      <kwa>function</kwa> <def>Key</def> <sym>(</sym><def>Element</def> <sym>:</sym> <def></def><kwa>in</kwa> <def>Element_Type</def><sym>)</sym> <def></def><kwa>return</kwa> <def>Fragment</def> <kwa>is</kwa><br />
<def></def>      <kwa>begin</kwa><br />
<def></def>         <kwa>return</kwa> <def>Element.Key</def><sym>;</sym><br />
<def></def>      <kwa>end</kwa> <def>Key</def><sym>;</sym><br />
<def></def><br />
   <kwa>end</kwa> <def>Calculator</def><sym>;</sym><br />
<def></def><br />
   <slc>----------------------------------------------------------------------------</slc><br />
<def></def>   <slc>--</slc><br />
<def></def>   <slc>--  Calculate and write data - either a percentage for all fragments found or - when</slc><br />
<def></def>   <slc>--  Nucleotide_Fragment is given - the count for that fragment.</slc><br />
<def></def>   <slc>--</slc><br />
<def></def>   <kwa>procedure</kwa> <def>Write</def> <sym>(</sym><def>Nucleotide_Length</def> <sym>:</sym> <def></def><kwa>in</kwa> <def>Frequencies</def><sym>)</sym> <def></def><kwa>is</kwa><br />
<def></def>   <kwa>begin</kwa><br />
<def>      Calculator.Calculate_Frequencies</def> <sym>(</sym><def>Nucleotide_Length</def><sym>);</sym><br />
<def><br />
      Calculate_Total</def> <sym>:</sym> <def></def><kwa>declare</kwa><br />
<def>         Count</def> <sym>:</sym> <def></def><kwb>Natural</kwb><def></def><sym>;</sym><br />
<def>         Total</def> <sym>:</sym> <def></def><kwb>Natural</kwb><def></def><sym>;</sym><br />
<def></def>      <kwa>begin</kwa><br />
<def>         Calculator.Get_Total</def> <sym>(</sym><def>Total</def> <sym>=&gt;</sym> <def>Total</def><sym>,</sym> <def>Count</def> <sym>=&gt;</sym> <def>Count</def><sym>);</sym><br />
<def><br />
         Get_Sort_Put</def> <sym>:</sym> <def></def><kwa>declare</kwa><br />
<def>            Data</def> <sym>:</sym> <def></def><kwa>constant</kwa> <def>Calculator.Element_Array</def> <sym>:=</sym> <def>Calculator.Get_Array</def> <sym>(</sym><def>Count</def><sym>);</sym><br />
<def></def>         <kwa>begin</kwa><br />
<def></def>            <kwa>for</kwa> <def>I</def> <kwa>in</kwa> <def>Data</def><sym>'</sym><def></def><kwa>Range loop</kwa><br />
<def>               Ada.Text_IO.Put</def> <sym>(</sym><def>Fragments.To_String</def> <sym>(</sym><def>Calculator.Key</def> <sym>(</sym><def>Data</def> <sym>(</sym><def>I</def><sym>))));</sym><br />
<def>               Ada.Text_IO.Put</def> <sym>(</sym><def>Ada.Characters.Latin_1.Space</def><sym>);</sym><br />
<def>               Ada.Float_Text_IO.Put</def><br />
                 <sym>(</sym><def>Item</def> <sym>=&gt;</sym> <def></def><num>100.0</num> <def></def><sym>*</sym> <def></def><kwb>Float</kwb> <def></def><sym>(</sym><def>Calculator.Count</def> <sym>(</sym><def>Data</def> <sym>(</sym><def>I</def><sym>))) /</sym> <def></def><kwb>Float</kwb> <def></def><sym>(</sym><def>Total</def><sym>),</sym><br />
<def>                  Fore</def> <sym>=&gt;</sym> <def></def><num>1</num><def></def><sym>,</sym><br />
<def>                  Aft</def>  <sym>=&gt;</sym> <def></def><num>3</num><def></def><sym>,</sym><br />
<def>                  Exp</def>  <sym>=&gt;</sym> <def></def><num>0</num><def></def><sym>);</sym><br />
<def>               Ada.Text_IO.New_Line</def><sym>;</sym><br />
<def></def>            <kwa>end loop</kwa><def></def><sym>;</sym><br />
<def>            Ada.Text_IO.New_Line</def><sym>;</sym><br />
<def></def>         <kwa>end</kwa> <def>Get_Sort_Put</def><sym>;</sym><br />
<def></def>      <kwa>end</kwa> <def>Calculate_Total</def><sym>;</sym><br />
<def></def><br />
      <kwa>return</kwa><def></def><sym>;</sym><br />
<def></def>   <kwa>end</kwa> <def>Write</def><sym>;</sym><br />
<def></def><br />
   <slc>----------------------------------------------------------------------------</slc><br />
<def></def>   <slc>--</slc><br />
<def></def>   <slc>--  Calculate and write data - either a percentage for all fragments found or - when</slc><br />
<def></def>   <slc>--  Nucleotide_Fragment is given - the count for that fragment.</slc><br />
<def></def>   <slc>--</slc><br />
<def></def>   <kwa>procedure</kwa> <def>Write</def> <sym>(</sym><def>Nucleotide_Fragment</def> <sym>:</sym> <def></def><kwa>in</kwa> <def>Fragment</def><sym>)</sym> <def></def><kwa>is</kwa><br />
<def></def>   <kwa>begin</kwa><br />
<def>      Calculator.Calculate_Frequencies</def> <sym>(</sym><def>Fragments.Length</def> <sym>(</sym><def>Nucleotide_Fragment</def><sym>));</sym><br />
<def>      Ada.Integer_Text_IO.Put</def> <sym>(</sym><def>Item</def> <sym>=&gt;</sym> <def>Calculator.Get</def> <sym>(</sym><def>Nucleotide_Fragment</def><sym>),</sym> <def>Width</def> <sym>=&gt;</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def>      Ada.Text_IO.Put</def> <sym>(</sym><def>Ada.Characters.Latin_1.HT</def><sym>);</sym><br />
<def>      Ada.Text_IO.Put_Line</def> <sym>(</sym><def>Fragments.To_String</def> <sym>(</sym><def>Nucleotide_Fragment</def><sym>));</sym><br />
<def></def>      <kwa>return</kwa><def></def><sym>;</sym><br />
<def></def>   <kwa>end</kwa> <def>Write</def><sym>;</sym><br />
<def></def><br />
<kwa>begin</kwa><br />
<def>   Write</def> <sym>(</sym><def></def><num>1</num><def></def><sym>);</sym><br />
<def>   Write</def> <sym>(</sym><def></def><num>2</num><def></def><sym>);</sym><br />
<def>   Write</def> <sym>(</sym><def>Fragment_3</def><sym>);</sym><br />
<def>   Write</def> <sym>(</sym><def>Fragment_4</def><sym>);</sym><br />
<def>   Write</def> <sym>(</sym><def>Fragment_6</def><sym>);</sym><br />
<def>   Write</def> <sym>(</sym><def>Fragment_12</def><sym>);</sym><br />
<def>   Write</def> <sym>(</sym><def>Fragment_18</def><sym>);</sym><br />
<def></def>   <kwa>return</kwa><def></def><sym>;</sym><br />
<def></def><kwa>end</kwa> <def>KNucleotide_3</def><sym>;</sym><br />
<def></def><br />
<slc>----------------------------------------------------------------------------</slc><br />
<def></def><slc>--  $Author: igouy-guest $</slc><br />
<def></def><slc>--</slc><br />
<def></def><slc>--  $Revision: 1.1 $</slc><br />
<def></def><slc>--  $Date: 2008-08-05 04:40:16 $</slc><br />
<def></def><slc>--</slc><br />
<def></def><slc>--  $Id: knucleotide.gnat-2.gnat.code,v 1.1 2008-08-05 04:40:16 igouy-guest Exp $</slc><br />
<def></def><slc>--  $HeadURL: http://wikibook-ada.svn.sourceforge.net/svnroot/wikibook-ada/trunk/demos/Source/Language_Shootout/knucleotide_3.adb $</slc><br />
<def></def><slc>-------------------------------------------------------------------------------</slc><br />
<def></def><slc>--   vim: textwidth=0 nowrap tabstop=8 shiftwidth=3 softtabstop=3 expandtab filetype=ada vim:</slc><br />
<def></def><slc>--   fileencoding=latin1 fileformat=unix</slc><def></def><br />
</source>
