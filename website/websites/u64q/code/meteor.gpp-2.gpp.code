<source>
<def></def><slc>// The Computer Language Shootout</slc><br />
<def></def><slc>// http://shootout.alioth.debian.org/</slc><br />
<def></def><slc>// contributed by Ben St. John</slc><br />
<def></def><br />
<dir>#include &lt;iostream&gt;</dir><br />
<def></def><dir>#include &lt;vector&gt;</dir><br />
<def></def><dir>#include &lt;string&gt;</dir><br />
<def></def><br />
<kwa>using namespace</kwa> <def>std</def><sym>;</sym><br />
<def></def><br />
<dir>#define FREE(p) {free(p); p = NULL;}</dir><br />
<def></def><br />
<kwb>enum</kwb> <def></def><sym>{</sym><def>X</def><sym>,</sym> <def>Y</def><sym>,</sym> <def>N_DIM</def><sym>};</sym><br />
<def></def><kwb>enum</kwb> <def></def><sym>{</sym><def>EVEN</def><sym>,</sym> <def>ODD</def><sym>,</sym> <def>N_PARITY</def><sym>};</sym><br />
<def></def><br />
<kwc>typedef</kwc> <def></def><kwb>unsigned int</kwb> <def>TUInt32</def><sym>;</sym><br />
<def></def><kwc>typedef</kwc> <def></def><kwb>unsigned long long</kwb> <def>TUInt64</def><sym>;</sym><br />
<def></def><kwc>typedef</kwc> <def></def><kwb>signed char</kwb> <def>TInt8</def><sym>;</sym><br />
<def></def><br />
<kwc>typedef</kwc> <def>TUInt64 BitVec</def><sym>;</sym><br />
<def></def><br />
<kwa>namespace</kwa> <def>Meteor</def><br />
<sym>{</sym><br />
<def></def><kwb>static const int</kwb> <def>N_COL</def> <sym>=</sym> <def></def><num>5</num><def></def><sym>;</sym><br />
<def></def><kwb>static const int</kwb> <def>N_ROW</def> <sym>=</sym> <def></def><num>10</num><def></def><sym>;</sym><br />
<def></def><kwb>static const int</kwb> <def>N_CELL</def> <sym>=</sym> <def>N_COL</def> <sym>*</sym> <def>N_ROW</def><sym>;</sym><br />
<def></def><br />
<kwc>class</kwc> <def>Piece</def><sym>;</sym><br />
<def></def><br />
<slc>//------------------------------------</slc><br />
<def></def><br />
<kwc>class</kwc> <def>Solution</def><br />
<sym>{</sym><br />
<def></def><kwc>public</kwc><def></def><sym>:</sym><br />
<def></def>   <kwb>static const int</kwb> <def>NO_PIECE</def> <sym>= -</sym><def></def><num>1</num><def></def><sym>;</sym><br />
<def></def><br />
   <kwb>void</kwb> <def></def><kwd>addPiece</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>BitVec</def> <sym>&amp;</sym> <def>vec</def><sym>,</sym> <def></def><kwb>int</kwb> <def>iPiece</def><sym>);</sym><br />
<def></def>   <kwb>void</kwb> <def></def><kwd>removeLastPiece</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>);</sym><br />
<def></def>   <kwb>void</kwb> <def></def><kwd>setCells</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>);</sym><br />
<def></def>   <kwb>bool</kwb> <def></def><kwd>lessThan</kwd><def></def><sym>(</sym><def>Solution</def> <sym>&amp;</sym> <def>r</def><sym>);</sym> <def></def><slc>///&lt; I don't feel like operator overloading</slc><br />
<def>   string</def> <kwd>toString</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>)</sym> <def></def><kwb>const</kwb><def></def><sym>;</sym><br />
<def></def>   <kwb>void</kwb> <def></def><kwd>fill</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>val</def><sym>);</sym><br />
<def></def>   <kwb>bool</kwb> <def></def><kwd>isEmpty</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>) {</sym><def></def><kwa>return</kwa> <def></def><sym>(</sym><def>m_pieces</def><sym>.</sym><def></def><kwd>size</kwd><def></def><sym>() ==</sym> <def></def><num>0</num><def></def><sym>);}</sym><br />
<def></def>   <kwb>void</kwb> <def></def><kwd>spin</kwd><def></def><sym>(</sym><def>Solution</def> <sym>&amp;</sym> <def>spun</def><sym>);</sym><br />
<def></def><br />
   <kwd>Solution</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>fillVal</def><sym>);</sym><br />
<def></def>   <kwd>Solution</kwd><def></def><sym>() {</sym><def>m_synched</def> <sym>=</sym> <def></def><kwa>false</kwa><def></def><sym>;}</sym><br />
<def></def><br />
<kwc>private</kwc><def></def><sym>:</sym><br />
<def></def>   <kwb>struct</kwb> <def>SPiece</def> <sym>{</sym><br />
<def>      BitVec vec</def><sym>;</sym><br />
<def>      TUInt32 iPiece</def><sym>;</sym><br />
<def></def>   <sym>};</sym><br />
<def>   vector</def><sym>&lt;</sym><def>SPiece</def><sym>&gt;</sym> <def>m_pieces</def><sym>;</sym><br />
<def>   TInt8 m_cells</def><sym>[</sym><def>N_ROW</def><sym>][</sym><def>N_COL</def><sym>];</sym><br />
<def></def>   <kwb>bool</kwb> <def>m_synched</def><sym>;</sym><br />
<def></def><sym>};</sym><br />
<def></def><br />
<slc>//------------------------------------</slc><br />
<def></def><br />
<kwc>class</kwc> <def>Board</def><br />
<sym>{</sym><br />
<def></def><kwc>public</kwc><def></def><sym>:</sym><br />
<def></def>   <kwb>static const</kwb> <def>BitVec L_EDGE_MASK</def> <sym>=</sym><br />
<def></def>      <sym>(</sym><def></def><num>1L</num><def>L</def> <sym>&lt;&lt;</sym>  <def></def><num>0</num><def></def><sym>) | (</sym><def></def><num>1L</num><def>L</def> <sym>&lt;&lt;</sym>  <def></def><num>5</num><def></def><sym>) | (</sym><def></def><num>1L</num><def>L</def> <sym>&lt;&lt;</sym> <def></def><num>10</num><def></def><sym>) | (</sym><def></def><num>1L</num><def>L</def> <sym>&lt;&lt;</sym> <def></def><num>15</num><def></def><sym>) |</sym><br />
<def></def>      <sym>(</sym><def></def><num>1L</num><def>L</def> <sym>&lt;&lt;</sym> <def></def><num>20</num><def></def><sym>) | (</sym><def></def><num>1L</num><def>L</def> <sym>&lt;&lt;</sym> <def></def><num>25</num><def></def><sym>) | (</sym><def></def><num>1L</num><def>L</def> <sym>&lt;&lt;</sym> <def></def><num>30</num><def></def><sym>) | (</sym><def></def><num>1L</num><def>L</def> <sym>&lt;&lt;</sym> <def></def><num>35</num><def></def><sym>) |</sym><br />
<def></def>      <sym>(</sym><def></def><num>1L</num><def>L</def> <sym>&lt;&lt;</sym> <def></def><num>40</num><def></def><sym>) | (</sym><def></def><num>1L</num><def>L</def> <sym>&lt;&lt;</sym> <def></def><num>45</num><def></def><sym>) | (</sym><def></def><num>1L</num><def>L</def> <sym>&lt;&lt;</sym> <def></def><num>50</num><def></def><sym>) | (</sym><def></def><num>1L</num><def>L</def> <sym>&lt;&lt;</sym> <def></def><num>55</num><def></def><sym>);</sym><br />
<def></def>   <kwb>static const</kwb> <def>BitVec R_EDGE_MASK</def> <sym>=</sym> <def>L_EDGE_MASK</def> <sym>&lt;&lt;</sym> <def></def><num>4</num><def></def><sym>;</sym><br />
<def></def>   <kwb>static const</kwb> <def>BitVec TOP_ROW</def> <sym>=</sym> <def></def><num>0x1f</num><def>LL</def><sym>;</sym><br />
<def></def>   <kwb>static const</kwb> <def>BitVec ROW_0_MASK</def> <sym>=</sym><br />
<def></def>      <sym>(</sym> <def>TOP_ROW</def>        <sym>| (</sym><def>TOP_ROW</def> <sym>&lt;&lt;</sym> <def></def><num>10</num><def></def><sym>) | (</sym><def>TOP_ROW</def> <sym>&lt;&lt;</sym> <def></def><num>20</num><def></def><sym>) | (</sym><def>TOP_ROW</def> <sym>&lt;&lt;</sym> <def></def><num>30</num><def></def><sym>) |</sym><br />
<def></def>       <sym>(</sym><def>TOP_ROW</def> <sym>&lt;&lt;</sym> <def></def><num>40</num><def></def><sym>) | (</sym><def>TOP_ROW</def> <sym>&lt;&lt;</sym> <def></def><num>50</num><def></def><sym>));</sym><br />
<def></def>   <kwb>static const</kwb> <def>BitVec ROW_1_MASK</def> <sym>=</sym> <def>ROW_0_MASK</def> <sym>&lt;&lt;</sym> <def></def><num>5</num><def></def><sym>;</sym><br />
<def></def>   <kwb>static const</kwb> <def>BitVec BOARD_MASK</def> <sym>= (</sym><def></def><num>1L</num><def>L</def> <sym>&lt;&lt;</sym> <def>N_CELL</def><sym>) -</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def><br />
   <kwd>Board</kwd><def></def><sym>();</sym><br />
<def></def><br />
   <kwb>static</kwb> <def>TUInt32</def> <kwd>getIndex</kwd><def></def><sym>(</sym><def>TUInt32 x</def><sym>,</sym> <def>TUInt32 y</def><sym>) {</sym> <def></def><kwa>return</kwa> <def>y</def> <sym>*</sym> <def>N_COL</def> <sym>+</sym> <def>x</def><sym>;    }</sym><br />
<def></def>   <kwb>static bool</kwb> <def></def><kwd>hasBadFirstRegion</kwd><def></def><sym>(</sym><def>BitVec</def> <sym>&amp;</sym> <def>toFill</def><sym>);</sym><br />
<def></def>   <kwb>static bool</kwb> <def></def><kwd>hasBadIslands</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>BitVec</def> <sym>&amp;</sym> <def>boardVec</def><sym>);</sym><br />
<def></def><br />
   <kwb>void</kwb> <def></def><kwd>genAllSolutions</kwd><def></def><sym>(</sym><def>BitVec boardVec</def><sym>,</sym> <def>TUInt32 placedPieces</def><sym>,</sym> <def>TUInt32 iNextFill</def><sym>,</sym> <def></def><kwb>const</kwb> <def>BitVec</def> <sym>&amp;</sym> <def>maskNextFill</def><sym>);</sym><br />
<def></def>   <kwb>void</kwb> <def></def><kwd>recordSolution</kwd><def></def><sym>(</sym><def>Solution</def> <sym>&amp;</sym> <def>s</def><sym>);</sym><br />
<def><br />
   Solution m_curSolution</def><sym>;</sym><br />
<def>   Solution m_minSolution</def><sym>;</sym><br />
<def>   Solution m_maxSolution</def><sym>;</sym><br />
<def>   TUInt32 m_nSolutionFound</def><sym>;</sym><br />
<def></def><sym>};</sym><br />
<def></def><br />
<slc>//------------------------------------</slc><br />
<def></def><br />
<kwc>class</kwc> <def>Piece</def><br />
<sym>{</sym><br />
<def></def><kwc>public</kwc><def></def><sym>:</sym><br />
<def></def>   <kwb>struct</kwb> <def>Instance</def> <sym>{</sym><br />
<def>      BitVec m_vec</def><sym>;</sym><br />
<def>      BitVec m_allowed</def><sym>;</sym><br />
<def>      TUInt32 m_offset</def><sym>;</sym><br />
<def>      TUInt32 m_w</def><sym>;</sym><br />
<def>      TUInt32 m_h</def><sym>;</sym><br />
<def></def>   <sym>};</sym><br />
<def></def><br />
   <kwb>static const int</kwb> <def>N_ELEM</def> <sym>=</sym> <def></def><num>5</num><def></def><sym>;</sym><br />
<def></def>   <kwb>static const int</kwb> <def>N_ORIENT</def> <sym>=</sym> <def></def><num>12</num><def></def><sym>;</sym><br />
<def></def>   <kwb>static const int</kwb> <def>N_TYPE</def> <sym>=</sym> <def></def><num>10</num><def></def><sym>;</sym><br />
<def></def>   <kwb>static const int</kwb> <def>ALL_PIECE_MASK</def> <sym>= (</sym><def></def><num>1</num> <def></def><sym>&lt;&lt;</sym> <def>N_TYPE</def><sym>) -</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>   <kwb>static const</kwb> <def>TUInt32 SKIP_PIECE</def> <sym>=</sym> <def></def><num>5</num><def></def><sym>;</sym> <def></def><slc>// it's magic!</slc><br />
<def></def><br />
   <kwc>typedef</kwc> <def></def><kwb>int</kwb> <def>TCoordList</def><sym>[</sym><def>N_ELEM</def><sym>][</sym><def>N_DIM</def><sym>];</sym><br />
<def></def><br />
   <kwb>static const</kwb> <def>BitVec BaseDefinitions</def><sym>[</sym><def>N_TYPE</def><sym>];</sym><br />
<def></def>   <kwb>static</kwb> <def>Piece s_basePiece</def><sym>[</sym><def>N_TYPE</def><sym>][</sym><def>N_ORIENT</def><sym>];</sym><br />
<def></def><br />
   <kwb>static const</kwb> <def>Instance</def> <sym>&amp;</sym> <def></def><kwd>getPiece</kwd><def></def><sym>(</sym><def>TUInt32 iPiece</def><sym>,</sym> <def>TUInt32 iOrient</def><sym>,</sym> <def>TUInt32 iParity</def><sym>);</sym><br />
<def></def>   <kwb>static bool</kwb> <def></def><kwd>checkBaseDefinitions</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>);</sym><br />
<def></def>   <kwb>static</kwb> <def>BitVec</def> <kwd>toBitVector</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>TCoordList</def> <sym>&amp;</sym> <def>coords</def><sym>);</sym><br />
<def></def>   <kwb>static void</kwb> <def></def><kwd>genOrientation</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>BitVec</def> <sym>&amp;</sym> <def>vec</def><sym>,</sym> <def>TUInt32 iOrient</def><sym>,</sym> <def>Piece</def> <sym>&amp;</sym> <def>target</def><sym>);</sym><br />
<def></def>   <kwb>static void</kwb> <def></def><kwd>setCoordList</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>BitVec</def> <sym>&amp;</sym> <def>vec</def><sym>,</sym> <def>TCoordList</def> <sym>&amp;</sym> <def>coords</def><sym>);</sym><br />
<def></def>   <kwb>static void</kwb> <def></def><kwd>shiftUpLines</kwd><def></def><sym>(</sym><def>TCoordList</def> <sym>&amp;</sym> <def>coords</def><sym>,</sym> <def></def><kwb>int</kwb> <def>shift</def><sym>);</sym><br />
<def></def>   <kwb>static void</kwb> <def></def><kwd>shiftToX0</kwd><def></def><sym>(</sym><def>TCoordList</def> <sym>&amp;</sym> <def>coords</def><sym>,</sym> <def>Instance</def> <sym>&amp;</sym> <def>instance</def><sym>,</sym> <def></def><kwb>int</kwb> <def>offsetRow</def><sym>);</sym><br />
<def></def>   <kwb>static void</kwb> <def></def><kwd>setAllowedPositions</kwd><def></def><sym>(</sym><def>Instance</def> <sym>&amp;</sym> <def>p</def><sym>);</sym><br />
<def></def>   <kwb>static void</kwb> <def></def><kwd>genAllOrientations</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>);</sym><br />
<def><br />
   Instance m_instance</def><sym>[</sym><def>N_PARITY</def><sym>];</sym><br />
<def></def><sym>};</sym><br />
<def></def><br />
<slc>//------------------------------------</slc><br />
<def>Solution</def><sym>::</sym><def></def><kwd>Solution</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>fillVal</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <kwd>fill</kwd><def></def><sym>(</sym><def>fillVal</def><sym>);</sym><br />
<def>   m_pieces</def><sym>.</sym><def></def><kwd>reserve</kwd><def></def><sym>(</sym><def>Piece</def><sym>::</sym><def>N_TYPE</def><sym>);</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Solution</def><sym>::</sym><def></def><kwd>fill</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>val</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def>   m_synched</def> <sym>=</sym> <def></def><kwa>false</kwa><def></def><sym>;</sym><br />
<def></def>   <kwd>memset</kwd><def></def><sym>(&amp;</sym><def>m_cells</def><sym>[</sym><def></def><num>0</num><def></def><sym>][</sym><def></def><num>0</num><def></def><sym>],</sym> <def>val</def><sym>,</sym> <def>N_CELL</def><sym>);</sym><br />
<def></def><sym>}</sym><br />
<def><br />
string Solution</def><sym>::</sym><def></def><kwd>toString</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>)</sym> <def></def><kwb>const</kwb><br />
<def></def><sym>{</sym><br />
<def>   string result</def><sym>;</sym><br />
<def>   result</def><sym>.</sym><def></def><kwd>reserve</kwd><def></def><sym>(</sym><def>N_CELL</def> <sym>*</sym> <def></def><num>2</num><def></def><sym>);</sym><br />
<def></def><br />
   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>y</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>y</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>y</def><sym>++) {</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>x</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>x</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>x</def><sym>++) {</sym><br />
<def></def>         <kwb>int</kwb> <def>val</def> <sym>=</sym> <def>m_cells</def><sym>[</sym><def>y</def><sym>][</sym><def>x</def><sym>];</sym><br />
<def>         result</def> <sym>+= ((</sym><def>val</def> <sym>==</sym> <def>NO_PIECE</def><sym>)</sym> <def>?</def> <str>'.'</str><def></def> <sym>:</sym> <def></def><kwb>char</kwb><def></def><sym>(</sym><def></def><str>'0'</str><def></def> <sym>+</sym> <def>val</def><sym>));</sym><br />
<def>         result</def> <sym>+=</sym> <def></def><str>' '</str><def></def><sym>;</sym><br />
<def></def>      <sym>}</sym><br />
<def>      result</def> <sym>+=</sym> <def></def><str>'</str><esc>\n</esc><str>'</str><def></def><sym>;</sym><br />
<def></def><br />
      <slc>// indent every second line</slc><br />
<def></def>      <kwa>if</kwa> <def></def><sym>(</sym><def>y</def> <sym>%</sym> <def></def><num>2</num> <def></def><sym>==</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def>         result</def> <sym>+=</sym> <def></def><str>&quot; &quot;</str><def></def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>return</kwa> <def>result</def><sym>;</sym> <def></def><slc>// copies result. Oh well</slc><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Solution</def><sym>::</sym><def></def><kwd>setCells</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>m_synched</def><sym>)</sym><br />
<def></def>      <kwa>return</kwa><def></def><sym>;</sym><br />
<def></def><br />
   <kwd>fill</kwd><def></def><sym>(</sym><def>NO_PIECE</def><sym>);</sym><br />
<def></def><br />
   <slc>// could be more efficient</slc><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def>TUInt32 iPiece</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iPiece</def> <sym>&lt;</sym> <def>m_pieces</def><sym>.</sym><def></def><kwd>size</kwd><def></def><sym>();</sym> <def>iPiece</def><sym>++) {</sym><br />
<def></def><br />
      <kwb>const</kwb> <def>BitVec</def> <sym>&amp;</sym> <def>vec</def> <sym>=</sym> <def>m_pieces</def><sym>[</sym><def>iPiece</def><sym>].</sym><def>vec</def><sym>;</sym><br />
<def></def>      <kwb>int</kwb> <def>pID</def> <sym>=</sym> <def>m_pieces</def><sym>[</sym><def>iPiece</def><sym>].</sym><def>iPiece</def><sym>;</sym><br />
<def>      BitVec mask</def> <sym>=</sym> <def></def><num>1L</num><def>L</def><sym>;</sym><br />
<def></def>      <kwb>int</kwb> <def>nNewCells</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def><br />
      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>y</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>y</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>y</def><sym>++) {</sym><br />
<def></def>         <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>x</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>x</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>x</def><sym>++) {</sym><br />
<def></def>            <kwa>if</kwa> <def></def><sym>(</sym><def>mask</def> <sym>&amp;</sym> <def>vec</def><sym>) {</sym><br />
<def>               m_cells</def><sym>[</sym><def>y</def><sym>][</sym><def>x</def><sym>] = (</sym><def>TInt8</def><sym>)</sym><def>pID</def><sym>;</sym><br />
<def><br />
               nNewCells</def><sym>++;</sym><br />
<def></def>            <sym>}</sym><br />
<def>            mask</def> <sym>&lt;&lt;=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>         <sym>}</sym><br />
<def></def>         <kwa>if</kwa> <def></def><sym>(</sym><def>nNewCells</def> <sym>==</sym> <def>Piece</def><sym>::</sym><def>N_ELEM</def><sym>)</sym><br />
<def></def>            <kwa>break</kwa><def></def><sym>;</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def><br />
   m_synched</def> <sym>=</sym> <def></def><kwa>true</kwa><def></def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Solution</def><sym>::</sym><def></def><kwd>addPiece</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>BitVec</def> <sym>&amp;</sym> <def>vec</def><sym>,</sym> <def></def><kwb>int</kwb> <def>iPiece</def><sym>) {</sym><br />
<def>   SPiece p</def> <sym>= {</sym><def>vec</def><sym>,</sym> <def>iPiece</def><sym>};</sym><br />
<def>   m_pieces</def><sym>.</sym><def></def><kwd>push_back</kwd><def></def><sym>(</sym><def>p</def><sym>);</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Solution</def><sym>::</sym><def></def><kwd>removeLastPiece</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>) {</sym><br />
<def>   m_pieces</def><sym>.</sym><def></def><kwd>pop_back</kwd><def></def><sym>();</sym><br />
<def>   m_synched</def> <sym>=</sym> <def></def><kwa>false</kwa><def></def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>bool</kwb> <def>Solution</def><sym>::</sym><def></def><kwd>lessThan</kwd><def></def><sym>(</sym><def>Solution</def> <sym>&amp;</sym> <def>r</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>m_pieces</def><sym>[</sym><def></def><num>0</num><def></def><sym>].</sym><def>iPiece</def> <sym>!=</sym> <def>r</def><sym>.</sym><def>m_pieces</def><sym>[</sym><def></def><num>0</num><def></def><sym>].</sym><def>iPiece</def><sym>) {</sym><br />
<def></def>      <kwa>return</kwa> <def>m_pieces</def><sym>[</sym><def></def><num>0</num><def></def><sym>].</sym><def>iPiece</def> <sym>&lt;</sym> <def>r</def><sym>.</sym><def>m_pieces</def><sym>[</sym><def></def><num>0</num><def></def><sym>].</sym><def>iPiece</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwd>setCells</kwd><def></def><sym>();</sym><br />
<def>   r</def><sym>.</sym><def></def><kwd>setCells</kwd><def></def><sym>();</sym><br />
<def></def><br />
   <kwb>int</kwb> <def>y</def><sym>;</sym><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def>y</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>y</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>y</def><sym>++) {</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>x</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>x</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>x</def><sym>++) {</sym><br />
<def></def>         <kwb>int</kwb> <def>lval</def> <sym>=</sym> <def>m_cells</def><sym>[</sym><def>y</def><sym>][</sym><def>x</def><sym>];</sym><br />
<def></def>         <kwb>int</kwb> <def>rval</def> <sym>=</sym> <def>r</def><sym>.</sym><def>m_cells</def><sym>[</sym><def>y</def><sym>][</sym><def>x</def><sym>];</sym><br />
<def></def><br />
         <kwa>if</kwa> <def></def><sym>(</sym><def>lval</def> <sym>!=</sym> <def>rval</def><sym>)</sym><br />
<def></def>            <kwa>return</kwa> <def></def><sym>(</sym><def>lval</def> <sym>&lt;</sym> <def>rval</def><sym>);</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>return false</kwa><def></def><sym>;</sym> <def></def><slc>// solutions are equal</slc><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Solution</def><sym>::</sym><def></def><kwd>spin</kwd><def></def><sym>(</sym><def>Solution</def> <sym>&amp;</sym> <def>spun</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <kwd>setCells</kwd><def></def><sym>();</sym><br />
<def></def><br />
   <slc>// swap cells</slc><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>y</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>y</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>y</def><sym>++) {</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>x</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>x</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>x</def><sym>++) {</sym><br />
<def>         TInt8 flipped</def> <sym>=</sym> <def>m_cells</def><sym>[</sym><def>N_ROW</def> <sym>-</sym> <def>y</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>][</sym><def>N_COL</def> <sym>-</sym> <def>x</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>];</sym><br />
<def>         spun</def><sym>.</sym><def>m_cells</def><sym>[</sym><def>y</def><sym>][</sym><def>x</def><sym>] =</sym> <def>flipped</def><sym>;</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <slc>// swap first and last pieces (the rest aren't used)</slc><br />
<def>   spun</def><sym>.</sym><def>m_pieces</def><sym>.</sym><def></def><kwd>push_back</kwd><def></def><sym>(</sym><def>m_pieces</def><sym>[</sym><def>Piece</def><sym>::</sym><def>N_TYPE</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>]);</sym><br />
<def>   spun</def><sym>.</sym><def>m_synched</def> <sym>=</sym> <def></def><kwa>true</kwa><def></def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<slc>//------------------------------------</slc><br />
<def><br />
Piece Piece</def><sym>::</sym><def>s_basePiece</def><sym>[</sym><def>N_TYPE</def><sym>][</sym><def>N_ORIENT</def><sym>];</sym><br />
<def></def><br />
<kwb>const</kwb> <def>BitVec Piece</def><sym>::</sym><def>BaseDefinitions</def><sym>[] = {</sym><br />
<def></def>   <num>0x010f</num><def></def><sym>,</sym>   <def></def><num>0x00cb</num><def></def><sym>,</sym> <def></def><num>0x1087</num><def></def><sym>,</sym> <def></def><num>0x0427</num><def></def><sym>,</sym> <def></def><num>0x0465</num><def></def><sym>,</sym><br />
<def></def>   <num>0x00c7</num><def></def><sym>,</sym> <def></def><num>0x08423</num><def></def><sym>,</sym> <def></def><num>0x00a7</num><def></def><sym>,</sym> <def></def><num>0x0187</num><def></def><sym>,</sym> <def></def><num>0x008f</num><br />
<def></def><sym>};</sym><br />
<def></def><br />
<kwb>int</kwb> <def></def><kwd>floor</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>top</def><sym>,</sym> <def></def><kwb>int</kwb> <def>bot</def><sym>) {</sym><br />
<def></def>   <kwb>int</kwb> <def>toZero</def> <sym>=</sym> <def>top</def> <sym>/</sym> <def>bot</def><sym>;</sym><br />
<def></def>   <slc>// negative numbers should be rounded down, not towards zero</slc><br />
<def></def>   <kwa>if</kwa> <def></def><sym>((</sym><def>toZero</def> <sym>*</sym> <def>bot</def> <sym>!=</sym> <def>top</def><sym>) &amp;&amp; ((</sym><def>top</def> <sym>&lt;</sym> <def></def><num>0</num><def></def><sym>) != (</sym><def>bot</def> <sym>&lt;=</sym> <def></def><num>0</num><def></def><sym>)))</sym><br />
<def>      toZero</def><sym>--;</sym><br />
<def></def><br />
   <kwa>return</kwa> <def>toZero</def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def><br />
TUInt32</def> <kwd>getFirstOne</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>BitVec</def> <sym>&amp;</sym> <def>v</def><sym>,</sym> <def>TUInt32 startPos</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>) {</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>v</def> <sym>== (</sym><def>BitVec</def><sym>)</sym><def></def><num>0</num><def></def><sym>)</sym><br />
<def></def>      <kwa>return</kwa> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def><br />
   <kwb>static const</kwb> <def>TUInt32 firstOne</def><sym>[</sym><def></def><num>16</num><def></def><sym>] =   {</sym><br />
<def></def>      <num>0</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym><br />
<def></def>      <num>2</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym><br />
<def></def>      <num>3</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym><br />
<def></def>      <num>2</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym><br />
<def></def>   <sym>};</sym><br />
<def><br />
   TUInt32 iPos</def> <sym>=</sym> <def>startPos</def><sym>;</sym><br />
<def>   BitVec mask</def> <sym>=</sym> <def></def><num>0xff</num><def>LL</def> <sym>&lt;&lt;</sym> <def>startPos</def><sym>;</sym><br />
<def></def>   <kwa>while</kwa> <def></def><sym>((</sym><def>mask</def> <sym>&amp;</sym> <def>v</def><sym>) ==</sym> <def></def><num>0</num><def></def><sym>) {</sym><br />
<def>      mask</def> <sym>&lt;&lt;=</sym> <def></def><num>8</num><def></def><sym>;</sym><br />
<def>      iPos</def> <sym>+=</sym> <def></def><num>8</num><def></def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def>   TUInt32 result</def> <sym>=</sym> <def></def><kwd>TUInt32</kwd><def></def><sym>((</sym><def>mask</def> <sym>&amp;</sym> <def>v</def><sym>) &gt;&gt;</sym> <def>iPos</def><sym>);</sym><br />
<def>   TUInt32 resultLow</def> <sym>=</sym> <def>result</def> <sym>&amp;</sym> <def></def><num>0x0f</num><def></def><sym>;</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>resultLow</def> <sym>!=</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def>      iPos</def> <sym>+=</sym> <def>firstOne</def><sym>[</sym><def>resultLow</def><sym>];</sym><br />
<def></def>   <kwa>else</kwa><br />
<def>      iPos</def> <sym>+=</sym> <def></def><num>4</num> <def></def><sym>+</sym> <def>firstOne</def><sym>[</sym><def>result</def> <sym>&gt;&gt;</sym> <def></def><num>4</num><def></def><sym>];</sym><br />
<def></def><br />
   <kwa>return</kwa> <def>iPos</def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def><br />
TUInt32</def> <kwd>countOnes</kwd><def></def><sym>(</sym><def>BitVec v</def><sym>) {</sym><br />
<def>   TUInt32 n</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>   <kwa>while</kwa> <def></def><sym>(</sym><def>v</def><sym>) {</sym><br />
<def>      n</def><sym>++;</sym><br />
<def>      v</def> <sym>=</sym> <def>v</def> <sym>&amp; (</sym><def>v</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>return</kwa> <def>n</def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Piece</def><sym>::</sym><def></def><kwd>genAllOrientations</kwd><def></def><sym>(</sym><def></def><kwb>void</kwb><def></def><sym>) {</sym><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iPiece</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iPiece</def> <sym>&lt;</sym> <def>N_TYPE</def><sym>;</sym> <def>iPiece</def><sym>++) {</sym><br />
<def></def>      <kwb>const</kwb> <def>BitVec</def> <sym>&amp;</sym> <def>refPiece</def> <sym>=</sym> <def>BaseDefinitions</def><sym>[</sym><def>iPiece</def><sym>];</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iOrient</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iOrient</def> <sym>&lt;</sym> <def>N_ORIENT</def><sym>;</sym> <def>iOrient</def><sym>++)</sym><br />
<def></def>         <kwd>genOrientation</kwd><def></def><sym>(</sym><def>refPiece</def><sym>,</sym> <def>iOrient</def><sym>,</sym> <def>s_basePiece</def><sym>[</sym><def>iPiece</def><sym>][</sym><def>iOrient</def><sym>]);</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Piece</def><sym>::</sym><def></def><kwd>setCoordList</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>BitVec</def> <sym>&amp;</sym> <def>vec</def><sym>,</sym> <def>TCoordList</def> <sym>&amp;</sym> <def>coords</def><sym>) {</sym><br />
<def></def>   <kwb>int</kwb> <def>iCoord</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def>   BitVec mask</def> <sym>=</sym> <def></def><num>1L</num><def>L</def><sym>;</sym><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>y</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>y</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>y</def><sym>++) {</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>x</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>x</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>x</def><sym>++) {</sym><br />
<def></def>         <kwa>if</kwa> <def></def><sym>(</sym><def>mask</def> <sym>&amp;</sym> <def>vec</def><sym>) {</sym><br />
<def>            coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>X</def><sym>] =</sym> <def>x</def><sym>;</sym><br />
<def>            coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>Y</def><sym>] =</sym> <def>y</def><sym>;</sym><br />
<def><br />
            iCoord</def><sym>++;</sym><br />
<def></def>         <sym>}</sym><br />
<def>         mask</def> <sym>&lt;&lt;=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><sym>}</sym><br />
<def><br />
BitVec Piece</def><sym>::</sym><def></def><kwd>toBitVector</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>TCoordList</def> <sym>&amp;</sym> <def>coords</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <kwb>int</kwb> <def>y</def><sym>,</sym> <def>x</def><sym>;</sym><br />
<def>   BitVec result</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iCoord</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iCoord</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iCoord</def><sym>++) {</sym><br />
<def>      x</def> <sym>=</sym> <def>coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>X</def><sym>];</sym><br />
<def>      y</def> <sym>=</sym> <def>coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def><br />
      <kwb>int</kwb> <def>pos</def> <sym>=</sym> <def>Board</def><sym>::</sym><def></def><kwd>getIndex</kwd><def></def><sym>(</sym><def>x</def><sym>,</sym> <def>y</def><sym>);</sym><br />
<def>      result</def> <sym>|= (</sym><def></def><num>1L</num><def>L</def> <sym>&lt;&lt;</sym> <def>pos</def><sym>);</sym> <def></def><slc>// to generate a 64 bit representation of 1</slc><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>return</kwa> <def>result</def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Piece</def><sym>::</sym><def></def><kwd>shiftUpLines</kwd><def></def><sym>(</sym><def>TCoordList</def> <sym>&amp;</sym> <def>coords</def><sym>,</sym> <def></def><kwb>int</kwb> <def>shift</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <slc>// apply shifts are not so simple in the vertical direction</slc><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iCoord</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iCoord</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iCoord</def><sym>++) {</sym><br />
<def></def>      <kwb>int</kwb> <def></def><sym>&amp;</sym> <def>rx</def> <sym>=</sym> <def>coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>X</def><sym>];</sym><br />
<def></def>      <kwb>int</kwb> <def></def><sym>&amp;</sym> <def>ry</def> <sym>=</sym> <def>coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def><br />
      <kwa>if</kwa> <def></def><sym>(</sym><def>ry</def> <sym>&amp;</sym> <def>shift</def> <sym>&amp;</sym> <def></def><num>0x1</num><def></def><sym>)</sym><br />
<def>         rx</def><sym>++;</sym><br />
<def>      ry</def> <sym>-=</sym> <def>shift</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Piece</def><sym>::</sym><def></def><kwd>shiftToX0</kwd><def></def><sym>(</sym><def>TCoordList</def> <sym>&amp;</sym> <def>coords</def><sym>,</sym> <def>Piece</def><sym>::</sym><def>Instance</def> <sym>&amp;</sym> <def>instance</def><sym>,</sym> <def></def><kwb>int</kwb> <def>offsetRow</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <slc>// .. determine shift</slc><br />
<def></def>   <kwb>int</kwb> <def>x</def><sym>,</sym> <def>y</def><sym>;</sym><br />
<def></def>   <kwb>int</kwb> <def>xMin</def> <sym>=</sym> <def>coords</def><sym>[</sym><def></def><num>0</num><def></def><sym>][</sym><def>X</def><sym>];</sym><br />
<def></def>   <kwb>int</kwb> <def>xMax</def> <sym>=</sym> <def>xMin</def><sym>;</sym><br />
<def></def>   <kwb>int</kwb> <def>iCoord</def><sym>;</sym><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def>iCoord</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym> <def>iCoord</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iCoord</def><sym>++) {</sym><br />
<def>      x</def> <sym>=</sym> <def>coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>X</def><sym>];</sym><br />
<def>      y</def> <sym>=</sym> <def>coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def><br />
      <kwa>if</kwa> <def></def><sym>(</sym><def>x</def> <sym>&lt;</sym> <def>xMin</def><sym>)</sym><br />
<def>         xMin</def> <sym>=</sym> <def>x</def><sym>;</sym><br />
<def></def>      <kwa>else if</kwa> <def></def><sym>(</sym><def>x</def> <sym>&gt;</sym> <def>xMax</def><sym>)</sym><br />
<def>         xMax</def> <sym>=</sym> <def>x</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <slc>// I'm dying for a 'foreach' here</slc><br />
<def></def>   <kwb>int</kwb> <def>offset</def> <sym>=</sym> <def>N_ELEM</def><sym>;</sym><br />
<def></def><br />
   <kwa>for</kwa> <def></def><sym>(</sym><def>iCoord</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iCoord</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iCoord</def><sym>++) {</sym><br />
<def></def>      <kwb>int</kwb> <def></def><sym>&amp;</sym> <def>rx</def> <sym>=</sym> <def>coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>X</def><sym>];</sym><br />
<def></def>      <kwb>int</kwb> <def></def><sym>&amp;</sym> <def>ry</def> <sym>=</sym> <def>coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def><br />
      rx</def> <sym>-=</sym> <def>xMin</def><sym>;</sym><br />
<def></def><br />
      <slc>// check offset -- leftmost cell on top line</slc><br />
<def></def>      <kwa>if</kwa> <def></def><sym>((</sym><def>ry</def> <sym>==</sym> <def>offsetRow</def><sym>) &amp;&amp; (</sym><def>rx</def> <sym>&lt;</sym> <def>offset</def><sym>))</sym><br />
<def>         offset</def> <sym>=</sym> <def>rx</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def><br />
   instance</def><sym>.</sym><def>m_w</def> <sym>=</sym> <def>xMax</def> <sym>-</sym> <def>xMin</def><sym>;</sym><br />
<def>   instance</def><sym>.</sym><def>m_offset</def> <sym>=</sym> <def>offset</def><sym>;</sym><br />
<def>   instance</def><sym>.</sym><def>m_vec</def> <sym>=</sym> <def></def><kwd>toBitVector</kwd><def></def><sym>(</sym><def>coords</def><sym>);</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Piece</def><sym>::</sym><def></def><kwd>setAllowedPositions</kwd><def></def><sym>(</sym><def>Piece</def><sym>::</sym><def>Instance</def> <sym>&amp;</sym> <def>p</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def>   BitVec</def> <sym>&amp;</sym> <def>allowed</def> <sym>=</sym> <def>p</def><sym>.</sym><def>m_allowed</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def>   BitVec posMask</def> <sym>=</sym> <def></def><num>1L</num><def>L</def><sym>;</sym><br />
<def>   TUInt32 iPos</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>y</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>y</def> <sym>&lt;</sym> <def>N_ROW</def><sym>;</sym> <def>y</def><sym>++) {</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>x</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>x</def> <sym>&lt;</sym> <def>N_COL</def><sym>;</sym> <def>x</def><sym>++,</sym> <def>iPos</def><sym>++,</sym> <def>posMask</def> <sym>&lt;&lt;=</sym> <def></def><num>1</num><def></def><sym>){</sym><br />
<def></def>         <slc>// check if the new position is on the board</slc><br />
<def></def>         <kwb>int</kwb> <def>xPos</def> <sym>=</sym> <def>x</def> <sym>-</sym> <def>p</def><sym>.</sym><def>m_offset</def><sym>;</sym><br />
<def></def>         <kwa>if</kwa> <def></def><sym>((</sym><def>xPos</def> <sym>&lt;</sym> <def></def><num>0</num><def></def><sym>) || (</sym><def>y</def> <sym>+</sym> <def>p</def><sym>.</sym><def>m_h</def> <sym>&gt;=</sym> <def>N_ROW</def><sym>) || (</sym><def>xPos</def> <sym>+</sym> <def>p</def><sym>.</sym><def>m_w</def> <sym>&gt;=</sym> <def>N_COL</def><sym>))</sym><br />
<def></def>            <kwa>continue</kwa><def></def><sym>;</sym><br />
<def></def><br />
         <slc>// move it to the desired location</slc><br />
<def>         BitVec pieceVec</def> <sym>=</sym> <def>p</def><sym>.</sym><def>m_vec</def> <sym>&lt;&lt; (</sym><def>iPos</def> <sym>-</sym> <def>p</def><sym>.</sym><def>m_offset</def><sym>);</sym><br />
<def></def><br />
         <kwa>if</kwa> <def></def><sym>(</sym><def>Board</def><sym>::</sym><def></def><kwd>hasBadIslands</kwd><def></def><sym>(</sym><def>pieceVec</def><sym>))</sym><br />
<def></def>            <kwa>continue</kwa><def></def><sym>;</sym><br />
<def></def><br />
         <slc>// position is allowed</slc><br />
<def>         allowed</def> <sym>|=</sym> <def>posMask</def><sym>;</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Piece</def><sym>::</sym><def></def><kwd>genOrientation</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>BitVec</def> <sym>&amp;</sym> <def>vec</def><sym>,</sym> <def>TUInt32 iOrient</def><sym>,</sym> <def>Piece</def> <sym>&amp;</sym> <def>target</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <slc>// get (x,y) coordinates</slc><br />
<def>   TCoordList coords</def><sym>;</sym><br />
<def></def>   <kwd>setCoordList</kwd><def></def><sym>(</sym><def>vec</def><sym>,</sym> <def>coords</def><sym>);</sym><br />
<def></def><br />
   <kwb>int</kwb> <def>y</def><sym>,</sym> <def>x</def><sym>;</sym><br />
<def></def>   <kwb>int</kwb> <def>iCoord</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def>   <kwb>int</kwb> <def>rot</def> <sym>=</sym> <def>iOrient</def> <sym>%</sym> <def></def><num>6</num><def></def><sym>;</sym><br />
<def></def>   <kwb>int</kwb> <def>flip</def> <sym>=</sym> <def>iOrient</def> <sym>&gt;=</sym> <def></def><num>6</num><def></def><sym>;</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>flip</def><sym>) {</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def>iCoord</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iCoord</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iCoord</def><sym>++)</sym><br />
<def>         coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>Y</def><sym>] = -</sym><def>coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <slc>// rotate (if necessary)</slc><br />
<def></def>   <kwa>while</kwa> <def></def><sym>(</sym><def>rot</def><sym>--) {</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def>iCoord</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iCoord</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iCoord</def><sym>++) {</sym><br />
<def>         x</def> <sym>=</sym> <def>coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>X</def><sym>];</sym><br />
<def>         y</def> <sym>=</sym> <def>coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def><br />
         <slc>// I just worked this out by hand. Took a while.</slc><br />
<def></def>         <kwb>int</kwb> <def>xNew</def> <sym>=</sym> <def></def><kwd>floor</kwd><def></def><sym>((</sym><def></def><num>2</num> <def></def><sym>*</sym> <def>x</def> <sym>-</sym> <def></def><num>3</num> <def></def><sym>*</sym> <def>y</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>),</sym> <def></def><num>4</num><def></def><sym>);</sym><br />
<def></def>         <kwb>int</kwb> <def>yNew</def> <sym>=</sym> <def></def><kwd>floor</kwd><def></def><sym>((</sym><def></def><num>2</num> <def></def><sym>*</sym> <def>x</def> <sym>+</sym> <def>y</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>),</sym> <def></def><num>2</num><def></def><sym>);</sym><br />
<def>         coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>X</def><sym>] =</sym> <def>xNew</def><sym>;</sym><br />
<def>         coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>Y</def><sym>] =</sym> <def>yNew</def><sym>;</sym><br />
<def></def>      <sym>}</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <slc>// shift vertically</slc><br />
<def></def>   <slc>// .. determine shift</slc><br />
<def></def>   <kwb>int</kwb> <def>yMin</def> <sym>=</sym> <def>coords</def><sym>[</sym><def></def><num>0</num><def></def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def>   <kwb>int</kwb> <def>yMax</def> <sym>=</sym> <def>yMin</def><sym>;</sym><br />
<def></def>   <kwa>for</kwa> <def></def><sym>(</sym><def>iCoord</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym> <def>iCoord</def> <sym>&lt;</sym> <def>N_ELEM</def><sym>;</sym> <def>iCoord</def><sym>++) {</sym><br />
<def>      y</def> <sym>=</sym> <def>coords</def><sym>[</sym><def>iCoord</def><sym>][</sym><def>Y</def><sym>];</sym><br />
<def></def><br />
      <kwa>if</kwa> <def></def><sym>(</sym><def>y</def> <sym>&lt;</sym> <def>yMin</def><sym>)</sym><br />
<def>         yMin</def> <sym>=</sym> <def>y</def><sym>;</sym><br />
<def></def>      <kwa>else if</kwa> <def></def><sym>(</sym><def>y</def> <sym>&gt;</sym> <def>yMax</def><sym>)</sym><br />
<def>         yMax</def> <sym>=</sym> <def>y</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def>   TUInt32 h</def> <sym>=</sym> <def>yMax</def> <sym>-</sym> <def>yMin</def><sym>;</sym><br />
<def>   target</def><sym>.</sym><def>m_instance</def><sym>[</sym><def>EVEN</def><sym>].</sym><def>m_h</def> <sym>=</sym> <def>h</def><sym>;</sym><br />
<def>   target</def><sym>.</sym><def>m_instance</def><sym>[</sym><def>ODD</def><sym>].</sym><def>m_h</def> <sym>=</sym> <def>h</def><sym>;</sym><br />
<def></def><br />
   <kwd>shiftUpLines</kwd><def></def><sym>(</sym><def>coords</def><sym>,</sym> <def>yMin</def><sym>);</sym><br />
<def></def>   <kwd>shiftToX0</kwd><def></def><sym>(</sym><def>coords</def><sym>,</sym> <def>target</def><sym>.</sym><def>m_instance</def><sym>[</sym><def>EVEN</def><sym>],</sym> <def></def><num>0</num><def></def><sym>);</sym><br />
<def></def>   <kwd>setAllowedPositions</kwd><def></def><sym>(</sym><def>target</def><sym>.</sym><def>m_instance</def><sym>[</sym><def>EVEN</def><sym>]);</sym><br />
<def></def><br />
   <slc>// shift down one line</slc><br />
<def></def>   <kwd>shiftUpLines</kwd><def></def><sym>(</sym><def>coords</def><sym>, -</sym><def></def><num>1</num><def></def><sym>);</sym><br />
<def></def>   <kwd>shiftToX0</kwd><def></def><sym>(</sym><def>coords</def><sym>,</sym> <def>target</def><sym>.</sym><def>m_instance</def><sym>[</sym><def>ODD</def><sym>],</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def></def>   <slc>// shift the bitmask back one line</slc><br />
<def>   target</def><sym>.</sym><def>m_instance</def><sym>[</sym><def>ODD</def><sym>].</sym><def>m_vec</def> <sym>&gt;&gt;=</sym> <def>N_COL</def><sym>;</sym><br />
<def></def>   <kwd>setAllowedPositions</kwd><def></def><sym>(</sym><def>target</def><sym>.</sym><def>m_instance</def><sym>[</sym><def>ODD</def><sym>]);</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>const</kwb> <def>Piece</def><sym>::</sym><def>Instance</def> <sym>&amp;</sym> <def>Piece</def><sym>::</sym><def></def><kwd>getPiece</kwd><def></def><sym>(</sym><def>TUInt32 iPiece</def><sym>,</sym> <def>TUInt32 iOrient</def><sym>,</sym> <def>TUInt32 iParity</def><sym>) {</sym><br />
<def></def>   <kwa>return</kwa> <def>s_basePiece</def><sym>[</sym><def>iPiece</def><sym>][</sym><def>iOrient</def><sym>].</sym><def>m_instance</def><sym>[</sym><def>iParity</def><sym>];</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<slc>// ------------------------------------</slc><br />
<def><br />
Board</def><sym>::</sym><def></def><kwd>Board</kwd><def></def><sym>() :</sym><br />
<def></def>   <kwd>m_curSolution</kwd><def></def><sym>(</sym><def>Solution</def><sym>::</sym><def>NO_PIECE</def><sym>),</sym> <def></def><kwd>m_minSolution</kwd><def></def><sym>(</sym><def>Piece</def><sym>::</sym><def>N_TYPE</def><sym>),</sym><br />
<def></def>   <kwd>m_maxSolution</kwd><def></def><sym>(</sym><def>Solution</def><sym>::</sym><def>NO_PIECE</def><sym>),</sym> <def></def><kwd>m_nSolutionFound</kwd><def></def><sym>(</sym><def></def><num>0</num><def></def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>bool</kwb> <def>Board</def><sym>::</sym><def></def><kwd>hasBadFirstRegion</kwd><def></def><sym>(</sym><def>BitVec</def> <sym>&amp;</sym> <def>toFill</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <kwb>int</kwb> <def>iPos</def> <sym>=</sym> <def></def><kwd>getFirstOne</kwd><def></def><sym>(</sym><def>toFill</def><sym>);</sym><br />
<def></def><br />
   <slc>// grow empty region, until it doesn't change any more</slc><br />
<def>   BitVec region</def><sym>;</sym><br />
<def>   BitVec rNew</def> <sym>=</sym> <def></def><num>1L</num><def>L</def> <sym>&lt;&lt;</sym> <def>iPos</def><sym>;</sym><br />
<def></def>   <kwa>do</kwa> <def></def><sym>{</sym><br />
<def>      region</def> <sym>=</sym> <def>rNew</def><sym>;</sym><br />
<def></def><br />
      <slc>// grow right/left</slc><br />
<def>      rNew</def> <sym>|= (</sym><def>region</def> <sym>&amp; ~</sym><def>L_EDGE_MASK</def><sym>) &gt;&gt;</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def>      rNew</def> <sym>|= (</sym><def>region</def> <sym>&amp; ~</sym><def>R_EDGE_MASK</def><sym>) &lt;&lt;</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def><br />
      <slc>// simple grow up/down</slc><br />
<def>      rNew</def> <sym>|= (</sym><def>region</def> <sym>&gt;&gt;</sym> <def>N_COL</def><sym>);</sym><br />
<def>      rNew</def> <sym>|= (</sym><def>region</def> <sym>&lt;&lt;</sym> <def>N_COL</def><sym>);</sym><br />
<def></def><br />
      <slc>// tricky growth</slc><br />
<def>      BitVec evenRegion</def> <sym>=</sym> <def>region</def> <sym>&amp; (</sym><def>ROW_0_MASK</def> <sym>&amp; ~</sym><def>L_EDGE_MASK</def><sym>);</sym><br />
<def>      rNew</def> <sym>|=</sym> <def>evenRegion</def> <sym>&gt;&gt; (</sym><def>N_COL</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def>      rNew</def> <sym>|=</sym> <def>evenRegion</def> <sym>&lt;&lt; (</sym><def>N_COL</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def><br />
      BitVec oddRegion</def> <sym>=</sym> <def>region</def> <sym>&amp; (</sym><def>ROW_1_MASK</def> <sym>&amp; ~</sym><def>R_EDGE_MASK</def><sym>);</sym><br />
<def>      rNew</def> <sym>|=</sym> <def>oddRegion</def> <sym>&gt;&gt; (</sym><def>N_COL</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def>      rNew</def> <sym>|=</sym> <def>oddRegion</def> <sym>&lt;&lt; (</sym><def>N_COL</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def></def><br />
      <slc>// clamp against existing pieces</slc><br />
<def>      rNew</def> <sym>&amp;=</sym> <def>toFill</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def>   <kwa>while</kwa> <def></def><sym>((</sym><def>rNew</def> <sym>!=</sym> <def>toFill</def><sym>) &amp;&amp; (</sym><def>rNew</def> <sym>!=</sym> <def>region</def><sym>));</sym><br />
<def></def><br />
   <slc>// subtract empty region from board</slc><br />
<def>   toFill ^</def><sym>=</sym> <def>rNew</def><sym>;</sym><br />
<def><br />
   TUInt32 nEmptyCells</def> <sym>=</sym> <def></def><kwd>countOnes</kwd><def></def><sym>(</sym><def>toFill</def><sym>);</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>nEmptyCells</def> <sym>%</sym> <def></def><num>5</num> <def></def><sym>!=</sym> <def></def><num>0</num><def></def><sym>)</sym><br />
<def></def>      <kwa>return true</kwa><def></def><sym>;</sym><br />
<def></def><br />
   <kwa>return false</kwa><def></def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>bool</kwb> <def>Board</def><sym>::</sym><def></def><kwd>hasBadIslands</kwd><def></def><sym>(</sym><def></def><kwb>const</kwb> <def>BitVec</def> <sym>&amp;</sym> <def>boardVec</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def>   BitVec toFill</def> <sym>= ~</sym><def>boardVec</def> <sym>&amp;</sym> <def>BOARD_MASK</def><sym>;</sym><br />
<def></def><br />
   <slc>// a little pre-work to speed things up</slc><br />
<def>   BitVec row</def> <sym>= (</sym><def>Board</def><sym>::</sym><def>TOP_ROW</def> <sym>&lt;&lt; ((</sym><def>N_ROW</def> <sym>-</sym> <def></def><num>1</num><def></def><sym>) *</sym> <def>N_COL</def><sym>));</sym><br />
<def></def>   <kwb>bool</kwb> <def>filled</def> <sym>= ((</sym><def>row</def> <sym>&amp;</sym> <def>toFill</def><sym>) ==</sym> <def>row</def><sym>);</sym><br />
<def></def>   <kwa>while</kwa> <def></def><sym>((</sym><def>row</def> <sym>&amp;</sym> <def>toFill</def><sym>) ==</sym> <def>row</def><sym>) {</sym><br />
<def>      toFill ^</def><sym>=</sym> <def>row</def><sym>;</sym><br />
<def>      row</def> <sym>&gt;&gt;=</sym> <def>N_COL</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def>   <slc>// undo the last row, so regions stay connected</slc><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>filled</def><sym>)   {</sym><br />
<def>      row</def> <sym>&lt;&lt;=</sym> <def>N_COL</def><sym>;</sym><br />
<def>      toFill</def> <sym>|=</sym> <def>row</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>while</kwa> <def></def><sym>(</sym><def>toFill</def><sym>)    {</sym><br />
<def></def>      <kwa>if</kwa> <def></def><sym>(</sym><def></def><kwd>hasBadFirstRegion</kwd><def></def><sym>(</sym><def>toFill</def><sym>))</sym><br />
<def></def>         <kwa>return true</kwa><def></def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>return false</kwa><def></def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<slc>// recursive vs iterative?</slc><br />
<def></def><kwb>void</kwb> <def>Board</def><sym>::</sym><def></def><kwd>genAllSolutions</kwd><def></def><sym>(</sym><def>BitVec boardVec</def><sym>,</sym> <def>TUInt32 placedPieces</def><sym>,</sym> <def>TUInt32 iNextFill</def><sym>,</sym> <def></def><kwb>const</kwb> <def>BitVec</def> <sym>&amp;</sym> <def>maskNextFill</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def>   BitVec pieceVec</def><sym>;</sym><br />
<def></def>   <kwb>int</kwb> <def>pieceMask</def> <sym>=</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def>   <kwb>int</kwb> <def>y</def> <sym>=</sym> <def>iNextFill</def> <sym>/</sym> <def>N_COL</def><sym>;</sym><br />
<def></def>   <kwb>int</kwb> <def>isOddLine</def> <sym>=</sym> <def>y</def> <sym>&amp;</sym> <def></def><num>1</num><def></def><sym>;</sym><br />
<def></def><br />
   <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iPlacedPiece</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iPlacedPiece</def> <sym>&lt;</sym> <def>Piece</def><sym>::</sym><def>N_TYPE</def><sym>;</sym> <def>iPlacedPiece</def><sym>++,</sym> <def>pieceMask</def> <sym>&lt;&lt;=</sym> <def></def><num>1</num><def></def><sym>)</sym><br />
<def></def>   <sym>{</sym><br />
<def>      TUInt32 iPiece</def> <sym>=</sym> <def>iPlacedPiece</def><sym>;</sym> <def></def><slc>// leftover from when I remapped it</slc><br />
<def></def><br />
      <slc>// skip if we've already used this piece</slc><br />
<def></def>      <kwa>if</kwa> <def></def><sym>(</sym><def>pieceMask</def> <sym>&amp;</sym> <def>placedPieces</def><sym>)</sym><br />
<def></def>         <kwa>continue</kwa><def></def><sym>;</sym><br />
<def></def><br />
      <slc>// try to fit piece</slc><br />
<def></def>      <kwb>bool</kwb> <def>skipFlippedOdd</def> <sym>= (</sym><def>iPiece</def> <sym>==</sym> <def>Piece</def><sym>::</sym><def>SKIP_PIECE</def><sym>);</sym><br />
<def></def>      <kwa>for</kwa> <def></def><sym>(</sym><def></def><kwb>int</kwb> <def>iOrient</def> <sym>=</sym> <def></def><num>0</num><def></def><sym>;</sym> <def>iOrient</def> <sym>&lt;</sym> <def>Piece</def><sym>::</sym><def>N_ORIENT</def><sym>;</sym> <def>iOrient</def><sym>++)</sym><br />
<def></def>      <sym>{</sym><br />
<def></def>         <kwa>if</kwa> <def></def><sym>(</sym><def>skipFlippedOdd</def> <sym>&amp;&amp; ((</sym><def>iOrient</def> <sym>/</sym> <def></def><num>3</num><def></def><sym>) &amp;</sym> <def></def><num>1</num><def></def><sym>))</sym><br />
<def></def>            <kwa>continue</kwa><def></def><sym>;</sym><br />
<def></def><br />
         <slc>// get the particular piece in the particular orientation</slc><br />
<def></def>         <kwb>const</kwb> <def>Piece</def><sym>::</sym><def>Instance</def> <sym>&amp;</sym> <def>p</def> <sym>=</sym> <def>Piece</def><sym>::</sym><def></def><kwd>getPiece</kwd><def></def><sym>(</sym><def>iPiece</def><sym>,</sym> <def>iOrient</def><sym>,</sym> <def>isOddLine</def><sym>);</sym><br />
<def></def><br />
         <slc>// check if the new position is allowed on the board</slc><br />
<def></def>         <kwa>if</kwa> <def></def><sym>(!(</sym><def>p</def><sym>.</sym><def>m_allowed</def> <sym>&amp;</sym> <def>maskNextFill</def><sym>))</sym><br />
<def></def>            <kwa>continue</kwa><def></def><sym>;</sym><br />
<def></def><br />
         <slc>// move it to the desired location, if possible and</slc><br />
<def>         pieceVec</def> <sym>=</sym> <def>p</def><sym>.</sym><def>m_vec</def> <sym>&lt;&lt; (</sym><def>iNextFill</def> <sym>-</sym> <def>p</def><sym>.</sym><def>m_offset</def><sym>);</sym><br />
<def></def><br />
         <slc>// check if piece conflicts with other pieces</slc><br />
<def></def>         <kwa>if</kwa> <def></def><sym>(</sym><def>pieceVec</def> <sym>&amp;</sym> <def>boardVec</def><sym>)</sym><br />
<def></def>            <kwa>continue</kwa><def></def><sym>;</sym><br />
<def></def><br />
         <slc>// add the piece to the board</slc><br />
<def>         boardVec</def> <sym>|=</sym> <def>pieceVec</def><sym>;</sym><br />
<def></def><br />
         <kwa>if</kwa> <def></def><sym>((</sym><def>boardVec</def> <sym>!=</sym> <def>pieceVec</def><sym>) &amp;&amp;</sym> <def></def><kwd>hasBadIslands</kwd><def></def><sym>(</sym><def>boardVec</def><sym>)) {</sym><br />
<def></def>            <slc>// remove the piece from the board vector</slc><br />
<def>            boardVec ^</def><sym>=</sym> <def>pieceVec</def><sym>;</sym><br />
<def></def>            <kwa>continue</kwa><def></def><sym>;</sym><br />
<def></def>         <sym>}</sym><br />
<def></def><br />
         <slc>// mark piece as placed</slc><br />
<def>         placedPieces</def> <sym>|=</sym> <def>pieceMask</def><sym>;</sym><br />
<def>         m_curSolution</def><sym>.</sym><def></def><kwd>addPiece</kwd><def></def><sym>(</sym><def>pieceVec</def><sym>,</sym> <def>iPiece</def><sym>);</sym><br />
<def></def><br />
         <slc>// recur if not done</slc><br />
<def></def>         <kwa>if</kwa> <def></def><sym>(</sym><def>placedPieces</def> <sym>!=</sym> <def>Piece</def><sym>::</sym><def>ALL_PIECE_MASK</def><sym>)   {</sym><br />
<def></def>            <slc>// need to find the next unfilled cell</slc><br />
<def>            TUInt32 iCell</def> <sym>=</sym> <def></def><kwd>getFirstOne</kwd><def></def><sym>(~</sym><def>boardVec</def><sym>,</sym> <def>iNextFill</def> <sym>+</sym> <def></def><num>1</num><def></def><sym>);</sym><br />
<def>            BitVec mNextFill</def> <sym>= (</sym><def>maskNextFill</def> <sym>&lt;&lt; (</sym><def>iCell</def> <sym>-</sym> <def>iNextFill</def><sym>));</sym><br />
<def></def><br />
            <kwd>genAllSolutions</kwd><def></def><sym>(</sym><def>boardVec</def><sym>,</sym> <def>placedPieces</def><sym>,</sym> <def>iCell</def><sym>,</sym> <def>mNextFill</def><sym>);</sym><br />
<def></def>         <sym>}</sym><br />
<def></def>         <kwa>else</kwa> <def></def><sym>{</sym><br />
<def></def>            <slc>// done, record piece/solution and end recursion</slc><br />
<def></def>            <kwd>recordSolution</kwd><def></def><sym>(</sym><def>m_curSolution</def><sym>);</sym><br />
<def></def>         <sym>}</sym><br />
<def></def><br />
         <slc>// remove the piece before continuing with a new piece</slc><br />
<def>         boardVec ^</def><sym>=</sym> <def>pieceVec</def><sym>;</sym><br />
<def>         m_curSolution</def><sym>.</sym><def></def><kwd>removeLastPiece</kwd><def></def><sym>();</sym><br />
<def></def>      <sym>}</sym><br />
<def><br />
      placedPieces</def> <sym>&amp;= ~</sym><def>pieceMask</def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<kwb>void</kwb> <def>Board</def><sym>::</sym><def></def><kwd>recordSolution</kwd><def></def><sym>(</sym><def>Solution</def> <sym>&amp;</sym> <def>s</def><sym>)</sym><br />
<def></def><sym>{</sym><br />
<def>   m_nSolutionFound</def> <sym>+=</sym> <def></def><num>2</num><def></def><sym>;</sym> <def></def><slc>// we add the solution and its rotation</slc><br />
<def></def><br />
   <kwa>if</kwa> <def></def><sym>(</sym><def>m_minSolution</def><sym>.</sym><def></def><kwd>isEmpty</kwd><def></def><sym>()) {</sym><br />
<def>      m_minSolution</def> <sym>=</sym> <def>m_maxSolution</def> <sym>=</sym> <def>s</def><sym>;</sym><br />
<def></def>      <kwa>return</kwa><def></def><sym>;</sym><br />
<def></def>   <sym>}</sym><br />
<def></def><br />
   <kwa>if</kwa> <def></def><sym>(</sym><def>s</def><sym>.</sym><def></def><kwd>lessThan</kwd><def></def><sym>(</sym><def>m_minSolution</def><sym>))</sym><br />
<def>      m_minSolution</def> <sym>=</sym> <def>s</def><sym>;</sym><br />
<def></def>   <kwa>else if</kwa> <def></def><sym>(</sym><def>m_maxSolution</def><sym>.</sym><def></def><kwd>lessThan</kwd><def></def><sym>(</sym><def>s</def><sym>))</sym><br />
<def>      m_maxSolution</def> <sym>=</sym> <def>s</def><sym>;</sym><br />
<def><br />
   Solution spun</def><sym>;</sym><br />
<def>   s</def><sym>.</sym><def></def><kwd>spin</kwd><def></def><sym>(</sym><def>spun</def><sym>);</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>spun</def><sym>.</sym><def></def><kwd>lessThan</kwd><def></def><sym>(</sym><def>m_minSolution</def><sym>))</sym><br />
<def>      m_minSolution</def> <sym>=</sym> <def>spun</def><sym>;</sym><br />
<def></def>   <kwa>else if</kwa> <def></def><sym>(</sym><def>m_maxSolution</def><sym>.</sym><def></def><kwd>lessThan</kwd><def></def><sym>(</sym><def>s</def><sym>))</sym><br />
<def>      m_maxSolution</def> <sym>=</sym> <def>spun</def><sym>;</sym><br />
<def></def><sym>}</sym><br />
<def></def><br />
<sym>}</sym> <def></def><slc>// namespace</slc><br />
<def></def><br />
<kwa>using namespace</kwa> <def>Meteor</def><sym>;</sym><br />
<def></def><br />
<kwb>int</kwb> <def></def><kwd>main</kwd><def></def><sym>(</sym><def></def><kwb>int</kwb> <def>argc</def><sym>,</sym> <def></def><kwb>char</kwb> <def></def><sym>*</sym> <def>argv</def> <sym>[])</sym><br />
<def></def><sym>{</sym><br />
<def></def>   <kwb>const int</kwb> <def>N_SOLUTION</def> <sym>=</sym> <def></def><num>2098</num><def></def><sym>;</sym><br />
<def>   TUInt32 nSolMax</def> <sym>=</sym> <def>N_SOLUTION</def><sym>;</sym><br />
<def></def>   <kwa>if</kwa> <def></def><sym>(</sym><def>argc</def> <sym>&gt;</sym> <def></def><num>2</num><def></def><sym>)</sym><br />
<def></def>      <kwa>return</kwa> <def></def><num>1</num><def></def><sym>;</sym> <def></def><slc>// spec says this is an error</slc><br />
<def></def>   <kwa>else if</kwa> <def></def><sym>(</sym><def>argc</def> <sym>==</sym> <def></def><num>2</num><def></def><sym>)</sym><br />
<def>      nSolMax</def> <sym>= *((</sym><def>TUInt32</def> <sym>*)</sym><def>argv</def><sym>[</sym><def></def><num>1</num><def></def><sym>]);</sym><br />
<def><br />
   Board board</def><sym>;</sym><br />
<def>   Piece</def><sym>::</sym><def></def><kwd>genAllOrientations</kwd><def></def><sym>();</sym><br />
<def>   board</def><sym>.</sym><def></def><kwd>genAllSolutions</kwd><def></def><sym>(</sym><def></def><num>0</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>0</num><def></def><sym>,</sym> <def></def><num>1L</num><def>L</def><sym>);</sym><br />
<def><br />
   cout</def> <sym>&lt;&lt;</sym> <def>board</def><sym>.</sym><def>m_nSolutionFound</def> <sym>&lt;&lt;</sym> <def></def><str>&quot; solutions found</str><esc>\n\n</esc><str>&quot;</str><def></def><sym>;</sym><br />
<def>   cout</def> <sym>&lt;&lt;</sym> <def>board</def><sym>.</sym><def>m_minSolution</def><sym>.</sym><def></def><kwd>toString</kwd><def></def><sym>() &lt;&lt;</sym> <def></def><str>'</str><esc>\n</esc><str>'</str><def></def><sym>;</sym><br />
<def>   cout</def> <sym>&lt;&lt;</sym> <def>board</def><sym>.</sym><def>m_maxSolution</def><sym>.</sym><def></def><kwd>toString</kwd><def></def><sym>() &lt;&lt;</sym> <def>endl</def><sym>;</sym><br />
<def></def><br />
<slc>//   if (nSolMax != N_SOLUTION)</slc><br />
<def></def><slc>//      return 1;</slc><br />
<def></def><br />
   <kwa>return</kwa> <def></def><num>0</num><def></def><sym>;</sym><br />
<def></def><sym>}</sym><def></def><br />
</source>
