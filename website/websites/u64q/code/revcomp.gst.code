<source>
<def></def><com>&quot;*  The Computer Language Shootout</com><br />
<com>   http://shootout.alioth.debian.org/</com><br />
<com>   contributed by Eliot Miranda and Isaac Gouy *&quot;</com><def>!<br />
<br />
<br />
!</def><kwc>Tests</kwc> <def></def><kwb>class methodsFor:</kwb> <def></def><str>'benchmarking'</str><def>!</def><br />
<kwb>reverseComplement:</kwb> <def>sequence</def> <kwb>named:</kwb> <def>sequenceName</def> <kwb>to:</kwb> <def>output</def><br />
   <kwd>| complement newline lineLength n |</kwd><br />
<def></def>   <sym>(</sym><def>sequenceName</def> <kwb>isNil</kwb><def></def><sym>)</sym> <def></def><kwb>ifTrue:</kwb> <def></def><sym>[^</sym><def></def><kwa>self</kwa><def></def><sym>].</sym><br />
<def><br />
   complement</def> <sym>:=</sym> <def></def><kwc>String</kwc> <def></def><kwb>new:</kwb> <def></def><num>128</num> <def></def><kwb>withAll:</kwb> <def>$</def><kwb>*</kwb><def></def><sym>.</sym><br />
<def></def><br />
   <str>'ABCDGHKMNRSTVWY'</str><def></def> <kwb>with:</kwb><br />
<def></def>   <str>'TVGHCDMKNYSABWR'</str><def></def><br />
      <kwb>do:</kwb> <def></def><sym>[</sym><def></def><kwd>:a :b</kwd><def></def><sym>|</sym><br />
<def>         complement</def> <kwb>at:</kwb> <def>a</def> <kwb>asInteger put:</kwb> <def>b</def><sym>.</sym><br />
<def>         complement</def> <kwb>at:</kwb> <def>a</def> <kwb>asLowercase asInteger put:</kwb> <def>b</def><sym>].</sym><br />
<def><br />
   newline</def> <sym>:=</sym> <def></def><kwc>Character</kwc> <def></def><kwb>lf</kwb><def></def><sym>.</sym><br />
<def>   lineLength</def> <sym>:=</sym> <def></def><num>60</num><def></def><sym>.</sym><br />
<def>   n</def> <sym>:=</sym> <def>sequence</def> <kwb>size</kwb><def></def><sym>.</sym><br />
<def><br />
   output</def> <kwb>nextPutAll:</kwb> <def>sequenceName</def><sym>;</sym> <def></def><kwb>nextPut:</kwb> <def>newline</def><sym>.</sym><br />
<def></def><br />
   <sym>[</sym><def>n &gt;</def> <num>0</num><def></def><sym>]</sym> <def></def><kwb>whileTrue:</kwb> <def></def><sym>[</sym><br />
<def></def>         <num>1</num> <def></def><kwb>to:</kwb> <def></def><sym>((</sym><def>n &lt;</def> <kwb>lineLength</kwb><def></def><sym>)</sym> <def></def><kwb>ifTrue:</kwb> <def></def><sym>[</sym><def>n</def><sym>]</sym> <def></def><kwb>ifFalse:</kwb> <def></def><sym>[</sym><def>lineLength</def><sym>])</sym> <def></def><kwb>do:</kwb><br />
<def></def>            <sym>[</sym><def></def><kwd>:i</kwd> <def></def><sym>|</sym> <def>output</def> <kwb>nextPut:</kwb><br />
<def></def>               <sym>(</sym><def>complement</def> <kwb>at:</kwb> <def></def><sym>(</sym><def>sequence</def> <kwb>at:</kwb> <def>n</def> <kwb>-</kwb> <def>i</def> <kwb>+</kwb> <def></def><num>1</num><def></def><sym>)</sym> <def></def><kwb>asInteger</kwb><def></def><sym>)].</sym><br />
<def>         output</def> <kwb>nextPut:</kwb> <def>newline</def><sym>.</sym><br />
<def>         n</def> <sym>:=</sym> <def>n</def> <kwb>-</kwb> <def>lineLength</def><sym>.</sym><br />
<def></def>      <sym>]</sym> <def>! !<br />
<br />
<br />
!</def><kwc>Tests</kwc> <def></def><kwb>class methodsFor:</kwb> <def></def><str>'benchmarking'</str><def>!</def><br />
<kwb>readFasta:</kwb> <def>sequenceName</def> <kwb>from:</kwb> <def>input</def><br />
   <kwd>| prefix newline buffer description line char |</kwd><br />
<def>   prefix</def> <sym>:=</sym> <def></def><str>'&gt;'</str><def>,sequenceName</def><sym>.</sym><br />
<def>   newline</def> <sym>:=</sym> <def></def><kwc>Character</kwc> <def></def><kwb>lf</kwb><def></def><sym>.</sym><br />
<def></def><br />
   <com>&quot;* find start of particular fasta sequence *&quot;</com><def></def><br />
   <sym>[(</sym><def>input</def> <kwb>atEnd</kwb><def></def><sym>)</sym> <def></def><kwb>or:</kwb> <def></def><sym>[</sym><br />
<def></def>         <sym>(</sym><def>input</def> <kwb>peek =</kwb> <def>$&gt;</def><sym>)</sym><br />
<def></def>            <kwb>ifTrue:</kwb> <def></def><sym>[((</sym><def>line</def> <sym>:=</sym> <def>input</def> <kwb>upTo:</kwb> <def>newline</def><sym>)</sym><br />
<def></def>               <kwb>indexOfSubCollection:</kwb> <def>prefix</def> <kwb>startingAt:</kwb> <def></def><num>1</num><def></def><sym>)</sym> <def></def><kwb>=</kwb> <def></def><num>1</num><def></def><sym>]</sym><br />
<def></def>            <kwb>ifFalse:</kwb> <def></def><sym>[</sym><def>input</def> <kwb>skipTo:</kwb> <def>newline</def><sym>.</sym> <def></def><kwa>false</kwa><def></def><sym>]]</sym><br />
<def></def>      <sym>]</sym> <def></def><kwb>whileFalse</kwb><def></def><sym>.</sym><br />
<def></def><br />
   <com>&quot;* line-by-line read - it would be a lot faster to block read *&quot;</com><def><br />
   description</def> <sym>:=</sym> <def>line</def><sym>.</sym><br />
<def>   buffer</def> <sym>:=</sym> <def></def><kwc>ReadWriteStream</kwc> <def></def><kwb>on:</kwb> <def></def><sym>(</sym><def></def><kwc>String</kwc> <def></def><kwb>new:</kwb> <def></def><num>1028</num><def></def><sym>).</sym><br />
<def></def>   <sym>[(</sym><def>input</def> <kwb>atEnd</kwb><def></def><sym>)</sym> <def></def><kwb>or:</kwb> <def></def><sym>[(</sym><def>char</def> <sym>:=</sym> <def>input</def> <kwb>peek</kwb><def></def><sym>)</sym> <def></def><kwb>=</kwb> <def>$&gt;</def><sym>]]</sym> <def></def><kwb>whileFalse:</kwb> <def></def><sym>[</sym><br />
<def></def>      <sym>(</sym><def>char</def> <kwb>=</kwb> <def>$</def><sym>;)</sym><br />
<def></def>         <kwb>ifTrue:</kwb> <def></def><sym>[</sym><def>input</def> <kwb>upTo:</kwb> <def>newline</def><sym>]</sym><br />
<def></def>         <kwb>ifFalse:</kwb> <def></def><sym>[</sym><def>buffer</def> <kwb>nextPutAll:</kwb> <def></def><sym>(</sym><def>input</def> <kwb>upTo:</kwb> <def>newline</def><sym>)]</sym><br />
<def></def>      <sym>].</sym><br />
<def></def>   <sym>^</sym><def></def><kwc>Association</kwc> <def></def><kwb>key:</kwb> <def>description</def> <kwb>value:</kwb> <def>buffer</def> <kwb>contents</kwb> <def>! !<br />
<br />
<br />
!</def><kwc>Tests</kwc> <def></def><kwb>class methodsFor:</kwb> <def></def><str>'benchmark scripts'</str><def>!</def><br />
<kwb>revcomp</kwb><br />
<def></def>   <kwd>| input output |</kwd><br />
<def>   input</def> <sym>:=</sym> <def></def><kwa>self</kwa> <def></def><kwb>stdin</kwb><def></def><sym>.</sym><br />
<def>   output</def> <sym>:=</sym> <def></def><kwa>self</kwa> <def></def><kwb>stdout</kwb><def></def><sym>.</sym><br />
<def></def><br />
   <sym>#(</sym><def></def><str>'ONE'</str><def></def> <str>'TWO'</str><def></def> <str>'THREE'</str><def></def><sym>)</sym> <def></def><kwb>do:</kwb><br />
<def></def>      <sym>[</sym><def></def><kwd>:sequenceName</kwd><def></def><sym>|</sym>   <def></def><kwd>| fasta |</kwd><br />
<def>         fasta</def> <sym>:=</sym> <def></def><kwa>self</kwa> <def></def><kwb>readFasta:</kwb> <def>sequenceName</def> <kwb>from:</kwb> <def>input</def><sym>.</sym><br />
<def></def>         <kwa>self</kwa> <def></def><kwb>reverseComplement:</kwb> <def>fasta</def> <kwb>value named:</kwb> <def>fasta</def> <kwb>key to:</kwb> <def>output</def><sym>.</sym><br />
<def></def>      <sym>].</sym><br />
<def><br />
   output</def> <kwb>flush</kwb><def></def><sym>.</sym><br />
<def></def>   <sym>^</sym><def></def><str>''</str><def> ! !<br />
<br />
<br />
Tests</def> <kwb>revcomp</kwb><def>!</def><br />
</source>
