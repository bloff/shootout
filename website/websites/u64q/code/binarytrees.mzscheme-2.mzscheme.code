<source>
<def></def><slc>;;; The Computer Language Benchmarks Game</slc><br />
<def></def><slc>;;; http://shootout.alioth.debian.org/</slc><br />
<def></def><slc>;;; Derived from the Chicken variant by Sven Hartrumpf</slc><br />
<def></def><slc>;;; contributed by Matthew Flatt</slc><br />
<def><br />
#lang scheme</def><sym>/</sym><def>base</def><br />
<sym>(</sym><def>require scheme</def><sym>/</sym><def>cmdline</def><sym>)</sym><br />
<def></def><br />
<sym>(</sym><def>define</def><sym>-</sym><def>struct node</def> <sym>(</sym><def>left val right</def><sym>))</sym><br />
<def></def><br />
<slc>;; Instead of (define-struct leaf (val)):</slc><br />
<def></def><sym>(</sym><def>define</def> <sym>(</sym><def>make</def><sym>-</sym><def>leaf val</def><sym>) (</sym><def>make</def><sym>-</sym><def>node #f val #f</def><sym>))</sym><br />
<def></def><sym>(</sym><def>define</def> <sym>(</sym><def>leaf? l</def><sym>) (</sym><def></def><kwa>not</kwa> <def></def><sym>(</sym><def>node</def><sym>-</sym><def>left l</def><sym>)))</sym><br />
<def></def><sym>(</sym><def>define</def> <sym>(</sym><def>leaf</def><sym>-</sym><def>val l</def><sym>) (</sym><def>node</def><sym>-</sym><def>val l</def><sym>))</sym><br />
<def></def><br />
<sym>(</sym><def>define</def> <sym>(</sym><def>make item d</def><sym>)</sym><br />
<def></def>  <sym>(</sym><def></def><kwa>if</kwa> <def></def><sym>(=</sym> <def>d</def> <num>0</num><def></def><sym>)</sym><br />
<def></def>      <sym>(</sym><def>make</def><sym>-</sym><def>leaf item</def><sym>)</sym><br />
<def></def>      <sym>(</sym><def>let</def> <sym>((</sym><def>item2</def> <sym>(*</sym> <def>item</def> <num>2</num><def></def><sym>))</sym><br />
<def></def>            <sym>(</sym><def>d2</def> <sym>(-</sym> <def>d</def> <num>1</num><def></def><sym>)))</sym><br />
<def></def>        <sym>(</sym><def>make</def><sym>-</sym><def>node</def> <sym>(</sym><def>make</def> <sym>(-</sym> <def>item2</def> <num>1</num><def></def><sym>)</sym> <def>d2</def><sym>)</sym> <def>item</def> <sym>(</sym><def>make item2 d2</def><sym>)))))</sym><br />
<def></def><br />
<sym>(</sym><def>define</def> <sym>(</sym><def>check t</def><sym>)</sym><br />
<def></def>  <sym>(</sym><def></def><kwa>if</kwa> <def></def><sym>(</sym><def>leaf? t</def><sym>)</sym><br />
<def></def>      <sym>(</sym><def>leaf</def><sym>-</sym><def>val t</def><sym>)</sym><br />
<def></def>      <sym>(+ (</sym><def>node</def><sym>-</sym><def>val t</def><sym>) (- (</sym><def>check</def> <sym>(</sym><def>node</def><sym>-</sym><def>left t</def><sym>))</sym><br />
<def></def>                         <sym>(</sym><def>check</def> <sym>(</sym><def>node</def><sym>-</sym><def>right t</def><sym>))))))</sym><br />
<def></def><br />
<sym>(</sym><def>define</def> <sym>(</sym><def>main n</def><sym>)</sym><br />
<def></def>  <sym>(</sym><def>let</def><sym>* ((</sym><def></def><kwa>min</kwa><def></def><sym>-</sym><def>depth</def> <num>4</num><def></def><sym>)</sym><br />
<def></def>         <sym>(</sym><def></def><kwa>max</kwa><def></def><sym>-</sym><def>depth</def> <sym>(</sym><def></def><kwa>max</kwa> <def></def><sym>(+</sym> <def></def><kwa>min</kwa><def></def><sym>-</sym><def>depth</def> <num>2</num><def></def><sym>)</sym> <def>n</def><sym>)))</sym><br />
<def></def>    <sym>(</sym><def>let</def> <sym>((</sym><def>stretch</def><sym>-</sym><def>depth</def> <sym>(+</sym> <def></def><kwa>max</kwa><def></def><sym>-</sym><def>depth</def> <num>1</num><def></def><sym>)))</sym><br />
<def></def>      <sym>(</sym><def>printf</def> <str>&quot;stretch tree of depth ~a</str><esc>\</esc><str>t check: ~a</str><esc>\</esc><str>n&quot;</str><def><br />
              stretch</def><sym>-</sym><def>depth</def><br />
              <sym>(</sym><def>check</def> <sym>(</sym><def>make</def> <num>0</num> <def>stretch</def><sym>-</sym><def>depth</def><sym>))))</sym><br />
<def></def>    <sym>(</sym><def>let</def> <sym>((</sym><def>long</def><sym>-</sym><def>lived</def><sym>-</sym><def>tree</def> <sym>(</sym><def>make</def> <num>0</num> <def></def><kwa>max</kwa><def></def><sym>-</sym><def>depth</def><sym>)))</sym><br />
<def></def>      <sym>(</sym><def>for</def> <sym>((</sym><def>d</def> <sym>(</sym><def>in</def><sym>-</sym><def>range</def> <num>4</num> <def></def><sym>(</sym><def>add1</def> <kwa>max</kwa><def></def><sym>-</sym><def>depth</def><sym>)</sym> <def></def><num>2</num><def></def><sym>)))</sym><br />
<def></def>        <sym>(</sym><def>let</def> <sym>((</sym><def>iterations</def> <sym>(</sym><def>arithmetic</def><sym>-</sym><def>shift</def> <num>1</num> <def></def><sym>(+ (-</sym> <def></def><kwa>max</kwa><def></def><sym>-</sym><def>depth d</def><sym>)</sym> <def></def><kwa>min</kwa><def></def><sym>-</sym><def>depth</def><sym>))))</sym><br />
<def></def>          <sym>(</sym><def>printf</def> <str>&quot;~a</str><esc>\</esc><str>t trees of depth ~a</str><esc>\</esc><str>t check: ~a</str><esc>\</esc><str>n&quot;</str><def></def><br />
                  <sym>(*</sym> <def></def><num>2</num> <def>iterations</def><sym>)</sym><br />
<def>                  d</def><br />
                  <sym>(</sym><def>for</def><sym>/</sym><def>fold</def> <sym>([</sym><def>c</def> <num>0</num><def></def><sym>])</sym><br />
<def></def>                            <sym>([</sym><def>i</def> <sym>(</sym><def>in</def><sym>-</sym><def>range iterations</def><sym>)])</sym><br />
<def></def>                    <sym>(+</sym> <def>c</def><br />
                       <sym>(</sym><def>check</def> <sym>(</sym><def>make i d</def><sym>))</sym><br />
<def></def>                       <sym>(</sym><def>check</def> <sym>(</sym><def>make</def> <sym>(-</sym> <def>i</def><sym>)</sym> <def>d</def><sym>)))))))</sym><br />
<def></def>      <sym>(</sym><def>printf</def> <str>&quot;long lived tree of depth ~a</str><esc>\</esc><str>t check: ~a</str><esc>\</esc><str>n&quot;</str><def></def><br />
              <kwa>max</kwa><def></def><sym>-</sym><def>depth</def><br />
              <sym>(</sym><def>check long</def><sym>-</sym><def>lived</def><sym>-</sym><def>tree</def><sym>)))))</sym><br />
<def></def><br />
<sym>(</sym><def></def><kwa>command</kwa><def></def><sym>-</sym><def></def><kwa>line</kwa> <def>#</def><sym>:</sym><def>args</def> <sym>(</sym><def>n</def><sym>)</sym><br />
<def></def>              <sym>(</sym><def>main</def> <sym>(</sym><def>string</def><sym>-&gt;</sym><def>number n</def><sym>)))</sym><def></def><br />
</source>
