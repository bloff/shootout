BUILD COMMANDS FOR: binarytrees.sbcl-2.sbcl

Sat Jul 29 20:18:01 PDT 2006

SBCL built with: /usr/bin/sbcl --userinit /dev/null --sysinit /dev/null -batch -eval '(load "binarytrees.sbcl-2.sbcl_compile")'
### START binarytrees.sbcl-2.sbcl_compile
(proclaim '(optimize (speed 3) (safety 0) (debug 0) (compilation-speed 0) (space 0)))
(asdf:operate 'asdf:load-op 'cl-ppcre)
(handler-bind ((sb-ext:defconstant-uneql      (lambda (c) (abort c))))      (load (compile-file "binarytrees.sbcl-2.sbcl" ))) (save-lisp-and-die "sbcl.core" :purify t)
### END binarytrees.sbcl-2.sbcl_compile

; loading system definition from /usr/share/common-lisp/systems/cl-ppcre.asd
; into #<PACKAGE "ASDF0">
; registering #<SYSTEM #:CL-PPCRE {A93BC39}> as CL-PPCRE
; compiling file "/home/dunham/gp4/shootout/bench/binarytrees/tmp/binarytrees.sbcl-2.sbcl" (written 29 JUL 2006 08:18:01 PM):
; compiling (DEFUN BUILD-BTREE ...)
; file: /home/dunham/gp4/shootout/bench/binarytrees/tmp/binarytrees.sbcl-2.sbcl
; in: DEFUN BUILD-BTREE
;     (CONS ITEM NIL NIL)
; 
; caught STYLE-WARNING:
;   The function was called with three arguments, but wants exactly two.

;     (DEFUN BUILD-BTREE (ITEM DEPTH)
;     (DECLARE (FIXNUM ITEM DEPTH))
;     (IF (ZEROP DEPTH)
;         (CONS ITEM NIL NIL)
;         (LET ((ITEM2 #) (DEPTH-1 #))
;           (DECLARE (FIXNUM ITEM2 DEPTH-1))
;           (CONS ITEM (CONS # #)))))
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA BUILD-BTREE
;                          (ITEM DEPTH)
;                          (DECLARE (FIXNUM ITEM DEPTH))
;                          (BLOCK BUILD-BTREE
;                            (IF (ZEROP DEPTH)
;                                (CONS ITEM NIL NIL)
;                                (LET (# #)
;                                  (DECLARE #)
;                                  (CONS ITEM #)))))
; 
; note: Return type not fixed values, so can't use known return convention:
;   NIL

; compiling (DEFUN CHECK-NODE ...)
; compiling (DEFUN LOOP-DEPTHS ...)
; file: /home/dunham/gp4/shootout/bench/binarytrees/tmp/binarytrees.sbcl-2.sbcl
; in: DEFUN LOOP-DEPTHS
;     (LOOP FOR
;         D
;         FROM
;         MIN-DEPTH
;         BY
;         2
;         UPTO
;         MAX-DEPTH
;         DO
;         (LET ((ITERATIONS (ASH 1 #)))
;           (FORMAT T
;                   "~D~C trees of depth ~D~C check: ~D~%"
;                   (* ITERATIONS 2)
;                   #\Tab
;                   D
;                   #\Tab
;                   (LOOP FOR
;                         I
;                         FROM
;                         1
;                         UPTO
;                         ITERATIONS
;                         SUM
;                         (CHECK-NODE #)
;                         SUM
;                         (CHECK-NODE #)))))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN COND IF 
; ==>
;   (> D #:LOOP-LIMIT-7)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

;     (+ MAX-DEPTH MIN-DEPTH (- D))
; --> + 
; ==>
;   (+ MAX-DEPTH MIN-DEPTH)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a RATIONAL.
;   The second argument is a REAL, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.

; ==>
;   (+ (+ MAX-DEPTH MIN-DEPTH) (- D))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a RATIONAL.
;   The second argument is a REAL, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.

;     (LOOP FOR
;         D
;         FROM
;         MIN-DEPTH
;         BY
;         2
;         UPTO
;         MAX-DEPTH
;         DO
;         (LET ((ITERATIONS (ASH 1 #)))
;           (FORMAT T
;                   "~D~C trees of depth ~D~C check: ~D~%"
;                   (* ITERATIONS 2)
;                   #\Tab
;                   D
;                   #\Tab
;                   (LOOP FOR
;                         I
;                         FROM
;                         1
;                         UPTO
;                         ITERATIONS
;                         SUM
;                         (CHECK-NODE #)
;                         SUM
;                         (CHECK-NODE #)))))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 
; ==>
;   (+ D 2)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (LOOP FOR
;         I
;         FROM
;         1
;         UPTO
;         ITERATIONS
;         SUM
;         (CHECK-NODE (BUILD-BTREE I D))
;         SUM
;         (CHECK-NODE (BUILD-BTREE (- I) D)))
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY SETQ THE 
; ==>
;   (+ #:LOOP-SUM-9 (CHECK-NODE (BUILD-BTREE I D)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

; ==>
;   (+ #:LOOP-SUM-9 (CHECK-NODE (BUILD-BTREE (- I) D)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (LOOP FOR
;         D
;         FROM
;         MIN-DEPTH
;         BY
;         2
;         UPTO
;         MAX-DEPTH
;         DO
;         (LET ((ITERATIONS (ASH 1 #)))
;           (FORMAT T
;                   "~D~C trees of depth ~D~C check: ~D~%"
;                   (* ITERATIONS 2)
;                   #\Tab
;                   D
;                   #\Tab
;                   (LOOP FOR
;                         I
;                         FROM
;                         1
;                         UPTO
;                         ITERATIONS
;                         SUM
;                         (CHECK-NODE #)
;                         SUM
;                         (CHECK-NODE #)))))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN COND IF 
; ==>
;   (> D #:LOOP-LIMIT-7)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       etc.

;     (+ MAX-DEPTH MIN-DEPTH (- D))
; --> + 
; ==>
;   (+ MAX-DEPTH MIN-DEPTH)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       The result is a (VALUES REAL
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES REAL
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (- D)
; ==>
;   (SB-KERNEL:%NEGATE D)
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The result is a (VALUES REAL
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES REAL
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+ MAX-DEPTH MIN-DEPTH (- D))
; ==>
;   (+ (+ MAX-DEPTH MIN-DEPTH) (- D))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 32) arithmetic (cost 5) because:
;       The first argument is a REAL, not a (SIGNED-BYTE 32).
;       The second argument is a REAL, not a (SIGNED-BYTE 32).
;       The result is a (VALUES INTEGER
;                               &OPTIONAL), not a (VALUES (SIGNED-BYTE 32)
;                                                         &REST
;                                                         T).
;       etc.

;     (ASH 1 (+ MAX-DEPTH MIN-DEPTH (- D)))
; 
; note: forced to do full call
;       unable to do inline ASH (cost 3) because:
;       The second argument is a INTEGER, not a (UNSIGNED-BYTE 29).
;       The result is a (VALUES UNSIGNED-BYTE
;                               &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The second argument is a INTEGER, not a (UNSIGNED-BYTE 29).
;       The result is a (VALUES UNSIGNED-BYTE
;                               &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (* ITERATIONS 2)
; ==>
;   (ASH SB-C::X 1)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES UNSIGNED-BYTE
;                               &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a UNSIGNED-BYTE, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES UNSIGNED-BYTE
;                               &OPTIONAL), not a (VALUES (UNSIGNED-BYTE 32)
;                                                         &REST
;                                                         T).
;       etc.

;     (LOOP FOR
;         I
;         FROM
;         1
;         UPTO
;         ITERATIONS
;         SUM
;         (CHECK-NODE (BUILD-BTREE I D))
;         SUM
;         (CHECK-NODE (BUILD-BTREE (- I) D)))
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN COND IF 
; ==>
;   (> I #:LOOP-LIMIT-8)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1 536870912), not a FIXNUM.
;       The second argument is a UNSIGNED-BYTE, not a FIXNUM.

;     (LOOP FOR
;         D
;         FROM
;         MIN-DEPTH
;         BY
;         2
;         UPTO
;         MAX-DEPTH
;         DO
;         (LET ((ITERATIONS (ASH 1 #)))
;           (FORMAT T
;                   "~D~C trees of depth ~D~C check: ~D~%"
;                   (* ITERATIONS 2)
;                   #\Tab
;                   D
;                   #\Tab
;                   (LOOP FOR
;                         I
;                         FROM
;                         1
;                         UPTO
;                         ITERATIONS
;                         SUM
;                         (CHECK-NODE #)
;                         SUM
;                         (CHECK-NODE #)))))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 
; ==>
;   (+ D 2)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (LOOP FOR
;         I
;         FROM
;         1
;         UPTO
;         ITERATIONS
;         SUM
;         (CHECK-NODE (BUILD-BTREE I D))
;         SUM
;         (CHECK-NODE (BUILD-BTREE (- I) D)))
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY SETQ THE 
; ==>
;   (+ #:LOOP-SUM-9 (CHECK-NODE (BUILD-BTREE I D)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 32) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 32).
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES (SIGNED-BYTE 32)
;                                                         &REST
;                                                         T).
;       etc.

; ==>
;   (+ #:LOOP-SUM-9 (CHECK-NODE (BUILD-BTREE (- I) D)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 32) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 32).
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES (SIGNED-BYTE 32)
;                                                         &REST
;                                                         T).
;       etc.

; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ 
; ==>
;   (SETQ I (1+ I))
; 
; note: doing signed word to integer coercion (cost 20) to I

; compiling (DEFUN MAIN ...)
; file: /home/dunham/gp4/shootout/bench/binarytrees/tmp/binarytrees.sbcl-2.sbcl
; in: DEFUN MAIN
;     (1+ N)
; ==>
;   (+ N 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       etc.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
;   printed 38 notes


; /home/dunham/gp4/shootout/bench/binarytrees/tmp/binarytrees.sbcl-2.fasl written
; compilation finished in 0:00:00
[doing purification: roots handlers stack bindings static cleanup done]
[undoing binding stack and other enclosing state... done]
[saving current Lisp image into /home/dunham/gp4/shootout/bench/binarytrees/tmp/sbcl.core:
writing 21906408 bytes from the read-only space at 0x01000000
writing 5477680 bytes from the static space at 0x05000000
writing 4096 bytes from the dynamic space at 0x09000000
done]
### START binarytrees.sbcl-2.sbcl_run
(proclaim '(optimize (speed 3) (safety 0) (debug 0) (compilation-speed 0) (space 0)))
(main) (quit)
### END binarytrees.sbcl-2.sbcl_run


=================================================================
COMMAND LINE (%A is single numeric argument):

 /usr/bin/sbcl --noinform --core sbcl.core --userinit /dev/null --sysinit /dev/null --load binarytrees.sbcl-2.sbcl_run %A
unhandled SIMPLE-ERROR in thread #<SB-THREAD:THREAD "initial thread" {90035C1}>:
  Error during processing of --eval option (LOAD
                                            #P"binarytrees.sbcl-2.sbcl_run"):

  invalid number of arguments: 3

0: (BACKTRACE 128 #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDERR* {5062CF1}>)
1: (SB-DEBUG::DEBUGGER-DISABLED-HOOK
    #<SIMPLE-ERROR {9015641}>
    #<unavailable argument>)
2: (INVOKE-DEBUGGER #<SIMPLE-ERROR {9015641}>)
3: (ERROR
    "Error during processing of --eval ~
                                    option ~S:~%~%  ~A")
4: ((LAMBDA (SB-IMPL::E)) #<SB-INT:SIMPLE-PROGRAM-ERROR {9015599}>)
5: ((LAMBDA (SB-IMPL::E)) #<SB-INT:SIMPLE-PROGRAM-ERROR {9015599}>)
6: (SIGNAL #<SB-INT:SIMPLE-PROGRAM-ERROR {9015599}>)
7: (ERROR SB-INT:SIMPLE-PROGRAM-ERROR)
8: (SB-KERNEL::INVALID-ARG-COUNT-ERROR-HANDLER
    #<unavailable argument>
    #.(SB-SYS:INT-SAP #XB6006924)
    #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #XB600660C :TYPE (*
                                                            (STRUCT
                                                             SB-VM::OS-CONTEXT-T-STRUCT))>
    (205))
9: (SB-KERNEL:INTERNAL-ERROR
    #.(SB-SYS:INT-SAP #XB600660C)
    #<unavailable argument>)
10: ("foreign function: call_into_lisp")
11: ("foreign function: funcall2")
12: ("foreign function: interrupt_internal_error")
13: ("foreign function: sigtrap_handler")
14: (CONS -8191 NIL)
15: (BUILD-BTREE #<unavailable lambda list>)
16: (BUILD-BTREE #<unavailable lambda list>)
17: (BUILD-BTREE #<unavailable lambda list>)
18: (BUILD-BTREE #<unavailable lambda list>)
19: (BUILD-BTREE #<unavailable lambda list>)
20: (BUILD-BTREE #<unavailable lambda list>)
21: (BUILD-BTREE #<unavailable lambda list>)
22: (BUILD-BTREE #<unavailable lambda list>)
23: (BUILD-BTREE #<unavailable lambda list>)
24: (BUILD-BTREE #<unavailable lambda list>)
25: (BUILD-BTREE #<unavailable lambda list>)
26: (BUILD-BTREE #<unavailable lambda list>)
27: (BUILD-BTREE #<unavailable lambda list>)
28: (MAIN #<unavailable lambda list>)
29: (SB-INT:EVAL-IN-LEXENV (MAIN) #<NULL-LEXENV>)
30: (SB-FASL::LOAD-AS-SOURCE
     #<SB-SYS:FD-STREAM for "file /home/dunham/gp4/shootout/bench/binarytrees/tmp/binarytrees.sbcl-2.sbcl_run" {900ED11}>
     NIL
     NIL)
31: (SB-FASL::INTERNAL-LOAD
     #P"binarytrees.sbcl-2.sbcl_run"
     #P"/home/dunham/gp4/shootout/bench/binarytrees/tmp/binarytrees.sbcl-2.sbcl_run"
     :ERROR
     NIL
     NIL
     :SOURCE
     :DEFAULT)
32: (SB-FASL::INTERNAL-LOAD
     #P"binarytrees.sbcl-2.sbcl_run"
     #P"/home/dunham/gp4/shootout/bench/binarytrees/tmp/binarytrees.sbcl-2.sbcl_run"
     :ERROR
     NIL
     NIL
     NIL
     :DEFAULT)
33: (LOAD #P"binarytrees.sbcl-2.sbcl_run")
34: (SB-INT:EVAL-IN-LEXENV
     (LOAD #P"binarytrees.sbcl-2.sbcl_run")
     #<NULL-LEXENV>)
35: (SB-IMPL::PROCESS-EVAL-OPTIONS ((LOAD #P"binarytrees.sbcl-2.sbcl_run")))
36: (SB-IMPL::TOPLEVEL-INIT)
37: ((LABELS SB-IMPL::RESTART-LISP))

unhandled condition in --disable-debugger mode, quitting
TEST FAILED - Child processed exited with error code (1)


PROGRAM OUTPUT
==============
