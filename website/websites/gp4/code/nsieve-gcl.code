<span class="slc">;;; The Great Computer Language Shootout</span>
<span class="slc">;;; http://shootout.alioth.debian.org/</span>
<span class="slc">;;; contributed by Dima Dorfman, 2005</span>

<span class="sym">(</span><span class="kwa">defun</span> nsieve <span class="sym">(</span>m<span class="sym">)</span>
  <span class="sym">(</span>declare <span class="sym">(</span><span class="kwa">type</span> integer m<span class="sym">))</span>
  <span class="sym">(</span>let <span class="sym">((</span>a <span class="sym">(</span>make<span class="sym">-</span>array <span class="sym">(</span><span class="kwa">list</span> m<span class="sym">) :</span>initial<span class="sym">-</span>element t
		       <span class="sym">:</span>element<span class="sym">-</span><span class="kwa">type</span> <span class="str">'boolean)))</span>
<span class="str">    (flet ((clear (i)</span>
<span class="str">	     (loop for j from (+ i i) to (1- m) by i</span>
<span class="str">		   do (setf (aref a j) nil))))</span>
<span class="str">      (loop for i from 2 to (1- m)</span>
<span class="str">	    when (aref a i) do (clear i)</span>
<span class="str">	    count (aref a i)))))</span>
<span class="str"></span>
<span class="str">(defun test (n)</span>
<span class="str">  (let ((m (* 10000 (expt 2 n))))</span>
<span class="str">    (format t &quot;Primes up to~T~8&lt;~d~&gt;~T~8&lt;~d~&gt;~%&quot; m (nsieve m))))</span>
<span class="str"></span>
<span class="str">(defun main ()</span>
<span class="str">  (let* ((args #+sbcl sb-ext:*posix-argv*</span>
<span class="str">	       #+cmu extensions:*command-line-strings*</span>
<span class="str">	       #+gcl si::*command-args*)</span>
<span class="str">	 (n (parse-integer (car (last args)))))</span>
<span class="str">    (when (&gt;= n 0) (test n))</span>
<span class="str">    (when (&gt;= n 1) (test (- n 1)))</span>
<span class="str">    (when (&gt;= n 2) (test (- n 2)))))</span>
