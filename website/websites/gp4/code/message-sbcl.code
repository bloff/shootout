<span class="hl slc">;;   The Great Computer Language Shootout</span>
<span class="hl slc">;;   http://shootout.alioth.debian.org/</span>
<span class="hl slc">;;</span>
<span class="hl slc">;;   Threads-flow.</span>
<span class="hl slc">;;</span>
<span class="hl slc">;;   Contributed by Christopher Neufeld</span>
<span class="hl slc">;;</span>


<span class="hl slc">;; set this to 't' to print copious debugging.</span>
<span class="hl slc">;; (defconstant +debug-print+ nil)</span>
<span class="hl slc">;; (defparameter print-mutex nil)</span>

<span class="hl slc">;; (defmacro debug-output (format-string &amp;rest args)</span>
<span class="hl slc">;;   (if +debug-print+</span>
<span class="hl slc">;;       `(progn</span>
<span class="hl slc">;;         (lock-mutex print-mutex)</span>
<span class="hl slc">;;         (format t ,format-string ,&#64;args)</span>
<span class="hl slc">;;         (release-mutex print-mutex))))</span>




<span class="hl slc">;; If we serialize the creation of threads, things go much more</span>
<span class="hl slc">;; quickly, at least for my combination of sbcl and kernel</span>
<span class="hl slc">;; version/configuration.</span>
<span class="hl sym">(</span>defconstant <span class="hl sym">+</span>serialize-threads<span class="hl sym">+</span> t<span class="hl sym">)</span>
<span class="hl sym">(</span>defparameter <span class="hl sym">*</span>serialize-threads-mutex<span class="hl sym">*</span> nil<span class="hl sym">)</span>
<span class="hl sym">(</span>defparameter <span class="hl sym">*</span>serialize-threads-<span class="hl kwa">cond</span><span class="hl sym">*</span> nil<span class="hl sym">)</span>
<span class="hl sym">(</span>defparameter <span class="hl sym">*</span>serialize-threads-flag<span class="hl sym">*</span> nil<span class="hl sym">)</span>


<span class="hl slc">;; Note that sbcl seems to be limited to 512 calls to make-thread.</span>
<span class="hl sym">(</span>defparameter <span class="hl sym">*</span>n-threads<span class="hl sym">*</span> <span class="hl num">500</span><span class="hl sym">)</span>


#<span class="hl sym">+</span>clisp <span class="hl sym">(</span>error <span class="hl str">&quot;Presently, clisp does not support condition objects&quot;</span><span class="hl sym">)</span>
#<span class="hl sym">+</span>gcl <span class="hl sym">(</span>error <span class="hl str">&quot;Presently, gcl does not support multi-threading&quot;</span><span class="hl sym">)</span>


<span class="hl sym">(</span>defmacro forever <span class="hl sym">(&amp;</span>body body<span class="hl sym">)</span>
  `<span class="hl sym">(</span>do <span class="hl sym">() (</span>nil<span class="hl sym">) ,</span>&#64;body<span class="hl sym">))</span>


<span class="hl sym">(</span><span class="hl kwa">defun</span> create-<span class="hl kwa">cond</span> <span class="hl sym">()</span>
  #<span class="hl sym">+</span>sbcl <span class="hl sym">(</span>sb-thread<span class="hl sym">:</span>make-waitqueue<span class="hl sym">)</span>
  #-<span class="hl sym">(</span><span class="hl kwa">or</span> sbcl<span class="hl sym">) (</span>error <span class="hl str">&quot;We need an implementation of cond creation for this platform&quot;</span><span class="hl sym">))</span>

<span class="hl sym">(</span><span class="hl kwa">defun</span> create-mutex <span class="hl sym">()</span>
  #<span class="hl sym">+</span>sbcl <span class="hl sym">(</span>sb-thread<span class="hl sym">:</span>make-mutex <span class="hl sym">:</span>value nil<span class="hl sym">)</span>
  #-<span class="hl sym">(</span><span class="hl kwa">or</span> sbcl<span class="hl sym">) (</span>error <span class="hl str">&quot;We need an implementation of mutex creation for this platform&quot;</span><span class="hl sym">))</span>


<span class="hl sym">(</span><span class="hl kwa">defun</span> lock-mutex <span class="hl sym">(</span>mutex<span class="hl sym">)</span>
  #<span class="hl sym">+</span>sbcl <span class="hl sym">(</span>sb-thread<span class="hl sym">:</span>get-mutex mutex<span class="hl sym">)</span>
  #-<span class="hl sym">(</span><span class="hl kwa">or</span> sbcl<span class="hl sym">) (</span>error <span class="hl str">&quot;We need an implementation of mutex-locking for this platform&quot;</span><span class="hl sym">))</span>

<span class="hl sym">(</span><span class="hl kwa">defun</span> release-mutex <span class="hl sym">(</span>mutex<span class="hl sym">)</span>
  #<span class="hl sym">+</span>sbcl <span class="hl sym">(</span>sb-thread<span class="hl sym">:</span>release-mutex mutex<span class="hl sym">)</span>
  #-<span class="hl sym">(</span><span class="hl kwa">or</span> sbcl<span class="hl sym">) (</span>error <span class="hl str">&quot;We need an implementation of mutex-unlocking for this platform&quot;</span><span class="hl sym">))</span>

<span class="hl sym">(</span><span class="hl kwa">defun</span> wait-on-<span class="hl kwa">cond</span> <span class="hl sym">(</span><span class="hl kwa">cond</span> locked-mutex<span class="hl sym">)</span>
  #<span class="hl sym">+</span>sbcl <span class="hl sym">(</span>sb-thread<span class="hl sym">:</span>condition-wait <span class="hl kwa">cond</span> locked-mutex<span class="hl sym">)</span>
  #-<span class="hl sym">(</span><span class="hl kwa">or</span> sbcl<span class="hl sym">) (</span>error <span class="hl str">&quot;We need an implementation of condition waits for this platform&quot;</span><span class="hl sym">))</span>

<span class="hl slc">;; I was using condition-broadcast, but that just froze up the system.</span>
<span class="hl slc">;; Possibly a bug in the implementation on sbcl?</span>
<span class="hl sym">(</span><span class="hl kwa">defun</span> awaken-<span class="hl kwa">cond</span>-waiter <span class="hl sym">(</span><span class="hl kwa">cond</span><span class="hl sym">)</span>
  #<span class="hl sym">+</span>sbcl <span class="hl sym">(</span>sb-thread<span class="hl sym">:</span>condition-broadcast <span class="hl kwa">cond</span><span class="hl sym">)</span>
  #-<span class="hl sym">(</span><span class="hl kwa">or</span> sbcl<span class="hl sym">) (</span>error <span class="hl str">&quot;We need an implementation of condition awaken for this platform&quot;</span><span class="hl sym">))</span>

<span class="hl sym">(</span><span class="hl kwa">defun</span> spawn-thread <span class="hl sym">(</span>fcn<span class="hl sym">)</span>
  #<span class="hl sym">+</span>sbcl <span class="hl sym">(</span>sb-thread<span class="hl sym">:</span>make-thread fcn<span class="hl sym">)</span>
  #-<span class="hl sym">(</span><span class="hl kwa">or</span> sbcl<span class="hl sym">) (</span>error <span class="hl str">&quot;We need an implementation of thread starting for this platform&quot;</span><span class="hl sym">))</span>



<span class="hl sym">(</span>defclass worker <span class="hl sym">()</span>
  <span class="hl sym">((</span>mutex	<span class="hl sym">:</span>initform	<span class="hl sym">(</span>create-mutex<span class="hl sym">)</span>
                <span class="hl sym">:</span>reader		get-mutex<span class="hl sym">)</span>
   <span class="hl sym">(</span><span class="hl kwa">cond</span>	<span class="hl sym">:</span>initform	<span class="hl sym">(</span>create-<span class="hl kwa">cond</span><span class="hl sym">)</span>
                <span class="hl sym">:</span>reader		get-<span class="hl kwa">cond</span><span class="hl sym">)</span>
   <span class="hl sym">(</span>message	<span class="hl sym">:</span>initform	nil
                <span class="hl sym">:</span>accessor	get-message<span class="hl sym">)</span>
   <span class="hl sym">(</span>client	<span class="hl sym">:</span>initform	nil
                <span class="hl sym">:</span>accessor	get-client<span class="hl sym">)))</span>


<span class="hl sym">(</span>defgeneric work-fcn <span class="hl sym">(</span>obj<span class="hl sym">))</span>
<span class="hl sym">(</span>defgeneric main-reaper <span class="hl sym">(</span>obj<span class="hl sym">))</span>


<span class="hl sym">(</span><span class="hl kwa">defun</span> wait-for-msg <span class="hl sym">(</span><span class="hl kwa">cond</span> mutex get-msg-form<span class="hl sym">)</span>
  <span class="hl sym">(</span>let <span class="hl sym">((</span>msg nil<span class="hl sym">))</span>
    <span class="hl sym">(</span>do <span class="hl sym">()</span>
        <span class="hl sym">(</span>msg msg<span class="hl sym">)</span>
      <span class="hl sym">(</span><span class="hl kwa">or</span> <span class="hl sym">(</span>setf msg <span class="hl sym">(</span>funcall get-msg-form<span class="hl sym">))</span>
          <span class="hl sym">(</span>wait-on-<span class="hl kwa">cond cond</span> mutex<span class="hl sym">)))))</span>


<span class="hl sym">(</span>defmethod work-fcn <span class="hl sym">((</span>obj worker<span class="hl sym">))</span>
  <span class="hl sym">(</span>when <span class="hl sym">+</span>serialize-threads<span class="hl sym">+</span>
    <span class="hl sym">(</span>lock-mutex <span class="hl sym">*</span>serialize-threads-mutex<span class="hl sym">*)</span>
    <span class="hl sym">(</span>setf <span class="hl sym">*</span>serialize-threads-flag<span class="hl sym">*</span> t<span class="hl sym">)</span>
    <span class="hl sym">(</span>awaken-<span class="hl kwa">cond</span>-waiter <span class="hl sym">*</span>serialize-threads-<span class="hl kwa">cond</span><span class="hl sym">*)</span>
    <span class="hl sym">(</span>release-mutex <span class="hl sym">*</span>serialize-threads-mutex<span class="hl sym">*))</span>

  <span class="hl sym">(</span>forever
   <span class="hl sym">(</span>lock-mutex <span class="hl sym">(</span>get-mutex obj<span class="hl sym">))</span>
   <span class="hl sym">(</span>let <span class="hl sym">((</span>msg <span class="hl sym">(</span>wait-for-msg <span class="hl sym">(</span>get-<span class="hl kwa">cond</span> obj<span class="hl sym">) (</span>get-mutex obj<span class="hl sym">)</span> #<span class="hl sym">'(</span><span class="hl kwa">lambda</span> <span class="hl sym">() (</span>get-message obj<span class="hl sym">)))))</span>

     <span class="hl sym">(</span>setf <span class="hl sym">(</span>get-message obj<span class="hl sym">)</span> nil<span class="hl sym">)</span>
     <span class="hl sym">(</span>release-mutex <span class="hl sym">(</span>get-mutex obj<span class="hl sym">))</span>

     <span class="hl sym">(</span>lock-mutex <span class="hl sym">(</span>get-mutex <span class="hl sym">(</span>get-client obj<span class="hl sym">)))</span>
     <span class="hl sym">(</span>setf <span class="hl sym">(</span>get-message <span class="hl sym">(</span>get-client obj<span class="hl sym">)) (</span><span class="hl num">1</span><span class="hl sym">+</span> msg<span class="hl sym">))</span>
     <span class="hl sym">(</span>awaken-<span class="hl kwa">cond</span>-waiter <span class="hl sym">(</span>get-<span class="hl kwa">cond</span> <span class="hl sym">(</span>get-client obj<span class="hl sym">)))</span>
     <span class="hl sym">(</span>release-mutex <span class="hl sym">(</span>get-mutex <span class="hl sym">(</span>get-client obj<span class="hl sym">))))))</span>


<span class="hl sym">(</span>defmethod main-reaper <span class="hl sym">((</span>mainthread worker<span class="hl sym">))</span>
  <span class="hl sym">(</span>lock-mutex <span class="hl sym">(</span>get-mutex mainthread<span class="hl sym">))</span>
  <span class="hl sym">(</span>prog1
      <span class="hl sym">(</span>wait-for-msg <span class="hl sym">(</span>get-<span class="hl kwa">cond</span> mainthread<span class="hl sym">) (</span>get-mutex mainthread<span class="hl sym">)</span> #<span class="hl sym">'(</span><span class="hl kwa">lambda</span> <span class="hl sym">() (</span>get-message mainthread<span class="hl sym">)))</span>
    <span class="hl sym">(</span>release-mutex <span class="hl sym">(</span>get-mutex mainthread<span class="hl sym">))))</span>


<span class="hl sym">(</span><span class="hl kwa">defun</span> main <span class="hl sym">(&amp;</span>optional n-supplied<span class="hl sym">)</span>
  <span class="hl sym">(</span>let <span class="hl sym">((</span>n <span class="hl sym">(</span><span class="hl kwa">or</span> n-supplied
               <span class="hl sym">(</span>parse-integer <span class="hl sym">(</span><span class="hl kwa">or</span> <span class="hl sym">(</span><span class="hl kwa">car</span> <span class="hl sym">(</span><span class="hl kwa">last</span> #<span class="hl sym">+</span>sbcl sb-ext<span class="hl sym">:*</span>posix-argv<span class="hl sym">*</span>
                                             #<span class="hl sym">+</span>clisp ext<span class="hl sym">:*</span>args<span class="hl sym">*</span>
                                             #<span class="hl sym">+</span>gcl  si<span class="hl sym">::*</span><span class="hl kwa">command</span>-args<span class="hl sym">*))</span>
                                  <span class="hl str">&quot;10&quot;</span><span class="hl sym">)))))</span>

    <span class="hl sym">(</span>let<span class="hl sym">* ((</span>mainthread <span class="hl sym">(</span>make-instance <span class="hl sym">'</span>worker<span class="hl sym">))</span>
           <span class="hl sym">(</span><span class="hl kwa">last</span>-obj mainthread<span class="hl sym">)</span>
           worker
           <span class="hl sym">(</span>accumulator <span class="hl num">0</span><span class="hl sym">))</span>

      <span class="hl sym">(</span>dotimes <span class="hl sym">(</span>i <span class="hl sym">*</span>n-threads<span class="hl sym">*)</span>
        <span class="hl sym">(</span>setf worker <span class="hl sym">(</span>make-instance <span class="hl sym">'</span>worker<span class="hl sym">))</span>
        <span class="hl sym">(</span>setf <span class="hl sym">(</span>get-client worker<span class="hl sym">)</span> <span class="hl kwa">last</span>-obj<span class="hl sym">)</span>
        <span class="hl sym">(</span>setf <span class="hl kwa">last</span>-obj worker<span class="hl sym">)</span>

        <span class="hl sym">(</span>when <span class="hl sym">+</span>serialize-threads<span class="hl sym">+</span>
          <span class="hl sym">(</span>setf <span class="hl sym">*</span>serialize-threads-flag<span class="hl sym">*</span> nil<span class="hl sym">))</span>

        <span class="hl sym">(</span>spawn-thread #<span class="hl sym">'(</span><span class="hl kwa">lambda</span> <span class="hl sym">() (</span>work-fcn worker<span class="hl sym">)))</span>

        <span class="hl sym">(</span>when <span class="hl sym">+</span>serialize-threads<span class="hl sym">+</span>
          <span class="hl sym">(</span>lock-mutex <span class="hl sym">*</span>serialize-threads-mutex<span class="hl sym">*)</span>
          <span class="hl sym">(</span>do <span class="hl sym">()</span>
              <span class="hl sym">(*</span>serialize-threads-flag<span class="hl sym">*)</span>
            <span class="hl sym">(</span><span class="hl kwa">or</span> <span class="hl sym">*</span>serialize-threads-flag<span class="hl sym">*</span>
                <span class="hl sym">(</span>wait-on-<span class="hl kwa">cond</span> <span class="hl sym">*</span>serialize-threads-<span class="hl kwa">cond</span><span class="hl sym">* *</span>serialize-threads-mutex<span class="hl sym">*)))</span>
          <span class="hl sym">(</span>release-mutex <span class="hl sym">*</span>serialize-threads-mutex<span class="hl sym">*)))</span>

      <span class="hl sym">(</span>dotimes <span class="hl sym">(</span>i n<span class="hl sym">)</span>

        <span class="hl sym">(</span>lock-mutex <span class="hl sym">(</span>get-mutex worker<span class="hl sym">))</span>
        <span class="hl sym">(</span>setf <span class="hl sym">(</span>get-message worker<span class="hl sym">)</span> <span class="hl num">0</span><span class="hl sym">)</span>
        <span class="hl sym">(</span>awaken-<span class="hl kwa">cond</span>-waiter <span class="hl sym">(</span>get-<span class="hl kwa">cond</span> worker<span class="hl sym">))</span>
        <span class="hl sym">(</span>release-mutex <span class="hl sym">(</span>get-mutex worker<span class="hl sym">))</span>

        <span class="hl sym">(</span>incf accumulator <span class="hl sym">(</span>main-reaper mainthread<span class="hl sym">)))</span>

      <span class="hl sym">(</span>format t <span class="hl str">&quot;~D~%&quot;</span> accumulator<span class="hl sym">))))</span>



<span class="hl slc">;;;  Note: this cleanup function is not much use in my sbcl</span>
<span class="hl slc">;;;  (post-0.9.3 CVS checkout), as there seems to be a hard limit of</span>
<span class="hl slc">;;;  512 threads spawned in the lifetime of the sbcl job, after which</span>
<span class="hl slc">;;;  time we fail out with an mmap error whenever trying to make a new</span>
<span class="hl slc">;;;  thread.</span>
<span class="hl slc">;; #+sbcl (defun cleanup ()</span>
<span class="hl slc">;;          (dolist (thread (rest (nreverse (sb-thread:list-all-threads))))</span>
<span class="hl slc">;;            (sb-thread:terminate-thread thread)))</span>


<span class="hl sym">(</span><span class="hl kwa">if</span> <span class="hl sym">+</span>serialize-threads<span class="hl sym">+</span>
    <span class="hl sym">(</span>setf <span class="hl sym">*</span>serialize-threads-mutex<span class="hl sym">* (</span>create-mutex<span class="hl sym">) *</span>serialize-threads-<span class="hl kwa">cond</span><span class="hl sym">* (</span>create-<span class="hl kwa">cond</span><span class="hl sym">)))</span>
