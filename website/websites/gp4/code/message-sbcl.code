<span class="slc">;;   The Great Computer Language Shootout</span>
<span class="slc">;;   http://shootout.alioth.debian.org/</span>
<span class="slc">;;</span>
<span class="slc">;;   Threads-flow.</span>
<span class="slc">;;</span>
<span class="slc">;;   Contributed by Christopher Neufeld</span>
<span class="slc">;;</span>


<span class="slc">;; set this to 't' to print copious debugging.</span>
<span class="slc">;; (defconstant +debug-print+ nil)</span>
<span class="slc">;; (defparameter print-mutex nil)</span>

<span class="slc">;; (defmacro debug-output (format-string &amp;rest args)</span>
<span class="slc">;;   (if +debug-print+</span>
<span class="slc">;;       `(progn</span>
<span class="slc">;;         (lock-mutex print-mutex)</span>
<span class="slc">;;         (format t ,format-string ,&#64;args)</span>
<span class="slc">;;         (release-mutex print-mutex))))</span>




<span class="slc">;; If we serialize the creation of threads, things go much more</span>
<span class="slc">;; quickly, at least for my combination of sbcl and kernel</span>
<span class="slc">;; version/configuration.</span>
<span class="sym">(</span>defconstant <span class="sym">+</span>serialize<span class="sym">-</span>threads<span class="sym">+</span> t<span class="sym">)</span>
<span class="sym">(</span>defparameter <span class="sym">*</span>serialize<span class="sym">-</span>threads<span class="sym">-</span>mutex<span class="sym">*</span> nil<span class="sym">)</span>
<span class="sym">(</span>defparameter <span class="sym">*</span>serialize<span class="sym">-</span>threads<span class="sym">-</span><span class="kwa">cond</span><span class="sym">*</span> nil<span class="sym">)</span>
<span class="sym">(</span>defparameter <span class="sym">*</span>serialize<span class="sym">-</span>threads<span class="sym">-</span>flag<span class="sym">*</span> nil<span class="sym">)</span>


<span class="slc">;; Note that sbcl seems to be limited to 512 calls to make-thread.</span>
<span class="sym">(</span>defparameter <span class="sym">*</span>n<span class="sym">-</span>threads<span class="sym">*</span> <span class="num">500</span><span class="sym">)</span>


#<span class="sym">+</span>clisp <span class="sym">(</span>error <span class="str">&quot;Presently, clisp does not support condition objects&quot;</span><span class="sym">)</span>
#<span class="sym">+</span>gcl <span class="sym">(</span>error <span class="str">&quot;Presently, gcl does not support multi-threading&quot;</span><span class="sym">)</span>


<span class="sym">(</span>defmacro forever <span class="sym">(&amp;</span>body body<span class="sym">)</span>
  <span class="sym">`(</span>do <span class="sym">() (</span>nil<span class="sym">) ,</span>&#64;body<span class="sym">))</span>


<span class="sym">(</span><span class="kwa">defun</span> create<span class="sym">-</span><span class="kwa">cond</span> <span class="sym">()</span>
  #<span class="sym">+</span>sbcl <span class="sym">(</span>sb<span class="sym">-</span>thread<span class="sym">:</span>make<span class="sym">-</span>waitqueue<span class="sym">)</span>
  #<span class="sym">-(</span><span class="kwa">or</span> sbcl<span class="sym">) (</span>error <span class="str">&quot;We need an implementation of cond creation for this platform&quot;</span><span class="sym">))</span>

<span class="sym">(</span><span class="kwa">defun</span> create<span class="sym">-</span>mutex <span class="sym">()</span>
  #<span class="sym">+</span>sbcl <span class="sym">(</span>sb<span class="sym">-</span>thread<span class="sym">:</span>make<span class="sym">-</span>mutex <span class="sym">:</span>value nil<span class="sym">)</span>
  #<span class="sym">-(</span><span class="kwa">or</span> sbcl<span class="sym">) (</span>error <span class="str">&quot;We need an implementation of mutex creation for this platform&quot;</span><span class="sym">))</span>


<span class="sym">(</span><span class="kwa">defun</span> lock<span class="sym">-</span>mutex <span class="sym">(</span>mutex<span class="sym">)</span>
  #<span class="sym">+</span>sbcl <span class="sym">(</span>sb<span class="sym">-</span>thread<span class="sym">:</span>get<span class="sym">-</span>mutex mutex<span class="sym">)</span>
  #<span class="sym">-(</span><span class="kwa">or</span> sbcl<span class="sym">) (</span>error <span class="str">&quot;We need an implementation of mutex-locking for this platform&quot;</span><span class="sym">))</span>

<span class="sym">(</span><span class="kwa">defun</span> release<span class="sym">-</span>mutex <span class="sym">(</span>mutex<span class="sym">)</span>
  #<span class="sym">+</span>sbcl <span class="sym">(</span>sb<span class="sym">-</span>thread<span class="sym">:</span>release<span class="sym">-</span>mutex mutex<span class="sym">)</span>
  #<span class="sym">-(</span><span class="kwa">or</span> sbcl<span class="sym">) (</span>error <span class="str">&quot;We need an implementation of mutex-unlocking for this platform&quot;</span><span class="sym">))</span>

<span class="sym">(</span><span class="kwa">defun</span> wait<span class="sym">-</span>on<span class="sym">-</span><span class="kwa">cond</span> <span class="sym">(</span><span class="kwa">cond</span> locked<span class="sym">-</span>mutex<span class="sym">)</span>
  #<span class="sym">+</span>sbcl <span class="sym">(</span>sb<span class="sym">-</span>thread<span class="sym">:</span>condition<span class="sym">-</span>wait <span class="kwa">cond</span> locked<span class="sym">-</span>mutex<span class="sym">)</span>
  #<span class="sym">-(</span><span class="kwa">or</span> sbcl<span class="sym">) (</span>error <span class="str">&quot;We need an implementation of condition waits for this platform&quot;</span><span class="sym">))</span>

<span class="slc">;; I was using condition-broadcast, but that just froze up the system.</span>
<span class="slc">;; Possibly a bug in the implementation on sbcl?</span>
<span class="sym">(</span><span class="kwa">defun</span> awaken<span class="sym">-</span><span class="kwa">cond</span><span class="sym">-</span>waiter <span class="sym">(</span><span class="kwa">cond</span><span class="sym">)</span>
  #<span class="sym">+</span>sbcl <span class="sym">(</span>sb<span class="sym">-</span>thread<span class="sym">:</span>condition<span class="sym">-</span>broadcast <span class="kwa">cond</span><span class="sym">)</span>
  #<span class="sym">-(</span><span class="kwa">or</span> sbcl<span class="sym">) (</span>error <span class="str">&quot;We need an implementation of condition awaken for this platform&quot;</span><span class="sym">))</span>

<span class="sym">(</span><span class="kwa">defun</span> spawn<span class="sym">-</span>thread <span class="sym">(</span>fcn<span class="sym">)</span>
  #<span class="sym">+</span>sbcl <span class="sym">(</span>sb<span class="sym">-</span>thread<span class="sym">:</span>make<span class="sym">-</span>thread fcn<span class="sym">)</span>
  #<span class="sym">-(</span><span class="kwa">or</span> sbcl<span class="sym">) (</span>error <span class="str">&quot;We need an implementation of thread starting for this platform&quot;</span><span class="sym">))</span>



<span class="sym">(</span>defclass worker <span class="sym">()</span>
  <span class="sym">((</span>mutex	<span class="sym">:</span>initform	<span class="sym">(</span>create<span class="sym">-</span>mutex<span class="sym">)</span>
                <span class="sym">:</span>reader		get<span class="sym">-</span>mutex<span class="sym">)</span>
   <span class="sym">(</span><span class="kwa">cond</span>	<span class="sym">:</span>initform	<span class="sym">(</span>create<span class="sym">-</span><span class="kwa">cond</span><span class="sym">)</span>
                <span class="sym">:</span>reader		get<span class="sym">-</span><span class="kwa">cond</span><span class="sym">)</span>
   <span class="sym">(</span>message	<span class="sym">:</span>initform	nil
                <span class="sym">:</span>accessor	get<span class="sym">-</span>message<span class="sym">)</span>
   <span class="sym">(</span>client	<span class="sym">:</span>initform	nil
                <span class="sym">:</span>accessor	get<span class="sym">-</span>client<span class="sym">)))</span>


<span class="sym">(</span>defgeneric work<span class="sym">-</span>fcn <span class="sym">(</span>obj<span class="sym">))</span>
<span class="sym">(</span>defgeneric main<span class="sym">-</span>reaper <span class="sym">(</span>obj<span class="sym">))</span>


<span class="sym">(</span><span class="kwa">defun</span> wait<span class="sym">-</span>for<span class="sym">-</span>msg <span class="sym">(</span><span class="kwa">cond</span> mutex get<span class="sym">-</span>msg<span class="sym">-</span>form<span class="sym">)</span>
  <span class="sym">(</span>let <span class="sym">((</span>msg nil<span class="sym">))</span>
    <span class="sym">(</span>do <span class="sym">()</span>
        <span class="sym">(</span>msg msg<span class="sym">)</span>
      <span class="sym">(</span><span class="kwa">or</span> <span class="sym">(</span>setf msg <span class="sym">(</span>funcall get<span class="sym">-</span>msg<span class="sym">-</span>form<span class="sym">))</span>
          <span class="sym">(</span>wait<span class="sym">-</span>on<span class="sym">-</span><span class="kwa">cond cond</span> mutex<span class="sym">)))))</span>


<span class="sym">(</span>defmethod work<span class="sym">-</span>fcn <span class="sym">((</span>obj worker<span class="sym">))</span>
  <span class="sym">(</span>when <span class="sym">+</span>serialize<span class="sym">-</span>threads<span class="sym">+</span>
    <span class="sym">(</span>lock<span class="sym">-</span>mutex <span class="sym">*</span>serialize<span class="sym">-</span>threads<span class="sym">-</span>mutex<span class="sym">*)</span>
    <span class="sym">(</span>setf <span class="sym">*</span>serialize<span class="sym">-</span>threads<span class="sym">-</span>flag<span class="sym">*</span> t<span class="sym">)</span>
    <span class="sym">(</span>awaken<span class="sym">-</span><span class="kwa">cond</span><span class="sym">-</span>waiter <span class="sym">*</span>serialize<span class="sym">-</span>threads<span class="sym">-</span><span class="kwa">cond</span><span class="sym">*)</span>
    <span class="sym">(</span>release<span class="sym">-</span>mutex <span class="sym">*</span>serialize<span class="sym">-</span>threads<span class="sym">-</span>mutex<span class="sym">*))</span>

  <span class="sym">(</span>forever
   <span class="sym">(</span>lock<span class="sym">-</span>mutex <span class="sym">(</span>get<span class="sym">-</span>mutex obj<span class="sym">))</span>
   <span class="sym">(</span>let <span class="sym">((</span>msg <span class="sym">(</span>wait<span class="sym">-</span>for<span class="sym">-</span>msg <span class="sym">(</span>get<span class="sym">-</span><span class="kwa">cond</span> obj<span class="sym">) (</span>get<span class="sym">-</span>mutex obj<span class="sym">)</span> #<span class="sym">'(</span><span class="kwa">lambda</span> <span class="sym">() (</span>get<span class="sym">-</span>message obj<span class="sym">)))))</span>

     <span class="sym">(</span>setf <span class="sym">(</span>get<span class="sym">-</span>message obj<span class="sym">)</span> nil<span class="sym">)</span>
     <span class="sym">(</span>release<span class="sym">-</span>mutex <span class="sym">(</span>get<span class="sym">-</span>mutex obj<span class="sym">))</span>

     <span class="sym">(</span>lock<span class="sym">-</span>mutex <span class="sym">(</span>get<span class="sym">-</span>mutex <span class="sym">(</span>get<span class="sym">-</span>client obj<span class="sym">)))</span>
     <span class="sym">(</span>setf <span class="sym">(</span>get<span class="sym">-</span>message <span class="sym">(</span>get<span class="sym">-</span>client obj<span class="sym">)) (</span><span class="num">1</span><span class="sym">+</span> msg<span class="sym">))</span>
     <span class="sym">(</span>awaken<span class="sym">-</span><span class="kwa">cond</span><span class="sym">-</span>waiter <span class="sym">(</span>get<span class="sym">-</span><span class="kwa">cond</span> <span class="sym">(</span>get<span class="sym">-</span>client obj<span class="sym">)))</span>
     <span class="sym">(</span>release<span class="sym">-</span>mutex <span class="sym">(</span>get<span class="sym">-</span>mutex <span class="sym">(</span>get<span class="sym">-</span>client obj<span class="sym">))))))</span>


<span class="sym">(</span>defmethod main<span class="sym">-</span>reaper <span class="sym">((</span>mainthread worker<span class="sym">))</span>
  <span class="sym">(</span>lock<span class="sym">-</span>mutex <span class="sym">(</span>get<span class="sym">-</span>mutex mainthread<span class="sym">))</span>
  <span class="sym">(</span>prog1
      <span class="sym">(</span>wait<span class="sym">-</span>for<span class="sym">-</span>msg <span class="sym">(</span>get<span class="sym">-</span><span class="kwa">cond</span> mainthread<span class="sym">) (</span>get<span class="sym">-</span>mutex mainthread<span class="sym">)</span> #<span class="sym">'(</span><span class="kwa">lambda</span> <span class="sym">() (</span>get<span class="sym">-</span>message mainthread<span class="sym">)))</span>
    <span class="sym">(</span>release<span class="sym">-</span>mutex <span class="sym">(</span>get<span class="sym">-</span>mutex mainthread<span class="sym">))))</span>


<span class="sym">(</span><span class="kwa">defun</span> main <span class="sym">(&amp;</span>optional n<span class="sym">-</span>supplied<span class="sym">)</span>
  <span class="sym">(</span>let <span class="sym">((</span>n <span class="sym">(</span><span class="kwa">or</span> n<span class="sym">-</span>supplied
               <span class="sym">(</span>parse<span class="sym">-</span>integer <span class="sym">(</span><span class="kwa">or</span> <span class="sym">(</span><span class="kwa">car</span> <span class="sym">(</span><span class="kwa">last</span> #<span class="sym">+</span>sbcl sb<span class="sym">-</span>ext<span class="sym">:*</span>posix<span class="sym">-</span>argv<span class="sym">*</span>
                                             #<span class="sym">+</span>clisp ext<span class="sym">:*</span>args<span class="sym">*</span>
                                             #<span class="sym">+</span>gcl  si<span class="sym">::*</span><span class="kwa">command</span><span class="sym">-</span>args<span class="sym">*))</span>
                                  <span class="str">&quot;10&quot;</span><span class="sym">)))))</span>

    <span class="sym">(</span>let<span class="sym">* ((</span>mainthread <span class="sym">(</span>make<span class="sym">-</span>instance <span class="sym">'</span>worker<span class="sym">))</span>
           <span class="sym">(</span><span class="kwa">last</span><span class="sym">-</span>obj mainthread<span class="sym">)</span>
           worker
           <span class="sym">(</span>accumulator <span class="num">0</span><span class="sym">))</span>

      <span class="sym">(</span>dotimes <span class="sym">(</span>i <span class="sym">*</span>n<span class="sym">-</span>threads<span class="sym">*)</span>
        <span class="sym">(</span>setf worker <span class="sym">(</span>make<span class="sym">-</span>instance <span class="sym">'</span>worker<span class="sym">))</span>
        <span class="sym">(</span>setf <span class="sym">(</span>get<span class="sym">-</span>client worker<span class="sym">)</span> <span class="kwa">last</span><span class="sym">-</span>obj<span class="sym">)</span>
        <span class="sym">(</span>setf <span class="kwa">last</span><span class="sym">-</span>obj worker<span class="sym">)</span>

        <span class="sym">(</span>when <span class="sym">+</span>serialize<span class="sym">-</span>threads<span class="sym">+</span>
          <span class="sym">(</span>setf <span class="sym">*</span>serialize<span class="sym">-</span>threads<span class="sym">-</span>flag<span class="sym">*</span> nil<span class="sym">))</span>

        <span class="sym">(</span>spawn<span class="sym">-</span>thread #<span class="sym">'(</span><span class="kwa">lambda</span> <span class="sym">() (</span>work<span class="sym">-</span>fcn worker<span class="sym">)))</span>

        <span class="sym">(</span>when <span class="sym">+</span>serialize<span class="sym">-</span>threads<span class="sym">+</span>
          <span class="sym">(</span>lock<span class="sym">-</span>mutex <span class="sym">*</span>serialize<span class="sym">-</span>threads<span class="sym">-</span>mutex<span class="sym">*)</span>
          <span class="sym">(</span>do <span class="sym">()</span>
              <span class="sym">(*</span>serialize<span class="sym">-</span>threads<span class="sym">-</span>flag<span class="sym">*)</span>
            <span class="sym">(</span><span class="kwa">or</span> <span class="sym">*</span>serialize<span class="sym">-</span>threads<span class="sym">-</span>flag<span class="sym">*</span>
                <span class="sym">(</span>wait<span class="sym">-</span>on<span class="sym">-</span><span class="kwa">cond</span> <span class="sym">*</span>serialize<span class="sym">-</span>threads<span class="sym">-</span><span class="kwa">cond</span><span class="sym">* *</span>serialize<span class="sym">-</span>threads<span class="sym">-</span>mutex<span class="sym">*)))</span>
          <span class="sym">(</span>release<span class="sym">-</span>mutex <span class="sym">*</span>serialize<span class="sym">-</span>threads<span class="sym">-</span>mutex<span class="sym">*)))</span>

      <span class="sym">(</span>dotimes <span class="sym">(</span>i n<span class="sym">)</span>

        <span class="sym">(</span>lock<span class="sym">-</span>mutex <span class="sym">(</span>get<span class="sym">-</span>mutex worker<span class="sym">))</span>
        <span class="sym">(</span>setf <span class="sym">(</span>get<span class="sym">-</span>message worker<span class="sym">)</span> <span class="num">0</span><span class="sym">)</span>
        <span class="sym">(</span>awaken<span class="sym">-</span><span class="kwa">cond</span><span class="sym">-</span>waiter <span class="sym">(</span>get<span class="sym">-</span><span class="kwa">cond</span> worker<span class="sym">))</span>
        <span class="sym">(</span>release<span class="sym">-</span>mutex <span class="sym">(</span>get<span class="sym">-</span>mutex worker<span class="sym">))</span>

        <span class="sym">(</span>incf accumulator <span class="sym">(</span>main<span class="sym">-</span>reaper mainthread<span class="sym">)))</span>

      <span class="sym">(</span>format t <span class="str">&quot;~D~%&quot;</span> accumulator<span class="sym">))))</span>



<span class="slc">;;;  Note: this cleanup function is not much use in my sbcl</span>
<span class="slc">;;;  (post-0.9.3 CVS checkout), as there seems to be a hard limit of</span>
<span class="slc">;;;  512 threads spawned in the lifetime of the sbcl job, after which</span>
<span class="slc">;;;  time we fail out with an mmap error whenever trying to make a new</span>
<span class="slc">;;;  thread.</span>
<span class="slc">;; #+sbcl (defun cleanup ()</span>
<span class="slc">;;          (dolist (thread (rest (nreverse (sb-thread:list-all-threads))))</span>
<span class="slc">;;            (sb-thread:terminate-thread thread)))</span>


<span class="sym">(</span><span class="kwa">if</span> <span class="sym">+</span>serialize<span class="sym">-</span>threads<span class="sym">+</span>
    <span class="sym">(</span>setf <span class="sym">*</span>serialize<span class="sym">-</span>threads<span class="sym">-</span>mutex<span class="sym">* (</span>create<span class="sym">-</span>mutex<span class="sym">) *</span>serialize<span class="sym">-</span>threads<span class="sym">-</span><span class="kwa">cond</span><span class="sym">* (</span>create<span class="sym">-</span><span class="kwa">cond</span><span class="sym">)))</span>
