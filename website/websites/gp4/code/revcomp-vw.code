<span class="com">&quot;  The Computer Language Shootout</span>
<span class="com">   http://shootout.alioth.debian.org/</span>
<span class="com">   contributed by Isaac Gouy&quot;!</span>
<span class="com"></span>
<span class="com">!Shootout.Tests class methodsFor: 'benchmarking'!</span>
<span class="com"></span>
<span class="com">revcomp</span>
<span class="com">   | stdin stdout fasta |</span>
<span class="com">   stdin := ExternalReadStream on:</span>
<span class="com">      (ExternalConnection ioAccessor: (UnixDiskFileAccessor new handle: 0)).</span>
<span class="com">   stdout := ExternalWriteStream on:</span>
<span class="com">      (ExternalConnection ioAccessor: (UnixDiskFileAccessor new handle: 1)).</span>
<span class="com"></span>
<span class="com">   fasta := stdin readFasta: 'ONE'.</span>
<span class="com">   stdout writeReverseComplementFasta: fasta key sequence: fasta value.</span>
<span class="com"></span>
<span class="com">   fasta := stdin readFasta: 'TWO'.</span>
<span class="com">   stdout writeReverseComplementFasta: fasta key sequence: fasta value.</span>
<span class="com"></span>
<span class="com">   fasta := stdin readFasta: 'THREE'.</span>
<span class="com">   stdout writeReverseComplementFasta: fasta key sequence: fasta value.</span>
<span class="com"></span>
<span class="com">   stdout flush.</span>
<span class="com">   ^'' ! !</span>
<span class="com"></span>
<span class="com"></span>
<span class="com">!ExternalReadStream methodsFor: 'accessing'!</span>
<span class="com"></span>
<span class="com">readFasta: anId</span>
<span class="com">   | idString newline buffer description line char |</span>
<span class="com">   idString := '&gt;',anId.</span>
<span class="com">   newline := Character cr.</span>
<span class="com"></span>
<span class="com">   &quot;find start of particular fasta sequence&quot;</span>
<span class="com">   [(self atEnd) or: [</span>
<span class="com">         (self peek = $&gt;)</span>
<span class="com">            ifTrue: [((line := self upTo: newline)</span>
<span class="com">               indexOfSubCollection: idString startingAt: 1) = 1]</span>
<span class="com">            ifFalse: [self skipThrough: newline. false]]</span>
<span class="com">      ] whileFalse.</span>
<span class="com"></span>
<span class="com">   &quot;line-by-line read - it would be a lot faster to block read&quot;</span>
<span class="com">   description := line.</span>
<span class="com">   buffer := ReadWriteStream on: (String new: 1028).</span>
<span class="com">   [(self atEnd) or: [(char := self peek) = $&gt;]] whileFalse: [</span>
<span class="com">      (char = $;)</span>
<span class="com">         ifTrue: [self upTo: newline]</span>
<span class="com">         ifFalse: [buffer nextPutAll: (self upTo: newline)]</span>
<span class="com">      ].</span>
<span class="com">   ^Association key: description value: buffer contents ! !</span>
<span class="com"></span>
<span class="com"></span>
<span class="com">!ExternalwriteStream methodsFor: 'accessing'!</span>
<span class="com"></span>
<span class="com">writeReverseComplementFasta: aString sequence: aSequence</span>
<span class="com">   | lineLength n iub |</span>
<span class="com">   (aString isNil) ifTrue: [^self].</span>
<span class="com"></span>
<span class="com">   lineLength := 60. n := aSequence size.</span>
<span class="com"></span>
<span class="com">   iub := String new: 128 withAll: $*.</span>
<span class="com">   iub at: $a asInteger put: $T. iub at: $A asInteger put: $T.</span>
<span class="com">   iub at: $b asInteger put: $V. iub at: $B asInteger put: $V.</span>
<span class="com">   iub at: $c asInteger put: $G. iub at: $C asInteger put: $G.</span>
<span class="com">   iub at: $d asInteger put: $H. iub at: $D asInteger put: $H.</span>
<span class="com">   iub at: $g asInteger put: $C. iub at: $G asInteger put: $C.</span>
<span class="com">   iub at: $h asInteger put: $D. iub at: $H asInteger put: $D.</span>
<span class="com">   iub at: $k asInteger put: $M. iub at: $K asInteger put: $M.</span>
<span class="com">   iub at: $m asInteger put: $K. iub at: $M asInteger put: $K.</span>
<span class="com">   iub at: $n asInteger put: $N. iub at: $N asInteger put: $N.</span>
<span class="com">   iub at: $r asInteger put: $Y. iub at: $R asInteger put: $Y.</span>
<span class="com">   iub at: $s asInteger put: $S. iub at: $S asInteger put: $S.</span>
<span class="com">   iub at: $t asInteger put: $A. iub at: $T asInteger put: $A.</span>
<span class="com">   iub at: $v asInteger put: $B. iub at: $V asInteger put: $B.</span>
<span class="com">   iub at: $w asInteger put: $W. iub at: $W asInteger put: $W.</span>
<span class="com">   iub at: $y asInteger put: $R. iub at: $Y asInteger put: $R.</span>
<span class="com"></span>
<span class="com">   self nextPutAll: aString; cr.</span>
<span class="com"></span>
<span class="com">   [n &gt; 0] whileTrue: [</span>
<span class="com">         1 to: ((n &lt; lineLength) ifTrue: [n] ifFalse: [lineLength]) do:</span>
<span class="com">            [:i | self nextPut: (iub at: (aSequence at: n - i + 1) asInteger)].</span>
<span class="com">         self cr.</span>
<span class="com">         n := n - lineLength.</span>
<span class="com">      ] ! !</span>
