<span class="hl com">{ The Computer Language Benchmarks Game</span>
<span class="hl com">  http://shootout.alioth.debian.org</span>
<span class="hl com"></span>
<span class="hl com">  contributed by Steve Fisher</span>
<span class="hl com"></span>
<span class="hl com">  compile with</span>
<span class="hl com">  fpc -O3 regex-dna.pp</span>
<span class="hl com">}</span>

<span class="hl kwa">uses</span> regexpr<span class="hl sym">,</span> strutils<span class="hl sym">;</span>

<span class="hl kwa">function</span> <span class="hl kwd">replace_matches</span><span class="hl sym">(</span> <span class="hl kwa">const</span> target<span class="hl sym">:</span> pchar<span class="hl sym">;</span>  <span class="hl kwa">const</span> repl<span class="hl sym">:</span> pchar<span class="hl sym">;</span>
                <span class="hl kwa">const</span> str<span class="hl sym">:</span> ansistring<span class="hl sym">;</span>  <span class="hl kwa">var</span> dest<span class="hl sym">:</span> ansistring <span class="hl sym">):</span> <span class="hl kwb">longint</span><span class="hl sym">;</span>
<span class="hl kwa">var</span>
  engine <span class="hl sym">:</span> tRegexprEngine<span class="hl sym">;</span>
  substr <span class="hl sym">:</span> ansistring<span class="hl sym">;</span>
  count<span class="hl sym">,</span> index<span class="hl sym">,</span> size <span class="hl sym">:</span> <span class="hl kwb">longint</span><span class="hl sym">;</span>
<span class="hl kwa">begin</span>
  <span class="hl kwa">if not</span> <span class="hl kwd">GenerateRegExprEngine</span><span class="hl sym">(</span> target<span class="hl sym">, [],</span> engine<span class="hl sym">)</span> <span class="hl kwa">then</span>
  <span class="hl kwa">begin</span>
    <span class="hl kwd">writeln</span><span class="hl sym">(</span> <span class="hl str">'Failed to generate regex. engine for &quot;'</span><span class="hl sym">,</span>target<span class="hl sym">,</span><span class="hl str">'&quot;.'</span> <span class="hl sym">);</span>
    <span class="hl kwd">halt</span><span class="hl sym">(</span><span class="hl num">1</span><span class="hl sym">)</span>
  <span class="hl kwa">end</span><span class="hl sym">;</span>
  count <span class="hl sym">:=</span> <span class="hl num">0</span><span class="hl sym">;</span>
  dest <span class="hl sym">:=</span> <span class="hl str">''</span><span class="hl sym">;</span>
  substr <span class="hl sym">:=</span> str<span class="hl sym">;</span>
  <span class="hl kwa">while</span> <span class="hl kwd">length</span><span class="hl sym">(</span>substr<span class="hl sym">) &gt;</span> <span class="hl num">0</span> <span class="hl kwa">do</span>
  <span class="hl kwa">begin</span>
    <span class="hl kwa">if</span> <span class="hl kwd">RegExprPos</span><span class="hl sym">(</span>engine<span class="hl sym">,</span> <span class="hl kwd">pchar</span><span class="hl sym">(</span>substr<span class="hl sym">),</span> index<span class="hl sym">,</span> size <span class="hl sym">)</span> <span class="hl kwa">then</span>
    <span class="hl kwa">begin</span>
      count <span class="hl sym">+=</span> <span class="hl num">1</span><span class="hl sym">;</span>
      dest <span class="hl sym">+=</span> <span class="hl kwd">ansiLeftStr</span><span class="hl sym">(</span> substr<span class="hl sym">,</span> index<span class="hl sym">) +</span> repl<span class="hl sym">;</span>
      substr <span class="hl sym">:=</span> <span class="hl kwd">ansiRightStr</span><span class="hl sym">(</span>substr<span class="hl sym">,</span><span class="hl kwd">length</span><span class="hl sym">(</span>substr<span class="hl sym">)-</span>index<span class="hl sym">-</span>size<span class="hl sym">);</span>
    <span class="hl kwa">end</span>
    <span class="hl kwa">else</span>
      break
  <span class="hl kwa">end</span><span class="hl sym">;</span>
  <span class="hl kwd">DestroyRegExprEngine</span><span class="hl sym">(</span> engine <span class="hl sym">);</span>
  dest <span class="hl sym">+=</span> substr<span class="hl sym">;</span>
  <span class="hl kwd">exit</span><span class="hl sym">(</span>count<span class="hl sym">)</span>
<span class="hl kwa">end</span><span class="hl sym">;</span>

<span class="hl kwa">function</span> <span class="hl kwd">count_matches</span><span class="hl sym">(</span> target<span class="hl sym">:</span> pchar<span class="hl sym">;</span> <span class="hl kwa">const</span> str<span class="hl sym">:</span> ansistring <span class="hl sym">):</span> <span class="hl kwb">longint</span><span class="hl sym">;</span>
<span class="hl kwa">var</span>
  engine <span class="hl sym">:</span> tRegexprEngine<span class="hl sym">;</span>
  substr <span class="hl sym">:</span> ansistring<span class="hl sym">;</span>
  count<span class="hl sym">,</span> index<span class="hl sym">,</span> size <span class="hl sym">:</span> <span class="hl kwb">longint</span><span class="hl sym">;</span>
<span class="hl kwa">begin</span>
  <span class="hl kwa">if not</span> <span class="hl kwd">GenerateRegExprEngine</span><span class="hl sym">(</span> target<span class="hl sym">, [</span>ref_caseinsensitive<span class="hl sym">],</span> engine<span class="hl sym">)</span> <span class="hl kwa">then</span>
  <span class="hl kwa">begin</span>
    <span class="hl kwd">writeln</span><span class="hl sym">(</span> <span class="hl str">'Failed to generate regex. engine for &quot;'</span><span class="hl sym">,</span>target<span class="hl sym">,</span><span class="hl str">'&quot;.'</span> <span class="hl sym">);</span>
    <span class="hl kwd">halt</span><span class="hl sym">(</span><span class="hl num">1</span><span class="hl sym">)</span>
  <span class="hl kwa">end</span><span class="hl sym">;</span>
  count <span class="hl sym">:=</span> <span class="hl num">0</span><span class="hl sym">;</span>
  substr <span class="hl sym">:=</span> str<span class="hl sym">;</span>
  <span class="hl kwa">while</span> <span class="hl kwd">length</span><span class="hl sym">(</span>substr<span class="hl sym">) &gt;</span> <span class="hl num">0</span> <span class="hl kwa">do</span>
  <span class="hl kwa">begin</span>
    <span class="hl kwa">if</span> <span class="hl kwd">RegExprPos</span><span class="hl sym">(</span>engine<span class="hl sym">,</span> <span class="hl kwd">pchar</span><span class="hl sym">(</span>substr<span class="hl sym">),</span> index<span class="hl sym">,</span> size <span class="hl sym">)</span> <span class="hl kwa">then</span>
    <span class="hl kwa">begin</span>
      count <span class="hl sym">+=</span> <span class="hl num">1</span><span class="hl sym">;</span>
      substr <span class="hl sym">:=</span> <span class="hl kwd">ansiRightStr</span><span class="hl sym">(</span>substr<span class="hl sym">,</span><span class="hl kwd">length</span><span class="hl sym">(</span>substr<span class="hl sym">)-</span>index<span class="hl sym">-</span>size<span class="hl sym">);</span>
    <span class="hl kwa">end</span>
    <span class="hl kwa">else</span>
      break
  <span class="hl kwa">end</span><span class="hl sym">;</span>
  <span class="hl kwd">DestroyRegExprEngine</span><span class="hl sym">(</span> engine <span class="hl sym">);</span>
  <span class="hl kwd">exit</span><span class="hl sym">(</span>count<span class="hl sym">)</span>
<span class="hl kwa">end</span><span class="hl sym">;</span>

<span class="hl kwa">const</span>
  patterns <span class="hl sym">:</span> <span class="hl kwa">array</span><span class="hl sym">[</span><span class="hl num">1</span><span class="hl sym">.</span><span class="hl num">.9</span><span class="hl sym">]</span> <span class="hl kwa">of</span> pchar <span class="hl sym">=</span>
    <span class="hl sym">(</span>
      <span class="hl str">'(agggtaaa)|(tttaccct)'</span><span class="hl sym">,</span>
      <span class="hl str">'([cgt]gggtaaa)|(tttaccc[acg])'</span><span class="hl sym">,</span>
      <span class="hl str">'(a[act]ggtaaa)|(tttacc[agt]t)'</span><span class="hl sym">,</span>
      <span class="hl str">'(ag[act]gtaaa)|(tttac[agt]ct)'</span><span class="hl sym">,</span>
      <span class="hl str">'(agg[act]taaa)|(ttta[agt]cct)'</span><span class="hl sym">,</span>
      <span class="hl str">'(aggg[acg]aaa)|(ttt[cgt]ccct)'</span><span class="hl sym">,</span>
      <span class="hl str">'(agggt[cgt]aa)|(tt[acg]accct)'</span><span class="hl sym">,</span>
      <span class="hl str">'(agggta[cgt]a)|(t[acg]taccct)'</span><span class="hl sym">,</span>
      <span class="hl str">'(agggtaa[cgt])|([acg]ttaccct)'</span>
    <span class="hl sym">);</span>
  replacements <span class="hl sym">:</span> <span class="hl kwa">array</span><span class="hl sym">[</span><span class="hl num">1</span><span class="hl sym">.</span><span class="hl num">.11</span><span class="hl sym">,</span><span class="hl num">1</span><span class="hl sym">.</span><span class="hl num">.2</span><span class="hl sym">]</span> <span class="hl kwa">of</span> pchar <span class="hl sym">=</span>
  <span class="hl sym">(</span>
    <span class="hl sym">(</span><span class="hl str">'B'</span><span class="hl sym">,</span> <span class="hl str">'(c|g|t)'</span><span class="hl sym">), (</span><span class="hl str">'D'</span><span class="hl sym">,</span> <span class="hl str">'(a|g|t)'</span><span class="hl sym">), (</span><span class="hl str">'H'</span><span class="hl sym">,</span> <span class="hl str">'(a|c|t)'</span><span class="hl sym">), (</span><span class="hl str">'K'</span><span class="hl sym">,</span> <span class="hl str">'(g|t)'</span><span class="hl sym">),</span>
    <span class="hl sym">(</span><span class="hl str">'M'</span><span class="hl sym">,</span> <span class="hl str">'(a|c)'</span><span class="hl sym">), (</span><span class="hl str">'N'</span><span class="hl sym">,</span> <span class="hl str">'(a|c|g|t)'</span><span class="hl sym">), (</span><span class="hl str">'R'</span><span class="hl sym">,</span> <span class="hl str">'(a|g)'</span><span class="hl sym">), (</span><span class="hl str">'S'</span><span class="hl sym">,</span> <span class="hl str">'(c|t)'</span><span class="hl sym">),</span>
    <span class="hl sym">(</span><span class="hl str">'V'</span><span class="hl sym">,</span> <span class="hl str">'(a|c|g)'</span><span class="hl sym">), (</span><span class="hl str">'W'</span><span class="hl sym">,</span> <span class="hl str">'(a|t)'</span><span class="hl sym">), (</span><span class="hl str">'Y'</span><span class="hl sym">,</span> <span class="hl str">'(c|t)'</span><span class="hl sym">)</span>
  <span class="hl sym">);</span>


<span class="hl kwa">var</span>
  pattern <span class="hl sym">:</span> pchar<span class="hl sym">;</span>
  sequence<span class="hl sym">,</span> new_seq <span class="hl sym">:</span> ansiString<span class="hl sym">;</span>
  line<span class="hl sym">,</span> tmp<span class="hl sym">:</span> <span class="hl kwa">string</span><span class="hl sym">[</span><span class="hl num">255</span><span class="hl sym">];</span>
  letter<span class="hl sym">,</span> repl <span class="hl sym">:</span> pchar<span class="hl sym">;</span>
  i<span class="hl sym">,</span> count<span class="hl sym">,</span> init_length<span class="hl sym">,</span> clean_length<span class="hl sym">,</span> reps <span class="hl sym">:</span> <span class="hl kwb">longint</span><span class="hl sym">;</span>

<span class="hl kwa">begin</span>
  sequence <span class="hl sym">:=</span> <span class="hl str">''</span><span class="hl sym">;</span>
  init_length <span class="hl sym">:=</span> <span class="hl num">0</span><span class="hl sym">;</span>
  <span class="hl kwa">while not</span> eof <span class="hl kwa">do</span>
  <span class="hl kwa">begin</span>
    <span class="hl kwd">readln</span><span class="hl sym">(</span> line <span class="hl sym">);</span>
    init_length <span class="hl sym">+=</span> <span class="hl kwd">length</span><span class="hl sym">(</span> line <span class="hl sym">) +</span> <span class="hl num">1</span><span class="hl sym">;</span>
    <span class="hl kwa">if</span> line<span class="hl sym">[</span><span class="hl num">1</span><span class="hl sym">] &lt;&gt;</span> <span class="hl str">'&gt;'</span> <span class="hl kwa">then</span>
      sequence <span class="hl sym">:=</span> sequence <span class="hl sym">+</span> line<span class="hl sym">;</span>
  <span class="hl kwa">end</span><span class="hl sym">;</span>
  clean_length <span class="hl sym">:=</span> <span class="hl kwd">length</span><span class="hl sym">(</span>sequence<span class="hl sym">);</span>

  <span class="hl kwa">for</span> i <span class="hl sym">:=</span> <span class="hl kwd">low</span><span class="hl sym">(</span>patterns<span class="hl sym">)</span> <span class="hl kwa">to</span> <span class="hl kwd">high</span><span class="hl sym">(</span>patterns<span class="hl sym">)</span> <span class="hl kwa">do</span>
  <span class="hl kwa">begin</span>
    pattern <span class="hl sym">:=</span> patterns<span class="hl sym">[</span>i<span class="hl sym">];</span>
    count <span class="hl sym">:=</span> <span class="hl kwd">count_matches</span><span class="hl sym">(</span> pattern<span class="hl sym">,</span> sequence <span class="hl sym">);</span>
    tmp <span class="hl sym">:=</span> <span class="hl kwd">delChars</span><span class="hl sym">(</span> <span class="hl kwd">delChars</span><span class="hl sym">(</span>pattern<span class="hl sym">,</span><span class="hl str">'('</span><span class="hl sym">),</span> <span class="hl str">')'</span> <span class="hl sym">);</span>
    <span class="hl kwd">writeln</span><span class="hl sym">(</span> tmp<span class="hl sym">,</span> <span class="hl str">' '</span><span class="hl sym">,</span> count<span class="hl sym">);</span>
  <span class="hl kwa">end</span><span class="hl sym">;</span>


  <span class="hl slc">//  Replace.</span>
  <span class="hl kwa">for</span> i <span class="hl sym">:=</span> <span class="hl kwd">low</span><span class="hl sym">(</span>replacements<span class="hl sym">)</span> <span class="hl kwa">to</span> <span class="hl kwd">high</span><span class="hl sym">(</span>replacements<span class="hl sym">)</span> <span class="hl kwa">do</span>
  <span class="hl kwa">begin</span>
    letter <span class="hl sym">:=</span> replacements<span class="hl sym">[</span>i<span class="hl sym">][</span><span class="hl num">1</span><span class="hl sym">];</span>  repl <span class="hl sym">:=</span> replacements<span class="hl sym">[</span>i<span class="hl sym">][</span><span class="hl num">2</span><span class="hl sym">];</span>
    reps <span class="hl sym">:=</span> <span class="hl kwd">replace_matches</span><span class="hl sym">(</span>letter<span class="hl sym">,</span>repl<span class="hl sym">,</span>sequence<span class="hl sym">,</span>new_seq<span class="hl sym">);</span>
    sequence <span class="hl sym">:=</span> new_seq<span class="hl sym">;</span>
  <span class="hl kwa">end</span><span class="hl sym">;</span>


  writeln<span class="hl sym">;</span>
  <span class="hl kwd">writeln</span><span class="hl sym">(</span> init_length <span class="hl sym">);</span>
  <span class="hl kwd">writeln</span><span class="hl sym">(</span> clean_length <span class="hl sym">);</span>
  <span class="hl kwd">writeln</span><span class="hl sym">(</span> <span class="hl kwd">length</span><span class="hl sym">(</span>sequence<span class="hl sym">) );</span>
<span class="hl kwa">end</span><span class="hl sym">.</span>
