<span class="slc">#!/usr/bin/python</span>
<span class="slc"># $Id: fannkuch-psyco.code,v 1.9 2005-11-05 02:06:03 igouy-guest Exp $</span>
<span class="slc"># http://shootout.alioth.debian.org/</span>
<span class="slc">#</span>
<span class="slc"># Contributed by Antoine Pitrou</span>

<span class="kwc">import</span> sys<span class="sym">,</span> psyco
<span class="kwc">from</span> array <span class="kwc">import</span> array

psyco<span class="sym">.</span><span class="kwd">full</span><span class="sym">()</span>

<span class="slc">#</span>
<span class="slc"># This implementation does the search for solutions in reverse order.</span>
<span class="slc"># Instead of starting from each permutation and calculating the number</span>
<span class="slc"># of transformations needed to reach the end, it starts from trivial</span>
<span class="slc"># permutations (those that have a 1 in the first place) and traverse the</span>
<span class="slc"># tree of all permutations from them, recording the maximum tree depth.</span>
<span class="slc"># This ensures that we only process each permutation once, speeding up</span>
<span class="slc"># the calculation.</span>


<span class="kwb">def</span> <span class="kwd">build_perms</span><span class="sym">(</span>n<span class="sym">,</span> N<span class="sym">):</span>
    <span class="slc"># This helper routine is used to build permutations.</span>
    <span class="slc"># It tries hard to avoid temporary allocations</span>
    <span class="kwb">if</span> n <span class="sym">==</span> <span class="num">1</span><span class="sym">:</span>
        l <span class="sym">=</span> <span class="kwd">array</span><span class="sym">(</span><span class="str">'b'</span><span class="sym">, [</span><span class="num">1</span><span class="sym">]) *</span> N
        <span class="kwb">return</span> <span class="sym">[</span>l<span class="sym">]</span>
    prev <span class="sym">=</span> <span class="kwd">build_perms</span><span class="sym">(</span>n <span class="sym">-</span> <span class="num">1</span><span class="sym">,</span> N<span class="sym">)</span>
    size <span class="sym">=</span> n <span class="sym">*</span> <span class="kwa">len</span><span class="sym">(</span>prev<span class="sym">)</span>
    l <span class="sym">= [</span>None<span class="sym">] *</span> size
    c <span class="sym">=</span> <span class="num">0</span>
    r <span class="sym">=</span> <span class="kwa">xrange</span><span class="sym">(</span>n<span class="sym">-</span><span class="num">1</span><span class="sym">,</span> <span class="num">0</span><span class="sym">, -</span><span class="num">1</span><span class="sym">)</span>
    <span class="slc"># From the permutations of { 1 ... n - 1 }, we build</span>
    <span class="slc"># the permutations of { 1 ... n } by inserting n at</span>
    <span class="slc"># all possible places.</span>
    <span class="kwb">for</span> p <span class="kwb">in</span> prev<span class="sym">:</span>
        p<span class="sym">[</span>n<span class="sym">-</span><span class="num">1</span><span class="sym">] =</span> n
        l<span class="sym">[</span>c<span class="sym">] =</span> p<span class="sym">[:]</span>
        <span class="kwb">for</span> i <span class="kwb">in</span> r<span class="sym">:</span>
            p<span class="sym">[</span>i<span class="sym">],</span> p<span class="sym">[</span>i<span class="sym">-</span><span class="num">1</span><span class="sym">] =</span> p<span class="sym">[</span>i<span class="sym">-</span><span class="num">1</span><span class="sym">],</span> n
            l<span class="sym">[</span>c<span class="sym">+</span>i<span class="sym">] =</span> p<span class="sym">[:]</span>
        c <span class="sym">+=</span> n
    <span class="kwb">return</span> l

<span class="kwb">def</span> <span class="kwd">permutations</span><span class="sym">(</span>n<span class="sym">):</span>
    <span class="slc"># This routine build all permutations of { 1, ... n }</span>
    <span class="kwb">return</span> <span class="kwd">build_perms</span><span class="sym">(</span>n<span class="sym">,</span> n<span class="sym">)</span>


<span class="kwb">def</span> <span class="kwd">search</span><span class="sym">(</span>n<span class="sym">,</span> seeds<span class="sym">,</span> depth<span class="sym">):</span>
    <span class="slc"># This function explores the search tree breadth-first</span>
    r <span class="sym">=</span> <span class="kwa">range</span><span class="sym">(</span><span class="num">1</span><span class="sym">,</span> n<span class="sym">)</span>
    children <span class="sym">= [</span>s<span class="sym">[</span>k<span class="sym">::-</span><span class="num">1</span><span class="sym">] +</span> s<span class="sym">[</span>k<span class="sym">+</span><span class="num">1</span><span class="sym">:]</span> <span class="kwb">for</span> s <span class="kwb">in</span> seeds <span class="kwb">for</span> k <span class="kwb">in</span> r <span class="kwb">if</span> s<span class="sym">[</span>k<span class="sym">] ==</span> k<span class="sym">]</span>
    <span class="kwb">if</span> <span class="kwa">len</span><span class="sym">(</span>children<span class="sym">) ==</span> <span class="num">0</span><span class="sym">:</span>
        <span class="kwb">return</span> depth
    <span class="kwb">else</span><span class="sym">:</span>
        <span class="kwb">return</span> <span class="kwd">search</span><span class="sym">(</span>n<span class="sym">,</span> children<span class="sym">,</span> depth <span class="sym">+</span> <span class="num">1</span><span class="sym">)</span>


<span class="kwb">def</span> <span class="kwd">main</span><span class="sym">():</span>
    n <span class="sym">=</span> <span class="kwa">int</span><span class="sym">(</span>sys<span class="sym">.</span>argv<span class="sym">[</span><span class="num">1</span><span class="sym">])</span>

    <span class="slc"># 1. Generate all permutations in { 1, ..., n-1 }</span>
    perms <span class="sym">=</span> <span class="kwd">permutations</span><span class="sym">(</span>n<span class="sym">-</span><span class="num">1</span><span class="sym">)</span>

    <span class="slc"># 2. The search domain is structured as a tree</span>
    <span class="slc"># Here we calculate the roots of the tree (&quot;seeds&quot;)</span>
    seeds <span class="sym">= []</span>
    one <span class="sym">=</span> <span class="kwd">array</span><span class="sym">(</span><span class="str">'b'</span><span class="sym">, [</span><span class="num">0</span><span class="sym">])</span>
    seeds <span class="sym">= [</span>p<span class="sym">[:</span>p<span class="sym">[</span><span class="num">0</span><span class="sym">]] +</span> one <span class="sym">+</span> p<span class="sym">[</span>p<span class="sym">[</span><span class="num">0</span><span class="sym">]:]</span> <span class="kwb">for</span> p <span class="kwb">in</span> perms<span class="sym">]</span>

    <span class="slc"># 3. Traverse the search tree to calculate maximum depth</span>
    m <span class="sym">=</span> <span class="kwd">search</span><span class="sym">(</span>n<span class="sym">,</span> seeds<span class="sym">,</span> <span class="num">1</span><span class="sym">)</span>

    <span class="kwb">print</span> <span class="str">&quot;Pfannkuchen(%d) = %d&quot;</span> <span class="sym">% (</span>n<span class="sym">,</span> m<span class="sym">)</span>


<span class="kwd">main</span><span class="sym">()</span>
