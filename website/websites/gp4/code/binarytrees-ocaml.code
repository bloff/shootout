<span class="com">(* binarytrees.ml</span>
<span class="com"> *</span>
<span class="com"> * The Great Computer Language Shootout</span>
<span class="com"> * http://shootout.alioth.debian.org/</span>
<span class="com"> *</span>
<span class="com"> * Contributed by Troestler Christophe</span>
<span class="com"> *)</span>

<span class="com">(* type 'a tree = Empty | Node of 'a tree * 'a * 'a tree *)</span>
<span class="kwa">type</span> int_tree <span class="sym">=</span> Empty <span class="sym">|</span> Node <span class="kwa">of</span> int_tree <span class="sym">*</span> <span class="kwb">int</span> <span class="sym">*</span> int_tree

<span class="kwa">let rec</span> make i d <span class="sym">=</span>
  <span class="kwa">if</span> d <span class="sym">=</span> <span class="num">0</span> <span class="kwa">then</span> Empty
  <span class="kwa">else let</span> d<span class="str">' = d - 1 and i2 = 2 * i in Node(make (i2 - 1) d'</span><span class="sym">,</span> i<span class="sym">,</span> make i2 d<span class="str">')</span>
<span class="str"></span>
<span class="str">let rec check = function Empty -&gt; 0 | Node(l, i, r) -&gt; i + check l - check r</span>
<span class="str"></span>
<span class="str"></span>
<span class="str">let min_depth = 4</span>
<span class="str">let max_depth = (let n = try int_of_string(Array.get Sys.argv 1) with _ -&gt; 10 in</span>
<span class="str">                 max (min_depth + 2) n)</span>
<span class="str">let stretch_depth = max_depth + 1</span>
<span class="str"></span>
<span class="str">let () =</span>
<span class="str">  let c = check (make 0 stretch_depth) in</span>
<span class="str">  Printf.printf &quot;stretch tree of depth %i</span><span class="esc">\t</span> <span class="str">check: %i</span><span class="esc">\n</span><span class="str">&quot; stretch_depth c</span>
<span class="str"></span>
<span class="str">let long_lived_tree = make 0 max_depth</span>
<span class="str"></span>
<span class="str">let rec loop_depths d =</span>
<span class="str">  if d &lt;= max_depth then</span>
<span class="str">    let iterations = 1 lsl (max_depth - d + min_depth) and c = ref 0 in</span>
<span class="str">    for i = 1 to iterations do</span>
<span class="str">      c := !c + check(make i d) + check(make (-i) d)</span>
<span class="str">    done;</span>
<span class="str">    Printf.printf &quot;%i</span><span class="esc">\t</span> <span class="str">trees of depth %i</span><span class="esc">\t</span> <span class="str">check: %i</span><span class="esc">\n</span><span class="str">&quot; (2 * iterations) d !c;</span>
<span class="str">    loop_depths (d + 2)</span>
<span class="str"></span>
<span class="str">let () =</span>
<span class="str">  loop_depths min_depth;</span>
<span class="str">  Printf.printf &quot;long lived tree of depth %i</span><span class="esc">\t</span> <span class="str">check: %i</span><span class="esc">\n</span><span class="str">&quot;</span>
<span class="str">    max_depth (check long_lived_tree)</span>
<span class="str"></span>
