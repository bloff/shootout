<span class="hl com">{-# OPTIONS -O2 -optc-O3 -fglasgow-exts #-}</span>
<span class="hl slc">--</span>
<span class="hl slc">-- The Computer Language Benchmarks Game</span>
<span class="hl slc">-- http://shootout.alioth.debian.org/</span>
<span class="hl slc">--</span>
<span class="hl slc">-- Contributed by Sterling Clover</span>
<span class="hl slc">-- Heavily inspired by contribution from Don Stewart</span>
<span class="hl slc">-- Suggested flags: -funfolding-use-threshold=32 -O2 -optc-O3</span>
<span class="hl slc">--</span>

<span class="hl kwa">import qualified</span> Data.ByteString.Char8 <span class="hl kwa">as</span> S
<span class="hl kwa">import</span> Data.ByteString.Base
<span class="hl kwa">import</span> Foreign
<span class="hl kwa">import</span> Control.Arrow
<span class="hl kwa">import</span> GHC.Base
<span class="hl kwa">import</span> GHC.Ptr
<span class="hl kwa">import</span> GHC.IOBase

main <span class="hl sym">=</span> uncurry proc <span class="hl sym">=&lt;&lt;</span> clines `fmap` S.getContents

proc <span class="hl sym">[]</span> _ <span class="hl sym">=</span> return <span class="hl sym">()</span>
proc <span class="hl sym">(</span>h<span class="hl sym">:</span>hs<span class="hl sym">) (</span>b<span class="hl sym">:</span>bs<span class="hl sym">) =</span> S.putStrLn h <span class="hl sym">&gt;&gt;</span> revcomp b <span class="hl sym">&gt;&gt;</span> writeFasta b <span class="hl sym">&gt;&gt;</span> proc hs bs

writeFasta t
    <span class="hl sym">|</span> S.null t <span class="hl sym">=</span>return <span class="hl sym">()</span>
    <span class="hl sym">|</span> otherwise <span class="hl sym">=</span> S.putStrLn l <span class="hl sym">&gt;&gt;</span> writeFasta r
    <span class="hl kwa">where</span> <span class="hl sym">(</span>l<span class="hl sym">,</span>r<span class="hl sym">) =</span> S.splitAt <span class="hl num">60</span> t

clines <span class="hl sym">::</span> ByteString <span class="hl sym">-&gt; ([</span>ByteString<span class="hl sym">],[</span>ByteString<span class="hl sym">])</span>
clines ps <span class="hl sym">=</span> clines<span class="hl str">' ps ([],[])</span>
<span class="hl str">    where</span>
<span class="hl str">      clines'</span> ps accum&#64;<span class="hl sym">(</span>f<span class="hl sym">,</span>s<span class="hl sym">)</span>
          <span class="hl sym">|</span> otherwise <span class="hl sym">=</span> <span class="hl kwa">case</span> S.elemIndex <span class="hl str">'\n'</span> ps <span class="hl kwa">of</span>
                          Just n  <span class="hl sym">-&gt;</span> clines<span class="hl str">''</span> <span class="hl sym">(</span>S.drop <span class="hl sym">(</span>n<span class="hl sym">+</span><span class="hl num">1</span><span class="hl sym">)</span> ps<span class="hl sym">) (</span>f<span class="hl sym">++[</span>S.take n ps<span class="hl sym">],</span>s<span class="hl sym">)</span>
      clines<span class="hl str">''</span> ps accum&#64;<span class="hl sym">(</span>f<span class="hl sym">,</span>s<span class="hl sym">)</span>
          <span class="hl sym">|</span> otherwise <span class="hl sym">=</span> <span class="hl kwa">case</span> S.elemIndex <span class="hl str">'&gt;'</span> ps <span class="hl kwa">of</span>
                      Nothing <span class="hl sym">-&gt; (</span>f<span class="hl sym">,</span>s<span class="hl sym">++[</span>S.filter <span class="hl sym">(/=</span><span class="hl str">'\n'</span><span class="hl sym">)</span> ps<span class="hl sym">])</span>
                      Just n  <span class="hl sym">-&gt;</span> clines<span class="hl str">' (S.drop n ps) (f,s++[S.filter (/='</span>\n<span class="hl str">') . S.take n $ ps])</span>
<span class="hl str"></span>
<span class="hl str">comps = map (ord *** c2w) [</span>
<span class="hl str">    ('</span>A<span class="hl str">' , '</span>T<span class="hl str">'), ( '</span>a<span class="hl str">' , '</span>T<span class="hl str">'), ( '</span>C<span class="hl str">' , '</span>G<span class="hl str">'), ( '</span>c<span class="hl str">' , '</span>G<span class="hl str">'), ( '</span>G<span class="hl str">' , '</span>C<span class="hl str">'),</span>
<span class="hl str">    ('</span>g<span class="hl str">' , '</span>C<span class="hl str">'), ( '</span>T<span class="hl str">' , '</span>A<span class="hl str">'), ( '</span>t<span class="hl str">' , '</span>A<span class="hl str">'), ( '</span>U<span class="hl str">' , '</span>A<span class="hl str">'), ( '</span>u<span class="hl str">' , '</span>A<span class="hl str">'),</span>
<span class="hl str">    ('</span>M<span class="hl str">' , '</span>K<span class="hl str">'), ( '</span>m<span class="hl str">' , '</span>K<span class="hl str">'), ( '</span>R<span class="hl str">' , '</span>Y<span class="hl str">'), ( '</span>r<span class="hl str">' , '</span>Y<span class="hl str">'), ( '</span>Y<span class="hl str">' , '</span>R<span class="hl str">'),</span>
<span class="hl str">    ('</span>y<span class="hl str">' , '</span>R<span class="hl str">'), ( '</span>K<span class="hl str">' , '</span>M<span class="hl str">'), ( '</span>k<span class="hl str">' , '</span>M<span class="hl str">'), ( '</span>V<span class="hl str">' , '</span>B<span class="hl str">'), ( '</span>v<span class="hl str">' , '</span>B<span class="hl str">'),</span>
<span class="hl str">    ('</span>H<span class="hl str">' , '</span>D<span class="hl str">'), ( '</span>h<span class="hl str">' , '</span>D<span class="hl str">'), ( '</span>D<span class="hl str">' , '</span>H<span class="hl str">'), ( '</span>d<span class="hl str">' , '</span>H<span class="hl str">'), ( '</span>B<span class="hl str">' , '</span>V<span class="hl str">'), ( '</span>b<span class="hl str">' , '</span>V<span class="hl str">')]</span>
<span class="hl str"></span>
<span class="hl str">{- NOINLINE -}</span>
<span class="hl str">ca :: Ptr Word8</span>
<span class="hl str">ca = inlinePerformIO $ do</span>
<span class="hl str">       a &lt;- mallocArray 200</span>
<span class="hl str">       mapM_ (uncurry (pokeByteOff a)) $ zip [0..199::Int] [0..199::Word8]</span>
<span class="hl str">       mapM_ (uncurry (pokeByteOff a)) comps</span>
<span class="hl str">       return a</span>
<span class="hl str"></span>
<span class="hl str">comp :: Word# -&gt; Word#</span>
<span class="hl str">comp c = rw8 ca (word2Int# c)</span>
<span class="hl str"></span>
<span class="hl str">revcomp (PS fp s (I# l)) = withForeignPtr fp $ \p -&gt; rc (p `plusPtr` s) 0# (l -# 1#)</span>
<span class="hl str">  where</span>
<span class="hl str">    rc :: Ptr Word8 -&gt; Int# -&gt; Int# -&gt; IO ()</span>
<span class="hl str">    rc p i j  = rc'</span> i j
        <span class="hl kwa">where</span>
          rc<span class="hl str">' i j</span>
<span class="hl str">              | i &lt;# j = do</span>
<span class="hl str">                          let x = rw8 p i</span>
<span class="hl str">                          ww8 p i (comp (rw8 p j))</span>
<span class="hl str">                          ww8 p j (comp x)</span>
<span class="hl str">                          rc'</span> <span class="hl sym">(</span>i <span class="hl sym">+</span># <span class="hl num">1</span>#<span class="hl sym">) (</span>j <span class="hl sym">-</span># <span class="hl num">1</span>#<span class="hl sym">)</span>
              <span class="hl sym">|</span> i <span class="hl sym">==</span># j <span class="hl sym">=</span> ww8 p i <span class="hl sym">(</span>comp <span class="hl sym">(</span>rw8 p i<span class="hl sym">))</span>
              <span class="hl sym">|</span> otherwise <span class="hl sym">=</span>  return <span class="hl sym">()</span>

rw8 <span class="hl sym">::</span> Ptr Word8 <span class="hl sym">-&gt;</span> <span class="hl kwb">Int</span># <span class="hl sym">-&gt;</span> Word#
rw8 <span class="hl sym">(</span>Ptr a<span class="hl sym">)</span> i <span class="hl sym">=</span> <span class="hl kwa">case</span> readWord8OffAddr# a i realWorld#  <span class="hl kwa">of</span> <span class="hl sym">(</span># _<span class="hl sym">,</span> x #<span class="hl sym">) -&gt;</span>  x

ww8 <span class="hl sym">::</span> Ptr Word8 <span class="hl sym">-&gt;</span> <span class="hl kwb">Int</span># <span class="hl sym">-&gt;</span> Word# <span class="hl sym">-&gt;</span> IO <span class="hl sym">()</span>
ww8 <span class="hl sym">(</span>Ptr a<span class="hl sym">)</span> i x  <span class="hl sym">=</span> IO $ \s <span class="hl sym">-&gt;</span> <span class="hl kwa">case</span> writeWord8OffAddr# a i x s <span class="hl kwa">of</span> s2 <span class="hl sym">-&gt; (</span># s2<span class="hl sym">, ()</span> #<span class="hl sym">)</span>
