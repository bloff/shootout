<span class="com">{-# OPTIONS -fglasgow-exts -O2 -optc-O3 #-}</span>
<span class="slc">-- The Great Computer Language Shootout</span>
<span class="slc">-- http://shootout.alioth.debian.org/</span>
<span class="slc">-- contributed by Don Stewart, translated from C version</span>

<span class="kwa">import</span> Data.<span class="kwb">Char</span>
<span class="kwa">import</span> Control.Arrow
<span class="kwa">import</span> Foreign.Marshal.Array
<span class="kwa">import</span> Foreign.Storable
<span class="kwa">import</span> Control.Monad
<span class="kwa">import qualified</span> Control.Exception <span class="kwa">as</span> C
<span class="kwa">import</span> System.IO
<span class="kwa">import</span> GHC.IOBase
<span class="kwa">import</span> GHC.Base
<span class="kwa">import</span> GHC.Ptr
<span class="kwa">import</span> GHC.Word

pairs <span class="sym">=</span> map <span class="sym">(</span>c2w <span class="sym">***</span> c2w<span class="sym">) [(</span>'A'<span class="sym">,</span>'T'<span class="sym">),(</span>'C'<span class="sym">,</span>'G'<span class="sym">),(</span>'B'<span class="sym">,</span>'V'<span class="sym">),(</span>'D'<span class="sym">,</span>'H'<span class="sym">),(</span>'K'<span class="sym">,</span>'M'<span class="sym">),(</span>'R'<span class="sym">,</span>'Y'<span class="sym">),(</span>'\<span class="num">0</span>'<span class="sym">,</span>'\<span class="num">0</span>'<span class="sym">)]</span>

main <span class="sym">=</span> <span class="kwa">do</span>
    inp  <span class="sym">&lt;-</span> mallocArray <span class="num">129</span>  <span class="sym">::</span> IO <span class="sym">(</span>Ptr Word8<span class="sym">)</span>
    buf  <span class="sym">&lt;-</span> mallocArray <span class="num">1024</span> <span class="sym">::</span> IO <span class="sym">(</span>Ptr Word8<span class="sym">)</span>
    iubP <span class="sym">&lt;-</span> sequence <span class="sym">[</span> newArray <span class="sym">[</span>x<span class="sym">,</span>y<span class="sym">] | (</span>x<span class="sym">,</span>y<span class="sym">) &lt;-</span> pairs <span class="sym">] &gt;&gt;=</span> newArray
    iubC <span class="sym">&lt;-</span> newArray <span class="sym">(</span>map c2w <span class="sym">[</span>'\<span class="num">0</span>'..'\<span class="num">255</span>'<span class="sym">]++[</span><span class="num">0</span><span class="sym">])</span>
    buildIubComplement iubC iubP <span class="sym">(</span><span class="num">0</span> <span class="sym">::</span> <span class="kwb">Int</span><span class="sym">)</span>
    <span class="sym">(</span>slen<span class="sym">,</span>inp<span class="sym">) &lt;-</span> go <span class="num">0 128</span> inp buf iubC
    when <span class="sym">(</span>slen <span class="sym">&gt;</span> <span class="num">0</span><span class="sym">)</span> $ process iubC inp slen

go slen mlen inp buffer iubC <span class="sym">=</span> <span class="kwa">do</span>
    eof <span class="sym">&lt;-</span> C.catch <span class="sym">(</span>getLine <span class="sym">&gt;&gt;=</span> pokeArray0 <span class="num">0</span> buffer . c2ws . take <span class="num">1023</span> <span class="sym">&gt;&gt;</span> return <span class="kwa">False</span><span class="sym">)</span>
                   <span class="sym">(</span>\_ <span class="sym">-&gt;</span> return <span class="kwa">True</span><span class="sym">)</span>
    if eof <span class="kwa">then</span> return <span class="sym">(</span>slen<span class="sym">,</span>inp<span class="sym">)</span> <span class="kwa">else do</span>
        b0 <span class="sym">&lt;-</span> buffer <span class="sym">! (</span><span class="num">0</span><span class="sym">::</span><span class="kwb">Int</span><span class="sym">)</span>
        if b0 <span class="sym">==</span> c2w '<span class="sym">&gt;</span>'
            <span class="kwa">then do</span> when <span class="sym">(</span>slen <span class="sym">&gt;</span> <span class="num">0</span><span class="sym">)</span> $ process iubC inp slen
                    lengthArray0 <span class="num">0</span> buffer <span class="sym">&gt;&gt;=</span> hPutBuf stdout buffer <span class="sym">&gt;&gt;</span> putChar '\n'
                    go <span class="num">0</span> mlen inp buffer iubC

            <span class="kwa">else do</span> l <span class="sym">&lt;-</span> lengthArray0 <span class="num">0</span> buffer <span class="sym">&gt;&gt;=</span> shrink buffer . <span class="sym">(+</span><span class="num">1</span><span class="sym">)</span>
                    <span class="sym">(</span>inp'<span class="sym">,</span>mlen'<span class="sym">) &lt;-</span> tweak slen mlen l inp
                    copyArray <span class="sym">(</span>inp' `plusPtr` slen<span class="sym">)</span> buffer l
                    go <span class="sym">(</span>slen <span class="sym">+</span> l<span class="sym">)</span> mlen' inp' buffer iubC

process iubc strand len <span class="sym">=</span> <span class="kwa">do</span>
    inplacereverse iubc strand len
    <span class="sym">(</span>s<span class="sym">,</span>l<span class="sym">) &lt;-</span> print60 strand len
    hPutBuf stdout s l <span class="sym">&gt;&gt;</span> putChar '\n'

print60 s n
    <span class="sym">|</span> n <span class="sym">&lt;=</span> <span class="num">60</span> <span class="sym">=</span> return <span class="sym">(</span>s<span class="sym">,</span>n<span class="sym">)</span>
    <span class="sym">|</span> otherwise <span class="sym">=</span> <span class="kwa">do</span>
        hPutBuf stdout s <span class="num">60</span> <span class="sym">&gt;&gt;</span> putChar '\n'
        print60 <span class="sym">(</span>s `advancePtr` <span class="num">60</span><span class="sym">) (</span>n <span class="sym">-</span> <span class="num">60</span><span class="sym">)</span>

tweak slen mlen l inp
    <span class="sym">|</span> slen <span class="sym">+</span> l <span class="sym">&lt;=</span> mlen <span class="sym">=</span> return <span class="sym">(</span>inp<span class="sym">,</span>mlen<span class="sym">)</span>
    <span class="sym">|</span> otherwise        <span class="sym">=</span> <span class="kwa">do</span>
        <span class="kwa">let</span> mlen' <span class="sym">=</span> mlen <span class="sym">+</span> mlen
        inp' <span class="sym">&lt;-</span> reallocArray0 inp mlen'
        tweak slen mlen' l inp'

shrink b l <span class="sym">|</span> l <span class="sym">&lt;=</span> <span class="num">0</span>  <span class="sym">=</span> return l
           <span class="sym">|</span> otherwise <span class="sym">=</span> <span class="kwa">do</span>
                bl1 <span class="sym">&lt;-</span> b <span class="sym">! (</span>l<span class="sym">-</span><span class="num">1</span><span class="sym">)</span>
                if not . isAlpha . w2c $ bl1 <span class="kwa">then</span> shrink b <span class="sym">(</span>l<span class="sym">-</span><span class="num">1</span><span class="sym">)</span> <span class="kwa">else</span> return l

buildIubComplement iubC iubP i <span class="sym">=</span> <span class="kwa">do</span>
    i0 <span class="sym">&lt;-</span> index2 iubP i <span class="sym">(</span><span class="num">0</span><span class="sym">::</span><span class="kwb">Int</span><span class="sym">)</span>
    when <span class="sym">(</span>i0 <span class="sym">/=</span> <span class="num">0</span><span class="sym">)</span> $ <span class="kwa">do</span>
        i1 <span class="sym">&lt;-</span> index2 iubP i <span class="sym">(</span><span class="num">1</span><span class="sym">::</span><span class="kwb">Int</span><span class="sym">)</span>
        set iubC i0 i1
        set iubC i1 i0
        set iubC <span class="sym">(</span>tolower i0<span class="sym">)</span> i1
        set iubC <span class="sym">(</span>tolower i1<span class="sym">)</span> i0
        buildIubComplement iubC iubP <span class="sym">(</span>i<span class="sym">+</span><span class="num">1</span><span class="sym">)</span>

inplacereverse iubc<span class="sym">&#64;(</span>Ptr r<span class="sym">)</span> strand<span class="sym">&#64;(</span>Ptr s<span class="sym">)</span> len<span class="sym">&#64;(</span>I# ln<span class="sym">) =</span> <span class="kwa">do</span>
    <span class="sym">(</span>i<span class="sym">,</span>l<span class="sym">) &lt;-</span> IO $ reverseit r s <span class="num">0</span># <span class="sym">(</span>ln <span class="sym">-</span># <span class="num">1</span>#<span class="sym">)</span>
    when <span class="sym">(</span>i <span class="sym">==</span> l<span class="sym">)</span> $ strand <span class="sym">!</span> i <span class="sym">&gt;&gt;= (</span>iubc <span class="sym">!) &gt;&gt;=</span> set strand i

reverseit iubc strand i l s <span class="sym">=</span>
    if i <span class="sym">&gt;=</span># l
        <span class="kwa">then</span> <span class="sym">(</span># s<span class="sym">, (</span>I# i<span class="sym">,</span> I# l<span class="sym">)</span> #<span class="sym">)</span>
        <span class="kwa">else case</span> readWord8OffAddr# strand i s  <span class="kwa">of</span> { <span class="sym">(</span># s<span class="sym">,</span> c #<span class="sym">) -&gt;</span>
             <span class="kwa">case</span> readWord8OffAddr# strand l s  <span class="kwa">of</span> { <span class="sym">(</span># s<span class="sym">,</span> x #<span class="sym">) -&gt;</span>
             <span class="kwa">case</span> readWord8OffAddr# iubc   <span class="sym">(</span>word2Int# x<span class="sym">)</span> s  <span class="kwa">of</span> { <span class="sym">(</span># s<span class="sym">,</span> y #<span class="sym">) -&gt;</span>
             <span class="kwa">case</span> readWord8OffAddr# iubc   <span class="sym">(</span>word2Int# c<span class="sym">)</span> s  <span class="kwa">of</span> { <span class="sym">(</span># s<span class="sym">,</span> z #<span class="sym">) -&gt;</span>
             <span class="kwa">case</span> writeWord8OffAddr# strand i y s <span class="kwa">of</span> { s <span class="sym">-&gt;</span>
             <span class="kwa">case</span> writeWord8OffAddr# strand l z s <span class="kwa">of</span> { s <span class="sym">-&gt;</span>
             reverseit iubc strand <span class="sym">(</span>i <span class="sym">+</span># <span class="num">1</span>#<span class="sym">) (</span>l <span class="sym">-</span># <span class="num">1</span>#<span class="sym">)</span> s
        } } } } } }

arr <span class="sym">!</span> i     <span class="sym">=</span> peekElemOff arr <span class="sym">(</span>fromIntegral i<span class="sym">)</span>
set arr i n <span class="sym">=</span> pokeElemOff arr <span class="sym">(</span>fromIntegral i<span class="sym">)</span> n

index2 arr i j <span class="sym">=</span> arr <span class="sym">!</span> i <span class="sym">&gt;&gt;= (!</span> j<span class="sym">)</span>
set2 arr i j n <span class="sym">=</span> arr <span class="sym">!</span> i <span class="sym">&gt;&gt;=</span> \arr' <span class="sym">-&gt;</span> set arr' j n

c2w     <span class="sym">=</span> fromIntegral . ord
w2c     <span class="sym">=</span> chr . fromIntegral
c2ws    <span class="sym">=</span> unsafeCoerce#
tolower <span class="sym">=</span> fromIntegral . ord . toLower . chr . fromIntegral

