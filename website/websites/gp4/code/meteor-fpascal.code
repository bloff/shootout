<span class="kwa">program</span> meteor<span class="sym">;</span>

<span class="com">{ The Computer Language Benchmarks Game</span>
<span class="com">  http://shootout.alioth.debian.org/</span>
<span class="com"></span>
<span class="com">  contributed by Daniel Mantione</span>
<span class="com">  mostly based on Ben St. John's implementation.}</span>

<span class="kwa">uses</span> dos<span class="sym">;</span>

<span class="kwa">const</span> N_COL <span class="sym">=</span> <span class="num">5</span><span class="sym">;</span>
      N_ROW <span class="sym">=</span> <span class="num">10</span><span class="sym">;</span>
      N_CELL <span class="sym">=</span> N_COL <span class="sym">*</span> N_ROW<span class="sym">;</span>
      N_PIECE_TYPE <span class="sym">=</span> <span class="num">10</span><span class="sym">;</span>

      N_ELEM<span class="sym">=</span><span class="num">5</span><span class="sym">;</span>
      N_ORIENT<span class="sym">=</span><span class="num">12</span><span class="sym">;</span>
      ALL_PIECE_MASK<span class="sym">=[</span><span class="num">0</span>..N_PIECE_TYPE<span class="sym">-</span><span class="num">1</span><span class="sym">];</span>
      SKIP_PIECE<span class="sym">=</span><span class="num">5</span><span class="sym">;</span>

      no_piece<span class="sym">=</span><span class="kwd">high</span><span class="sym">(</span><span class="kwb">byte</span><span class="sym">);</span>

      L_EDGE_MASK<span class="sym">=[</span><span class="num">0</span><span class="sym">,</span><span class="num">5</span><span class="sym">,</span><span class="num">10</span><span class="sym">,</span><span class="num">15</span><span class="sym">,</span><span class="num">20</span><span class="sym">,</span><span class="num">25</span><span class="sym">,</span><span class="num">30</span><span class="sym">];</span>
      R_EDGE_MASK<span class="sym">=[</span><span class="num">4</span><span class="sym">,</span><span class="num">9</span><span class="sym">,</span><span class="num">14</span><span class="sym">,</span><span class="num">19</span><span class="sym">,</span><span class="num">24</span><span class="sym">,</span><span class="num">29</span><span class="sym">];</span>
      TOP_ROW    <span class="sym">= [</span><span class="num">0</span><span class="sym">*</span>N_COL.<span class="num">.1</span><span class="sym">*</span>N_COL<span class="sym">-</span><span class="num">1</span><span class="sym">];</span>
      SECOND_ROW <span class="sym">= [</span><span class="num">1</span><span class="sym">*</span>N_COL.<span class="num">.2</span><span class="sym">*</span>N_COL<span class="sym">-</span><span class="num">1</span><span class="sym">];</span>
      THIRD_ROW  <span class="sym">= [</span><span class="num">2</span><span class="sym">*</span>N_COL.<span class="num">.3</span><span class="sym">*</span>N_COL<span class="sym">-</span><span class="num">1</span><span class="sym">];</span>
      FOURTH_ROW <span class="sym">= [</span><span class="num">3</span><span class="sym">*</span>N_COL.<span class="num">.4</span><span class="sym">*</span>N_COL<span class="sym">-</span><span class="num">1</span><span class="sym">];</span>
      FIFTH_ROW  <span class="sym">= [</span><span class="num">4</span><span class="sym">*</span>N_COL.<span class="num">.5</span><span class="sym">*</span>N_COL<span class="sym">-</span><span class="num">1</span><span class="sym">];</span>
      SIXTH_ROW  <span class="sym">= [</span><span class="num">5</span><span class="sym">*</span>N_COL.<span class="num">.6</span><span class="sym">*</span>N_COL<span class="sym">-</span><span class="num">1</span><span class="sym">];</span>
      LAST_ROW   <span class="sym">=</span> SIXTH_ROW<span class="sym">;</span>
      ROW_0_MASK<span class="sym">=[</span><span class="num">0</span>..N_COL<span class="sym">-</span><span class="num">1</span><span class="sym">,</span><span class="num">10</span>..N_COL<span class="sym">+</span><span class="num">10</span><span class="sym">-</span><span class="num">1</span><span class="sym">,</span><span class="num">20</span>..N_COL<span class="sym">+</span><span class="num">20</span><span class="sym">-</span><span class="num">1</span><span class="sym">,</span><span class="num">30</span><span class="sym">,</span><span class="num">31</span><span class="sym">];</span>
      ROW_1_MASK<span class="sym">=[</span><span class="num">5</span>..N_COL<span class="sym">+</span><span class="num">5</span><span class="sym">-</span><span class="num">1</span><span class="sym">,</span><span class="num">15</span>..N_COL<span class="sym">+</span><span class="num">15</span><span class="sym">-</span><span class="num">1</span><span class="sym">,</span><span class="num">25</span>..N_COL<span class="sym">+</span><span class="num">25</span><span class="sym">-</span><span class="num">1</span><span class="sym">];</span>
      BOARD_MASK<span class="sym">=[</span><span class="num">0</span>.<span class="num">.29</span><span class="sym">];</span>


<span class="kwa">type</span>  bitvec<span class="sym">=</span><span class="kwa">set of</span> <span class="num">0</span>.<span class="num">.31</span><span class="sym">;</span>
      dimensions<span class="sym">=(</span>dimx<span class="sym">,</span>dimy<span class="sym">);</span>
      parity<span class="sym">=(</span>even<span class="sym">,</span>odd<span class="sym">);</span>
      goodbad<span class="sym">=(</span>good<span class="sym">,</span>bad<span class="sym">,</span>always_bad<span class="sym">);</span>
      piecenr<span class="sym">=</span><span class="kwa">type</span> <span class="num">0</span>..N_PIECE_TYPE<span class="sym">-</span><span class="num">1</span><span class="sym">;</span>
      orientation<span class="sym">=</span><span class="kwa">type</span> <span class="num">0</span>..N_ORIENT<span class="sym">-</span><span class="num">1</span><span class="sym">;</span>

      piece_placement<span class="sym">=</span><span class="kwa">record</span>
        vec<span class="sym">:</span>bitvec<span class="sym">;</span>
        ipiece<span class="sym">:</span>piecenr<span class="sym">;</span>
        row<span class="sym">:</span><span class="kwb">byte</span><span class="sym">;</span>
      <span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">type</span> Soln<span class="sym">=</span><span class="kwa">object</span>
       m_pieces<span class="sym">:</span><span class="kwa">array</span><span class="sym">[</span>piecenr<span class="sym">]</span> <span class="kwa">of</span> piece_placement<span class="sym">;</span>
       m_npiece<span class="sym">:</span><span class="kwb">byte</span><span class="sym">;</span>
       m_cells<span class="sym">:</span><span class="kwa">array</span><span class="sym">[</span><span class="num">0</span>..N_ROW<span class="sym">-</span><span class="num">1</span><span class="sym">,</span><span class="num">0</span>..N_COL<span class="sym">-</span><span class="num">1</span><span class="sym">]</span> <span class="kwa">of</span> piecenr<span class="sym">;</span>
       m_synched<span class="sym">:</span><span class="kwb">boolean</span><span class="sym">;</span>
       <span class="kwa">constructor</span> <span class="kwd">init</span><span class="sym">(</span>fillval<span class="sym">:</span><span class="kwb">byte</span><span class="sym">);</span>
       <span class="kwa">procedure</span> setCells<span class="sym">;</span>
       <span class="kwa">function</span> <span class="kwd">lessThan</span><span class="sym">(</span><span class="kwa">var</span> r<span class="sym">:</span>Soln<span class="sym">):</span><span class="kwb">boolean</span><span class="sym">;</span>
       <span class="kwa">procedure</span> <span class="kwd">write</span><span class="sym">(</span><span class="kwa">var</span> f<span class="sym">:</span><span class="kwb">text</span><span class="sym">);</span>
       <span class="kwa">procedure</span> <span class="kwd">fill</span><span class="sym">(</span>value<span class="sym">:</span><span class="kwb">byte</span><span class="sym">);</span>
       <span class="kwa">procedure</span> <span class="kwd">spin</span><span class="sym">(</span><span class="kwa">var</span> spun<span class="sym">:</span>Soln<span class="sym">);</span>

       <span class="kwa">function</span> isEmpty<span class="sym">:</span><span class="kwb">boolean</span><span class="sym">;</span>
       <span class="kwa">procedure</span> popPiece<span class="sym">;</span>
       <span class="kwa">procedure</span> <span class="kwd">pushPiece</span><span class="sym">(</span>Avec<span class="sym">:</span>bitvec<span class="sym">;</span>AiPiece<span class="sym">:</span>piecenr<span class="sym">;</span>Arow<span class="sym">:</span><span class="kwb">byte</span><span class="sym">);</span>
     <span class="kwa">end</span><span class="sym">;</span>

     instance<span class="sym">=</span><span class="kwa">record</span>
       m_allowed<span class="sym">:</span><span class="kwa">set of</span> <span class="kwb">byte</span><span class="sym">;</span>
       m_vec<span class="sym">:</span>bitvec<span class="sym">;</span>
       m_offset<span class="sym">:</span><span class="kwb">longint</span><span class="sym">;</span>
     <span class="kwa">end</span><span class="sym">;</span>

     TPts<span class="sym">=</span><span class="kwa">array</span><span class="sym">[</span><span class="num">0</span>..N_ELEM<span class="sym">-</span><span class="num">1</span><span class="sym">,</span>dimensions<span class="sym">]</span> <span class="kwa">of</span> shortint<span class="sym">;</span>
     piece<span class="sym">=</span><span class="kwa">object</span>
       m_instance<span class="sym">:</span><span class="kwa">array</span><span class="sym">[</span>parity<span class="sym">]</span> <span class="kwa">of</span> instance<span class="sym">;</span>
       <span class="kwa">procedure</span> <span class="kwd">set_ok_positions</span><span class="sym">(</span>isOdd<span class="sym">:</span>parity<span class="sym">;</span>w<span class="sym">,</span>h<span class="sym">:</span><span class="kwb">longint</span><span class="sym">);</span>
     <span class="kwa">end</span><span class="sym">;</span>

     OkPieces<span class="sym">=</span><span class="kwa">record</span>
       nPieces<span class="sym">:</span><span class="kwa">array</span><span class="sym">[</span>piecenr<span class="sym">]</span> <span class="kwa">of</span> <span class="kwb">byte</span><span class="sym">;</span>
       pieceVec<span class="sym">:</span><span class="kwa">array</span><span class="sym">[</span>piecenr<span class="sym">,</span>orientation<span class="sym">]</span> <span class="kwa">of</span> bitvec<span class="sym">;</span>
     <span class="kwa">end</span><span class="sym">;</span>


<span class="kwa">type</span>  fixed<span class="sym">=(</span>OPEN<span class="sym">,</span> CLOSED<span class="sym">);</span>
      islandinfo<span class="sym">=</span><span class="kwa">record</span>
        has_bad<span class="sym">:</span><span class="kwa">array</span><span class="sym">[</span>fixed<span class="sym">,</span>parity<span class="sym">]</span> <span class="kwa">of</span> bitvec<span class="sym">;</span>
        is_known<span class="sym">:</span><span class="kwa">array</span><span class="sym">[</span>fixed<span class="sym">,</span>parity<span class="sym">]</span> <span class="kwa">of</span> bitvec<span class="sym">;</span>
        alwaysBad<span class="sym">:</span><span class="kwa">array</span><span class="sym">[</span>parity<span class="sym">]</span> <span class="kwa">of</span> bitvec<span class="sym">;</span>
      <span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">const</span> MAX_ISLAND_OFFSET<span class="sym">=</span><span class="num">1024</span><span class="sym">;</span>

<span class="kwa">var</span> s_basePiece<span class="sym">:</span><span class="kwa">array</span><span class="sym">[</span>piecenr<span class="sym">,</span>orientation<span class="sym">]</span> <span class="kwa">of</span> piece<span class="sym">;</span>
    g_okPieces<span class="sym">:</span><span class="kwa">array</span><span class="sym">[</span><span class="num">0</span>..N_ROW<span class="sym">-</span><span class="num">1</span><span class="sym">,</span><span class="num">0</span>..N_COL<span class="sym">-</span><span class="num">1</span><span class="sym">]</span> <span class="kwa">of</span> OkPieces<span class="sym">;</span>
    g_islandInfo<span class="sym">:</span><span class="kwa">array</span><span class="sym">[</span><span class="num">0</span>..MAX_ISLAND_OFFSET<span class="sym">-</span><span class="num">1</span><span class="sym">]</span> <span class="kwa">of</span> islandinfo<span class="sym">;</span>
    g_nIslandInfo<span class="sym">:</span><span class="kwb">cardinal</span><span class="sym">=</span><span class="num">0</span><span class="sym">;</span>
    cache<span class="sym">:</span><span class="kwa">array</span><span class="sym">[</span><span class="num">0</span>.<span class="num">.9</span><span class="sym">,</span><span class="num">0</span>.<span class="num">.1023</span><span class="sym">,</span><span class="num">0</span>.<span class="num">.255</span><span class="sym">]</span> <span class="kwa">of</span> bitvec<span class="sym">;</span>

    m_curSoln<span class="sym">,</span>m_minSoln<span class="sym">,</span>m_maxSoln<span class="sym">:</span>Soln<span class="sym">;</span>
    m_nSoln<span class="sym">:</span><span class="kwb">cardinal</span><span class="sym">;</span>

<span class="kwa">const</span> basevecs<span class="sym">:</span><span class="kwa">array</span> <span class="sym">[</span><span class="num">0</span>.<span class="num">.9</span><span class="sym">]</span> <span class="kwa">of</span> bitvec<span class="sym">= (</span>
        <span class="sym">[</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">,</span><span class="num">3</span><span class="sym">,</span><span class="num">8</span><span class="sym">],</span>
        <span class="sym">[</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">,</span><span class="num">3</span><span class="sym">,</span><span class="num">6</span><span class="sym">,</span><span class="num">7</span><span class="sym">],</span>
        <span class="sym">[</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">,</span><span class="num">7</span><span class="sym">,</span><span class="num">12</span><span class="sym">],</span>
        <span class="sym">[</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">,</span><span class="num">5</span><span class="sym">,</span><span class="num">10</span><span class="sym">],</span>
        <span class="sym">[</span><span class="num">0</span><span class="sym">,</span><span class="num">2</span><span class="sym">,</span><span class="num">5</span><span class="sym">,</span><span class="num">6</span><span class="sym">,</span><span class="num">10</span><span class="sym">],</span>
        <span class="sym">[</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">,</span><span class="num">6</span><span class="sym">,</span><span class="num">7</span><span class="sym">],</span>
        <span class="sym">[</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">,</span><span class="num">5</span><span class="sym">,</span><span class="num">10</span><span class="sym">,</span><span class="num">15</span><span class="sym">],</span>
        <span class="sym">[</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">,</span><span class="num">5</span><span class="sym">,</span><span class="num">7</span><span class="sym">],</span>
        <span class="sym">[</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">,</span><span class="num">7</span><span class="sym">,</span><span class="num">8</span><span class="sym">],</span>
        <span class="sym">[</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">,</span><span class="num">3</span><span class="sym">,</span><span class="num">7</span><span class="sym">]</span>
      <span class="sym">);</span>


<span class="kwa">constructor</span> soln.<span class="kwd">init</span><span class="sym">(</span>fillval<span class="sym">:</span><span class="kwb">byte</span><span class="sym">);</span>

<span class="kwa">begin</span>
  <span class="kwd">fill</span><span class="sym">(</span>fillval<span class="sym">);</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">procedure</span> Soln.<span class="kwd">fill</span><span class="sym">(</span>value<span class="sym">:</span><span class="kwb">byte</span><span class="sym">);</span>

<span class="kwa">begin</span>
   m_synched<span class="sym">:=</span><span class="kwb">false</span><span class="sym">;</span>
   <span class="kwd">fillchar</span><span class="sym">(</span>m_cells<span class="sym">,</span>N_CELL<span class="sym">,</span>value<span class="sym">);</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">function</span> soln.isEmpty<span class="sym">:</span><span class="kwb">boolean</span><span class="sym">;</span>

<span class="kwa">begin</span>
  isempty<span class="sym">:=</span>m_nPiece<span class="sym">=</span><span class="num">0</span><span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">procedure</span> soln.<span class="kwd">pushPiece</span><span class="sym">(</span>Avec<span class="sym">:</span>bitvec<span class="sym">;</span>AiPiece<span class="sym">:</span>piecenr<span class="sym">;</span>Arow<span class="sym">:</span><span class="kwb">byte</span><span class="sym">);</span>

<span class="kwa">begin</span>
  <span class="kwa">with</span> m_pieces<span class="sym">[</span>m_npiece<span class="sym">]</span> <span class="kwa">do</span>
    <span class="kwa">begin</span>
      vec<span class="sym">:=</span>Avec<span class="sym">;</span>
      iPiece<span class="sym">:=</span>AiPiece<span class="sym">;</span>
      row<span class="sym">:=</span>Arow<span class="sym">;</span>
    <span class="kwa">end</span><span class="sym">;</span>
  <span class="kwd">inc</span><span class="sym">(</span>m_npiece<span class="sym">);</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">procedure</span> soln.popPiece<span class="sym">;</span>

<span class="kwa">begin</span>
  <span class="kwd">dec</span><span class="sym">(</span>m_nPiece<span class="sym">);</span>
  m_synched <span class="sym">:=</span> <span class="kwb">false</span><span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">procedure</span> soln.<span class="kwd">write</span><span class="sym">(</span><span class="kwa">var</span> f<span class="sym">:</span><span class="kwb">text</span><span class="sym">);</span>

<span class="kwa">var</span> x<span class="sym">,</span>y<span class="sym">:</span><span class="kwb">byte</span><span class="sym">;</span>

<span class="kwa">begin</span>
  <span class="kwa">for</span> y<span class="sym">:=</span><span class="num">0</span> <span class="kwa">to</span> N_ROW<span class="sym">-</span><span class="num">1</span> <span class="kwa">do</span>
    <span class="kwa">begin</span>
      <span class="com">{indent every second line}</span>
      <span class="kwa">if</span> y <span class="kwa">mod</span> <span class="num">2</span><span class="sym">=</span><span class="num">1</span> <span class="kwa">then</span>
        system.<span class="kwd">write</span><span class="sym">(</span>f<span class="sym">,</span><span class="str">' '</span><span class="sym">);</span>
      <span class="kwa">for</span> x<span class="sym">:=</span><span class="num">0</span> <span class="kwa">to</span> N_COL<span class="sym">-</span><span class="num">1</span> <span class="kwa">do</span>
        <span class="kwa">if</span> m_cells<span class="sym">[</span>y<span class="sym">,</span>x<span class="sym">]=</span>no_piece <span class="kwa">then</span>
          system.<span class="kwd">write</span><span class="sym">(</span>f<span class="sym">,</span><span class="str">'. '</span><span class="sym">)</span>
        <span class="kwa">else</span>
          system.<span class="kwd">write</span><span class="sym">(</span>f<span class="sym">,</span><span class="kwb">char</span><span class="sym">(</span><span class="kwb">byte</span><span class="sym">(</span><span class="str">'0'</span><span class="sym">)+</span>m_cells<span class="sym">[</span>y<span class="sym">,</span>x<span class="sym">]),</span><span class="str">' '</span><span class="sym">);</span>
      <span class="kwd">writeln</span><span class="sym">(</span>f<span class="sym">);</span>
    <span class="kwa">end</span><span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>


<span class="kwa">procedure</span> Soln.setCells<span class="sym">;</span>

<span class="kwa">var</span> c<span class="sym">,</span>i<span class="sym">,</span>x<span class="sym">,</span>y<span class="sym">,</span>newcells<span class="sym">:</span><span class="kwb">byte</span><span class="sym">;</span>

<span class="kwa">begin</span>
   <span class="kwa">if</span> m_synched <span class="kwa">then</span>
     exit<span class="sym">;</span>
   <span class="kwa">for</span> i<span class="sym">:=</span><span class="num">1</span> <span class="kwa">to</span> m_nPiece <span class="kwa">do</span>
     <span class="kwa">with</span> m_pieces<span class="sym">[</span>i<span class="sym">-</span><span class="num">1</span><span class="sym">]</span> <span class="kwa">do</span>
       <span class="kwa">begin</span>
         newcells<span class="sym">:=</span><span class="num">0</span><span class="sym">;</span>
         c<span class="sym">:=</span><span class="num">0</span><span class="sym">;</span>
         <span class="kwa">for</span> y<span class="sym">:=</span>row <span class="kwa">to</span> N_ROW <span class="kwa">do</span>
           <span class="kwa">begin</span>
             <span class="kwa">for</span> x<span class="sym">:=</span><span class="num">0</span> <span class="kwa">to</span> N_COL<span class="sym">-</span><span class="num">1</span> <span class="kwa">do</span>
               <span class="kwa">begin</span>
                 <span class="kwa">if</span> c <span class="kwa">in</span> vec <span class="kwa">then</span>
                   <span class="kwa">begin</span>
                     m_cells<span class="sym">[</span>y<span class="sym">,</span>x<span class="sym">]:=</span>ipiece<span class="sym">;</span>
                     <span class="kwd">inc</span><span class="sym">(</span>NewCells<span class="sym">);</span>
                   <span class="kwa">end</span><span class="sym">;</span>
                 <span class="kwd">inc</span><span class="sym">(</span>c<span class="sym">);</span>
               <span class="kwa">end</span><span class="sym">;</span>
             <span class="kwa">if</span> NewCells<span class="sym">=</span>N_ELEM <span class="kwa">then</span>
               break<span class="sym">;</span>
           <span class="kwa">end</span><span class="sym">;</span>
       <span class="kwa">end</span><span class="sym">;</span>
   m_synched<span class="sym">:=</span><span class="kwb">true</span><span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">function</span> Soln.<span class="kwd">lessThan</span><span class="sym">(</span><span class="kwa">var</span> r<span class="sym">:</span>Soln<span class="sym">):</span><span class="kwb">boolean</span><span class="sym">;</span>

<span class="kwa">var</span> x<span class="sym">,</span>y<span class="sym">,</span>lval<span class="sym">,</span>rval<span class="sym">:</span><span class="kwb">byte</span><span class="sym">;</span>

<span class="kwa">begin</span>
   <span class="kwa">if</span> m_pieces<span class="sym">[</span><span class="num">0</span><span class="sym">]</span>.iPiece<span class="sym">&lt;&gt;</span>r.m_pieces<span class="sym">[</span><span class="num">0</span><span class="sym">]</span>.iPiece <span class="kwa">then</span>
     <span class="kwa">begin</span>
       lessthan<span class="sym">:=</span>m_pieces<span class="sym">[</span><span class="num">0</span><span class="sym">]</span>.iPiece <span class="sym">&lt;</span> r.m_pieces<span class="sym">[</span><span class="num">0</span><span class="sym">]</span>.iPiece<span class="sym">;</span>
       exit<span class="sym">;</span>
     <span class="kwa">end</span><span class="sym">;</span>

   <span class="kwd">setCells</span><span class="sym">();</span>
   r.<span class="kwd">setCells</span><span class="sym">();</span>

   <span class="kwa">for</span> y<span class="sym">:=</span><span class="num">0</span> <span class="kwa">to</span> N_ROW<span class="sym">-</span><span class="num">1</span> <span class="kwa">do</span>
      <span class="kwa">for</span> x<span class="sym">:=</span><span class="num">0</span> <span class="kwa">to</span> N_COL<span class="sym">-</span><span class="num">1</span> <span class="kwa">do</span>
        <span class="kwa">begin</span>
         lval<span class="sym">:=</span>m_cells<span class="sym">[</span>y<span class="sym">,</span>x<span class="sym">];</span>
         rval<span class="sym">:=</span>r.m_cells<span class="sym">[</span>y<span class="sym">,</span>x<span class="sym">];</span>

         <span class="kwa">if</span> lval <span class="sym">&lt;&gt;</span> rval <span class="kwa">then</span>
           <span class="kwa">begin</span>
             lessthan<span class="sym">:=</span>lval<span class="sym">&lt;</span>rval<span class="sym">;</span>
             exit<span class="sym">;</span>
           <span class="kwa">end</span><span class="sym">;</span>
        <span class="kwa">end</span><span class="sym">;</span>

   lessthan<span class="sym">:=</span><span class="kwb">false</span><span class="sym">;</span> <span class="com">{solutions are equal}</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">procedure</span> Soln.<span class="kwd">spin</span><span class="sym">(</span><span class="kwa">var</span> spun<span class="sym">:</span>Soln<span class="sym">);</span>

<span class="kwa">var</span> x<span class="sym">,</span>y<span class="sym">:</span><span class="kwb">byte</span><span class="sym">;</span>

<span class="kwa">begin</span>
   setCells<span class="sym">;</span>
   <span class="com">{swap cells}</span>
   <span class="kwa">for</span> y<span class="sym">:=</span><span class="num">0</span> <span class="kwa">to</span> N_ROW<span class="sym">-</span><span class="num">1</span> <span class="kwa">do</span>
      <span class="kwa">for</span> x<span class="sym">:=</span><span class="num">0</span> <span class="kwa">to</span> N_COL<span class="sym">-</span><span class="num">1</span> <span class="kwa">do</span>
        spun.m_cells<span class="sym">[</span>y<span class="sym">,</span>x<span class="sym">]:=</span>m_cells<span class="sym">[</span>N_ROW<span class="sym">-</span>y<span class="sym">-</span><span class="num">1</span><span class="sym">,</span>N_COL<span class="sym">-</span>x<span class="sym">-</span><span class="num">1</span><span class="sym">];</span>

   <span class="com">{swap first and last pieces (the rest aren't used)}</span>
   spun.m_pieces<span class="sym">[</span><span class="num">0</span><span class="sym">]</span>.iPiece<span class="sym">:=</span>m_pieces<span class="sym">[</span>N_PIECE_TYPE<span class="sym">-</span><span class="num">1</span><span class="sym">]</span>.iPiece<span class="sym">;</span>
   spun.m_synched<span class="sym">:=</span><span class="kwb">true</span><span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">function</span> <span class="kwd">getIndex</span><span class="sym">(</span>x<span class="sym">,</span>y<span class="sym">:</span><span class="kwb">cardinal</span><span class="sym">):</span><span class="kwb">cardinal</span><span class="sym">;</span><span class="kwa">inline</span><span class="sym">;</span>

<span class="kwa">begin</span>
  getindex<span class="sym">:=</span>y<span class="sym">*</span>N_COL<span class="sym">+</span>x<span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>



<span class="kwa">function</span> <span class="kwd">floor</span><span class="sym">(</span>top<span class="sym">,</span>bot<span class="sym">:</span><span class="kwb">longint</span><span class="sym">):</span><span class="kwb">longint</span><span class="sym">;</span>

<span class="kwa">begin</span>
   floor<span class="sym">:=</span>top <span class="kwa">div</span> bot<span class="sym">;</span>
   <span class="com">{negative numbers should be rounded down, not towards zero}</span>
   <span class="kwa">if</span> <span class="sym">(</span>floor<span class="sym">*</span>bot<span class="sym">&lt;&gt;</span>top<span class="sym">)</span> <span class="kwa">and</span> <span class="sym">((</span>top<span class="sym">&lt;</span><span class="num">0</span><span class="sym">)</span> <span class="kwa">xor</span> <span class="sym">(</span>bot<span class="sym">&lt;=</span><span class="num">0</span><span class="sym">))</span> <span class="kwa">then</span>
      <span class="kwd">dec</span><span class="sym">(</span>floor<span class="sym">);</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">const</span> s_firstOne<span class="sym">:</span><span class="kwa">array</span><span class="sym">[</span><span class="num">0</span>.<span class="num">.31</span><span class="sym">]</span> <span class="kwa">of</span> <span class="kwb">byte</span><span class="sym">=(</span>
   <span class="num">0</span><span class="sym">,</span> <span class="num">0</span><span class="sym">,</span> <span class="num">1</span><span class="sym">,</span> <span class="num">0</span><span class="sym">,</span>   <span class="num">2</span><span class="sym">,</span> <span class="num">0</span><span class="sym">,</span> <span class="num">1</span><span class="sym">,</span> <span class="num">0</span><span class="sym">,</span>
   <span class="num">3</span><span class="sym">,</span> <span class="num">0</span><span class="sym">,</span> <span class="num">1</span><span class="sym">,</span> <span class="num">0</span><span class="sym">,</span>   <span class="num">2</span><span class="sym">,</span> <span class="num">0</span><span class="sym">,</span> <span class="num">1</span><span class="sym">,</span> <span class="num">0</span><span class="sym">,</span>

   <span class="num">4</span><span class="sym">,</span> <span class="num">0</span><span class="sym">,</span> <span class="num">1</span><span class="sym">,</span> <span class="num">0</span><span class="sym">,</span>   <span class="num">2</span><span class="sym">,</span> <span class="num">0</span><span class="sym">,</span> <span class="num">1</span><span class="sym">,</span> <span class="num">0</span><span class="sym">,</span>
   <span class="num">3</span><span class="sym">,</span> <span class="num">0</span><span class="sym">,</span> <span class="num">1</span><span class="sym">,</span> <span class="num">0</span><span class="sym">,</span>   <span class="num">2</span><span class="sym">,</span> <span class="num">0</span><span class="sym">,</span> <span class="num">1</span><span class="sym">,</span> <span class="num">0</span>
<span class="sym">);</span>

<span class="kwa">function</span> <span class="kwd">getFirstOne</span><span class="sym">(</span>v<span class="sym">:</span>bitvec<span class="sym">):</span><span class="kwb">cardinal</span><span class="sym">;</span>

<span class="kwa">var</span> ipos<span class="sym">:</span><span class="kwb">cardinal</span><span class="sym">;</span>
    mask<span class="sym">,</span>result<span class="sym">,</span>startpos<span class="sym">:</span><span class="kwb">cardinal</span><span class="sym">;</span>
    resultlow<span class="sym">:</span><span class="kwb">byte</span><span class="sym">;</span>

<span class="kwa">begin</span>
   startpos<span class="sym">:=</span><span class="num">0</span><span class="sym">;</span>
   <span class="kwa">if</span> v<span class="sym">=[]</span> <span class="kwa">then</span>
     <span class="kwa">begin</span>
       getfirstone<span class="sym">:=</span><span class="num">0</span><span class="sym">;</span>
       exit<span class="sym">;</span>
     <span class="kwa">end</span><span class="sym">;</span>
   iPos <span class="sym">:=</span> startPos<span class="sym">;</span>
   mask <span class="sym">:=</span> $ff <span class="kwa">shl</span> startPos<span class="sym">;</span>
   <span class="kwa">while</span> <span class="sym">(</span>mask <span class="kwa">and</span> <span class="kwb">cardinal</span><span class="sym">(</span>v<span class="sym">)) =</span> <span class="num">0</span> <span class="kwa">do</span>
     <span class="kwa">begin</span>
       mask<span class="sym">:=</span>mask <span class="kwa">shl</span> <span class="num">8</span><span class="sym">;</span>
       <span class="kwd">inc</span><span class="sym">(</span>ipos<span class="sym">,</span><span class="num">8</span><span class="sym">);</span>
    <span class="kwa">end</span><span class="sym">;</span>
   result<span class="sym">:=(</span>mask <span class="kwa">and</span> <span class="kwb">cardinal</span><span class="sym">(</span>v<span class="sym">))</span> <span class="kwa">shr</span> iPos<span class="sym">;</span>
   resultLow <span class="sym">:=</span> <span class="kwb">byte</span><span class="sym">(</span>result <span class="kwa">and</span> $<span class="num">0</span>f<span class="sym">);</span>
   <span class="kwa">if</span> resultLow<span class="sym">&lt;&gt;</span><span class="num">0</span> <span class="kwa">then</span>
      <span class="kwd">inc</span><span class="sym">(</span>iPos<span class="sym">,</span>s_firstOne<span class="sym">[</span>resultLow<span class="sym">])</span>
   <span class="kwa">else</span>
      <span class="kwd">inc</span><span class="sym">(</span>iPos<span class="sym">,</span><span class="num">4</span><span class="sym">+</span>s_firstOne<span class="sym">[</span>result <span class="kwa">shr</span> <span class="num">4</span><span class="sym">]);</span>

   getfirstone<span class="sym">:=</span>iPos<span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">function</span> <span class="kwd">count_ones</span><span class="sym">(</span>v<span class="sym">:</span>bitvec<span class="sym">):</span><span class="kwb">cardinal</span><span class="sym">;</span><span class="kwa">inline</span><span class="sym">;</span>

<span class="kwa">begin</span>
   count_ones<span class="sym">:=</span><span class="num">0</span><span class="sym">;</span>
   <span class="kwa">while</span> v<span class="sym">&lt;&gt;[]</span> <span class="kwa">do</span>
     <span class="kwa">begin</span>
       <span class="kwd">inc</span><span class="sym">(</span>count_ones<span class="sym">);</span>
       <span class="kwb">cardinal</span><span class="sym">(</span>v<span class="sym">):=</span><span class="kwb">cardinal</span><span class="sym">(</span>v<span class="sym">)</span> <span class="kwa">and</span> <span class="sym">(</span><span class="kwb">cardinal</span><span class="sym">(</span>v<span class="sym">)-</span><span class="num">1</span><span class="sym">);</span>
     <span class="kwa">end</span><span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">procedure</span> <span class="kwd">setCoordList</span><span class="sym">(</span>vec<span class="sym">:</span>bitvec<span class="sym">;</span><span class="kwa">var</span> pts<span class="sym">:</span>Tpts<span class="sym">);</span>

<span class="kwa">var</span> iPt<span class="sym">,</span>n<span class="sym">:</span><span class="kwb">longint</span><span class="sym">;</span>
    x<span class="sym">,</span>y<span class="sym">:</span><span class="kwb">byte</span><span class="sym">;</span>

<span class="kwa">begin</span>
   iPt<span class="sym">:=</span><span class="num">0</span><span class="sym">;</span>
   n<span class="sym">:=</span><span class="num">0</span><span class="sym">;</span>
   <span class="kwa">for</span> y<span class="sym">:=</span><span class="num">0</span> <span class="kwa">to</span> N_ROW<span class="sym">-</span><span class="num">1</span> <span class="kwa">do</span>
     <span class="kwa">for</span> x<span class="sym">:=</span><span class="num">0</span> <span class="kwa">to</span> N_COL<span class="sym">-</span><span class="num">1</span> <span class="kwa">do</span>
       <span class="kwa">begin</span>
         <span class="kwa">if</span> n <span class="kwa">in</span> vec <span class="kwa">then</span>
           <span class="kwa">begin</span>
             pts<span class="sym">[</span>iPt<span class="sym">,</span>dimx<span class="sym">]:=</span>x<span class="sym">;</span>
             pts<span class="sym">[</span>iPt<span class="sym">,</span>dimy<span class="sym">]:=</span>y<span class="sym">;</span>
             <span class="kwd">inc</span><span class="sym">(</span>iPt<span class="sym">);</span>
           <span class="kwa">end</span><span class="sym">;</span>
         <span class="kwd">inc</span><span class="sym">(</span>n<span class="sym">);</span>
         <span class="kwa">if</span> n<span class="sym">=</span><span class="num">32</span> <span class="kwa">then</span>
           exit<span class="sym">;</span>
       <span class="kwa">end</span><span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">function</span> <span class="kwd">toBitVector</span><span class="sym">(</span><span class="kwa">const</span> pts<span class="sym">:</span>Tpts<span class="sym">):</span>bitvec<span class="sym">;</span>

<span class="kwa">var</span> x<span class="sym">,</span>y<span class="sym">,</span>iPt<span class="sym">:</span><span class="kwb">byte</span><span class="sym">;</span>

<span class="kwa">begin</span>
   tobitvector<span class="sym">:=[];</span>
   <span class="kwa">for</span> iPt<span class="sym">:=</span><span class="kwd">low</span><span class="sym">(</span>pts<span class="sym">)</span> <span class="kwa">to</span> <span class="kwd">high</span><span class="sym">(</span>pts<span class="sym">)</span> <span class="kwa">do</span>
     <span class="kwa">begin</span>
       x<span class="sym">:=</span>pts<span class="sym">[</span>iPt<span class="sym">,</span>dimx<span class="sym">];</span>
       y<span class="sym">:=</span>pts<span class="sym">[</span>iPt<span class="sym">,</span>dimy<span class="sym">];</span>
       <span class="kwd">include</span><span class="sym">(</span>tobitvector<span class="sym">,</span> <span class="kwd">getIndex</span><span class="sym">(</span>x<span class="sym">,</span> y<span class="sym">));</span>
     <span class="kwa">end</span><span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">procedure</span> <span class="kwd">shiftUpLines</span><span class="sym">(</span><span class="kwa">var</span> pts<span class="sym">:</span>Tpts<span class="sym">;</span>shift<span class="sym">:</span><span class="kwb">longint</span><span class="sym">);</span>

<span class="kwa">var</span> iPt<span class="sym">:</span><span class="kwb">byte</span><span class="sym">;</span>

<span class="kwa">begin</span>
   <span class="com">{vertical shifts have a twist}</span>
   <span class="kwa">for</span> iPt<span class="sym">:=</span><span class="kwd">low</span><span class="sym">(</span>pts<span class="sym">)</span> <span class="kwa">to</span> <span class="kwd">high</span><span class="sym">(</span>pts<span class="sym">)</span> <span class="kwa">do</span>
     <span class="kwa">begin</span>
       <span class="kwa">if</span> pts<span class="sym">[</span>iPt<span class="sym">,</span>dimy<span class="sym">]</span> <span class="kwa">and</span> shift <span class="kwa">and</span> <span class="num">1</span><span class="sym">&lt;&gt;</span><span class="num">0</span> <span class="kwa">then</span>
         <span class="kwd">inc</span><span class="sym">(</span>pts<span class="sym">[</span>iPt<span class="sym">,</span>dimx<span class="sym">]);</span>
       <span class="kwd">dec</span><span class="sym">(</span>pts<span class="sym">[</span>iPt<span class="sym">,</span>dimy<span class="sym">],</span>shift<span class="sym">);</span>
     <span class="kwa">end</span><span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">function</span> <span class="kwd">shiftToX0</span><span class="sym">(</span><span class="kwa">var</span> pts<span class="sym">:</span>Tpts<span class="sym">;</span><span class="kwa">var</span> Ainstance<span class="sym">:</span>instance<span class="sym">;</span>offsetRow<span class="sym">:</span><span class="kwb">longint</span><span class="sym">):</span>shortint<span class="sym">;</span>

<span class="kwa">var</span> x<span class="sym">,</span>y<span class="sym">,</span>xmin<span class="sym">,</span>xmax<span class="sym">,</span>iPt<span class="sym">,</span>offset<span class="sym">:</span>shortint<span class="sym">;</span>

<span class="kwa">begin</span>
   <span class="com">{ .. determine shift}</span>
   xMin<span class="sym">:=</span>pts<span class="sym">[</span><span class="num">0</span><span class="sym">,</span>dimx<span class="sym">];</span>
   xMax<span class="sym">:=</span>xMin<span class="sym">;</span>
   <span class="kwa">for</span> iPt<span class="sym">:=</span><span class="kwd">low</span><span class="sym">(</span>pts<span class="sym">)+</span><span class="num">1</span> <span class="kwa">to</span> <span class="kwd">high</span><span class="sym">(</span>pts<span class="sym">)</span> <span class="kwa">do</span>
     <span class="kwa">begin</span>
       x<span class="sym">:=</span>pts<span class="sym">[</span>iPt<span class="sym">,</span>dimx<span class="sym">];</span>
       y<span class="sym">:=</span>pts<span class="sym">[</span>iPt<span class="sym">,</span>dimy<span class="sym">];</span>
       <span class="kwa">if</span> x<span class="sym">&lt;</span>xMin <span class="kwa">then</span>
         xMin<span class="sym">:=</span>x
       <span class="kwa">else if</span> x <span class="sym">&gt;</span> xMax <span class="kwa">then</span>
         xMax<span class="sym">:=</span>x<span class="sym">;</span>
     <span class="kwa">end</span><span class="sym">;</span>

   offset<span class="sym">:=</span>N_ELEM<span class="sym">;</span>
   <span class="kwa">for</span> iPt<span class="sym">:=</span><span class="kwd">low</span><span class="sym">(</span>pts<span class="sym">)</span> <span class="kwa">to</span> <span class="kwd">high</span><span class="sym">(</span>pts<span class="sym">)</span> <span class="kwa">do</span>
     <span class="kwa">begin</span>
      <span class="kwd">dec</span><span class="sym">(</span>pts<span class="sym">[</span>iPt<span class="sym">,</span>dimx<span class="sym">],</span>xMin<span class="sym">);</span>
      <span class="com">{check offset -- leftmost cell on top line}</span>
      <span class="kwa">if</span> <span class="sym">(</span>pts<span class="sym">[</span>iPt<span class="sym">,</span>dimy<span class="sym">]=</span>offsetRow<span class="sym">)</span> <span class="kwa">and</span> <span class="sym">(</span>pts<span class="sym">[</span>iPt<span class="sym">,</span>dimx<span class="sym">]&lt;</span>offset<span class="sym">)</span> <span class="kwa">then</span>
         offset<span class="sym">:=</span>pts<span class="sym">[</span>iPt<span class="sym">,</span>dimx<span class="sym">];</span>
   <span class="kwa">end</span><span class="sym">;</span>

   Ainstance.m_offset <span class="sym">:=</span> offset<span class="sym">;</span>
   Ainstance.m_vec <span class="sym">:=</span> <span class="kwd">toBitVector</span><span class="sym">(</span>pts<span class="sym">);</span>
   shifttox0<span class="sym">:=</span>xMax <span class="sym">-</span> xMin<span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">function</span> <span class="kwd">badregion</span><span class="sym">(</span><span class="kwa">var</span> to_fill<span class="sym">:</span>bitvec<span class="sym">;</span>rnew<span class="sym">:</span>bitvec<span class="sym">):</span><span class="kwb">boolean</span><span class="sym">;</span>

<span class="kwa">var</span> region<span class="sym">,</span>even_region<span class="sym">,</span>odd_region<span class="sym">:</span>bitvec<span class="sym">;</span>
    cell_count<span class="sym">:</span><span class="kwb">cardinal</span><span class="sym">;</span>

<span class="kwa">begin</span>
   <span class="com">{Grow empty region, until it doesn't change any more.}</span>
   <span class="kwa">repeat</span>
      region<span class="sym">:=</span>rnew<span class="sym">;</span>
      even_region<span class="sym">:=</span>region<span class="sym">*(</span>ROW_0_MASK<span class="sym">*([</span><span class="num">0</span>.<span class="num">.31</span><span class="sym">]-</span>L_EDGE_MASK<span class="sym">));</span>
      odd_region<span class="sym">:=</span>region<span class="sym">*(</span>ROW_1_MASK<span class="sym">*([</span><span class="num">0</span>.<span class="num">.31</span><span class="sym">]-</span>R_EDGE_MASK<span class="sym">));</span>

      rnew<span class="sym">:=</span>to_fill<span class="sym">*(</span>rnew
                    <span class="com">{simple grow up/down}</span>
                    <span class="sym">+</span><span class="kwd">bitvec</span><span class="sym">(</span><span class="kwb">cardinal</span><span class="sym">(</span>region<span class="sym">)</span> <span class="kwa">shr</span> N_COL<span class="sym">)</span>
                    <span class="sym">+</span><span class="kwd">bitvec</span><span class="sym">(</span><span class="kwb">cardinal</span><span class="sym">(</span>region<span class="sym">)</span> <span class="kwa">shl</span> N_COL<span class="sym">)</span>
                    <span class="com">{grow right/left}</span>
                    <span class="sym">+</span><span class="kwd">bitvec</span><span class="sym">(</span><span class="kwb">cardinal</span><span class="sym">(</span>region<span class="sym">)</span> <span class="kwa">and not</span> <span class="kwb">cardinal</span><span class="sym">(</span>L_EDGE_MASK<span class="sym">)</span> <span class="kwa">shr</span> <span class="num">1</span><span class="sym">)</span>
                    <span class="sym">+</span><span class="kwd">bitvec</span><span class="sym">(</span><span class="kwb">cardinal</span><span class="sym">(</span>region<span class="sym">)</span> <span class="kwa">and not</span> <span class="kwb">cardinal</span><span class="sym">(</span>R_EDGE_MASK<span class="sym">)</span> <span class="kwa">shl</span> <span class="num">1</span><span class="sym">)</span>
                    <span class="com">{tricky growth}</span>
                    <span class="sym">+</span><span class="kwd">bitvec</span><span class="sym">(</span><span class="kwb">cardinal</span><span class="sym">(</span>even_Region<span class="sym">)</span> <span class="kwa">shr</span> <span class="sym">(</span>N_COL<span class="sym">+</span><span class="num">1</span><span class="sym">))</span>
                    <span class="sym">+</span><span class="kwd">bitvec</span><span class="sym">(</span><span class="kwb">cardinal</span><span class="sym">(</span>even_Region<span class="sym">)</span> <span class="kwa">shl</span> <span class="sym">(</span>N_COL<span class="sym">-</span><span class="num">1</span><span class="sym">))</span>
                    <span class="sym">+</span><span class="kwd">bitvec</span><span class="sym">(</span><span class="kwb">cardinal</span><span class="sym">(</span>odd_Region<span class="sym">)</span> <span class="kwa">shr</span> <span class="sym">(</span>N_COL<span class="sym">-</span><span class="num">1</span><span class="sym">))</span>
                    <span class="sym">+</span><span class="kwd">bitvec</span><span class="sym">(</span><span class="kwb">cardinal</span><span class="sym">(</span>odd_Region<span class="sym">)</span> <span class="kwa">shl</span> <span class="sym">(</span>N_COL<span class="sym">+</span><span class="num">1</span><span class="sym">))</span>
                    <span class="sym">);</span>
   <span class="kwa">until</span> <span class="sym">(</span>rnew<span class="sym">=</span>to_fill<span class="sym">)</span> <span class="kwa">or</span> <span class="sym">(</span>rnew<span class="sym">=</span>region<span class="sym">);</span>

   <span class="com">{Subtract empty region from board.}</span>
   to_fill<span class="sym">:=</span>to_fill<span class="sym">-</span>rnew<span class="sym">;</span>

   cell_count<span class="sym">:=</span><span class="kwd">count_ones</span><span class="sym">(</span>to_fill<span class="sym">);</span>
   <span class="com">{Optimize 'cell_count mod 5&lt;&gt;0' by hand...}</span>
   badregion<span class="sym">:=</span>cell_count<span class="sym">&lt;&gt;((</span>cell_count<span class="sym">*</span>$cccd<span class="sym">)</span> <span class="kwa">shr</span> <span class="num">18</span><span class="sym">)*</span><span class="num">5</span><span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">function</span> <span class="kwd">has_bad_islands_single</span><span class="sym">(</span>boardVec<span class="sym">:</span>bitvec<span class="sym">;</span>row<span class="sym">:</span><span class="kwb">longint</span><span class="sym">):</span><span class="kwb">boolean</span><span class="sym">;</span>

<span class="kwa">var</span> tofill<span class="sym">,</span>startregion<span class="sym">,</span>bmask<span class="sym">:</span>bitvec<span class="sym">;</span>
    isodd<span class="sym">:</span><span class="kwb">boolean</span><span class="sym">;</span>

<span class="kwa">begin</span>
   tofill<span class="sym">:=[</span><span class="num">0</span>.<span class="num">.31</span><span class="sym">]-</span>boardvec<span class="sym">;</span>
   isOdd<span class="sym">:=</span>row <span class="kwa">and</span> <span class="num">1</span><span class="sym">&lt;&gt;</span><span class="num">0</span><span class="sym">;</span>
   <span class="kwa">if</span> isOdd <span class="kwa">then</span>
     <span class="kwa">begin</span>
       <span class="kwd">dec</span><span class="sym">(</span>row<span class="sym">);</span>
       toFill<span class="sym">:=</span><span class="kwd">bitvec</span><span class="sym">(</span><span class="kwb">cardinal</span><span class="sym">(</span>tofill<span class="sym">)</span> <span class="kwa">shl</span> N_COL<span class="sym">);</span> <span class="com">{shift to even aligned}</span>
       toFill<span class="sym">:=</span> tofill <span class="sym">+</span> TOP_ROW<span class="sym">;</span>
     <span class="kwa">end</span><span class="sym">;</span>

   startRegion <span class="sym">:=</span> TOP_ROW<span class="sym">;</span>
   bMask <span class="sym">:=</span> BOARD_MASK<span class="sym">;</span> <span class="com">{all but the first two bits}</span>
   <span class="kwa">if</span> row<span class="sym">&gt;=</span><span class="num">4</span> <span class="kwa">then</span>
      <span class="kwb">cardinal</span><span class="sym">(</span>bMask<span class="sym">):=</span><span class="kwb">cardinal</span><span class="sym">(</span>bmask<span class="sym">)</span> <span class="kwa">shr</span> <span class="sym">((</span>row<span class="sym">-</span><span class="num">4</span><span class="sym">)*</span>N_COL<span class="sym">)</span>
   <span class="kwa">else if</span> isOdd <span class="kwa">or</span> <span class="sym">(</span>row <span class="sym">=</span> <span class="num">0</span><span class="sym">)</span> <span class="kwa">then</span>
      startRegion <span class="sym">:=</span> LAST_ROW<span class="sym">;</span>

   toFill<span class="sym">:=</span>tofill<span class="sym">*</span>bMask<span class="sym">;</span>
   startRegion<span class="sym">:=</span>startregion<span class="sym">*</span>toFill<span class="sym">;</span>

   has_bad_islands_single<span class="sym">:=</span><span class="kwb">true</span><span class="sym">;</span>
   <span class="kwa">while</span> toFill<span class="sym">&lt;&gt;[]</span> <span class="kwa">do</span>
     <span class="kwa">begin</span>
       <span class="kwa">if</span> <span class="kwd">badRegion</span><span class="sym">(</span>toFill<span class="sym">,</span> startRegion<span class="sym">)</span> <span class="kwa">then</span>
         exit<span class="sym">;</span>
       startRegion<span class="sym">:=[</span><span class="kwd">getFirstOne</span><span class="sym">(</span>toFill<span class="sym">)];</span>
     <span class="kwa">end</span><span class="sym">;</span>
   has_bad_islands_single<span class="sym">:=</span><span class="kwb">false</span><span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>


<span class="kwa">procedure</span> piece.<span class="kwd">set_ok_positions</span><span class="sym">(</span>isOdd<span class="sym">:</span>parity<span class="sym">;</span>w<span class="sym">,</span>h<span class="sym">:</span><span class="kwb">longint</span><span class="sym">);</span>

<span class="kwa">var</span> x<span class="sym">,</span>y<span class="sym">,</span>xpos<span class="sym">,</span>pos<span class="sym">:</span><span class="kwb">byte</span><span class="sym">;</span>

<span class="kwa">begin</span>
   pos<span class="sym">:=</span><span class="kwb">byte</span><span class="sym">(</span>isodd<span class="sym">)*</span>N_COL<span class="sym">;</span>
   <span class="kwa">with</span> m_instance<span class="sym">[</span>isOdd<span class="sym">]</span> <span class="kwa">do</span>
     <span class="kwa">begin</span>
       m_allowed<span class="sym">:=[];</span>
       y<span class="sym">:=</span><span class="kwb">byte</span><span class="sym">(</span>isOdd<span class="sym">);</span>
       <span class="kwa">while</span> y<span class="sym">&lt;</span>N_ROW<span class="sym">-</span>h <span class="kwa">do</span>
         <span class="kwa">begin</span>
           <span class="kwa">if</span> m_offset<span class="sym">&lt;&gt;</span><span class="num">0</span> <span class="kwa">then</span>
             <span class="kwd">inc</span><span class="sym">(</span>pos<span class="sym">,</span>m_offset<span class="sym">);</span>
           <span class="kwa">for</span> xPos<span class="sym">:=</span><span class="num">0</span> <span class="kwa">to</span> N_COL<span class="sym">-</span><span class="num">1</span><span class="sym">-</span>m_offset <span class="kwa">do</span>
             <span class="kwa">begin</span>
               <span class="com">{check if the new position is on the board}</span>
               <span class="kwa">if</span> <span class="sym">(</span>xPos<span class="sym">&lt;</span>N_COL<span class="sym">-</span>w<span class="sym">)</span> <span class="kwa">and not</span> <span class="kwd">has_bad_islands_single</span><span class="sym">(</span><span class="kwd">bitvec</span><span class="sym">(</span><span class="kwb">cardinal</span><span class="sym">(</span>m_vec<span class="sym">)</span> <span class="kwa">shl</span> xPos<span class="sym">),</span>y<span class="sym">)</span> <span class="kwa">then</span>
                 <span class="kwa">begin</span>
                   <span class="com">{position is allowed}</span>
                   <span class="kwd">include</span><span class="sym">(</span>m_allowed<span class="sym">,</span>pos<span class="sym">);</span>
                 <span class="kwa">end</span><span class="sym">;</span>
               <span class="kwd">inc</span><span class="sym">(</span>pos<span class="sym">);</span>
             <span class="kwa">end</span><span class="sym">;</span>
           y<span class="sym">:=</span>y<span class="sym">+</span><span class="num">2</span><span class="sym">;</span>
           <span class="com">{Skip row with wrong parity:}</span>
           <span class="kwd">inc</span><span class="sym">(</span>pos<span class="sym">,</span>N_COL<span class="sym">);</span>
         <span class="kwa">end</span><span class="sym">;</span>
   <span class="kwa">end</span><span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">procedure</span> <span class="kwd">gen_orientation</span><span class="sym">(</span>vec<span class="sym">:</span>bitvec<span class="sym">;</span>iOrient<span class="sym">:</span><span class="kwb">cardinal</span><span class="sym">;</span><span class="kwa">var</span> target<span class="sym">:</span>Piece<span class="sym">);</span>

<span class="kwa">var</span> pts<span class="sym">:</span>Tpts<span class="sym">;</span>
    x<span class="sym">,</span>y<span class="sym">,</span>ymin<span class="sym">,</span>ymax<span class="sym">,</span>h<span class="sym">,</span>w<span class="sym">:</span>shortint<span class="sym">;</span>
    rot<span class="sym">,</span>iPt<span class="sym">:</span><span class="kwb">byte</span><span class="sym">;</span>
    flip<span class="sym">:</span><span class="kwb">boolean</span><span class="sym">;</span>

<span class="kwa">begin</span>
   <span class="com">{get (x,y) coordinates}</span>
   <span class="kwd">setCoordList</span><span class="sym">(</span>vec<span class="sym">,</span> pts<span class="sym">);</span>

   rot <span class="sym">:=</span> iOrient <span class="kwa">mod</span> <span class="num">6</span><span class="sym">;</span>
   flip <span class="sym">:=</span> iOrient <span class="sym">&gt;=</span> <span class="num">6</span><span class="sym">;</span>
   <span class="kwa">if</span> flip <span class="kwa">then</span>
     <span class="kwa">for</span> iPt<span class="sym">:=</span><span class="num">0</span> <span class="kwa">to</span> N_ELEM<span class="sym">-</span><span class="num">1</span> <span class="kwa">do</span>
       pts<span class="sym">[</span>iPt<span class="sym">,</span>dimy<span class="sym">]:=-</span>pts<span class="sym">[</span>iPt<span class="sym">,</span>dimy<span class="sym">];</span>

   <span class="com">{rotate as necessary}</span>
   <span class="kwa">while</span> rot<span class="sym">&gt;</span><span class="num">0</span> <span class="kwa">do</span>
     <span class="kwa">begin</span>
       <span class="kwa">for</span> iPt<span class="sym">:=</span><span class="num">0</span> <span class="kwa">to</span> N_ELEM<span class="sym">-</span><span class="num">1</span> <span class="kwa">do</span>
         <span class="kwa">begin</span>
           x<span class="sym">:=</span>pts<span class="sym">[</span>iPt<span class="sym">,</span>dimx<span class="sym">];</span>
           y<span class="sym">:=</span>pts<span class="sym">[</span>iPt<span class="sym">,</span>dimy<span class="sym">];</span>
           pts<span class="sym">[</span>iPt<span class="sym">,</span>dimx<span class="sym">]:=</span><span class="kwd">floor</span><span class="sym">(</span><span class="num">2</span><span class="sym">*</span>x<span class="sym">-</span><span class="num">3</span><span class="sym">*</span>y<span class="sym">+</span><span class="num">1</span><span class="sym">,</span><span class="num">4</span><span class="sym">);</span>
           pts<span class="sym">[</span>iPt<span class="sym">,</span>dimy<span class="sym">]:=</span><span class="kwd">floor</span><span class="sym">(</span><span class="num">2</span><span class="sym">*</span>x<span class="sym">+</span>y<span class="sym">+</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">);</span>
         <span class="kwa">end</span><span class="sym">;</span>
      <span class="kwd">dec</span><span class="sym">(</span>rot<span class="sym">);</span>
   <span class="kwa">end</span><span class="sym">;</span>

   <span class="com">{determine vertical shift}</span>
   yMin <span class="sym">:=</span> pts<span class="sym">[</span><span class="num">0</span><span class="sym">,</span>dimy<span class="sym">];</span>
   yMax <span class="sym">:=</span> yMin<span class="sym">;</span>
   <span class="kwa">for</span> iPt<span class="sym">:=</span> <span class="num">1</span> <span class="kwa">to</span> N_ELEM<span class="sym">-</span><span class="num">1</span> <span class="kwa">do</span>
     <span class="kwa">begin</span>
       y <span class="sym">:=</span> pts<span class="sym">[</span>iPt<span class="sym">,</span>dimy<span class="sym">];</span>

       <span class="kwa">if</span> y <span class="sym">&lt;</span> yMin <span class="kwa">then</span>
         yMin <span class="sym">:=</span> y
       <span class="kwa">else if</span> y <span class="sym">&gt;</span> yMax <span class="kwa">then</span>
         yMax <span class="sym">:=</span> y<span class="sym">;</span>
     <span class="kwa">end</span><span class="sym">;</span>
   h<span class="sym">:=</span>yMax<span class="sym">-</span>yMin<span class="sym">;</span>

   <span class="kwd">shiftUpLines</span><span class="sym">(</span>pts<span class="sym">,</span> yMin<span class="sym">);</span>
   w <span class="sym">:=</span> <span class="kwd">shiftToX0</span><span class="sym">(</span>pts<span class="sym">,</span> target.m_instance<span class="sym">[</span>EVEN<span class="sym">],</span> <span class="num">0</span><span class="sym">);</span>
   target.<span class="kwd">set_ok_positions</span><span class="sym">(</span>EVEN<span class="sym">,</span> w<span class="sym">,</span> h<span class="sym">);</span>
   <span class="kwb">cardinal</span><span class="sym">(</span>target.m_instance<span class="sym">[</span>EVEN<span class="sym">]</span>.m_vec<span class="sym">) :=</span> <span class="kwb">cardinal</span><span class="sym">(</span>target.m_instance<span class="sym">[</span>EVEN<span class="sym">]</span>.m_vec<span class="sym">)</span> <span class="kwa">shr</span> target.m_instance<span class="sym">[</span>EVEN<span class="sym">]</span>.m_offset<span class="sym">;</span>

   <span class="com">{shift down one line}</span>
   <span class="kwd">shiftUpLines</span><span class="sym">(</span>pts<span class="sym">, -</span><span class="num">1</span><span class="sym">);</span>
   w <span class="sym">:=</span> <span class="kwd">shiftToX0</span><span class="sym">(</span>pts<span class="sym">,</span> target.m_instance<span class="sym">[</span>ODD<span class="sym">],</span> <span class="num">1</span><span class="sym">);</span>
   <span class="com">{shift the bitmask back one line}</span>
   <span class="kwb">cardinal</span><span class="sym">(</span>target.m_instance<span class="sym">[</span>ODD<span class="sym">]</span>.m_vec<span class="sym">) :=</span><span class="kwb">cardinal</span><span class="sym">(</span>target.m_instance<span class="sym">[</span>ODD<span class="sym">]</span>.m_vec<span class="sym">)</span> <span class="kwa">shr</span> N_COL<span class="sym">;</span>
   target.<span class="kwd">set_ok_positions</span><span class="sym">(</span>ODD<span class="sym">,</span> w<span class="sym">,</span> h<span class="sym">);</span>
   <span class="kwb">cardinal</span><span class="sym">(</span>target.m_instance<span class="sym">[</span>ODD<span class="sym">]</span>.m_vec<span class="sym">):=</span> <span class="kwb">cardinal</span><span class="sym">(</span>target.m_instance<span class="sym">[</span>ODD<span class="sym">]</span>.m_vec<span class="sym">)</span> <span class="kwa">shr</span> target.m_instance<span class="sym">[</span>ODD<span class="sym">]</span>.m_offset<span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">function</span> <span class="kwd">getPiece</span><span class="sym">(</span>iPiece<span class="sym">,</span>iOrient<span class="sym">:</span><span class="kwb">cardinal</span><span class="sym">;</span>iParity<span class="sym">:</span>parity<span class="sym">):</span>instance<span class="sym">;</span><span class="kwa">inline</span><span class="sym">;</span>

<span class="kwa">begin</span>
  getpiece<span class="sym">:=</span>s_basePiece<span class="sym">[</span>iPiece<span class="sym">][</span>iOrient<span class="sym">]</span>.m_instance<span class="sym">[</span>iParity<span class="sym">];</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">procedure</span> gen_all_orientations<span class="sym">;</span>

<span class="kwa">var</span> ipiece<span class="sym">:</span>piecenr<span class="sym">;</span>
    iorient<span class="sym">:</span>orientation<span class="sym">;</span>
    irow<span class="sym">,</span>icol<span class="sym">:</span><span class="kwb">byte</span><span class="sym">;</span>
    refpiece<span class="sym">:</span>bitvec<span class="sym">;</span>
    n<span class="sym">,</span>npiece<span class="sym">:</span><span class="kwb">byte</span><span class="sym">;</span>

<span class="kwa">begin</span>
   <span class="kwa">for</span> iPiece<span class="sym">:=</span><span class="kwd">low</span><span class="sym">(</span>ipiece<span class="sym">)</span> <span class="kwa">to</span> <span class="kwd">high</span><span class="sym">(</span>ipiece<span class="sym">)</span> <span class="kwa">do</span>
     <span class="kwa">begin</span>
       refPiece<span class="sym">:=</span>BaseVecs<span class="sym">[</span>iPiece<span class="sym">];</span>
       <span class="kwa">for</span> iOrient<span class="sym">:=</span><span class="kwd">low</span><span class="sym">(</span>iorient<span class="sym">)</span> <span class="kwa">to</span> <span class="kwd">high</span><span class="sym">(</span>iorient<span class="sym">)</span> <span class="kwa">do</span>
         <span class="kwa">begin</span>
           <span class="kwd">gen_orientation</span><span class="sym">(</span>refPiece<span class="sym">,</span> iOrient<span class="sym">,</span> s_basePiece<span class="sym">[</span>iPiece<span class="sym">,</span>iOrient<span class="sym">]);</span>
           <span class="kwa">with</span> s_basePiece<span class="sym">[</span>iPiece<span class="sym">,</span>iOrient<span class="sym">]</span> <span class="kwa">do</span>
             <span class="kwa">begin</span>
               <span class="kwa">if</span> <span class="sym">(</span>iPiece<span class="sym">=</span>SKIP_PIECE<span class="sym">)</span> <span class="kwa">and</span> <span class="sym">(</span>iOrient <span class="kwa">in</span> <span class="sym">[</span><span class="num">3</span>.<span class="num">.5</span><span class="sym">,</span><span class="num">9</span>.<span class="num">.11</span><span class="sym">])</span> <span class="kwa">then</span>
                 <span class="kwa">begin</span>
                   m_instance<span class="sym">[</span>odd<span class="sym">]</span>.m_allowed <span class="sym">:= [];</span>
                   m_instance<span class="sym">[</span>even<span class="sym">]</span>.m_allowed <span class="sym">:= [];</span>
                 <span class="kwa">end</span><span class="sym">;</span>
             <span class="kwa">end</span><span class="sym">;</span>
         <span class="kwa">end</span><span class="sym">;</span>
     <span class="kwa">end</span><span class="sym">;</span>

   <span class="kwa">for</span> iPiece<span class="sym">:=</span><span class="kwd">low</span><span class="sym">(</span>ipiece<span class="sym">)</span> <span class="kwa">to</span> <span class="kwd">high</span><span class="sym">(</span>ipiece<span class="sym">)</span> <span class="kwa">do</span>
     <span class="kwa">begin</span>
      <span class="kwa">for</span> iOrient<span class="sym">:=</span><span class="kwd">low</span><span class="sym">(</span>iorient<span class="sym">)</span> <span class="kwa">to</span> <span class="kwd">high</span><span class="sym">(</span>iorient<span class="sym">)</span> <span class="kwa">do</span>
        <span class="kwa">begin</span>
         n<span class="sym">:=</span><span class="num">0</span><span class="sym">;</span>
         <span class="kwa">for</span> iRow<span class="sym">:=</span><span class="num">0</span> <span class="kwa">to</span> N_ROW<span class="sym">-</span><span class="num">1</span> <span class="kwa">do</span>
           <span class="kwa">begin</span>
            <span class="kwa">with</span> <span class="kwd">getPiece</span><span class="sym">(</span>iPiece<span class="sym">,</span> iOrient<span class="sym">,</span> <span class="kwd">parity</span><span class="sym">(</span>iRow <span class="kwa">and</span> <span class="num">1</span><span class="sym">))</span> <span class="kwa">do</span>
              <span class="kwa">for</span> iCol<span class="sym">:=</span><span class="num">0</span> <span class="kwa">to</span> N_COL<span class="sym">-</span><span class="num">1</span> <span class="kwa">do</span>
                <span class="kwa">begin</span>
                  <span class="kwa">if</span> n <span class="kwa">in</span> m_allowed <span class="kwa">then</span>
                    <span class="kwa">begin</span>
                      nPiece<span class="sym">:=</span>g_okPieces<span class="sym">[</span>iRow<span class="sym">,</span>iCol<span class="sym">]</span>.nPieces<span class="sym">[</span>iPiece<span class="sym">];</span>
                      g_okPieces<span class="sym">[</span>iRow<span class="sym">,</span>iCol<span class="sym">]</span>.pieceVec<span class="sym">[</span>iPiece<span class="sym">,</span>nPiece<span class="sym">]:=</span><span class="kwd">bitvec</span><span class="sym">(</span><span class="kwb">cardinal</span><span class="sym">(</span>m_vec<span class="sym">)</span> <span class="kwa">shl</span> iCol<span class="sym">);</span>
                      <span class="kwd">inc</span><span class="sym">(</span>g_okPieces<span class="sym">[</span>iRow<span class="sym">,</span>iCol<span class="sym">]</span>.nPieces<span class="sym">[</span>iPiece<span class="sym">]);</span>
                    <span class="kwa">end</span><span class="sym">;</span>
                  <span class="kwd">inc</span><span class="sym">(</span>n<span class="sym">);</span>
                <span class="kwa">end</span><span class="sym">;</span>
          <span class="kwa">end</span>
      <span class="kwa">end</span>
   <span class="kwa">end</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">procedure</span> init_board<span class="sym">;</span>

<span class="kwa">begin</span>
  m_cursoln.<span class="kwd">init</span><span class="sym">(</span>NO_PIECE<span class="sym">);</span>
  m_minsoln.<span class="kwd">init</span><span class="sym">(</span>NO_PIECE<span class="sym">);</span>
  m_maxsoln.<span class="kwd">init</span><span class="sym">(</span>NO_PIECE<span class="sym">);</span>
  m_nsoln<span class="sym">:=</span><span class="num">0</span><span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">const</span> g_firstRegion<span class="sym">:</span><span class="kwa">array</span><span class="sym">[</span><span class="num">0</span>.<span class="num">.31</span><span class="sym">]</span> <span class="kwa">of</span> bitvec<span class="sym">=(</span>
        <span class="sym">[],      [</span><span class="num">0</span><span class="sym">],      [</span><span class="num">1</span><span class="sym">],       [</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">],</span>
        <span class="sym">[</span><span class="num">2</span><span class="sym">],     [</span><span class="num">0</span><span class="sym">],      [</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">],     [</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">],</span>
        <span class="sym">[</span><span class="num">3</span><span class="sym">],     [</span><span class="num">0</span><span class="sym">],      [</span><span class="num">1</span><span class="sym">],       [</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">],</span>
        <span class="sym">[</span><span class="num">2</span><span class="sym">,</span><span class="num">3</span><span class="sym">],   [</span><span class="num">0</span><span class="sym">],      [</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">,</span><span class="num">3</span><span class="sym">],   [</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">,</span><span class="num">3</span><span class="sym">],</span>
        <span class="sym">[</span><span class="num">4</span><span class="sym">],     [</span><span class="num">0</span><span class="sym">],      [</span><span class="num">1</span><span class="sym">],       [</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">],</span>
        <span class="sym">[</span><span class="num">2</span><span class="sym">],     [</span><span class="num">0</span><span class="sym">],      [</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">],     [</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">],</span>
        <span class="sym">[</span><span class="num">3</span><span class="sym">,</span><span class="num">4</span><span class="sym">],   [</span><span class="num">0</span><span class="sym">],      [</span><span class="num">1</span><span class="sym">],       [</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">],</span>
        <span class="sym">[</span><span class="num">2</span><span class="sym">,</span><span class="num">3</span><span class="sym">,</span><span class="num">4</span><span class="sym">], [</span><span class="num">0</span><span class="sym">],      [</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">,</span><span class="num">3</span><span class="sym">,</span><span class="num">4</span><span class="sym">], [</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">,</span><span class="num">3</span><span class="sym">,</span><span class="num">4</span><span class="sym">]</span>
<span class="sym">);</span>

<span class="kwa">function</span> <span class="kwd">calc_bad_islands</span><span class="sym">(</span>boardVec<span class="sym">:</span>bitvec<span class="sym">;</span>row<span class="sym">:</span><span class="kwb">longint</span><span class="sym">):</span>goodbad<span class="sym">;</span>

<span class="kwa">var</span> tofill<span class="sym">,</span>boardmask<span class="sym">,</span>bottom<span class="sym">,</span>startregion<span class="sym">:</span>bitvec<span class="sym">;</span>
    filled<span class="sym">:</span><span class="kwb">boolean</span><span class="sym">;</span>

<span class="kwa">begin</span>
   toFill<span class="sym">:=[</span><span class="num">0</span>.<span class="num">.31</span><span class="sym">]-</span>boardVec<span class="sym">;</span>
   <span class="com">{Compensate for odd rows.}</span>
   <span class="kwa">if</span> row <span class="kwa">and</span> <span class="num">1</span><span class="sym">&lt;&gt;</span><span class="num">0</span> <span class="kwa">then</span>
     <span class="kwa">begin</span>
       <span class="kwd">dec</span><span class="sym">(</span>row<span class="sym">);</span>
       <span class="kwb">cardinal</span><span class="sym">(</span>toFill<span class="sym">):=</span><span class="kwb">cardinal</span><span class="sym">(</span>tofill<span class="sym">)</span> <span class="kwa">shl</span> N_COL<span class="sym">;</span>
     <span class="kwa">end</span><span class="sym">;</span>

   boardMask <span class="sym">:=</span> BOARD_MASK<span class="sym">;</span> <span class="com">{all but the first two bits}</span>
   <span class="kwa">if</span> row<span class="sym">&gt;</span><span class="num">4</span> <span class="kwa">then</span>
      <span class="kwb">cardinal</span><span class="sym">(</span>boardMask<span class="sym">):=</span><span class="kwb">cardinal</span><span class="sym">(</span>boardmask<span class="sym">)</span> <span class="kwa">shr</span> <span class="sym">((</span>row<span class="sym">-</span><span class="num">4</span><span class="sym">)*</span>N_COL<span class="sym">);</span>
   toFill<span class="sym">:=</span>tofill<span class="sym">*</span>boardMask<span class="sym">;</span>

   <span class="com">{a little pre-work to speed things up}</span>
   filled<span class="sym">:=</span>toFill<span class="sym">*</span>LAST_ROW<span class="sym">=</span>LAST_ROW<span class="sym">;</span>
   bottom<span class="sym">:=</span>LAST_ROW<span class="sym">;</span>
   <span class="kwa">while</span> bottom<span class="sym">*</span>toFill<span class="sym">=</span>bottom <span class="kwa">do</span>
     <span class="kwa">begin</span>
       toFill<span class="sym">:=</span>tofill<span class="sym">-</span>bottom<span class="sym">;</span>
       <span class="kwb">cardinal</span><span class="sym">(</span>bottom<span class="sym">):=</span><span class="kwb">cardinal</span><span class="sym">(</span>bottom<span class="sym">)</span> <span class="kwa">shr</span> N_COL<span class="sym">;</span>
     <span class="kwa">end</span><span class="sym">;</span>

   <span class="kwa">if</span> filled <span class="kwa">or</span> <span class="sym">(</span>row<span class="sym">&lt;</span><span class="num">4</span><span class="sym">)</span> <span class="kwa">then</span>
      startRegion <span class="sym">:=</span> bottom <span class="sym">*</span> toFill
   <span class="kwa">else</span>
     <span class="kwa">begin</span>
       startRegion <span class="sym">:=</span> g_firstRegion<span class="sym">[</span><span class="kwb">cardinal</span><span class="sym">(</span>toFill<span class="sym">*</span>TOP_ROW<span class="sym">)];</span>
       <span class="kwa">if</span> startRegion<span class="sym">=[]</span> <span class="kwa">then</span>
          <span class="kwa">begin</span>
            startRegion <span class="sym">:=</span> <span class="kwd">bitvec</span><span class="sym">(</span><span class="kwb">cardinal</span><span class="sym">(</span>toFill<span class="sym">)</span> <span class="kwa">shr</span> N_COL<span class="sym">)*</span>TOP_ROW<span class="sym">;</span>
            startRegion <span class="sym">:=</span> g_firstRegion<span class="sym">[</span><span class="kwb">cardinal</span><span class="sym">(</span>startRegion<span class="sym">)];</span>
            <span class="kwb">cardinal</span><span class="sym">(</span>startRegion<span class="sym">) :=</span> <span class="kwb">cardinal</span><span class="sym">(</span>startregion<span class="sym">)</span> <span class="kwa">shl</span> N_COL<span class="sym">;</span>
          <span class="kwa">end</span><span class="sym">;</span>
        startRegion<span class="sym">:=</span>startregion<span class="sym">+</span><span class="kwd">bitvec</span><span class="sym">(</span><span class="kwb">cardinal</span><span class="sym">(</span>startRegion<span class="sym">)</span> <span class="kwa">shl</span> N_COL<span class="sym">)*</span>toFill<span class="sym">;</span>
     <span class="kwa">end</span><span class="sym">;</span>

   <span class="kwa">while</span> toFill<span class="sym">&lt;&gt;[]</span> <span class="kwa">do</span>
     <span class="kwa">begin</span>
       <span class="kwa">if</span> <span class="kwd">badRegion</span><span class="sym">(</span>toFill<span class="sym">,</span> startRegion<span class="sym">)</span> <span class="kwa">then</span>
          <span class="kwa">begin</span>
            <span class="kwa">if</span> toFill<span class="sym">&lt;&gt;[]</span> <span class="kwa">then</span>
              calc_bad_islands<span class="sym">:=</span>ALWAYS_BAD
            <span class="kwa">else</span>
              calc_bad_islands<span class="sym">:=</span>BAD<span class="sym">;</span>
            exit<span class="sym">;</span>
          <span class="kwa">end</span><span class="sym">;</span>
       startRegion <span class="sym">:= [</span><span class="kwd">getFirstOne</span><span class="sym">(</span>toFill<span class="sym">)];</span>
     <span class="kwa">end</span><span class="sym">;</span>

   calc_bad_islands<span class="sym">:=</span>GOOD<span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>


<span class="kwa">function</span> <span class="kwd">has_bad_islands</span><span class="sym">(</span>boardvec<span class="sym">:</span>bitvec<span class="sym">;</span>row<span class="sym">:</span><span class="kwb">longint</span><span class="sym">):</span>goodbad<span class="sym">;</span>

<span class="kwa">var</span> last_row<span class="sym">:</span>bitvec<span class="sym">;</span>
    isodd<span class="sym">:</span>parity<span class="sym">;</span>
    isclosed<span class="sym">:</span>fixed<span class="sym">;</span>

<span class="kwa">begin</span>
   <span class="com">{skip over any filled rows}</span>
   <span class="kwa">while</span> boardVec<span class="sym">*</span>TOP_ROW<span class="sym">=</span>TOP_ROW <span class="kwa">do</span>
     <span class="kwa">begin</span>
       <span class="kwb">cardinal</span><span class="sym">(</span>boardVec<span class="sym">):=</span><span class="kwb">cardinal</span><span class="sym">(</span>boardvec<span class="sym">)</span> <span class="kwa">shr</span> N_COL<span class="sym">;</span>
       <span class="kwd">inc</span><span class="sym">(</span>row<span class="sym">);</span>
     <span class="kwa">end</span><span class="sym">;</span>

   has_bad_islands<span class="sym">:=</span>bad<span class="sym">;</span>
   <span class="kwa">with</span> g_islandInfo<span class="sym">[</span><span class="kwb">cardinal</span><span class="sym">(</span>boardvec<span class="sym">*(</span>TOP_ROW<span class="sym">+</span>SECOND_ROW<span class="sym">))]</span> <span class="kwa">do</span>
     <span class="kwa">begin</span>
       last_row<span class="sym">:=</span><span class="kwd">bitvec</span><span class="sym">(</span><span class="kwb">cardinal</span><span class="sym">(</span>boardvec<span class="sym">)</span> <span class="kwa">shr</span> <span class="sym">(</span><span class="num">2</span><span class="sym">*</span>N_COL<span class="sym">))*</span>TOP_ROW<span class="sym">;</span>
       isOdd<span class="sym">:=</span><span class="kwd">parity</span><span class="sym">(</span>row <span class="kwa">and</span> <span class="num">1</span><span class="sym">);</span>

       <span class="kwa">if not</span><span class="sym">(</span><span class="kwb">cardinal</span><span class="sym">(</span>last_row<span class="sym">)</span> <span class="kwa">in</span> alwaysBad<span class="sym">[</span><span class="kwd">parity</span><span class="sym">(</span>row <span class="kwa">and</span> <span class="num">1</span><span class="sym">)])</span> <span class="kwa">then</span>
         <span class="kwa">if</span> boardVec<span class="sym">*</span><span class="kwd">bitvec</span><span class="sym">(</span><span class="kwb">cardinal</span><span class="sym">(</span>TOP_ROW<span class="sym">)</span> <span class="kwa">shl</span> N_COL<span class="sym">*</span><span class="num">3</span><span class="sym">)=[]</span> <span class="kwa">then</span>
           <span class="kwa">begin</span>
             isClosed<span class="sym">:=</span><span class="kwd">fixed</span><span class="sym">(</span>row<span class="sym">&gt;</span><span class="num">6</span><span class="sym">);</span> <span class="com">{because we track 3 rows}</span>
               <span class="kwa">if not</span><span class="sym">(</span><span class="kwb">cardinal</span><span class="sym">(</span>last_row<span class="sym">)</span> <span class="kwa">in</span> is_known<span class="sym">[</span>isClosed<span class="sym">,</span>isOdd<span class="sym">])</span> <span class="kwa">then</span>
                 <span class="kwa">if</span> boardVec<span class="sym">&lt;&gt;[]</span> <span class="kwa">then</span>
                   <span class="kwa">begin</span>
                     has_bad_islands<span class="sym">:=</span><span class="kwd">calc_bad_islands</span><span class="sym">(</span>boardvec<span class="sym">,</span>row<span class="sym">);</span>
                     <span class="kwd">include</span><span class="sym">(</span>is_known<span class="sym">[</span>isClosed<span class="sym">,</span>isOdd<span class="sym">],</span><span class="kwb">cardinal</span><span class="sym">(</span>last_row<span class="sym">));</span>
                     <span class="kwa">if</span> has_bad_islands<span class="sym">&lt;&gt;</span>good <span class="kwa">then</span>
                       <span class="kwd">include</span><span class="sym">(</span>is_known<span class="sym">[</span>isClosed<span class="sym">,</span>isOdd<span class="sym">],</span><span class="kwb">cardinal</span><span class="sym">(</span>last_row<span class="sym">));</span>
                   <span class="kwa">end</span>
                 <span class="kwa">else</span>
                   has_bad_islands<span class="sym">:=</span>good
               <span class="kwa">else</span>
                 <span class="kwa">if not</span><span class="sym">(</span><span class="kwb">cardinal</span><span class="sym">(</span>last_row<span class="sym">)</span> <span class="kwa">in</span> has_bad<span class="sym">[</span>isClosed<span class="sym">,</span>isOdd<span class="sym">])</span> <span class="kwa">then</span>
                   has_bad_islands<span class="sym">:=</span>good<span class="sym">;</span>
           <span class="kwa">end</span>
         <span class="kwa">else</span>
           has_bad_islands<span class="sym">:=</span><span class="kwd">calc_bad_islands</span><span class="sym">(</span>boardvec<span class="sym">,</span>row<span class="sym">);</span>
     <span class="kwa">end</span><span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">const</span> g_flip<span class="sym">:</span><span class="kwa">array</span><span class="sym">[</span><span class="num">0</span>.<span class="num">.31</span><span class="sym">]</span> <span class="kwa">of</span> bitvec<span class="sym">=(</span>
        <span class="sym">[],        [</span><span class="num">4</span><span class="sym">],        [</span><span class="num">3</span><span class="sym">],        [</span><span class="num">3</span><span class="sym">,</span><span class="num">4</span><span class="sym">],</span>
        <span class="sym">[</span><span class="num">2</span><span class="sym">],       [</span><span class="num">2</span><span class="sym">,</span><span class="num">4</span><span class="sym">],      [</span><span class="num">2</span><span class="sym">,</span><span class="num">3</span><span class="sym">],      [</span><span class="num">2</span><span class="sym">,</span><span class="num">3</span><span class="sym">,</span><span class="num">4</span><span class="sym">],</span>
        <span class="sym">[</span><span class="num">1</span><span class="sym">],       [</span><span class="num">1</span><span class="sym">,</span><span class="num">4</span><span class="sym">],      [</span><span class="num">1</span><span class="sym">,</span><span class="num">3</span><span class="sym">],      [</span><span class="num">1</span><span class="sym">,</span><span class="num">3</span><span class="sym">,</span><span class="num">4</span><span class="sym">],</span>
        <span class="sym">[</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">],     [</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">,</span><span class="num">4</span><span class="sym">],    [</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">,</span><span class="num">3</span><span class="sym">],    [</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">,</span><span class="num">3</span><span class="sym">,</span><span class="num">4</span><span class="sym">],</span>
        <span class="sym">[</span><span class="num">0</span><span class="sym">],       [</span><span class="num">0</span><span class="sym">,</span><span class="num">4</span><span class="sym">],      [</span><span class="num">0</span><span class="sym">,</span><span class="num">3</span><span class="sym">],      [</span><span class="num">0</span><span class="sym">,</span><span class="num">3</span><span class="sym">,</span><span class="num">4</span><span class="sym">],</span>
        <span class="sym">[</span><span class="num">0</span><span class="sym">,</span><span class="num">2</span><span class="sym">],     [</span><span class="num">0</span><span class="sym">,</span><span class="num">2</span><span class="sym">,</span><span class="num">4</span><span class="sym">],    [</span><span class="num">0</span><span class="sym">,</span><span class="num">2</span><span class="sym">,</span><span class="num">3</span><span class="sym">],    [</span><span class="num">0</span><span class="sym">,</span><span class="num">2</span><span class="sym">,</span><span class="num">3</span><span class="sym">,</span><span class="num">4</span><span class="sym">],</span>
        <span class="sym">[</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">],     [</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">,</span><span class="num">4</span><span class="sym">],    [</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">,</span><span class="num">3</span><span class="sym">],    [</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">,</span><span class="num">3</span><span class="sym">,</span><span class="num">4</span><span class="sym">],</span>
        <span class="sym">[</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">],   [</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">,</span><span class="num">4</span><span class="sym">],  [</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">,</span><span class="num">3</span><span class="sym">],  [</span><span class="num">0</span><span class="sym">,</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">,</span><span class="num">3</span><span class="sym">,</span><span class="num">4</span><span class="sym">]</span>
<span class="sym">);</span>

<span class="kwa">function</span> <span class="kwd">flipTwoRows</span><span class="sym">(</span>bits<span class="sym">:</span>bitvec<span class="sym">):</span>bitvec<span class="sym">;</span><span class="kwa">inline</span><span class="sym">;</span>

<span class="kwa">var</span> flipped<span class="sym">:</span><span class="kwb">cardinal</span><span class="sym">;</span>

<span class="kwa">begin</span>
   flipped<span class="sym">:=</span><span class="kwb">cardinal</span><span class="sym">(</span>g_flip<span class="sym">[</span><span class="kwb">cardinal</span><span class="sym">(</span>bits<span class="sym">)</span> <span class="kwa">shr</span> N_COL<span class="sym">])</span> <span class="kwa">shl</span> N_COL<span class="sym">;</span>
   fliptworows<span class="sym">:=</span><span class="kwd">bitvec</span><span class="sym">(</span>flipped <span class="kwa">or</span> <span class="kwb">cardinal</span><span class="sym">(</span>g_flip<span class="sym">[</span><span class="kwb">cardinal</span><span class="sym">(</span>bits<span class="sym">*</span>TOP_ROW<span class="sym">)]));</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">procedure</span> <span class="kwd">mark_bad</span><span class="sym">(</span><span class="kwa">var</span> info<span class="sym">:</span>IslandInfo<span class="sym">;</span>n<span class="sym">:</span><span class="kwb">byte</span><span class="sym">;</span>eo<span class="sym">:</span>parity<span class="sym">;</span>always<span class="sym">:</span><span class="kwb">boolean</span><span class="sym">);</span><span class="kwa">inline</span><span class="sym">;</span>

<span class="kwa">begin</span>
  <span class="kwa">with</span> info <span class="kwa">do</span>
   <span class="kwa">begin</span>
     <span class="kwd">include</span><span class="sym">(</span>has_bad<span class="sym">[</span>OPEN<span class="sym">,</span>eo<span class="sym">],</span>n<span class="sym">);</span>
     <span class="kwd">include</span><span class="sym">(</span>has_bad<span class="sym">[</span>CLOSED<span class="sym">,</span>eo<span class="sym">],</span>n<span class="sym">);</span>

     <span class="kwa">if</span> always <span class="kwa">then</span>
       <span class="kwd">include</span><span class="sym">(</span>alwaysBad<span class="sym">[</span>eo<span class="sym">],</span>n<span class="sym">);</span>
   <span class="kwa">end</span><span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">procedure</span> calc_always_bad<span class="sym">;</span>

<span class="kwa">var</span> i<span class="sym">,</span>iWord<span class="sym">:</span><span class="kwb">cardinal</span><span class="sym">;</span>
    boardvec<span class="sym">:</span>bitvec<span class="sym">;</span>
    hasbad<span class="sym">:</span>goodbad<span class="sym">;</span>
    always<span class="sym">:</span><span class="kwb">boolean</span><span class="sym">;</span>
    flipped<span class="sym">:</span>^islandinfo<span class="sym">;</span>

<span class="kwa">begin</span>
   <span class="kwa">for</span> iWord<span class="sym">:=</span><span class="num">1</span> <span class="kwa">to</span> MAX_ISLAND_OFFSET<span class="sym">-</span><span class="num">1</span> <span class="kwa">do</span>
     <span class="kwa">begin</span>
      flipped <span class="sym">:= &#64;</span>g_islandInfo<span class="sym">[</span><span class="kwb">cardinal</span><span class="sym">(</span><span class="kwd">flipTwoRows</span><span class="sym">(</span><span class="kwd">bitvec</span><span class="sym">(</span>iWord<span class="sym">)))];</span>
      <span class="kwa">for</span> i<span class="sym">:=</span><span class="num">0</span> <span class="kwa">to</span> <span class="num">31</span> <span class="kwa">do</span>
        <span class="kwa">begin</span>
          boardvec<span class="sym">:=</span><span class="kwd">bitvec</span><span class="sym">((</span>i <span class="kwa">shl</span> <span class="sym">(</span><span class="num">2</span><span class="sym">*</span>N_COL<span class="sym">))</span> <span class="kwa">or</span> iWord<span class="sym">);</span>
          <span class="kwa">if not</span><span class="sym">(</span>i <span class="kwa">in</span> g_islandInfo<span class="sym">[</span>iWord<span class="sym">]</span>.is_known<span class="sym">[</span>OPEN<span class="sym">,</span>EVEN<span class="sym">])</span> <span class="kwa">then</span>
            <span class="kwa">begin</span>
              hasBad<span class="sym">:=</span><span class="kwd">calc_bad_islands</span><span class="sym">(</span>boardvec<span class="sym">,</span><span class="num">0</span><span class="sym">);</span>
              <span class="kwa">if</span> hasBad<span class="sym">&lt;&gt;</span>good <span class="kwa">then</span>
                <span class="kwa">begin</span>
                 always<span class="sym">:=</span>hasBad<span class="sym">=</span>ALWAYS_BAD<span class="sym">;</span>
                 <span class="kwd">mark_bad</span><span class="sym">(</span>g_islandInfo<span class="sym">[</span>iWord<span class="sym">],</span> i<span class="sym">,</span> EVEN<span class="sym">,</span> always<span class="sym">);</span>
                 <span class="kwd">mark_bad</span><span class="sym">(</span>flipped^<span class="sym">,</span><span class="kwb">cardinal</span><span class="sym">(</span>g_flip<span class="sym">[</span>i<span class="sym">]),</span> ODD<span class="sym">,</span> always<span class="sym">);</span>
              <span class="kwa">end</span><span class="sym">;</span>
            <span class="kwa">end</span><span class="sym">;</span>
      <span class="kwa">end</span><span class="sym">;</span>
      flipped^.is_known<span class="sym">[</span>OPEN<span class="sym">,</span>odd<span class="sym">]:=[</span><span class="num">0</span>.<span class="num">.31</span><span class="sym">];</span>
      g_islandInfo<span class="sym">[</span>iWord<span class="sym">]</span>.is_known<span class="sym">[</span>OPEN<span class="sym">,</span>even<span class="sym">]:=[</span><span class="num">0</span>.<span class="num">.31</span><span class="sym">];</span>
   <span class="kwa">end</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">procedure</span> <span class="kwd">record_solution</span><span class="sym">(</span><span class="kwa">var</span> s<span class="sym">:</span>Soln<span class="sym">);</span>

<span class="kwa">var</span> spun<span class="sym">:</span>soln<span class="sym">;</span>

<span class="kwa">begin</span>
   s.setcells<span class="sym">;</span>
   <span class="kwd">inc</span><span class="sym">(</span>m_nSoln<span class="sym">,</span><span class="num">2</span><span class="sym">);</span> <span class="com">{add solution and its rotation}</span>

   <span class="kwa">if</span> m_minSoln.isEmpty <span class="kwa">then</span>
     <span class="kwa">begin</span>
       m_minSoln <span class="sym">:=</span> s<span class="sym">;</span>
       m_maxSoln <span class="sym">:=</span> s<span class="sym">;</span>
       exit<span class="sym">;</span>
     <span class="kwa">end</span><span class="sym">;</span>

   <span class="kwa">if</span> s.<span class="kwd">lessThan</span><span class="sym">(</span>m_minSoln<span class="sym">)</span> <span class="kwa">then</span>
      m_minSoln <span class="sym">:=</span> s
   <span class="kwa">else if</span> m_maxSoln.<span class="kwd">lessThan</span><span class="sym">(</span>s<span class="sym">)</span> <span class="kwa">then</span>
      m_maxSoln <span class="sym">:=</span> s<span class="sym">;</span>

   s.<span class="kwd">spin</span><span class="sym">(</span>spun<span class="sym">);</span>
   <span class="kwa">if</span> spun.<span class="kwd">lessThan</span><span class="sym">(</span>m_minSoln<span class="sym">)</span> <span class="kwa">then</span>
      m_minSoln <span class="sym">:=</span> spun
   <span class="kwa">else if</span> m_maxSoln.<span class="kwd">lessThan</span><span class="sym">(</span>spun<span class="sym">)</span> <span class="kwa">then</span>
      m_maxSoln <span class="sym">:=</span> spun<span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">function</span> <span class="kwd">gen_all_solutions</span><span class="sym">(</span>boardVec<span class="sym">,</span>placedPieces<span class="sym">:</span>bitvec<span class="sym">;</span>row<span class="sym">:</span><span class="kwb">byte</span><span class="sym">):</span><span class="kwb">cardinal</span><span class="sym">;</span>

<span class="kwa">var</span> i<span class="sym">,</span>inextfill<span class="sym">:</span><span class="kwb">cardinal</span><span class="sym">;</span>
    ipiece<span class="sym">:</span>piecenr<span class="sym">;</span>
    iorient<span class="sym">:</span><span class="kwb">byte</span><span class="sym">;</span>
    piece<span class="sym">:</span>bitvec<span class="sym">;</span>

<span class="kwa">begin</span>
   <span class="kwa">while</span> boardVec<span class="sym">*</span>TOP_ROW<span class="sym">=</span>TOP_ROW <span class="kwa">do</span>
     <span class="kwa">begin</span>
       <span class="kwb">cardinal</span><span class="sym">(</span>boardVec<span class="sym">):=</span><span class="kwb">cardinal</span><span class="sym">(</span>boardvec<span class="sym">)</span> <span class="kwa">shr</span> N_COL<span class="sym">;</span>
       <span class="kwd">inc</span><span class="sym">(</span>row<span class="sym">);</span>
     <span class="kwa">end</span><span class="sym">;</span>
   gen_all_solutions<span class="sym">:=</span><span class="num">0</span><span class="sym">;</span>
   <span class="kwa">if</span> cache<span class="sym">[</span>row<span class="sym">,</span><span class="kwb">cardinal</span><span class="sym">(</span>placedpieces<span class="sym">),</span><span class="kwb">cardinal</span><span class="sym">(</span>boardvec<span class="sym">*[</span><span class="num">0</span>.<span class="num">.7</span><span class="sym">])]&lt;&gt;</span>boardvec <span class="kwa">then</span>
     <span class="kwa">begin</span>
       iNextFill <span class="sym">:=</span> s_firstOne<span class="sym">[</span><span class="kwb">cardinal</span><span class="sym">([</span><span class="num">0</span>..N_COL<span class="sym">-</span><span class="num">1</span><span class="sym">]-</span>boardVec<span class="sym">)];</span>
       <span class="kwa">with</span> g_okpieces<span class="sym">[</span>row<span class="sym">,</span>inextfill<span class="sym">]</span> <span class="kwa">do</span>
         <span class="kwa">for</span> ipiece<span class="sym">:=</span><span class="num">0</span> <span class="kwa">to</span> N_PIECE_TYPE<span class="sym">-</span><span class="num">1</span> <span class="kwa">do</span>
           <span class="kwa">if not</span><span class="sym">(</span>ipiece <span class="kwa">in</span> placedpieces<span class="sym">)</span> <span class="kwa">then</span>
             <span class="kwa">for</span> iorient<span class="sym">:=</span><span class="num">1</span> <span class="kwa">to</span> npieces<span class="sym">[</span>ipiece<span class="sym">]</span> <span class="kwa">do</span> <span class="com">{start with 1, npieces[x] can be zero}</span>
               <span class="kwa">begin</span>
                 piece<span class="sym">:=</span>pieceVec<span class="sym">[</span>iPiece<span class="sym">,</span>iOrient<span class="sym">-</span><span class="num">1</span><span class="sym">];</span>
                 <span class="com">{check if piece conflicts with other pieces or if we get a bad island.}</span>
                 <span class="kwa">if</span> <span class="sym">(</span>piece<span class="sym">*</span>boardVec<span class="sym">=[])</span> <span class="kwa">and</span> <span class="sym">(</span><span class="kwd">has_bad_islands</span><span class="sym">(</span>boardVec<span class="sym">+</span>piece<span class="sym">,</span>row<span class="sym">)=</span>good<span class="sym">)</span> <span class="kwa">then</span>
                   <span class="kwa">begin</span>
                     m_curSoln.<span class="kwd">pushPiece</span><span class="sym">(</span>piece<span class="sym">,</span>iPiece<span class="sym">,</span>row<span class="sym">);</span>
                     <span class="com">{recurse or record solution}</span>
                     <span class="kwa">if</span> placedPieces<span class="sym">+[</span>ipiece<span class="sym">]&lt;&gt;</span>ALL_PIECE_MASK <span class="kwa">then</span>
                       <span class="kwd">inc</span><span class="sym">(</span>gen_all_solutions<span class="sym">,</span><span class="kwd">gen_all_solutions</span><span class="sym">(</span>boardVec<span class="sym">+</span>piece<span class="sym">,</span>placedPieces<span class="sym">+[</span>ipiece<span class="sym">],</span>row<span class="sym">))</span>
                     <span class="kwa">else</span>
                       <span class="kwa">begin</span>
                         <span class="kwd">record_solution</span><span class="sym">(</span>m_curSoln<span class="sym">);</span>
                         <span class="kwd">inc</span><span class="sym">(</span>gen_all_solutions<span class="sym">);</span>
                       <span class="kwa">end</span><span class="sym">;</span>
                     m_curSoln.<span class="kwd">popPiece</span><span class="sym">();</span>
                   <span class="kwa">end</span><span class="sym">;</span>
              <span class="kwa">end</span><span class="sym">;</span>
       <span class="kwa">if</span> gen_all_solutions<span class="sym">=</span><span class="num">0</span> <span class="kwa">then</span>
         cache<span class="sym">[</span>row<span class="sym">,</span><span class="kwb">cardinal</span><span class="sym">(</span>placedpieces<span class="sym">),</span><span class="kwb">cardinal</span><span class="sym">(</span>boardvec<span class="sym">*[</span><span class="num">0</span>.<span class="num">.7</span><span class="sym">])]:=</span>boardvec<span class="sym">;</span>
    <span class="kwa">end</span><span class="sym">;</span>
<span class="kwa">end</span><span class="sym">;</span>

<span class="kwa">begin</span>
   <span class="kwa">if</span> paramcount <span class="sym">&gt;</span> <span class="num">2</span> <span class="kwa">then</span>
     <span class="kwd">halt</span><span class="sym">(</span><span class="num">1</span><span class="sym">);</span> <span class="com">{spec says this is an error}</span>

   <span class="kwd">textrec</span><span class="sym">(</span>output<span class="sym">)</span>.flushfunc<span class="sym">:=</span><span class="kwa">nil</span><span class="sym">;</span>

   gen_all_orientations<span class="sym">;</span>
   calc_always_bad<span class="sym">;</span>
   init_board<span class="sym">;</span>
   <span class="kwd">filldword</span><span class="sym">(</span>cache<span class="sym">,</span><span class="kwd">sizeof</span><span class="sym">(</span>cache<span class="sym">)</span> <span class="kwa">shr</span> <span class="num">2</span><span class="sym">,</span>$ffffffff<span class="sym">);</span>
   <span class="kwd">gen_all_solutions</span><span class="sym">([], [],</span> <span class="num">0</span><span class="sym">);</span>

   <span class="kwd">writeln</span><span class="sym">(</span>m_nSoln<span class="sym">,</span><span class="str">' solutions found'</span><span class="sym">);</span>
   writeln<span class="sym">;</span>
   m_minSoln.<span class="kwd">write</span><span class="sym">(</span>output<span class="sym">);</span>
   writeln<span class="sym">;</span>
   m_maxSoln.<span class="kwd">write</span><span class="sym">(</span>output<span class="sym">);</span>
<span class="kwa">end</span>.
