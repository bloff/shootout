<span class="slc">;;; The Great Computer Language Shootout
</span><span class="slc">;;; http://shootout.alioth.debian.org/
</span><span class="slc">;;; contributed by Dima Dorfman, 2005
</span><span class="slc">;;; modified by Jim Jewett
</span>
<span class="sym">(</span><span class="kwa">defun</span> swap<span class="sym">! (</span>a i j<span class="sym">)
  (</span>let <span class="sym">((</span>temp <span class="sym">(</span>aref a i<span class="sym">)))
    (</span>setf <span class="sym">(</span>aref a i<span class="sym">) (</span>aref a j<span class="sym">))
    (</span>setf <span class="sym">(</span>aref a j<span class="sym">)</span> temp<span class="sym">)))

(</span><span class="kwa">defun reverse</span><span class="sym">-</span>slice<span class="sym">! (</span>a i j<span class="sym">)
    (</span>declare
        <span class="sym">(</span><span class="kwa">type</span> <span class="sym">(</span>simple<span class="sym">-</span>array <span class="sym">(</span>unsigned<span class="sym">-</span>byte <span class="num">8</span><span class="sym">))</span> a<span class="sym">)
         (</span><span class="kwa">type</span> fixnum i j<span class="sym">))
  (</span>when <span class="sym">(&lt;</span> i j<span class="sym">)
    (</span>swap<span class="sym">!</span> a i <span class="sym">(</span><span class="num">1</span><span class="sym">-</span> j<span class="sym">))
    (</span><span class="kwa">reverse</span><span class="sym">-</span>slice<span class="sym">!</span> a <span class="sym">(</span><span class="num">1</span><span class="sym">+</span> i<span class="sym">) (</span><span class="num">1</span><span class="sym">-</span> j<span class="sym">))))

(</span><span class="kwa">defun</span> count<span class="sym">-</span>flips <span class="sym">(</span>p<span class="sym">)
    (</span>let <span class="sym">((</span>p <span class="sym">(</span>copy<span class="sym">-</span>seq p<span class="sym">)))
        (</span>loop until <span class="sym">(= (</span>aref p <span class="num">0</span><span class="sym">)</span> <span class="num">1</span><span class="sym">)
</span>              do <span class="sym">(</span><span class="kwa">reverse</span><span class="sym">-</span>slice<span class="sym">!</span> p <span class="num">0</span> <span class="sym">(</span>aref p <span class="num">0</span><span class="sym">))
</span>              count t<span class="sym">)))

(</span><span class="kwa">defun</span> reorder<span class="sym">-</span>next <span class="sym">(</span>p n low high<span class="sym">)
    (</span>swap<span class="sym">!</span> p low high<span class="sym">)
    (</span><span class="kwa">reverse</span><span class="sym">-</span>slice<span class="sym">!</span> p <span class="sym">(</span><span class="num">1</span><span class="sym">+</span> low<span class="sym">)</span> n<span class="sym">))

    (</span><span class="kwa">defun</span> next<span class="sym">-</span>permutation <span class="sym">(</span>p n<span class="sym">)
    (</span>let <span class="sym">((</span>low nil<span class="sym">) (</span>high nil<span class="sym">))
        (</span>loop for i below <span class="sym">(</span><span class="num">1</span><span class="sym">-</span> n<span class="sym">)
</span>              when <span class="sym">(&lt; (</span>aref p i<span class="sym">) (</span>aref p <span class="sym">(</span><span class="num">1</span><span class="sym">+</span> i<span class="sym">)))
 </span>                do <span class="sym">(</span><span class="kwa">setq</span> low i<span class="sym">)
</span>              when <span class="sym">(</span><span class="kwa">and</span> low <span class="sym">(&lt; (</span>aref p low<span class="sym">) (</span>aref p <span class="sym">(</span><span class="num">1</span><span class="sym">+</span> i<span class="sym">))))
</span>                do <span class="sym">(</span><span class="kwa">setq</span> high <span class="sym">(</span><span class="num">1</span><span class="sym">+</span> i<span class="sym">)))
        (</span><span class="kwa">if</span> low <span class="sym">(</span>reorder<span class="sym">-</span>next p n low high<span class="sym">))
</span>        low<span class="sym">))

(</span><span class="kwa">defun</span> fannkuch <span class="sym">(</span>n<span class="sym">)
    (</span>declare <span class="sym">(</span><span class="kwa">type</span> fixnum n<span class="sym">))
    (</span>let <span class="sym">((</span>seq <span class="sym">(</span>make<span class="sym">-</span>array <span class="sym">(</span><span class="kwa">list</span> n<span class="sym">) :</span>element<span class="sym">-</span><span class="kwa">type</span> <span class="str">'(unsigned-byte 8)
                           :initial-contents (loop for i from 1 to n collect i))))
        (loop maximizing (count-flips seq)
              while (next-permutation seq n))))

            (defun main ()
  (let* ((args #+sbcl sb-ext:*posix-argv*
       #+cmu extensions:*command-line-strings*
       #+gcl si::*command-args*)
 (n (parse-integer (car (last args)))))
    (format t &quot;Pfannkuchen(~d) = ~d~%&quot; n (fannkuch n))))

;(defun mymain (n)
;   (format t &quot;Pfannkuchen(~d) = ~d~%&quot; n (fannkuch n)))

</span>
