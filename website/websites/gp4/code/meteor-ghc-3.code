<span class="hl com">{-# OPTIONS -O3 -fglasgow-exts #-}</span>

<span class="hl com">{-</span>
<span class="hl com">	The Computer Language Shootout</span>
<span class="hl com">   	http://shootout.alioth.debian.org/</span>
<span class="hl com">   	contributed by Olof Kraigher</span>
<span class="hl com">-}</span>

<span class="hl kwa">module</span> Main <span class="hl kwa">where</span>

<span class="hl kwa">import</span> System<span class="hl sym">(</span>getArgs<span class="hl sym">);</span>		<span class="hl kwa">import</span> Data.List<span class="hl sym">;</span>	<span class="hl kwa">import</span> Data.Bits<span class="hl sym">;</span>		<span class="hl kwa">import</span> Data.Array.IArray<span class="hl sym">;</span>
<span class="hl kwa">import</span> Data.Word<span class="hl sym">(</span>Word64<span class="hl sym">);</span>	<span class="hl kwa">import</span> Data.Maybe<span class="hl sym">;</span>	<span class="hl kwa">import</span> Control.Monad<span class="hl sym">;</span>

<span class="hl kwa">data</span> Direction <span class="hl sym">=</span> E <span class="hl sym">|</span> SE <span class="hl sym">|</span> SW <span class="hl sym">|</span> W <span class="hl sym">|</span> NW <span class="hl sym">|</span> NE <span class="hl kwa">deriving</span> <span class="hl sym">(</span>Enum<span class="hl sym">,</span> Eq<span class="hl sym">,</span> Ord<span class="hl sym">)</span>
<span class="hl kwa">type</span> Piece <span class="hl sym">= [</span>Direction<span class="hl sym">]</span>
<span class="hl kwa">type</span> CellCoord <span class="hl sym">= (</span><span class="hl kwb">Int</span><span class="hl sym">,</span> <span class="hl kwb">Int</span><span class="hl sym">)</span>
<span class="hl kwa">type</span> CellIndex <span class="hl sym">=</span> <span class="hl kwb">Int</span>
<span class="hl kwa">type</span> Mask <span class="hl sym">=</span> Word64
<span class="hl kwa">type</span> Color <span class="hl sym">=</span> <span class="hl kwb">Int</span>
<span class="hl kwa">type</span> Solution <span class="hl sym">=</span> String

<span class="hl kwa">class</span> Rotatable a <span class="hl kwa">where</span> rot <span class="hl sym">::</span> a <span class="hl sym">-&gt;</span> a
<span class="hl kwa">class</span> Floppable a <span class="hl kwa">where</span> flop <span class="hl sym">::</span> a <span class="hl sym">-&gt;</span> a
<span class="hl kwa">class</span> Maskable a <span class="hl kwa">where</span> mask <span class="hl sym">::</span> a <span class="hl sym">-&gt;</span> Mask

<span class="hl kwa">instance</span> Rotatable Direction	<span class="hl kwa">where</span> rot d <span class="hl sym">=</span> toEnum $ mod <span class="hl sym">((</span>fromEnum d<span class="hl sym">) +</span> <span class="hl num">1</span><span class="hl sym">)</span> <span class="hl num">6</span>
<span class="hl kwa">instance</span> Rotatable Piece 		<span class="hl kwa">where</span> rot a <span class="hl sym">=</span> map rot a

<span class="hl kwa">instance</span> Floppable Direction 	<span class="hl kwa">where</span> flop d <span class="hl sym">=</span> toEnum $ mod <span class="hl sym">(</span><span class="hl num">9</span> <span class="hl sym">- (</span>fromEnum d<span class="hl sym">))</span> <span class="hl num">6</span>
<span class="hl kwa">instance</span> Floppable Piece 		<span class="hl kwa">where</span> flop a <span class="hl sym">=</span> map flop a

<span class="hl kwa">instance</span> Maskable CellCoord 	<span class="hl kwa">where</span> mask <span class="hl sym">(</span>x<span class="hl sym">,</span>y<span class="hl sym">) =</span> bit <span class="hl sym">(</span>x <span class="hl sym">+</span> y<span class="hl sym">*</span>width<span class="hl sym">)</span>
<span class="hl kwa">instance</span> Maskable <span class="hl sym">[</span>CellCoord<span class="hl sym">]</span>	<span class="hl kwa">where</span> mask p <span class="hl sym">=</span> foldl<span class="hl str">' (\a b -&gt; a .|. mask b) 0 p</span>
<span class="hl str">instance Maskable CellIndex 	where mask i = bit i</span>
<span class="hl str"></span>
<span class="hl str"></span>
<span class="hl str">width :: Int</span>
<span class="hl str">width = 5</span>
<span class="hl str"></span>
<span class="hl str">height :: Int</span>
<span class="hl str">height = 10</span>
<span class="hl str"></span>
<span class="hl str">cellcs :: [CellCoord]</span>
<span class="hl str">cellcs = [(x,y) | y &lt;- [0..height-1], x &lt;- [0..width-1]]</span>
<span class="hl str"></span>
<span class="hl str">cellis :: [CellIndex]</span>
<span class="hl str">cellis = [0..width*height-1]</span>
<span class="hl str"></span>
<span class="hl str">fullMask :: Mask</span>
<span class="hl str">fullMask = 0x3FFFFFFFFFFFF</span>
<span class="hl str"></span>
<span class="hl str">pieces :: Array Color Piece</span>
<span class="hl str">pieces = array (0,9) $ zip [0..9] $</span>
<span class="hl str">		[	[E,	 E,  E,  SE],</span>
<span class="hl str">			[SE, SW, W,  SW],</span>
<span class="hl str">			[W,  W,  SW, SE],</span>
<span class="hl str">			[E,  E,  SW, SE],</span>
<span class="hl str">			[NW, W,  NW, SE, SW],</span>
<span class="hl str">			[E,  E,  NE, W],</span>
<span class="hl str">			[NW, NE, NE, W],</span>
<span class="hl str">			[NE, SE, E,  NE],</span>
<span class="hl str">			[SE, SE, E,  SE],</span>
<span class="hl str">			[E,  NW, NW, NW]]</span>
<span class="hl str"></span>
<span class="hl str">valid :: CellCoord -&gt; Maybe CellCoord</span>
<span class="hl str">valid p&#64;(x,y)</span>
<span class="hl str">	| 0 &lt;= x, x &lt; width, 0 &lt;= y, y &lt; height = Just p</span>
<span class="hl str">	|otherwise = Nothing</span>
<span class="hl str"></span>
<span class="hl str">move :: CellCoord -&gt; Direction -&gt; Maybe CellCoord</span>
<span class="hl str">move (x,y) E = valid (x+1,y)</span>
<span class="hl str">move (x,y) W = valid (x-1,y)</span>
<span class="hl str">move (x,y) NE = valid (x+(mod y 2),y-1)</span>
<span class="hl str">move (x,y) NW = valid (x+(mod y 2)-1,y-1)</span>
<span class="hl str">move (x,y) SE = valid (x+(mod y 2),y+1)</span>
<span class="hl str">move (x,y) SW = valid (x+(mod y 2)-1,y+1)</span>
<span class="hl str"></span>
<span class="hl str"></span>
<span class="hl str">overlap :: Mask -&gt; Mask -&gt; Bool</span>
<span class="hl str">overlap a b = (a .&amp;. b) /= 0</span>
<span class="hl str"></span>
<span class="hl str">legal :: Mask -&gt; Mask -&gt; Bool</span>
<span class="hl str">legal a b = not $ overlap a b</span>
<span class="hl str"></span>
<span class="hl str">bc :: Mask -&gt; Int</span>
<span class="hl str">bc 0 = 0</span>
<span class="hl str">bc mask = (fromIntegral $ (mask .&amp;. 1)) + (bc (shiftR mask 1))</span>
<span class="hl str"></span>
<span class="hl str">fill :: Mask -&gt; CellCoord -&gt; Mask</span>
<span class="hl str">fill mask cell&#64;(x,y)</span>
<span class="hl str">	| overlap mask (bit $ x + y*width) = mask</span>
<span class="hl str">	| otherwise =</span>
<span class="hl str">		let mask'</span> <span class="hl sym">=</span> mask .<span class="hl sym">|</span>. <span class="hl sym">(</span>bit $ x <span class="hl sym">+</span> y<span class="hl sym">*</span>width<span class="hl sym">)</span>
		<span class="hl kwa">in</span>	foldl<span class="hl str">' fill mask'</span> $ mapMaybe <span class="hl sym">(</span>move cell<span class="hl sym">) [</span>E .. NE<span class="hl sym">]</span>

freeCell <span class="hl sym">::</span> Mask <span class="hl sym">-&gt;</span> CellCoord
freeCell mask <span class="hl sym">=</span>
	fromJust $ find <span class="hl sym">(</span>\<span class="hl sym">(</span>x<span class="hl sym">,</span>y<span class="hl sym">) -&gt;</span> legal mask <span class="hl sym">(</span>bit $ x <span class="hl sym">+</span> y<span class="hl sym">*</span>width<span class="hl sym">))</span> cellcs

noIslands <span class="hl sym">::</span> Mask <span class="hl sym">-&gt;</span> <span class="hl kwb">Bool</span>
noIslands mask <span class="hl sym">=</span> not $ any <span class="hl sym">(&lt;</span><span class="hl num">5</span><span class="hl sym">)</span> $ diffs $ noIslands<span class="hl str">' mask where</span>
<span class="hl str">	noIslands'</span> mask
		<span class="hl sym">|</span> mask <span class="hl sym">==</span> fullMask <span class="hl sym">= [</span>bc mask<span class="hl sym">]</span>
		<span class="hl sym">|</span> otherwise <span class="hl sym">= (</span>bc mask<span class="hl sym">) : (</span>noIslands<span class="hl str">' $ fill mask $ freeCell mask)</span>
<span class="hl str">	diffs l = zipWith (-) (tail l) l</span>
<span class="hl str"></span>
<span class="hl str"></span>
<span class="hl str">placePiece :: Piece -&gt; CellCoord -&gt; Maybe [CellCoord]</span>
<span class="hl str">placePiece [] cell = Just [cell]</span>
<span class="hl str">placePiece (p:ps) cell = move cell p &gt;&gt;= (placePiece ps) &gt;&gt;= return . (cell:)</span>
<span class="hl str"></span>
<span class="hl str">pieceMasks :: Array Color [Mask]</span>
<span class="hl str">pieceMasks = amap pieceMasks'</span> pieces <span class="hl kwa">where</span>
	pieceMasks<span class="hl str">' piece</span>
<span class="hl str">		| piece == (pieces!5) = do</span>
<span class="hl str">			piece'</span> <span class="hl sym">&lt;- (</span>take <span class="hl num">3</span> $ iterate rot piece<span class="hl sym">) ++ (</span>take <span class="hl num">3</span> $ iterate rot $ flop $ piece<span class="hl sym">)</span>
			filter noIslands $ map mask $ mapMaybe <span class="hl sym">(</span>placePiece piece<span class="hl str">') cellcs</span>
<span class="hl str"></span>
<span class="hl str">		| otherwise = do</span>
<span class="hl str">			piece'</span> <span class="hl sym">&lt;- (</span>take <span class="hl num">6</span> $ iterate rot piece<span class="hl sym">) ++ (</span>take <span class="hl num">6</span> $ iterate rot $ flop $ piece<span class="hl sym">)</span>
			filter noIslands $ map mask $ mapMaybe <span class="hl sym">(</span>placePiece piece<span class="hl str">') cellcs</span>
<span class="hl str"></span>
<span class="hl str">pieceMasksAtCell :: Array Color (Array CellIndex [Mask])</span>
<span class="hl str">pieceMasksAtCell = amap pieceMasksAtCell'</span> pieceMasks <span class="hl kwa">where</span>
	pieceMasksAtCell<span class="hl str">' masks = array (0,width*height-1) $ pieceMasksAtCell'</span><span class="hl str">' masks cellis where</span>
<span class="hl str">		pieceMasksAtCell'</span><span class="hl str">' masks [] = []</span>
<span class="hl str">		pieceMasksAtCell'</span><span class="hl str">' masks (c:cs) =</span>
<span class="hl str">			let (a,b) = partition (overlap (mask c)) masks</span>
<span class="hl str">			in (c,a) : (pieceMasksAtCell'</span><span class="hl str">' b cs)</span>
<span class="hl str"></span>
<span class="hl str">format :: Color -&gt; Mask -&gt; Integer</span>
<span class="hl str">format c m =  (fromIntegral c) * (binToDec m) where</span>
<span class="hl str">	binToDec :: Mask -&gt; Integer</span>
<span class="hl str">	binToDec 0 = 0</span>
<span class="hl str">	binToDec n = (fromIntegral (mod n 2)) + 10*(binToDec $ div n 2)</span>
<span class="hl str"></span>
<span class="hl str">ps :: Solution -&gt; IO ()</span>
<span class="hl str">ps solution = pe $ map (concatMap (\a -&gt; [a,'</span> <span class="hl str">'])) $</span>
<span class="hl str">					take height $ map (take 5) $ iterate (drop width) solution where</span>
<span class="hl str">	po [] = return ()</span>
<span class="hl str">	po (s:ss) = do</span>
<span class="hl str">		putStrLn $ '</span> <span class="hl str">':s</span>
<span class="hl str">		pe ss</span>
<span class="hl str"></span>
<span class="hl str">	pe [] = return ()</span>
<span class="hl str">	pe (s:ss) = do</span>
<span class="hl str">		putStrLn s</span>
<span class="hl str">		po ss</span>
<span class="hl str"></span>
<span class="hl str">solutions :: [Solution]</span>
<span class="hl str">solutions = solutions'</span> <span class="hl num">0 0</span> <span class="hl sym">[</span><span class="hl num">0</span>.<span class="hl num">.9</span><span class="hl sym">] (</span><span class="hl num">10</span>^<span class="hl sym">(</span>width<span class="hl sym">*</span>height<span class="hl sym">))</span> <span class="hl kwa">where</span>

	solutions<span class="hl str">' :: Mask -&gt; CellIndex -&gt; [Color] -&gt; Integer-&gt; [Solution]</span>
<span class="hl str">	solutions'</span> _ _ <span class="hl sym">[]</span> i <span class="hl sym">=</span> 	<span class="hl kwa">let</span> s <span class="hl sym">=</span> tail.show $ i <span class="hl kwa">in</span> <span class="hl sym">[</span>s<span class="hl sym">,</span> reverse s<span class="hl sym">]</span>
	solutions<span class="hl str">' board cell colorsLeft i</span>
<span class="hl str">		| overlap board (mask cell) = solutions'</span> board <span class="hl sym">(</span>cell<span class="hl sym">+</span><span class="hl num">1</span><span class="hl sym">)</span> colorsLeft i
		<span class="hl sym">|</span> otherwise <span class="hl sym">=</span> <span class="hl kwa">do</span>
			color <span class="hl sym">&lt;-</span> colorsLeft
			mask <span class="hl sym">&lt;-</span> filter <span class="hl sym">(</span>legal board<span class="hl sym">)</span> $ pieceMasksAtCell<span class="hl sym">!</span>color<span class="hl sym">!</span>cell
			solutions<span class="hl str">' (board .|. mask) (cell+1) (delete color colorsLeft) (i + (format color mask))</span>
<span class="hl str"></span>
<span class="hl str"></span>
<span class="hl str">main = do</span>
<span class="hl str">	(n :: Int) &lt;- return.read.head =&lt;&lt; getArgs</span>
<span class="hl str">	let nsolutions = take n solutions</span>
<span class="hl str">	putStrLn $ (show $ length nsolutions) ++ &quot; solutions found\n&quot;</span>
<span class="hl str">	ps $ minimum nsolutions</span>
<span class="hl str">	putStr &quot;\n&quot;</span>
<span class="hl str">	ps $ maximum nsolutions</span>
<span class="hl str">	putStr &quot;\n&quot;</span>
