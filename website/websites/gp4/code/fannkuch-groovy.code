<span class="dir">#!/bin/env groovy</span>
<span class="com">/*</span>
<span class="com">	$Id: fannkuch-groovy.code,v 1.2 2005-10-29 23:09:23 igouy-guest Exp $</span>
<span class="com"></span>
<span class="com">	The Great Computer Language Shootout</span>
<span class="com">	http://shootout.alioth.debian.org/</span>
<span class="com"></span>
<span class="com">	contributed by Jochen Hinrichsen</span>
<span class="com">*/</span>

<span class="slc">// This algorithm taken from the ruby sample does not produce the exact order as defined above</span>
def <span class="kwd">permute</span><span class="sym">(</span>head<span class="sym">,</span> tail<span class="sym">,</span> permute<span class="sym">) {</span>
	<span class="kwa">for</span> <span class="sym">(</span>i in <span class="num">0</span><span class="sym">..&lt;</span>tail<span class="sym">.</span><span class="kwd">size</span><span class="sym">()) {</span>
		head<span class="sym">.</span><span class="kwd">add</span><span class="sym">(</span>tail<span class="sym">.</span><span class="kwd">remove</span><span class="sym">(</span>i<span class="sym">))</span>
		tail<span class="sym">.</span><span class="kwd">isEmpty</span><span class="sym">()</span> ? <span class="kwd">permute</span><span class="sym">(</span>head<span class="sym">.</span><span class="kwd">clone</span><span class="sym">()) :</span> <span class="kwd">permute</span><span class="sym">(</span>head<span class="sym">,</span> tail<span class="sym">,</span> permute<span class="sym">)</span>
		tail<span class="sym">.</span><span class="kwd">add</span><span class="sym">(</span>i<span class="sym">,</span> head<span class="sym">.</span><span class="kwd">pop</span><span class="sym">())</span>
	<span class="sym">}</span>
<span class="sym">}</span>

def <span class="kwd">permute</span><span class="sym">(</span>size<span class="sym">,</span> closure<span class="sym">) {</span>
	<span class="kwd">permute</span><span class="sym">([], (</span><span class="num">1</span><span class="sym">..</span>size<span class="sym">).</span><span class="kwd">step</span><span class="sym">(</span><span class="num">1</span><span class="sym">),</span> closure<span class="sym">)</span>
<span class="sym">}</span>

def N <span class="sym">= (</span>args<span class="sym">.</span>length <span class="sym">==</span> <span class="num">0</span><span class="sym">)</span> ? <span class="num">7</span> <span class="sym">:</span> args<span class="sym">[</span><span class="num">0</span><span class="sym">].</span><span class="kwd">toInteger</span><span class="sym">()</span>
def maxflips <span class="sym">=</span> <span class="num">0</span>

<span class="kwd">permute</span><span class="sym">(</span>N<span class="sym">) { |</span>list<span class="sym">|</span>
	def flips <span class="sym">=</span> <span class="num">0</span>
	<span class="kwa">while</span> <span class="sym">((</span>count <span class="sym">=</span> list<span class="sym">[</span><span class="num">0</span><span class="sym">]) !=</span> <span class="num">1</span><span class="sym">) {</span>
		<span class="slc">// Inconsistent groovy syntax, lvalue list[0..&lt;count] does not work</span>
		<span class="slc">// Option #1</span>
		<span class="slc">// list[0, count-1] = list[0..&lt;count].reverse()</span>

		<span class="slc">// Option #2: more Java like alternative, little bit faster</span>
		Collections<span class="sym">.</span><span class="kwd">copy</span><span class="sym">(</span>list<span class="sym">,</span> list<span class="sym">[</span><span class="num">0</span><span class="sym">..&lt;</span>count<span class="sym">].</span><span class="kwd">reverse</span><span class="sym">())</span>

		flips<span class="sym">++</span>
	<span class="sym">}</span>
	maxflips <span class="sym">= [</span>maxflips<span class="sym">,</span> flips<span class="sym">].</span><span class="kwd">max</span><span class="sym">()</span>
<span class="sym">}</span>

println <span class="str">&quot;Pfannkuchen(${N}) = ${maxflips}&quot;</span>

<span class="slc">// EOF</span>

