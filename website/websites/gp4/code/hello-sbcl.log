BUILD COMMANDS FOR: hello.sbcl

Sun Jul 23 21:28:38 PDT 2006

SBCL built with: /usr/bin/sbcl --userinit /dev/null --sysinit /dev/null -batch -eval '(load "hello.sbcl_compile")'
### START hello.sbcl_compile
(proclaim '(optimize (speed 3) (safety 0) (debug 0) (compilation-speed 0) (space 0)))
(asdf:operate 'asdf:load-op 'cl-ppcre)
(handler-bind ((sb-ext:defconstant-uneql      (lambda (c) (abort c))))      (load (compile-file "hello.sbcl" ))) (save-lisp-and-die "sbcl.core" :purify t)
### END hello.sbcl_compile

; loading system definition from /usr/share/common-lisp/systems/cl-ppcre.asd
; into #<PACKAGE "ASDF0">
; registering #<SYSTEM #:CL-PPCRE {A93B9A9}> as CL-PPCRE
; compiling file "/usr/share/common-lisp/source/cl-ppcre/packages.lisp" (written 12 JUN 2006 10:18:57 PM):
; compiling (IN-PACKAGE :CL-USER)
; compiling (DEFPACKAGE #:CL-PPCRE ...)
; compiling (DEFPACKAGE #:CL-PPCRE-TEST ...)

; /var/cache/common-lisp-controller/1000/sbcl/cl-ppcre/packages.fasl written
; compilation finished in 0:00:00
; compiling file "/usr/share/common-lisp/source/cl-ppcre/specials.lisp" (written 12 JUN 2006 10:18:57 PM):
; compiling (IN-PACKAGE #:CL-PPCRE)
; compiling (DEFVAR *STANDARD-OPTIMIZE-SETTINGS* ...)
; compiling (DEFVAR *SPECIAL-OPTIMIZE-SETTINGS* ...)
; compiling (DEFVAR *EXTENDED-MODE-P* ...)
; compiling (DECLAIM (TYPE BOOLEAN ...))
; compiling (DEFVAR *STRING* ...)
; compiling (DECLAIM (TYPE SIMPLE-STRING ...))
; compiling (DEFVAR *START-POS* ...)
; compiling (DECLAIM (TYPE FIXNUM ...))
; compiling (DEFVAR *REAL-START-POS* ...)
; compiling (DECLAIM (TYPE # ...))
; compiling (DEFVAR *END-POS* ...)
; compiling (DECLAIM (TYPE FIXNUM ...))
; compiling (DEFVAR *REG-STARTS* ...)
; compiling (DECLAIM (TYPE SIMPLE-VECTOR ...))
; compiling (DEFVAR *REGS-MAYBE-START* ...)
; compiling (DECLAIM (TYPE SIMPLE-VECTOR ...))
; compiling (DEFVAR *REG-ENDS* ...)
; compiling (DECLAIM (TYPE SIMPLE-VECTOR ...))
; compiling (DEFVAR *END-STRING-POS* ...)
; compiling (DEFVAR *REP-NUM* ...)
; compiling (DECLAIM (TYPE FIXNUM ...))
; compiling (DEFVAR *ZERO-LENGTH-NUM* ...)
; compiling (DECLAIM (TYPE FIXNUM ...))
; compiling (DEFVAR *REPEAT-COUNTERS* ...)
; compiling (DECLAIM (TYPE # ...))
; compiling (DEFVAR *LAST-POS-STORES* ...)
; compiling (DECLAIM (TYPE SIMPLE-VECTOR ...))
; compiling (DEFVAR *USE-BMH-MATCHERS* ...)
; compiling (DEFVAR *ALLOW-QUOTING* ...)
; compiling (PUSHNEW :CL-PPCRE ...)
; compiling (DEFVAR *HYPERDOC-BASE-URI* ...)
; compiling (LET (#) ...); in: LAMBDA (#:WHOLE137 #:ENVIRONMENT138)
;     (MEMBER SB-IMPL::THIS-KIND '(:EXTERNAL))
; --> BLOCK LET DO BLOCK LET TAGBODY TAGBODY LET IF SB-IMPL::SATISFIES-THE-TEST 
; --> LET COND IF COND IF COND IF PROGN FUNCALL 
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G26 #:G27)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a SINGLE-FLOAT.
;   The second argument is a T, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a DOUBLE-FLOAT.
;   The second argument is a T, not a DOUBLE-FLOAT.
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

; file: /usr/share/common-lisp/source/cl-ppcre/specials.lisp
; in:
;      LET ((EXPORTED-SYMBOLS-ALIST
;        (LOOP FOR
;              SYMBOL
;              BEING
;              THE
;              EXTERNAL-SYMBOLS
;              OF
;              :CL-PPCRE
;              COLLECT
;              (CONS SYMBOL (CONCATENATE 'STRING "#" #)))))
;     (LOOP CL-PPCRE::FOR
;         SYMBOL
;         CL-PPCRE::BEING
;         THE
;         CL-PPCRE::EXTERNAL-SYMBOLS
;         CL-PPCRE::OF
;         :CL-PPCRE
;         CL-PPCRE::COLLECT
;         (CONS SYMBOL (CONCATENATE 'STRING "#" (STRING-DOWNCASE SYMBOL))))
; --> BLOCK LET WITH-PACKAGE-ITERATOR LET* MACROLET WHEN COND IF PROGN FLET 
; --> BLOCK > IF 
; ==>
;   (> NUMBER 1)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.


; /var/cache/common-lisp-controller/1000/sbcl/cl-ppcre/specials.fasl written
; compilation finished in 0:00:00
; compiling file "/usr/share/common-lisp/source/cl-ppcre/util.lisp" (written 12 JUN 2006 10:18:57 PM):
; compiling (IN-PACKAGE #:CL-PPCRE)
; compiling (DEFMACRO WITH-UNIQUE-NAMES ...)
; compiling (DEFMACRO WITH-REBINDING ...)
; compiling (DEFVAR *REGEX-CHAR-CODE-LIMIT* ...)
; compiling (DECLAIM (TYPE FIXNUM ...))
; compiling (DEFUN MAKE-CHAR-HASH ...); in: LAMBDA NIL
;     (FUNCALL CL-PPCRE::TEST CL-PPCRE::CHR)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR FUNCTION SYMBOL), not a FUNCTION.

; file: /usr/share/common-lisp/source/cl-ppcre/util.lisp
; in: DEFUN MAKE-CHAR-HASH
;     (FUNCALL CL-PPCRE::TEST CL-PPCRE::CHR)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR FUNCTION SYMBOL), not a FUNCTION.

; compiling (DECLAIM (INLINE WORD-CHAR-P))
; compiling (DEFUN WORD-CHAR-P ...); in: LAMBDA NIL
;     (ALPHANUMERICP CL-PPCRE::CHR)
; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; file: /usr/share/common-lisp/source/cl-ppcre/util.lisp
; in: DEFUN WORD-CHAR-P
;     (ALPHANUMERICP CL-PPCRE::CHR)
; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; compiling (UNLESS (BOUNDP #) ...)
; compiling (DEFUN WHITESPACEP ...)
; compiling (UNLESS (BOUNDP #) ...)
; compiling (UNLESS (BOUNDP #) ...)
; compiling (UNLESS (BOUNDP #) ...)
; compiling (DEFUN MERGE-HASH ...)
; compiling (DEFUN MERGE-INVERTED-HASH ...)
; compiling (DEFUN CREATE-RANGES-FROM-HASH ...)
; file: /usr/share/common-lisp/source/cl-ppcre/util.lisp
; in: DEFUN CREATE-RANGES-FROM-HASH
;     (CHAR-DOWNCASE CL-PPCRE::CHR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

; compiling (DEFMACRO MAYBE-COERCE-TO-SIMPLE-STRING ...)
; compiling (DECLAIM (INLINE NSUBSEQ))
; compiling (DEFUN NSUBSEQ ...)
; file: /usr/share/common-lisp/source/cl-ppcre/util.lisp
; in: DEFUN NSUBSEQ
;     (LENGTH SEQUENCE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN NORMALIZE-VAR-LIST ...)
; compiling (DEFUN STRING-LIST-TO-SIMPLE-STRING ...)
; file: /usr/share/common-lisp/source/cl-ppcre/util.lisp
; in: DEFUN STRING-LIST-TO-SIMPLE-STRING
;     (REPLACE CL-PPCRE::RESULT-STRING STRING :START1 CL-PPCRE::CURR-POS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a STRING, not a (SIMPLE-ARRAY CHARACTER (*)).


; /var/cache/common-lisp-controller/1000/sbcl/cl-ppcre/util.fasl written
; compilation finished in 0:00:01
STYLE-WARNING: redefining MAKE-CHAR-HASH in DEFUN
STYLE-WARNING: redefining WORD-CHAR-P in DEFUN
STYLE-WARNING: redefining WHITESPACEP in DEFUN
; compiling file "/usr/share/common-lisp/source/cl-ppcre/errors.lisp" (written 12 JUN 2006 10:18:57 PM):
; compiling (IN-PACKAGE #:CL-PPCRE)
; compiling (DEFVAR *SYNTAX-ERROR-STRING* ...)
; compiling (DEFINE-CONDITION PPCRE-ERROR ...)
; compiling (DEFINE-CONDITION PPCRE-SYNTAX-ERROR ...)
; file: /usr/share/common-lisp/source/cl-ppcre/errors.lisp
; in: DEFINE-CONDITION PPCRE-SYNTAX-ERROR
;     (FORMAT STREAM
;           "~?~@[ at position ~A~]~@[ in string ~S~]"
;           (SIMPLE-CONDITION-FORMAT-CONTROL CONDITION)
;           (SIMPLE-CONDITION-FORMAT-ARGUMENTS CONDITION)
;           (CL-PPCRE:PPCRE-SYNTAX-ERROR-POS CONDITION)
;           (CL-PPCRE:PPCRE-SYNTAX-ERROR-STRING CONDITION))
; ==>
;   (FORMAT SB-C::DEST
;           (FORMATTER "~?~@[ at position ~A~]~@[ in string ~S~]")
;           #:G4
;           #:G5
;           #:G6
;           #:G7)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (MEMBER T NIL)
;                               STREAM
;                               (VECTOR CHARACTER)
;                               (VECTOR NIL)
;                               BASE-STRING), not a STREAM.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (MEMBER T NIL)
;                               STREAM
;                               (VECTOR CHARACTER)
;                               (VECTOR NIL)
;                               BASE-STRING), not a (MEMBER T).

; compiling (SETF (DOCUMENTATION # ...) ...)
; compiling (SETF (DOCUMENTATION # ...) ...)
; compiling (DEFINE-CONDITION PPCRE-INVOCATION-ERROR ...)
; compiling (DEFMACRO SIGNAL-PPCRE-SYNTAX-ERROR* ...)
; compiling (DEFMACRO SIGNAL-PPCRE-SYNTAX-ERROR ...)
; compiling (DEFMACRO SIGNAL-PPCRE-INVOCATION-ERROR ...)

; /var/cache/common-lisp-controller/1000/sbcl/cl-ppcre/errors.fasl written
; compilation finished in 0:00:00
; compiling file "/usr/share/common-lisp/source/cl-ppcre/lexer.lisp" (written 12 JUN 2006 10:18:57 PM):
; compiling (IN-PACKAGE #:CL-PPCRE)
; compiling (DECLAIM (INLINE MAP-CHAR-TO-SPECIAL-CLASS))
; compiling (DEFUN MAP-CHAR-TO-SPECIAL-CHAR-CLASS ...)
; compiling (DEFSTRUCT (LEXER #) ...)
; compiling (DEFUN MAKE-LEXER ...)
; compiling (DECLAIM (INLINE END-OF-STRING-P))
; compiling (DEFUN END-OF-STRING-P ...)
; compiling (DECLAIM (INLINE LOOKING-AT-P))
; compiling (DEFUN LOOKING-AT-P ...)
; compiling (DECLAIM (INLINE NEXT-CHAR-NON-EXTENDED))
; compiling (DEFUN NEXT-CHAR-NON-EXTENDED ...)
; compiling (DEFUN NEXT-CHAR ...)
; file: /usr/share/common-lisp/source/cl-ppcre/lexer.lisp
; in: DEFUN NEXT-CHAR
;     (CL-PPCRE::SIGNAL-PPCRE-SYNTAX-ERROR* CL-PPCRE::ERROR-POS
;                                         "Comment group not closed")
; ==>
;   (ERROR 'CL-PPCRE:PPCRE-SYNTAX-ERROR
;          :POS
;          CL-PPCRE::ERROR-POS
;          :FORMAT-CONTROL
;          "Comment group not closed"
;          :FORMAT-ARGUMENTS
;          (LIST))
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DECLAIM (INLINE FAIL))
; compiling (DEFUN FAIL ...)
; compiling (DEFUN GET-NUMBER ...)
; file: /usr/share/common-lisp/source/cl-ppcre/lexer.lisp
; in: DEFUN GET-NUMBER
;     (IF (< CL-PPCRE::END-POS CL-PPCRE::LEXER-LEN)
;       CL-PPCRE::END-POS
;       CL-PPCRE::LEXER-LEN)
; ==>
;   CL-PPCRE::END-POS
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DECLAIM (INLINE TRY-NUMBER))
; compiling (DEFUN TRY-NUMBER ...)
; compiling (DECLAIM (INLINE MAKE-CHAR-FROM-CODE))
; compiling (DEFUN MAKE-CHAR-FROM-CODE ...)
; file: /usr/share/common-lisp/source/cl-ppcre/lexer.lisp
; in: DEFUN MAKE-CHAR-FROM-CODE
;     (CL-PPCRE::SIGNAL-PPCRE-SYNTAX-ERROR* CL-PPCRE::ERROR-POS
;                                         "No character for hex-code ~X"
;                                         NUMBER)
; --> ERROR 
; ==>
;   CL-PPCRE::ERROR-POS
; 
; note: deleting unreachable code

; compiling (DEFUN UNESCAPE-CHAR ...)
; file: /usr/share/common-lisp/source/cl-ppcre/lexer.lisp
; in: DEFUN MAKE-CHAR-FROM-CODE
;     (CL-PPCRE::SIGNAL-PPCRE-SYNTAX-ERROR* CL-PPCRE::ERROR-POS
;                                         "No character for hex-code ~X"
;                                         NUMBER)
; --> ERROR 
; ==>
;   "No character for hex-code ~X"
; 
; note: deleting unreachable code
; 
; note: deleting unreachable code

; in: DEFUN UNESCAPE-CHAR
;     (CHAR-UPCASE CL-PPCRE::NEXT-CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

; compiling (DEFUN COLLECT-CHAR-CLASS ...)
; compiling (DEFUN MAYBE-PARSE-FLAGS ...)
; compiling (DEFUN GET-QUANTIFIER ...)
; compiling (DEFUN GET-TOKEN ...)
; file: /usr/share/common-lisp/source/cl-ppcre/lexer.lisp
; in: DEFUN MAKE-CHAR-FROM-CODE
;     (CL-PPCRE::SIGNAL-PPCRE-SYNTAX-ERROR* CL-PPCRE::ERROR-POS
;                                         "No character for hex-code ~X"
;                                         NUMBER)
; --> ERROR 
; ==>
;   "No character for hex-code ~X"
; 
; note: deleting unreachable code

; ==>
;   CL-PPCRE::ERROR-POS
; 
; note: deleting unreachable code

; in: DEFUN GET-TOKEN
;     (SUBSEQ (CL-PPCRE::LEXER-STR CL-PPCRE::LEXER)
;           (CAR CL-PPCRE::THIS-LAST-POS)
;           (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES SIMPLE-BASE-STRING &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY CHARACTER (*))
;                                              &REST
;                                              T).

;     (SUBSEQ (CL-PPCRE::LEXER-STR CL-PPCRE::LEXER)
;           (CAR (CL-PPCRE::LEXER-LAST-POS CL-PPCRE::LEXER))
;           (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES SIMPLE-BASE-STRING &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY CHARACTER (*))
;                                              &REST
;                                              T).

;     (CL-PPCRE::SIGNAL-PPCRE-SYNTAX-ERROR*
;    (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER))
;    "Character '~A' may not follow '(?<'"
;    CL-PPCRE::NEXT-CHAR)
; ==>
;   (ERROR 'CL-PPCRE:PPCRE-SYNTAX-ERROR
;          :POS
;          (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER))
;          :FORMAT-CONTROL
;          "Character '~A' may not follow '(?<'"
;          :FORMAT-ARGUMENTS
;          (LIST CL-PPCRE::NEXT-CHAR))
; 
; note: doing signed word to integer coercion (cost 20)

;     (CL-PPCRE::SIGNAL-PPCRE-SYNTAX-ERROR*
;    (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER))
;    "Character '~A' may not follow '(?'"
;    CL-PPCRE::NEXT-CHAR)
; ==>
;   (ERROR 'CL-PPCRE:PPCRE-SYNTAX-ERROR
;          :POS
;          (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER))
;          :FORMAT-CONTROL
;          "Character '~A' may not follow '(?'"
;          :FORMAT-ARGUMENTS
;          (LIST CL-PPCRE::NEXT-CHAR))
; 
; note: doing signed word to integer coercion (cost 20)

;     (CL-PPCRE::SIGNAL-PPCRE-SYNTAX-ERROR*
;    (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER))
;    "Quantifier '~A' not allowed"
;    CL-PPCRE::NEXT-CHAR)
; ==>
;   (ERROR 'CL-PPCRE:PPCRE-SYNTAX-ERROR
;          :POS
;          (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER))
;          :FORMAT-CONTROL
;          "Quantifier '~A' not allowed"
;          :FORMAT-ARGUMENTS
;          (LIST CL-PPCRE::NEXT-CHAR))
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DECLAIM (INLINE UNGET-TOKEN))
; compiling (DEFUN UNGET-TOKEN ...)
; compiling (DECLAIM (INLINE START-OF-SUBEXPR-P))
; compiling (DEFUN START-OF-SUBEXPR-P ...)

; /var/cache/common-lisp-controller/1000/sbcl/cl-ppcre/lexer.fasl written
; compilation finished in 0:00:01
; compiling file "/usr/share/common-lisp/source/cl-ppcre/parser.lisp" (written 12 JUN 2006 10:18:57 PM):
; compiling (IN-PACKAGE #:CL-PPCRE)
; compiling (DEFUN GROUP ...)
; file: /usr/share/common-lisp/source/cl-ppcre/parser.lisp
; in: DEFUN GROUP
;     (CL-PPCRE::SIGNAL-PPCRE-SYNTAX-ERROR* (+ CL-PPCRE::OPEN-PAREN-POS 2)
;                                         "Opening paren has no matching closing paren")
; ==>
;   (ERROR 'CL-PPCRE:PPCRE-SYNTAX-ERROR
;          :POS
;          (+ CL-PPCRE::OPEN-PAREN-POS 2)
;          :FORMAT-CONTROL
;          "Opening paren has no matching closing paren"
;          :FORMAT-ARGUMENTS
;          (LIST))
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DEFUN GREEDY-QUANT ...)
; compiling (DEFUN QUANT ...)
; compiling (DEFUN SEQ ...)
; file: /usr/share/common-lisp/source/cl-ppcre/parser.lisp
; in: DEFUN SEQ
;     (SETF (AREF STRING 0) CL-PPCRE::CHAR1)
; --> SB-KERNEL:%ASET LET* SB-KERNEL:HAIRY-DATA-VECTOR-SET MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR CHARACTER), not a SIMPLE-ARRAY.

;     (SETF (AREF STRING 1) CL-PPCRE::CHAR2)
; --> SB-KERNEL:%ASET LET* SB-KERNEL:HAIRY-DATA-VECTOR-SET MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR CHARACTER), not a SIMPLE-ARRAY.

;     (CL-PPCRE::START-OF-SUBEXPR-P CL-PPCRE::LEXER)
; --> BLOCK LET* NOT IF OR LET IF OR PROG1 LET MEMBER BLOCK LET AND IF AND 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-IMPL::KEY)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR FUNCTION SYMBOL), not a FUNCTION.

; --> BLOCK LET* NOT IF OR LET IF OR PROG1 LET MEMBER BLOCK LET IF 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-IMPL::TEST)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR FUNCTION SYMBOL), not a FUNCTION.

; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-IMPL::TEST-NOT)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR FUNCTION SYMBOL), not a FUNCTION.

; compiling (DEFUN REG-EXPR ...)
; compiling (DEFUN REVERSE-STRINGS ...)
; compiling (DEFUN PARSE-STRING ...)

; /var/cache/common-lisp-controller/1000/sbcl/cl-ppcre/parser.fasl written
; compilation finished in 0:00:01
; compiling file "/usr/share/common-lisp/source/cl-ppcre/regex-class.lisp" (written 12 JUN 2006 10:18:57 PM):
; compiling (IN-PACKAGE #:CL-PPCRE)
; compiling (DEFCLASS REGEX ...)
; compiling (DEFCLASS SEQ ...)
; compiling (DEFCLASS ALTERNATION ...)
; compiling (DEFCLASS LOOKAHEAD ...)
; compiling (DEFCLASS LOOKBEHIND ...)
; compiling (DEFCLASS REPETITION ...)
; compiling (DEFCLASS REGISTER ...)
; compiling (DEFCLASS STANDALONE ...)
; compiling (DEFCLASS BACK-REFERENCE ...)
; compiling (DEFCLASS CHAR-CLASS ...)
; compiling (DEFCLASS STR ...)
; compiling (DEFCLASS ANCHOR ...)
; compiling (DEFCLASS EVERYTHING ...)
; compiling (DEFCLASS WORD-BOUNDARY ...)
; compiling (DEFCLASS BRANCH ...)
; compiling (DEFCLASS FILTER ...)
; compiling (DEFCLASS VOID ...)
; compiling (DEFMETHOD INITIALIZE-INSTANCE ...)
; file: /usr/share/common-lisp/source/cl-ppcre/regex-class.lisp
; in: DEFMETHOD INITIALIZE-INSTANCE :AFTER (CHAR-CLASS)
;     (> (HASH-TABLE-COUNT CL-PPCRE::HASH) (/ CL-PPCRE:*REGEX-CHAR-CODE-LIMIT* 2))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a (RATIONAL -268435456 536870911/2), not a FIXNUM.

; compiling (DEFMETHOD INITIALIZE-INSTANCE ...)
; file: /usr/share/common-lisp/source/cl-ppcre/regex-class.lisp
; in: DEFMETHOD INITIALIZE-INSTANCE :AFTER (STR)
;     (LENGTH (CL-PPCRE::STR CL-PPCRE::STR))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFMETHOD LEN ...)
; compiling (DEFMETHOD STR ...)
; compiling (DEFMETHOD SKIP ...)
; compiling (DEFMETHOD START-OF-END-STRING-P ...)
; compiling (DEFGENERIC CASE-MODE ...)
; compiling (DEFMETHOD CASE-MODE ...)
; file: /usr/share/common-lisp/source/cl-ppcre/regex-class.lisp
; in: DEFMETHOD CASE-MODE (STR T)
;     (ZEROP (CL-PPCRE::LEN CL-PPCRE::STR))
; ==>
;   (= (CL-PPCRE::LEN CL-PPCRE::STR) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; compiling (DEFMETHOD CASE-MODE ...)
; compiling (DEFGENERIC COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFGENERIC REMOVE-REGISTERS ...)
; compiling (DEFMETHOD REMOVE-REGISTERS ...)
; compiling (DEFMETHOD REMOVE-REGISTERS ...)
; compiling (DEFMETHOD REMOVE-REGISTERS ...)
; compiling (DEFMETHOD REMOVE-REGISTERS ...)
; compiling (DEFMETHOD REMOVE-REGISTERS ...)
; compiling (DEFMETHOD REMOVE-REGISTERS ...)
; compiling (DEFMETHOD REMOVE-REGISTERS ...)
; compiling (DEFMETHOD REMOVE-REGISTERS ...)
; compiling (DEFMETHOD REMOVE-REGISTERS ...)
; compiling (DEFGENERIC EVERYTHINGP ...)
; compiling (DEFMETHOD EVERYTHINGP ...)
; file: /usr/share/common-lisp/source/cl-ppcre/regex-class.lisp
; in: DEFMETHOD EVERYTHINGP (SEQ)
;     (LENGTH CL-PPCRE::CLEANED-ELEMENTS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR CONS
;                               NULL
;                               (SIMPLE-ARRAY * (*))), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR CONS NULL (SIMPLE-ARRAY * (*))), not a VECTOR.

; compiling (DEFMETHOD EVERYTHINGP ...)
; file: /usr/share/common-lisp/source/cl-ppcre/regex-class.lisp
; in: DEFMETHOD EVERYTHINGP (ALTERNATION)
;     (DEFMETHOD CL-PPCRE::EVERYTHINGP
;              ((CL-PPCRE::ALTERNATION CL-PPCRE::ALTERNATION))
;              (WITH-SLOTS ((CL-PPCRE::CHOICES CL-PPCRE::CHOICES))
;                          CL-PPCRE::ALTERNATION
;                          (AND (= 1 (LENGTH CL-PPCRE::CHOICES))
;                               (CL-PPCRE::EVERYTHINGP
;                                (FIRST CL-PPCRE::CHOICES)))))
; --> PROGN SB-PCL::LOAD-DEFMETHOD SB-INT:NAMED-LAMBDA FUNCTION SYMBOL-MACROLET 
; --> SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET LET SB-PCL::BIND-ARGS 
; --> LET* SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 SB-PCL::PV-ENV LET LET BLOCK 
; --> LET SYMBOL-MACROLET IF = 
; ==>
;   (LENGTH
;    (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 1)
;                           CL-PPCRE::ALTERNATION
;                           0
;                           'CL-PPCRE::CHOICES
;                           '#<STANDARD-CLASS CL-PPCRE::ALTERNATION>))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFMETHOD EVERYTHINGP ...)
; file: /usr/share/common-lisp/source/cl-ppcre/regex-class.lisp
; in: DEFMETHOD EVERYTHINGP (REPETITION)
;     (DEFMETHOD CL-PPCRE::EVERYTHINGP
;              ((CL-PPCRE::REPETITION CL-PPCRE::REPETITION))
;              (WITH-SLOTS
;               ((CL-PPCRE::MAXIMUM CL-PPCRE::MAXIMUM)
;                (CL-PPCRE::MINIMUM CL-PPCRE::MINIMUM)
;                (CL-PPCRE::REGEX CL-PPCRE::REGEX))
;               CL-PPCRE::REPETITION
;               (AND CL-PPCRE::MAXIMUM
;                    (= 1 CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM)
;                    (CL-PPCRE::EVERYTHINGP CL-PPCRE::REGEX))))
; --> PROGN SB-PCL::LOAD-DEFMETHOD SB-INT:NAMED-LAMBDA FUNCTION SYMBOL-MACROLET 
; --> SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET LET SB-PCL::BIND-ARGS 
; --> LET* SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 SB-PCL::PV-ENV LET LET BLOCK 
; --> LET SYMBOL-MACROLET IF IF = 
; --> (LAMBDA (#:G507 #:G506 #:G505) (DECLARE (TYPE NUMBER #:G507 #:G506 #:G505)) (IF (= #:G507 #:G506) (IF (= #:G506 #:G505) T NIL) NIL)) 
; --> IF = = IF 
; ==>
;   (= SB-C::Y 1)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; --> PROGN SB-PCL::LOAD-DEFMETHOD SB-INT:NAMED-LAMBDA FUNCTION SYMBOL-MACROLET 
; --> SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET LET SB-PCL::BIND-ARGS 
; --> LET* SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 SB-PCL::PV-ENV LET LET BLOCK 
; --> LET SYMBOL-MACROLET IF IF = 
; --> (LAMBDA (#:G507 #:G506 #:G505) (DECLARE (TYPE NUMBER #:G507 #:G506 #:G505)) (IF (= #:G507 #:G506) (IF (= #:G506 #:G505) T NIL) NIL)) 
; --> IF IF 
; ==>
;   (= #:G506 #:G505)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.

; compiling (DEFMETHOD EVERYTHINGP ...)
; compiling (DEFMETHOD EVERYTHINGP ...)
; compiling (DEFMETHOD EVERYTHINGP ...)
; compiling (DEFMETHOD EVERYTHINGP ...)
; compiling (DEFGENERIC REGEX-LENGTH ...)
; compiling (DEFMETHOD REGEX-LENGTH ...)
; file: /usr/share/common-lisp/source/cl-ppcre/regex-class.lisp
; in: DEFMETHOD REGEX-LENGTH (SEQ)
;     (LOOP CL-PPCRE::FOR
;         CL-PPCRE::SUB-REGEX
;         CL-PPCRE::IN
;         (CL-PPCRE::ELEMENTS CL-PPCRE::SEQ)
;         CL-PPCRE::FOR
;         CL-PPCRE::LEN
;         =
;         (CL-PPCRE::REGEX-LENGTH CL-PPCRE::SUB-REGEX)
;         IF
;         (NOT CL-PPCRE::LEN)
;         DO
;         ...)
; --> BLOCK LET LET LET SB-LOOP::LOOP-BODY TAGBODY SETQ THE 
; ==>
;   (+ #:LOOP-SUM-570 CL-PPCRE::LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFMETHOD REGEX-LENGTH ...)
; file: /usr/share/common-lisp/source/cl-ppcre/regex-class.lisp
; in: DEFMETHOD REGEX-LENGTH (ALTERNATION)
;     (/= CL-PPCRE::LEN CL-PPCRE::OLD-LEN)
; --> IF 
; ==>
;   (= CL-PPCRE::LEN CL-PPCRE::OLD-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.

; compiling (DEFMETHOD REGEX-LENGTH ...)
; file: /usr/share/common-lisp/source/cl-ppcre/regex-class.lisp
; in: DEFMETHOD REGEX-LENGTH (BRANCH)
;     (EQL CL-PPCRE::THEN-LENGTH
;        (CL-PPCRE::REGEX-LENGTH (CL-PPCRE::ELSE-REGEX CL-PPCRE::BRANCH)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a SINGLE-FLOAT.
;   The second argument is a T, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a DOUBLE-FLOAT.
;   The second argument is a T, not a DOUBLE-FLOAT.
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

; compiling (DEFMETHOD REGEX-LENGTH ...)
; file: /usr/share/common-lisp/source/cl-ppcre/regex-class.lisp
; in: DEFMETHOD REGEX-LENGTH (REPETITION)
;     (DEFMETHOD CL-PPCRE::REGEX-LENGTH
;              ((CL-PPCRE::REPETITION CL-PPCRE::REPETITION))
;              (WITH-SLOTS
;               ((CL-PPCRE::LEN CL-PPCRE::LEN)
;                (CL-PPCRE::MINIMUM CL-PPCRE::MINIMUM)
;                (CL-PPCRE::MAXIMUM CL-PPCRE::MAXIMUM))
;               CL-PPCRE::REPETITION
;               (IF (AND CL-PPCRE::LEN (EQL CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM))
;                   (* CL-PPCRE::MINIMUM CL-PPCRE::LEN)
;                   NIL)))
; --> PROGN SB-PCL::LOAD-DEFMETHOD SB-INT:NAMED-LAMBDA FUNCTION SYMBOL-MACROLET 
; --> SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET LET SB-PCL::BIND-ARGS 
; --> LET* SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 SB-PCL::PV-ENV LET LET BLOCK 
; --> LET SYMBOL-MACROLET IF IF 
; ==>
;   (EQL
;    (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 3)
;                           CL-PPCRE::REPETITION
;                           0
;                           'CL-PPCRE::MINIMUM
;                           '#<STANDARD-CLASS CL-PPCRE::REPETITION>)
;    (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 2)
;                           CL-PPCRE::REPETITION
;                           0
;                           'CL-PPCRE::MAXIMUM
;                           '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a SINGLE-FLOAT.
;   The second argument is a T, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a DOUBLE-FLOAT.
;   The second argument is a T, not a DOUBLE-FLOAT.

; --> PROGN SB-PCL::LOAD-DEFMETHOD SB-INT:NAMED-LAMBDA FUNCTION SYMBOL-MACROLET 
; --> SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET LET SB-PCL::BIND-ARGS 
; --> LET* SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 SB-PCL::PV-ENV LET LET BLOCK 
; --> LET SYMBOL-MACROLET IF 
; ==>
;   (*
;    (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 3)
;                           CL-PPCRE::REPETITION
;                           0
;                           'CL-PPCRE::MINIMUM
;                           '#<STANDARD-CLASS CL-PPCRE::REPETITION>)
;    (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 1)
;                           CL-PPCRE::REPETITION
;                           0
;                           'CL-PPCRE::LEN
;                           '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.

; --> PROGN SB-PCL::LOAD-DEFMETHOD SB-INT:NAMED-LAMBDA FUNCTION SYMBOL-MACROLET 
; --> SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET LET SB-PCL::BIND-ARGS 
; --> LET* SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 SB-PCL::PV-ENV LET LET BLOCK 
; --> LET SYMBOL-MACROLET IF IF 
; ==>
;   (EQL
;    (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 3)
;                           CL-PPCRE::REPETITION
;                           0
;                           'CL-PPCRE::MINIMUM
;                           '#<STANDARD-CLASS CL-PPCRE::REPETITION>)
;    (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 2)
;                           CL-PPCRE::REPETITION
;                           0
;                           'CL-PPCRE::MAXIMUM
;                           '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

; --> PROGN SB-PCL::LOAD-DEFMETHOD SB-INT:NAMED-LAMBDA FUNCTION SYMBOL-MACROLET 
; --> SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET LET SB-PCL::BIND-ARGS 
; --> LET* SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 SB-PCL::PV-ENV LET LET BLOCK 
; --> LET SYMBOL-MACROLET IF 
; ==>
;   (*
;    (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 3)
;                           CL-PPCRE::REPETITION
;                           0
;                           'CL-PPCRE::MINIMUM
;                           '#<STANDARD-CLASS CL-PPCRE::REPETITION>)
;    (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 1)
;                           CL-PPCRE::REPETITION
;                           0
;                           'CL-PPCRE::LEN
;                           '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       etc.

; compiling (DEFMETHOD REGEX-LENGTH ...)
; compiling (DEFMETHOD REGEX-LENGTH ...)
; compiling (DEFMETHOD REGEX-LENGTH ...)
; compiling (DEFMETHOD REGEX-LENGTH ...)
; compiling (DEFMETHOD REGEX-LENGTH ...)
; compiling (DEFMETHOD REGEX-LENGTH ...)
; compiling (DEFMETHOD REGEX-LENGTH ...)
; compiling (DEFMETHOD REGEX-LENGTH ...)
; compiling (DEFGENERIC REGEX-MIN-LENGTH ...)
; compiling (DEFMETHOD REGEX-MIN-LENGTH ...)
; file: /usr/share/common-lisp/source/cl-ppcre/regex-class.lisp
; in: DEFMETHOD REGEX-MIN-LENGTH (SEQ)
;     (LOOP CL-PPCRE::FOR
;         CL-PPCRE::SUB-REGEX
;         CL-PPCRE::IN
;         (CL-PPCRE::ELEMENTS CL-PPCRE::SEQ)
;         CL-PPCRE::FOR
;         CL-PPCRE::LEN
;         =
;         (CL-PPCRE::REGEX-MIN-LENGTH CL-PPCRE::SUB-REGEX)
;         CL-PPCRE::SUM
;         CL-PPCRE::LEN)
; --> BLOCK LET LET LET SB-LOOP::LOOP-BODY TAGBODY SETQ THE 
; ==>
;   (+ #:LOOP-SUM-693 CL-PPCRE::LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFMETHOD REGEX-MIN-LENGTH ...)
; file: /usr/share/common-lisp/source/cl-ppcre/regex-class.lisp
; in: DEFMETHOD REGEX-MIN-LENGTH (ALTERNATION)
;     (LOOP CL-PPCRE::FOR
;         CL-PPCRE::SUB-REGEX
;         CL-PPCRE::IN
;         (CL-PPCRE::CHOICES CL-PPCRE::ALTERNATION)
;         CL-PPCRE::FOR
;         CL-PPCRE::LEN
;         =
;         (CL-PPCRE::REGEX-MIN-LENGTH CL-PPCRE::SUB-REGEX)
;         CL-PPCRE::MINIMIZE
;         CL-PPCRE::LEN)
; --> BLOCK LET LET SB-LOOP::WITH-MINIMAX-VALUE LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN COND IF OR LET IF OR < 
; --> IF 
; ==>
;   (< #:LOOP-MAXMIN-TEMP-706 #:LOOP-MAXMIN-705)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFMETHOD REGEX-MIN-LENGTH ...)
; file: /usr/share/common-lisp/source/cl-ppcre/regex-class.lisp
; in: DEFMETHOD REGEX-MIN-LENGTH (BRANCH)
;     (MIN (CL-PPCRE::REGEX-MIN-LENGTH (CL-PPCRE::THEN-REGEX CL-PPCRE::BRANCH))
;        (CL-PPCRE::REGEX-MIN-LENGTH (CL-PPCRE::ELSE-REGEX CL-PPCRE::BRANCH)))
; --> LET LET IF <= IF 
; ==>
;   (> #:ONCE-ONLY-714 SB-C::MINREST)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFMETHOD REGEX-MIN-LENGTH ...)
; file: /usr/share/common-lisp/source/cl-ppcre/regex-class.lisp
; in: DEFMETHOD REGEX-MIN-LENGTH (REPETITION)
;     (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;      (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       etc.

; compiling (DEFMETHOD REGEX-MIN-LENGTH ...)
; compiling (DEFMETHOD REGEX-MIN-LENGTH ...)
; compiling (DEFMETHOD REGEX-MIN-LENGTH ...)
; compiling (DEFMETHOD REGEX-MIN-LENGTH ...)
; compiling (DEFMETHOD REGEX-MIN-LENGTH ...)
; compiling (DEFMETHOD REGEX-MIN-LENGTH ...)
; compiling (DEFMETHOD REGEX-MIN-LENGTH ...)
; compiling (DEFGENERIC COMPUTE-OFFSETS ...)
; compiling (DEFMETHOD COMPUTE-OFFSETS ...)
; compiling (DEFMETHOD COMPUTE-OFFSETS ...)
; file: /usr/share/common-lisp/source/cl-ppcre/regex-class.lisp
; in: DEFMETHOD COMPUTE-OFFSETS (ALTERNATION T)
;     (/= CL-PPCRE::CURR-OFFSET CL-PPCRE::OLD-OFFSET)
; --> IF 
; ==>
;   (= CL-PPCRE::CURR-OFFSET CL-PPCRE::OLD-OFFSET)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.

; compiling (DEFMETHOD COMPUTE-OFFSETS ...)
; file: /usr/share/common-lisp/source/cl-ppcre/regex-class.lisp
; in: DEFMETHOD COMPUTE-OFFSETS (BRANCH T)
;     (EQL CL-PPCRE::THEN-OFFSET
;        (CL-PPCRE::COMPUTE-OFFSETS (CL-PPCRE::ELSE-REGEX CL-PPCRE::BRANCH)
;                                   CL-PPCRE::START-POS))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a SINGLE-FLOAT.
;   The second argument is a T, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a DOUBLE-FLOAT.
;   The second argument is a T, not a DOUBLE-FLOAT.
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

; compiling (DEFMETHOD COMPUTE-OFFSETS ...)
; file: /usr/share/common-lisp/source/cl-ppcre/regex-class.lisp
; in: DEFMETHOD COMPUTE-OFFSETS (REPETITION T)
;     (DEFMETHOD CL-PPCRE::COMPUTE-OFFSETS
;              ((CL-PPCRE::REPETITION CL-PPCRE::REPETITION) CL-PPCRE::START-POS)
;              (WITH-SLOTS
;               ((CL-PPCRE::LEN CL-PPCRE::LEN)
;                (CL-PPCRE::MINIMUM CL-PPCRE::MINIMUM)
;                (CL-PPCRE::MAXIMUM CL-PPCRE::MAXIMUM))
;               CL-PPCRE::REPETITION
;               (IF (AND CL-PPCRE::LEN (EQ CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM))
;                   (+ CL-PPCRE::START-POS (* CL-PPCRE::MINIMUM CL-PPCRE::LEN))
;                   NIL)))
; --> PROGN SB-PCL::LOAD-DEFMETHOD SB-INT:NAMED-LAMBDA FUNCTION SYMBOL-MACROLET 
; --> SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET LET SB-PCL::BIND-ARGS 
; --> LET* SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 SB-PCL::PV-ENV LET LET BLOCK 
; --> LET SYMBOL-MACROLET IF + 
; ==>
;   (*
;    (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 3)
;                           CL-PPCRE::REPETITION
;                           0
;                           'CL-PPCRE::MINIMUM
;                           '#<STANDARD-CLASS CL-PPCRE::REPETITION>)
;    (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 1)
;                           CL-PPCRE::REPETITION
;                           0
;                           'CL-PPCRE::LEN
;                           '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.

; --> PROGN SB-PCL::LOAD-DEFMETHOD SB-INT:NAMED-LAMBDA FUNCTION SYMBOL-MACROLET 
; --> SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET LET SB-PCL::BIND-ARGS 
; --> LET* SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 SB-PCL::PV-ENV LET LET BLOCK 
; --> LET SYMBOL-MACROLET IF 
; ==>
;   (+ CL-PPCRE::START-POS
;      (*
;       (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 3)
;                              CL-PPCRE::REPETITION
;                              0
;                              'CL-PPCRE::MINIMUM
;                              '#<STANDARD-CLASS CL-PPCRE::REPETITION>)
;       (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 1)
;                              CL-PPCRE::REPETITION
;                              0
;                              'CL-PPCRE::LEN
;                              '#<STANDARD-CLASS CL-PPCRE::REPETITION>)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

; --> PROGN SB-PCL::LOAD-DEFMETHOD SB-INT:NAMED-LAMBDA FUNCTION SYMBOL-MACROLET 
; --> SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET LET SB-PCL::BIND-ARGS 
; --> LET* SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 SB-PCL::PV-ENV LET LET BLOCK 
; --> LET SYMBOL-MACROLET IF + 
; ==>
;   (*
;    (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 3)
;                           CL-PPCRE::REPETITION
;                           0
;                           'CL-PPCRE::MINIMUM
;                           '#<STANDARD-CLASS CL-PPCRE::REPETITION>)
;    (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 1)
;                           CL-PPCRE::REPETITION
;                           0
;                           'CL-PPCRE::LEN
;                           '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       etc.

; --> PROGN SB-PCL::LOAD-DEFMETHOD SB-INT:NAMED-LAMBDA FUNCTION SYMBOL-MACROLET 
; --> SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET LET SB-PCL::BIND-ARGS 
; --> LET* SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 SB-PCL::PV-ENV LET LET BLOCK 
; --> LET SYMBOL-MACROLET IF 
; ==>
;   (+ CL-PPCRE::START-POS
;      (*
;       (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 3)
;                              CL-PPCRE::REPETITION
;                              0
;                              'CL-PPCRE::MINIMUM
;                              '#<STANDARD-CLASS CL-PPCRE::REPETITION>)
;       (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 1)
;                              CL-PPCRE::REPETITION
;                              0
;                              'CL-PPCRE::LEN
;                              '#<STANDARD-CLASS CL-PPCRE::REPETITION>)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFMETHOD COMPUTE-OFFSETS ...)
; compiling (DEFMETHOD COMPUTE-OFFSETS ...)
; compiling (DEFMETHOD COMPUTE-OFFSETS ...)
; file: /usr/share/common-lisp/source/cl-ppcre/regex-class.lisp
; in: DEFMETHOD COMPUTE-OFFSETS (CHAR-CLASS T)
;     (1+ CL-PPCRE::START-POS)
; ==>
;   (+ CL-PPCRE::START-POS 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFMETHOD COMPUTE-OFFSETS ...)
; file: /usr/share/common-lisp/source/cl-ppcre/regex-class.lisp
; in: DEFMETHOD COMPUTE-OFFSETS (EVERYTHING T)
;     (1+ CL-PPCRE::START-POS)
; ==>
;   (+ CL-PPCRE::START-POS 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFMETHOD COMPUTE-OFFSETS ...)
; file: /usr/share/common-lisp/source/cl-ppcre/regex-class.lisp
; in: DEFMETHOD COMPUTE-OFFSETS (STR T)
;     (+ CL-PPCRE::START-POS (CL-PPCRE::LEN CL-PPCRE::STR))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFMETHOD COMPUTE-OFFSETS ...)
; compiling (DEFMETHOD COMPUTE-OFFSETS ...)
; file: /usr/share/common-lisp/source/cl-ppcre/regex-class.lisp
; in: DEFMETHOD COMPUTE-OFFSETS (FILTER T)
;     (+ CL-PPCRE::START-POS CL-PPCRE::LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFMETHOD COMPUTE-OFFSETS ...)

; /var/cache/common-lisp-controller/1000/sbcl/cl-ppcre/regex-class.fasl written
; compilation finished in 0:00:01
; compiling file "/usr/share/common-lisp/source/cl-ppcre/convert.lisp" (written 12 JUN 2006 10:18:57 PM):
; compiling (IN-PACKAGE #:CL-PPCRE)
; compiling (DEFMACRO CASE-INSENSITIVE-MODE-P ...)
; compiling (DEFMACRO MULTI-LINE-MODE-P ...)
; compiling (DEFMACRO SINGLE-LINE-MODE-P ...)
; compiling (DEFUN SET-FLAG ...)
; compiling (DEFUN ADD-RANGE-TO-HASH ...)
; file: /usr/share/common-lisp/source/cl-ppcre/convert.lisp
; in: DEFUN ADD-RANGE-TO-HASH
;     (CHAR-UPCASE CL-PPCRE::CHR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (CHAR-DOWNCASE CL-PPCRE::CHR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

; compiling (DEFUN CONVERT-CHAR-CLASS-TO-HASH ...)
; file: /usr/share/common-lisp/source/cl-ppcre/convert.lisp
; in: DEFUN CONVERT-CHAR-CLASS-TO-HASH
;     (CEILING (EXPT CL-PPCRE:*REGEX-CHAR-CODE-LIMIT* (/ 1 4)))
; --> CEILING BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL TRUNCATE LET VALUES 
; ==>
;   (- SB-C::X SB-C::RES)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR SINGLE-FLOAT RATIONAL), not a FLOAT.

; --> CEILING BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF 
; --> NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR RATIONAL SINGLE-FLOAT), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> CEILING BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF 
; --> AND IF PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR SINGLE-FLOAT RATIONAL), not a FLOAT.

; --> CEILING BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL TRUNCATE LET 
; ==>
;   (SB-KERNEL:%UNARY-TRUNCATE SB-C::X)
; 
; note: forced to do full call
;       unable to do inline float truncate (cost 5) because:
;       The first argument is a (OR SINGLE-FLOAT RATIONAL), not a SINGLE-FLOAT.
;       The result is a (VALUES INTEGER
;                               &OPTIONAL), not a (VALUES (UNSIGNED-BYTE 32)
;                                                         &REST
;                                                         T).
;       unable to do inline float truncate (cost 5) because:
;       The first argument is a (OR SINGLE-FLOAT RATIONAL), not a SINGLE-FLOAT.
;       The result is a (VALUES INTEGER
;                               &OPTIONAL), not a (VALUES (SIGNED-BYTE 32)
;                                                         &REST
;                                                         T).

; --> CEILING BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL TRUNCATE LET VALUES 
; ==>
;   (- SB-C::X SB-C::RES)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR SINGLE-FLOAT RATIONAL), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES (OR RATIONAL SINGLE-FLOAT)
;                               &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 32) arithmetic (cost 5) because:
;       The first argument is a (OR SINGLE-FLOAT
;                                   RATIONAL), not a (SIGNED-BYTE 32).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 32).
;       The result is a (VALUES (OR RATIONAL SINGLE-FLOAT)
;                               &OPTIONAL), not a (VALUES (SIGNED-BYTE 32)
;                                                         &REST
;                                                         T).
;       etc.

; --> CEILING BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF 
; --> AND IF PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a (OR SINGLE-FLOAT RATIONAL), not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (OR SINGLE-FLOAT RATIONAL), not a FIXNUM.
;       etc.

; --> CEILING BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF VALUES 
; ==>
;   (+ SB-KERNEL::TRU 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (FLOAT (EXPT CL-PPCRE:*REGEX-CHAR-CODE-LIMIT* (/ 1 4)))
; --> IF 
; ==>
;   (SB-KERNEL:%SINGLE-FLOAT SB-C::N)
; 
; note: forced to do full call
;       unable to do inline float coercion (cost 5) because:
;       The first argument is a RATIONAL, not a (SIGNED-BYTE 32).
;       unable to do inline float coercion (cost 6) because:
;       The first argument is a RATIONAL, not a (UNSIGNED-BYTE 32).

; compiling (DEFUN MAYBE-SPLIT-REPETITION ...)
; file: /usr/share/common-lisp/source/cl-ppcre/convert.lisp
; in: DEFUN MAYBE-SPLIT-REPETITION
;     (- CL-PPCRE::MAXIMUM CL-PPCRE::MINIMUM)
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DEFUN MAYBE-ACCUMULATE ...)
; file: /usr/share/common-lisp/source/cl-ppcre/convert.lisp
; in: DEFUN MAYBE-ACCUMULATE
;     (SETF (SUBSEQ (SLOT-VALUE CL-PPCRE::STARTS-WITH 'CL-PPCRE::STR)
;                 (- (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH)
;                    (CL-PPCRE::LEN CL-PPCRE::STR)))
;           (CL-PPCRE::STR CL-PPCRE::STR)
;         (CL-PPCRE::SKIP CL-PPCRE::STR)
;           T)
; --> PROGN SETF LET* MULTIPLE-VALUE-BIND LET PROGN 
; ==>
;   (REPLACE #:G78 #:G80 :START1 #:G79 :END1 NIL)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES SEQUENCE
;                           &OPTIONAL), not a (VALUES SIMPLE-BASE-STRING &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES SEQUENCE
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY CHARACTER (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;   The result is a (VALUES SEQUENCE
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY SINGLE-FLOAT (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-BIT-VECTOR.
;   The second argument is a SEQUENCE, not a SIMPLE-BIT-VECTOR.
;   The result is a (VALUES SEQUENCE
;                           &OPTIONAL), not a (VALUES SIMPLE-BIT-VECTOR &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 2) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 2) (*)).
;   The result is a (VALUES SEQUENCE
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 2)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 4) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 4) (*)).
;   The result is a (VALUES SEQUENCE
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 4)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 7) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 7) (*)).
;   The result is a (VALUES SEQUENCE
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 7)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)).
;   The result is a (VALUES SEQUENCE
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 8)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 15) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 15)
;                                                          (*)).
;   The result is a (VALUES SEQUENCE
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 15)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 16) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 16)
;                                                          (*)).
;   The result is a (VALUES SEQUENCE
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 16)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 29) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 29)
;                                                          (*)).
;   The result is a (VALUES SEQUENCE
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 29)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 31) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 31)
;                                                          (*)).
;   The result is a (VALUES SEQUENCE
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 31)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 32) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 32)
;                                                          (*)).
;   The result is a (VALUES SEQUENCE
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 32)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 8) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 8) (*)).
;   The result is a (VALUES SEQUENCE
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (SIGNED-BYTE 8) (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 16) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 16) (*)).
;   The result is a (VALUES SEQUENCE
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (SIGNED-BYTE 16)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY FIXNUM (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY FIXNUM (*)).
;   The result is a (VALUES SEQUENCE
;                           &OPTIONAL), not a (VALUES (SIMPLE-ARRAY FIXNUM (*))
;                                                     &REST
;                                                     T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 32) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 32) (*)).
;   The result is a (VALUES SEQUENCE
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (SIGNED-BYTE 32)
;                                                            (*))
;                                              &REST
;                                              T).

;     (SETF (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH)
;           (+ (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH)
;              (CL-PPCRE::LEN CL-PPCRE::STR)))
; --> LET* MULTIPLE-VALUE-BIND LET FUNCALL SB-C::%FUNCALL 
; ==>
;   (#<SB-C::GLOBAL-VAR
;      :%SOURCE-NAME (SETF CL-PPCRE::LEN)
;      :TYPE #<SB-KERNEL:FUN-TYPE (FUNCTION # *)>
;      :WHERE-FROM :DECLARED
;      :KIND :GLOBAL-FUNCTION {B0C8CC1}>
;    #:G76 #:G77)
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DEFUN CONVERT-AUX ...)
; file: /usr/share/common-lisp/source/cl-ppcre/convert.lisp
; in: DEFUN CONVERT-AUX
;     (EVERY (LAMBDA (CL-PPCRE::ITEM) (EQ CL-PPCRE::ITEM :NON-WORD-CHAR-CLASS))
;          CL-PPCRE::ITEM-LIST)
; --> LET BLOCK MAP TRULY-THE 
; ==>
;   (SB-KERNEL:%MAP SB-C::RESULT-TYPE-ARG SB-C::FUN #:G237)
; 
; note: unable to open code because: can't determine sequence argument type

;     (CHAR-EQUAL (FIRST CL-PPCRE::HASH-KEYS) (SECOND CL-PPCRE::HASH-KEYS))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (MEMBER CL-PPCRE::PARSE-TREE
;           '(:NON-DIGIT-CLASS :NON-WORD-CHAR-CLASS :NON-WHITESPACE-CHAR-CLASS)
;           :TEST
;           #'EQ)
; --> BLOCK LET AND IF AND 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-IMPL::KEY)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR FUNCTION SYMBOL), not a FUNCTION.

; --> BLOCK LET IF 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-IMPL::TEST)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR FUNCTION SYMBOL), not a FUNCTION.

; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-IMPL::TEST-NOT)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR FUNCTION SYMBOL), not a FUNCTION.

;     (LENGTH (CL-PPCRE::CHOICES CL-PPCRE::ALTERNATIONS))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (ZEROP LENGTH)
; --> = IF 
; ==>
;   (= LENGTH 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

;     (EVERY (LAMBDA (CL-PPCRE::ITEM) (EQ CL-PPCRE::ITEM :WORD-CHAR-CLASS))
;          CL-PPCRE::ITEM-LIST)
; --> LET BLOCK MAP TRULY-THE 
; ==>
;   (SB-KERNEL:%MAP SB-C::RESULT-TYPE-ARG SB-C::FUN #:G247)
; 
; note: unable to open code because: can't determine sequence argument type

;     (1- (THE FIXNUM CL-PPCRE::TEST-CANDIDATE))
; ==>
;   (- (THE FIXNUM CL-PPCRE::TEST-CANDIDATE) 1)
; 
; note: doing signed word to integer coercion (cost 20)

;     (1- CL-PPCRE::MAXIMUM)
; ==>
;   (- CL-PPCRE::MAXIMUM 1)
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DEFUN CONVERT ...)

; /var/cache/common-lisp-controller/1000/sbcl/cl-ppcre/convert.fasl written
; compilation finished in 0:00:01
; compiling file "/usr/share/common-lisp/source/cl-ppcre/optimize.lisp" (written 12 JUN 2006 10:18:57 PM):
; compiling (IN-PACKAGE #:CL-PPCRE)
; compiling (DEFGENERIC FLATTEN ...)
; compiling (DEFMETHOD FLATTEN ...)
; compiling (DEFMETHOD FLATTEN ...)
; compiling (DEFMETHOD FLATTEN ...)
; compiling (DEFMETHOD FLATTEN ...)
; compiling (DEFGENERIC GATHER-STRINGS ...)
; compiling (DEFMETHOD GATHER-STRINGS ...)
; file: /usr/share/common-lisp/source/cl-ppcre/optimize.lisp
; in: DEFMETHOD GATHER-STRINGS (SEQ)
;     (INCF CL-PPCRE::COLLECTOR-LENGTH (CL-PPCRE::LEN CL-PPCRE::ELEMENT))
; --> LET* 
; ==>
;   (+ CL-PPCRE::COLLECTOR-LENGTH #:G284)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (SETF (SUBSEQ CL-PPCRE::COLLECTOR CL-PPCRE::OLD-COLLECTOR-LENGTH)
;           (CL-PPCRE::STR CL-PPCRE::ELEMENT)
;         CL-PPCRE::SKIP
;           (CL-PPCRE::SKIP CL-PPCRE::ELEMENT))
; --> PROGN SETF LET* MULTIPLE-VALUE-BIND LET PROGN 
; ==>
;   (REPLACE #:G285 #:G287 :START1 #:G286 :END1 NIL)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-BASE-STRING.
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES VECTOR
;                           &OPTIONAL), not a (VALUES SIMPLE-BASE-STRING &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES VECTOR
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY CHARACTER (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;   The result is a (VALUES VECTOR
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY SINGLE-FLOAT (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-BIT-VECTOR.
;   The second argument is a SEQUENCE, not a SIMPLE-BIT-VECTOR.
;   The result is a (VALUES VECTOR
;                           &OPTIONAL), not a (VALUES SIMPLE-BIT-VECTOR &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 2) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 2) (*)).
;   The result is a (VALUES VECTOR
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 2)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 4) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 4) (*)).
;   The result is a (VALUES VECTOR
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 4)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 7) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 7) (*)).
;   The result is a (VALUES VECTOR
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 7)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)).
;   The result is a (VALUES VECTOR
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 8)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 15) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 15)
;                                                          (*)).
;   The result is a (VALUES VECTOR
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 15)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 16) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 16)
;                                                          (*)).
;   The result is a (VALUES VECTOR
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 16)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 29) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 29)
;                                                          (*)).
;   The result is a (VALUES VECTOR
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 29)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 31) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 31)
;                                                          (*)).
;   The result is a (VALUES VECTOR
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 31)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 32) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 32)
;                                                          (*)).
;   The result is a (VALUES VECTOR
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 32)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (SIGNED-BYTE 8) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 8) (*)).
;   The result is a (VALUES VECTOR
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (SIGNED-BYTE 8) (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (SIGNED-BYTE 16) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 16) (*)).
;   The result is a (VALUES VECTOR
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (SIGNED-BYTE 16)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY FIXNUM (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY FIXNUM (*)).
;   The result is a (VALUES VECTOR
;                           &OPTIONAL), not a (VALUES (SIMPLE-ARRAY FIXNUM (*))
;                                                     &REST
;                                                     T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (SIGNED-BYTE 32) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 32) (*)).
;   The result is a (VALUES VECTOR
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (SIGNED-BYTE 32)
;                                                            (*))
;                                              &REST
;                                              T).

;     (INCF CL-PPCRE::COLLECTOR-LENGTH (CL-PPCRE::LEN CL-PPCRE::ELEMENT))
; --> LET* 
; ==>
;   (+ CL-PPCRE::COLLECTOR-LENGTH #:G284)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a NUMBER, not a FIXNUM.
;       unable to do inline (signed-byte 32) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 32).
;       etc.

; compiling (DEFMETHOD GATHER-STRINGS ...)
; compiling (DEFMETHOD GATHER-STRINGS ...)
; compiling (DEFMETHOD GATHER-STRINGS ...)
; compiling (DEFGENERIC START-ANCHORED-P ...)
; compiling (DEFMETHOD START-ANCHORED-P ...)
; compiling (DEFMETHOD START-ANCHORED-P ...)
; compiling (DEFMETHOD START-ANCHORED-P ...)
; compiling (DEFMETHOD START-ANCHORED-P ...)
; file: /usr/share/common-lisp/source/cl-ppcre/optimize.lisp
; in: DEFMETHOD START-ANCHORED-P (REPETITION)
;     (PLUSP (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION))
; ==>
;   (> (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; compiling (DEFMETHOD START-ANCHORED-P ...)
; compiling (DEFMETHOD START-ANCHORED-P ...)
; compiling (DEFMETHOD START-ANCHORED-P ...)
; compiling (DEFMETHOD START-ANCHORED-P ...)
; file: /usr/share/common-lisp/source/cl-ppcre/optimize.lisp
; in: DEFMETHOD START-ANCHORED-P (REGEX)
;     (ZEROP (CL-PPCRE::LEN CL-PPCRE::REGEX))
; ==>
;   (= (CL-PPCRE::LEN CL-PPCRE::REGEX) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; compiling (DEFGENERIC END-STRING-AUX ...)
; compiling (DEFMETHOD END-STRING-AUX ...)
; compiling (DEFMETHOD END-STRING-AUX ...)
; file: /usr/share/common-lisp/source/cl-ppcre/optimize.lisp
; in: DEFMETHOD END-STRING-AUX (SEQ)
;     (ZEROP (CL-PPCRE::LEN CL-PPCRE::ELEMENT-END))
; --> = IF 
; ==>
;   (= (CL-PPCRE::LEN CL-PPCRE::ELEMENT-END) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

;     (CHAR CL-PPCRE::STR CL-PPCRE::I)
; --> AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

; compiling (DEFMETHOD END-STRING-AUX ...)
; compiling (DEFMETHOD END-STRING-AUX ...)
; compiling (DEFMETHOD END-STRING-AUX ...)
; compiling (DEFGENERIC END-STRING ...)
; compiling (DEFMETHOD END-STRING ...)
; compiling (DEFGENERIC COMPUTE-MIN-REST ...)
; compiling (DEFMETHOD COMPUTE-MIN-REST ...)
; compiling (DEFMETHOD COMPUTE-MIN-REST ...)
; file: /usr/share/common-lisp/source/cl-ppcre/optimize.lisp
; in: DEFMETHOD COMPUTE-MIN-REST (ALTERNATION T)
;     (LOOP CL-PPCRE::FOR
;         CL-PPCRE::CHOICE
;         CL-PPCRE::IN
;         (CL-PPCRE::CHOICES CL-PPCRE::ALTERNATION)
;         CL-PPCRE::MINIMIZE
;         (CL-PPCRE::COMPUTE-MIN-REST CL-PPCRE::CHOICE
;                                     CL-PPCRE::CURRENT-MIN-REST))
; --> BLOCK LET SB-LOOP::WITH-MINIMAX-VALUE LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN COND IF OR LET IF OR < 
; --> IF 
; ==>
;   (< #:LOOP-MAXMIN-TEMP-679 #:LOOP-MAXMIN-678)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFMETHOD COMPUTE-MIN-REST ...)
; file: /usr/share/common-lisp/source/cl-ppcre/optimize.lisp
; in: DEFMETHOD COMPUTE-MIN-REST (BRANCH T)
;     (MIN
;    (CL-PPCRE::COMPUTE-MIN-REST (CL-PPCRE::THEN-REGEX CL-PPCRE::BRANCH)
;                                CL-PPCRE::CURRENT-MIN-REST)
;    (CL-PPCRE::COMPUTE-MIN-REST (CL-PPCRE::ELSE-REGEX CL-PPCRE::BRANCH)
;                                CL-PPCRE::CURRENT-MIN-REST))
; --> LET LET IF <= IF 
; ==>
;   (> #:ONCE-ONLY-688 SB-C::MINREST)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFMETHOD COMPUTE-MIN-REST ...)
; file: /usr/share/common-lisp/source/cl-ppcre/optimize.lisp
; in: DEFMETHOD COMPUTE-MIN-REST (STR T)
;     (+ CL-PPCRE::CURRENT-MIN-REST (CL-PPCRE::LEN CL-PPCRE::STR))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFMETHOD COMPUTE-MIN-REST ...)
; file: /usr/share/common-lisp/source/cl-ppcre/optimize.lisp
; in: DEFMETHOD COMPUTE-MIN-REST (FILTER T)
;     (+ CL-PPCRE::CURRENT-MIN-REST (OR (CL-PPCRE::LEN CL-PPCRE::FILTER) 0))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFMETHOD COMPUTE-MIN-REST ...)
; file: /usr/share/common-lisp/source/cl-ppcre/optimize.lisp
; in: DEFMETHOD COMPUTE-MIN-REST (REPETITION T)
;     (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;      (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.

;     (+ CL-PPCRE::CURRENT-MIN-REST
;      (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;         (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;      (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       etc.

;     (+ CL-PPCRE::CURRENT-MIN-REST
;      (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;         (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFMETHOD COMPUTE-MIN-REST ...)
; compiling (DEFMETHOD COMPUTE-MIN-REST ...)
; compiling (DEFMETHOD COMPUTE-MIN-REST ...)
; compiling (DEFMETHOD COMPUTE-MIN-REST ...)
; file: /usr/share/common-lisp/source/cl-ppcre/optimize.lisp
; in: DEFMETHOD COMPUTE-MIN-REST (LOOKBEHIND T)
;     (+ CL-PPCRE::CURRENT-MIN-REST (CL-PPCRE::LEN CL-PPCRE::LOOKBEHIND))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFMETHOD COMPUTE-MIN-REST ...)
; file: /usr/share/common-lisp/source/cl-ppcre/optimize.lisp
; in: DEFMETHOD COMPUTE-MIN-REST (REGEX T)
;     (1+ CL-PPCRE::CURRENT-MIN-REST)
; ==>
;   (+ CL-PPCRE::CURRENT-MIN-REST 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.


; /var/cache/common-lisp-controller/1000/sbcl/cl-ppcre/optimize.fasl written
; compilation finished in 0:00:01
; compiling file "/usr/share/common-lisp/source/cl-ppcre/closures.lisp" (written 12 JUN 2006 10:18:57 PM):
; compiling (IN-PACKAGE #:CL-PPCRE)
; compiling (DECLAIM (INLINE *STRING*= ...))
; compiling (DEFUN *STRING*= ...)
; compiling (DEFUN *STRING*-EQUAL ...)
; file: /usr/share/common-lisp/source/cl-ppcre/closures.lisp
; in: DEFUN *STRING*-EQUAL
;     (CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;               (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

; compiling (DEFGENERIC CREATE-MATCHER-AUX ...)
; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; file: /usr/share/common-lisp/source/cl-ppcre/closures.lisp
; in: DEFMETHOD CREATE-MATCHER-AUX (LOOKBEHIND T)
;     (FUNCALL CL-PPCRE::TEST-MATCHER (- CL-PPCRE::START-POS CL-PPCRE::LEN))
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G167)
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (SB-C::%FUNCALL FUNCTION #:G169)
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DEFMACRO INSERT-CHAR-CLASS-TESTER ...)
; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; file: /usr/share/common-lisp/source/cl-ppcre/closures.lisp
; in: DEFMETHOD CREATE-MATCHER-AUX (CHAR-CLASS T)
;     (FUNCALL CL-PPCRE::NEXT-FN (1+ CL-PPCRE::START-POS))
; ==>
;   CL-PPCRE::NEXT-FN
; 
; note: deleting unreachable code

;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER
;    (CL-PPCRE::CHAR-CLASS (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS))
;    (IF (CL-PPCRE::INVERTEDP CL-PPCRE::CHAR-CLASS)
;        (LAMBDA (CL-PPCRE::START-POS)
;          (DECLARE (TYPE FIXNUM CL-PPCRE::START-POS))
;          (AND (< CL-PPCRE::START-POS CL-PPCRE::*END-POS*)
;               (NOT #)
;               (FUNCALL CL-PPCRE::NEXT-FN #)))
;        (LAMBDA (CL-PPCRE::START-POS)
;          (DECLARE (TYPE FIXNUM CL-PPCRE::START-POS))
;          (AND (< CL-PPCRE::START-POS CL-PPCRE::*END-POS*)
;               (CL-PPCRE::CHAR-CLASS-TEST)
;               (FUNCALL CL-PPCRE::NEXT-FN #)))))
; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF LAMBDA FUNCTION AND IF AND IF CL-PPCRE::WORD-CHAR-P 
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF LAMBDA FUNCTION AND IF AND IF CL-PPCRE::WORD-CHAR-P 
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF LAMBDA FUNCTION AND IF AND IF NOT IF 
; --> CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF LAMBDA FUNCTION AND IF AND IF NOT IF 
; --> CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = 
; --> IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF LAMBDA FUNCTION AND IF AND IF NOT IF 
; --> CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF LAMBDA FUNCTION AND IF AND IF CL-PPCRE::WORD-CHAR-P 
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; file: /usr/share/common-lisp/source/cl-ppcre/closures.lisp
; in: DEFUN *STRING*-EQUAL
;     (CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;               (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

; in: DEFMETHOD CREATE-MATCHER-AUX (STR T)
;     (CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS) CL-PPCRE::CHR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (LENGTH CL-PPCRE::END-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; in: DEFUN *STRING*-EQUAL
;     (CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;               (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

; in: DEFMETHOD CREATE-MATCHER-AUX (STR T)
;     (FUNCALL CL-PPCRE::NEXT-FN (+ CL-PPCRE::START-POS CL-PPCRE::LEN))
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G518)
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (SB-C::%FUNCALL FUNCTION #:G519)
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (SB-C::%FUNCALL FUNCTION #:G520)
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DECLAIM (INLINE WORD-BOUNDARY-P))
; compiling (DEFUN WORD-BOUNDARY-P ...)
; file: /usr/share/common-lisp/source/cl-ppcre/closures.lisp
; in: DEFUN WORD-BOUNDARY-P
;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::1-START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::1-START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::1-START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; file: /usr/share/common-lisp/source/cl-ppcre/closures.lisp
; in: DEFUN WORD-BOUNDARY-P
;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::1-START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::1-START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::1-START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::1-START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::1-START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; file: /usr/share/common-lisp/source/cl-ppcre/closures.lisp
; in: DEFUN *STRING*-EQUAL
;     (CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;               (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; file: /usr/share/common-lisp/source/cl-ppcre/closures.lisp
; in: DEFMETHOD CREATE-MATCHER-AUX (FILTER T)
;     (FUNCALL CL-PPCRE::FN CL-PPCRE::START-POS)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR FUNCTION SYMBOL), not a FUNCTION.

;     (FUNCALL CL-PPCRE::NEXT-FN CL-PPCRE::NEXT-POS)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR FUNCTION SYMBOL), not a FUNCTION.

; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)

; /var/cache/common-lisp-controller/1000/sbcl/cl-ppcre/closures.fasl written
; compilation finished in 0:00:02
; compiling file "/usr/share/common-lisp/source/cl-ppcre/repetition-closures.lisp" (written 12 JUN 2006 10:18:57 PM):
; compiling (IN-PACKAGE #:CL-PPCRE)
; compiling (DEFMACRO INCF-AFTER ...)
; compiling (DEFMACRO GREEDY-CONSTANT-LENGTH-CLOSURE ...)
; compiling (DEFUN CREATE-GREEDY-EVERYTHING-MATCHER ...)
; compiling (DEFGENERIC CREATE-GREEDY-CONSTANT-LENGTH-MATCHER ...)
; compiling (DEFMETHOD CREATE-GREEDY-CONSTANT-LENGTH-MATCHER ...)
; file: /usr/share/common-lisp/source/cl-ppcre/repetition-closures.lisp
; in: DEFMACRO GREEDY-CONSTANT-LENGTH-CLOSURE
;     (INCF CL-PPCRE::CURR-POS CL-PPCRE::LEN)
; --> LET* 
; ==>
;   CL-PPCRE::LEN
; 
; note: deleting unreachable code

; --> LET* + 
; ==>
;   CL-PPCRE::CURR-POS
; 
; note: deleting unreachable code

;     (GO CL-PPCRE::FORWARD-LOOP)
; 
; note: deleting unreachable code

;     (INCF CL-PPCRE::CURR-POS CL-PPCRE::LEN)
; --> LET* 
; ==>
;   CL-PPCRE::LEN
; 
; note: deleting unreachable code

; --> LET* + 
; ==>
;   CL-PPCRE::CURR-POS
; 
; note: deleting unreachable code

;     (GO CL-PPCRE::FORWARD-LOOP)
; 
; note: deleting unreachable code

; in: DEFMETHOD CREATE-GREEDY-CONSTANT-LENGTH-MATCHER (REPETITION T)
;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER
;    (CL-PPCRE::REGEX (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
;    (IF (CL-PPCRE::INVERTEDP CL-PPCRE::REGEX)
;        (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;         (NOT (CL-PPCRE::CHAR-CLASS-TEST)))
;        (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE (CL-PPCRE::CHAR-CLASS-TEST))))
; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET BLOCK TAGBODY WHEN COND IF CL-PPCRE::WORD-CHAR-P BLOCK OR 
; --> LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET BLOCK TAGBODY WHEN COND IF CL-PPCRE::WORD-CHAR-P BLOCK OR 
; --> LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET BLOCK TAGBODY WHEN COND IF CL-PPCRE::WORD-CHAR-P BLOCK OR 
; --> LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET BLOCK TAGBODY WHEN COND IF CL-PPCRE::WORD-CHAR-P BLOCK OR 
; --> LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET BLOCK TAGBODY WHEN COND IF NOT IF CL-PPCRE::WORD-CHAR-P 
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET BLOCK TAGBODY WHEN COND IF NOT IF CL-PPCRE::WORD-CHAR-P 
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET BLOCK TAGBODY WHEN COND IF NOT IF CL-PPCRE::WORD-CHAR-P 
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET BLOCK TAGBODY WHEN COND IF NOT IF CL-PPCRE::WORD-CHAR-P 
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR
;                             CL-PPCRE::CURR-POS
;                             (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN)
;                             0
;                             CL-PPCRE::LEN)
; --> BLOCK LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS COND IF NOT IF 
; ==>
;   (CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;               (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CHAR-EQUAL CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER
;    (CL-PPCRE::REGEX (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
;    (IF (CL-PPCRE::INVERTEDP CL-PPCRE::REGEX)
;        (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;         (NOT (CL-PPCRE::CHAR-CLASS-TEST)))
;        (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE (CL-PPCRE::CHAR-CLASS-TEST))))
; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET BLOCK TAGBODY WHEN COND IF NOT IF CL-PPCRE::WORD-CHAR-P 
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET BLOCK TAGBODY WHEN COND IF CL-PPCRE::WORD-CHAR-P BLOCK OR 
; --> LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; compiling (DEFGENERIC CREATE-GREEDY-NO-ZERO-MATCHER ...)
; compiling (DEFMETHOD CREATE-GREEDY-NO-ZERO-MATCHER ...)
; file: /usr/share/common-lisp/source/cl-ppcre/repetition-closures.lisp
; in: DEFMETHOD CREATE-GREEDY-NO-ZERO-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0)
; --> SB-KERNEL:%ASET LET* SB-KERNEL:HAIRY-DATA-VECTOR-SET MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; --> LET* SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* + AREF LET* SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET LET* SB-KERNEL:HAIRY-DATA-VECTOR-SET 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* - AREF LET* SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET LET* SB-KERNEL:HAIRY-DATA-VECTOR-SET 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; compiling (DEFGENERIC CREATE-GREEDY-MATCHER ...)
; compiling (DEFMETHOD CREATE-GREEDY-MATCHER ...)
; file: /usr/share/common-lisp/source/cl-ppcre/repetition-closures.lisp
; in: DEFMETHOD CREATE-GREEDY-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
;           0
;         (SVREF CL-PPCRE::*LAST-POS-STORES* CL-PPCRE::ZERO-LENGTH-NUM)
;           NIL)
; --> PROGN SETF SB-KERNEL:%ASET LET* SB-KERNEL:HAIRY-DATA-VECTOR-SET 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; --> LET* SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* + AREF LET* SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET LET* SB-KERNEL:HAIRY-DATA-VECTOR-SET 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* - AREF LET* SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET LET* SB-KERNEL:HAIRY-DATA-VECTOR-SET 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; compiling (DEFMACRO NON-GREEDY-CONSTANT-LENGTH-CLOSURE ...)
; compiling (DEFGENERIC CREATE-NON-GREEDY-CONSTANT-LENGTH-MATCHER ...)
; compiling (DEFMETHOD CREATE-NON-GREEDY-CONSTANT-LENGTH-MATCHER ...)
; file: /usr/share/common-lisp/source/cl-ppcre/repetition-closures.lisp
; in: DEFMETHOD CREATE-NON-GREEDY-CONSTANT-LENGTH-MATCHER (REPETITION T)
;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER
;    (CL-PPCRE::REGEX (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
;    (IF (CL-PPCRE::INVERTEDP CL-PPCRE::REGEX)
;        (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;         (NOT (CL-PPCRE::CHAR-CLASS-TEST)))
;        (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;         (CL-PPCRE::CHAR-CLASS-TEST))))
; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS COND IF 
; --> NOT IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET 
; --> < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS COND IF 
; --> NOT IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET 
; --> IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS COND IF 
; --> NOT IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET 
; --> < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS COND IF 
; --> NOT IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET 
; --> IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS COND IF 
; --> NOT IF NOT IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET 
; --> OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS COND IF 
; --> NOT IF NOT IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET 
; --> OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS COND IF 
; --> NOT IF NOT IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET 
; --> OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS COND IF 
; --> NOT IF NOT IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET 
; --> OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR
;                             CL-PPCRE::CURR-POS
;                             (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN)
;                             0
;                             CL-PPCRE::LEN)
; --> BLOCK LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS COND IF NOT IF 
; ==>
;   (CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;               (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CHAR-EQUAL CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER
;    (CL-PPCRE::REGEX (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
;    (IF (CL-PPCRE::INVERTEDP CL-PPCRE::REGEX)
;        (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;         (NOT (CL-PPCRE::CHAR-CLASS-TEST)))
;        (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;         (CL-PPCRE::CHAR-CLASS-TEST))))
; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS COND IF 
; --> NOT IF NOT IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET 
; --> OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS COND IF 
; --> NOT IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET 
; --> < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; compiling (DEFGENERIC CREATE-NON-GREEDY-NO-ZERO-MATCHER ...)
; compiling (DEFMETHOD CREATE-NON-GREEDY-NO-ZERO-MATCHER ...)
; file: /usr/share/common-lisp/source/cl-ppcre/repetition-closures.lisp
; in: DEFMETHOD CREATE-NON-GREEDY-NO-ZERO-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0)
; --> SB-KERNEL:%ASET LET* SB-KERNEL:HAIRY-DATA-VECTOR-SET MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; --> LET* SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* + AREF LET* SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET LET* SB-KERNEL:HAIRY-DATA-VECTOR-SET 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* - AREF LET* SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET LET* SB-KERNEL:HAIRY-DATA-VECTOR-SET 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; compiling (DEFGENERIC CREATE-NON-GREEDY-MATCHER ...)
; compiling (DEFMETHOD CREATE-NON-GREEDY-MATCHER ...)
; file: /usr/share/common-lisp/source/cl-ppcre/repetition-closures.lisp
; in: DEFMETHOD CREATE-NON-GREEDY-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
;           0
;         (SVREF CL-PPCRE::*LAST-POS-STORES* CL-PPCRE::ZERO-LENGTH-NUM)
;           NIL)
; --> PROGN SETF SB-KERNEL:%ASET LET* SB-KERNEL:HAIRY-DATA-VECTOR-SET 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; --> LET* SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* + AREF LET* SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET LET* SB-KERNEL:HAIRY-DATA-VECTOR-SET 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* - AREF LET* SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET LET* SB-KERNEL:HAIRY-DATA-VECTOR-SET 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; compiling (DEFMACRO CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE ...)
; compiling (DEFGENERIC CREATE-CONSTANT-REPETITION-CONSTANT-LENGTH-MATCHER ...)
; compiling (DEFMETHOD CREATE-CONSTANT-REPETITION-CONSTANT-LENGTH-MATCHER ...)
; file: /usr/share/common-lisp/source/cl-ppcre/repetition-closures.lisp
; in:
;      DEFMETHOD CREATE-CONSTANT-REPETITION-CONSTANT-LENGTH-MATCHER (REPETITION T)
;     (1+ CL-PPCRE::CURR-POS)
; --> + 
; ==>
;   CL-PPCRE::CURR-POS
; 
; note: deleting unreachable code

;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER
;    (CL-PPCRE::REGEX (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
;    (IF (CL-PPCRE::INVERTEDP CL-PPCRE::REGEX)
;        (CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE
;         (AND (NOT #) (1+ CL-PPCRE::CURR-POS)))
;        (CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE
;         (AND (CL-PPCRE::CHAR-CLASS-TEST) (1+ CL-PPCRE::CURR-POS)))))
; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE 
; --> LAMBDA FUNCTION LET AND IF AND IF LOOP BLOCK LET SB-LOOP::LOOP-BODY 
; --> TAGBODY UNLESS COND IF NOT IF AND IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET 
; --> ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE 
; --> LAMBDA FUNCTION LET AND IF AND IF LOOP BLOCK LET SB-LOOP::LOOP-BODY 
; --> TAGBODY UNLESS COND IF NOT IF AND IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET 
; --> ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE 
; --> LAMBDA FUNCTION LET AND IF AND IF LOOP BLOCK LET SB-LOOP::LOOP-BODY 
; --> TAGBODY UNLESS COND IF NOT IF AND IF NOT IF CL-PPCRE::WORD-CHAR-P BLOCK 
; --> OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE 
; --> LAMBDA FUNCTION LET AND IF AND IF LOOP BLOCK LET SB-LOOP::LOOP-BODY 
; --> TAGBODY UNLESS COND IF NOT IF AND IF NOT IF CL-PPCRE::WORD-CHAR-P BLOCK 
; --> OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR
;                             CL-PPCRE::CURR-POS
;                             CL-PPCRE::NEXT-POS
;                             0
;                             CL-PPCRE::LEN)
; --> BLOCK LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS COND IF NOT IF 
; ==>
;   (CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;               (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CHAR-EQUAL CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER
;    (CL-PPCRE::REGEX (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
;    (IF (CL-PPCRE::INVERTEDP CL-PPCRE::REGEX)
;        (CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE
;         (AND (NOT #) (1+ CL-PPCRE::CURR-POS)))
;        (CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE
;         (AND (CL-PPCRE::CHAR-CLASS-TEST) (1+ CL-PPCRE::CURR-POS)))))
; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE 
; --> LAMBDA FUNCTION LET AND IF AND IF LOOP BLOCK LET SB-LOOP::LOOP-BODY 
; --> TAGBODY UNLESS COND IF NOT IF AND IF NOT IF CL-PPCRE::WORD-CHAR-P BLOCK 
; --> OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE 
; --> LAMBDA FUNCTION LET AND IF AND IF LOOP BLOCK LET SB-LOOP::LOOP-BODY 
; --> TAGBODY UNLESS COND IF NOT IF AND IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET 
; --> ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; compiling (DEFGENERIC CREATE-CONSTANT-REPETITION-MATCHER ...)
; compiling (DEFMETHOD CREATE-CONSTANT-REPETITION-MATCHER ...)
; file: /usr/share/common-lisp/source/cl-ppcre/repetition-closures.lisp
; in: DEFMETHOD CREATE-CONSTANT-REPETITION-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0)
; --> SB-KERNEL:%ASET LET* SB-KERNEL:HAIRY-DATA-VECTOR-SET MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; --> LET* SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* + AREF LET* SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET LET* SB-KERNEL:HAIRY-DATA-VECTOR-SET 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* - AREF LET* SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET LET* SB-KERNEL:HAIRY-DATA-VECTOR-SET 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
;           0
;         (AREF CL-PPCRE::*LAST-POS-STORES* CL-PPCRE::ZERO-LENGTH-NUM)
;           NIL)
; --> PROGN SETF SB-KERNEL:%ASET LET* SB-KERNEL:HAIRY-DATA-VECTOR-SET 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (ZEROP (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION))
; ==>
;   (= (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; --> LET* SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* + AREF LET* SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET LET* SB-KERNEL:HAIRY-DATA-VECTOR-SET 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* - AREF LET* SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET LET* SB-KERNEL:HAIRY-DATA-VECTOR-SET 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; file: /usr/share/common-lisp/source/cl-ppcre/repetition-closures.lisp
; in: DEFMETHOD CREATE-MATCHER-AUX (REPETITION T)
;     (DEFMETHOD CL-PPCRE::CREATE-MATCHER-AUX
;              ((CL-PPCRE::REPETITION CL-PPCRE::REPETITION) CL-PPCRE::NEXT-FN)
;              (WITH-SLOTS
;               ((CL-PPCRE::MINIMUM CL-PPCRE::MINIMUM)
;                (CL-PPCRE::MAXIMUM CL-PPCRE::MAXIMUM)
;                (CL-PPCRE::LEN CL-PPCRE::LEN)
;                (CL-PPCRE::MIN-LEN CL-PPCRE::MIN-LEN)
;                (CL-PPCRE::GREEDYP CL-PPCRE::GREEDYP)
;                (CL-PPCRE::CONTAINS-REGISTER-P CL-PPCRE::CONTAINS-REGISTER-P))
;               CL-PPCRE::REPETITION
;               (COND
;                ((AND CL-PPCRE::MAXIMUM #)
;                 (ERROR "Got REPETITION with MAXIMUM 0 (should not happen)"))
;                ((AND CL-PPCRE::MAXIMUM #)
;                 (ERROR
;                  "Got REPETITION with MAXIMUM 1 and MINIMUM 1 (should not happen)"))
;                ((AND # CL-PPCRE::LEN #)
;                 (CL-PPCRE::CREATE-CONSTANT-REPETITION-CONSTANT-LENGTH-MATCHER
;                  CL-PPCRE::REPETITION
;                  CL-PPCRE::NEXT-FN))
;                ((EQL CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM)
;                 (CL-PPCRE::CREATE-CONSTANT-REPETITION-MATCHER
;                  CL-PPCRE::REPETITION
;                  CL-PPCRE::NEXT-FN))
;                ((AND CL-PPCRE::GREEDYP CL-PPCRE::LEN #)
;                 (CL-PPCRE::CREATE-GREEDY-CONSTANT-LENGTH-MATCHER
;                  CL-PPCRE::REPETITION
;                  CL-PPCRE::NEXT-FN))
;                ((AND CL-PPCRE::GREEDYP #)
;                 (CL-PPCRE::CREATE-GREEDY-NO-ZERO-MATCHER CL-PPCRE::REPETITION
;                                                          CL-PPCRE::NEXT-FN))
;                (CL-PPCRE::GREEDYP
;                 (CL-PPCRE::CREATE-GREEDY-MATCHER CL-PPCRE::REPETITION
;                                                  CL-PPCRE::NEXT-FN))
;                ((AND CL-PPCRE::LEN # #)
;                 (CL-PPCRE::CREATE-NON-GREEDY-CONSTANT-LENGTH-MATCHER
;                  CL-PPCRE::REPETITION
;                  CL-PPCRE::NEXT-FN))
;                ((OR # #)
;                 (CL-PPCRE::CREATE-NON-GREEDY-NO-ZERO-MATCHER
;                  CL-PPCRE::REPETITION
;                  CL-PPCRE::NEXT-FN))
;                (T
;                 (CL-PPCRE::CREATE-NON-GREEDY-MATCHER CL-PPCRE::REPETITION
;                                                      CL-PPCRE::NEXT-FN)))))
; --> PROGN SB-PCL::LOAD-DEFMETHOD SB-INT:NAMED-LAMBDA FUNCTION SYMBOL-MACROLET 
; --> SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET LET SB-PCL::BIND-ARGS 
; --> LET* SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 SB-PCL::PV-ENV LET LET BLOCK 
; --> LET SYMBOL-MACROLET IF IF ZEROP 
; ==>
;   (=
;    (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 4)
;                           CL-PPCRE::REPETITION
;                           0
;                           'CL-PPCRE::MAXIMUM
;                           '#<STANDARD-CLASS CL-PPCRE::REPETITION>)
;    0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; --> PROGN SB-PCL::LOAD-DEFMETHOD SB-INT:NAMED-LAMBDA FUNCTION SYMBOL-MACROLET 
; --> SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET LET SB-PCL::BIND-ARGS 
; --> LET* SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 SB-PCL::PV-ENV LET LET BLOCK 
; --> LET SYMBOL-MACROLET IF IF IF = 
; --> (LAMBDA (#:G3465 #:G3464 #:G3463) (DECLARE (TYPE NUMBER #:G3465 #:G3464 #:G3463)) (IF (= #:G3465 #:G3464) (IF (= #:G3464 #:G3463) T NIL) NIL)) 
; --> IF 
; ==>
;   (= #:G3465 #:G3464)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; --> PROGN SB-PCL::LOAD-DEFMETHOD SB-INT:NAMED-LAMBDA FUNCTION SYMBOL-MACROLET 
; --> SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET LET SB-PCL::BIND-ARGS 
; --> LET* SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 SB-PCL::PV-ENV LET LET BLOCK 
; --> LET SYMBOL-MACROLET IF IF IF = 
; --> (LAMBDA (#:G3465 #:G3464 #:G3463) (DECLARE (TYPE NUMBER #:G3465 #:G3464 #:G3463)) (IF (= #:G3465 #:G3464) (IF (= #:G3464 #:G3463) T NIL) NIL)) 
; --> IF IF 
; ==>
;   (= #:G3464 #:G3463)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; --> PROGN SB-PCL::LOAD-DEFMETHOD SB-INT:NAMED-LAMBDA FUNCTION SYMBOL-MACROLET 
; --> SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET LET SB-PCL::BIND-ARGS 
; --> LET* SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 SB-PCL::PV-ENV LET LET BLOCK 
; --> LET SYMBOL-MACROLET IF IF IF IF 
; ==>
;   (EQL
;    (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 6)
;                           CL-PPCRE::REPETITION
;                           0
;                           'CL-PPCRE::MINIMUM
;                           '#<STANDARD-CLASS CL-PPCRE::REPETITION>)
;    (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 4)
;                           CL-PPCRE::REPETITION
;                           0
;                           'CL-PPCRE::MAXIMUM
;                           '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a SINGLE-FLOAT.
;   The second argument is a T, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a DOUBLE-FLOAT.
;   The second argument is a T, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a SINGLE-FLOAT.
;   The second argument is a T, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a DOUBLE-FLOAT.
;   The second argument is a T, not a DOUBLE-FLOAT.

; --> PROGN SB-PCL::LOAD-DEFMETHOD SB-INT:NAMED-LAMBDA FUNCTION SYMBOL-MACROLET 
; --> SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET LET SB-PCL::BIND-ARGS 
; --> LET* SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 SB-PCL::PV-ENV LET LET BLOCK 
; --> LET SYMBOL-MACROLET IF IF IF IF IF IF IF LET PLUSP > IF 
; ==>
;   (>
;    (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 5)
;                           CL-PPCRE::REPETITION
;                           0
;                           'CL-PPCRE::MIN-LEN
;                           '#<STANDARD-CLASS CL-PPCRE::REPETITION>)
;    0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> PROGN SB-PCL::LOAD-DEFMETHOD SB-INT:NAMED-LAMBDA FUNCTION SYMBOL-MACROLET 
; --> SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET LET SB-PCL::BIND-ARGS 
; --> LET* SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 SB-PCL::PV-ENV LET LET BLOCK 
; --> LET SYMBOL-MACROLET IF IF IF IF IF IF IF IF IF IF PLUSP 
; ==>
;   (>
;    (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 3)
;                           CL-PPCRE::REPETITION
;                           0
;                           'CL-PPCRE::LEN
;                           '#<STANDARD-CLASS CL-PPCRE::REPETITION>)
;    0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> PROGN SB-PCL::LOAD-DEFMETHOD SB-INT:NAMED-LAMBDA FUNCTION SYMBOL-MACROLET 
; --> SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET LET SB-PCL::BIND-ARGS 
; --> LET* SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 SB-PCL::PV-ENV LET LET BLOCK 
; --> LET SYMBOL-MACROLET IF IF IF IF IF IF IF IF IF LET PLUSP > IF 
; ==>
;   (>
;    (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 5)
;                           CL-PPCRE::REPETITION
;                           0
;                           'CL-PPCRE::MIN-LEN
;                           '#<STANDARD-CLASS CL-PPCRE::REPETITION>)
;    0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> PROGN SB-PCL::LOAD-DEFMETHOD SB-INT:NAMED-LAMBDA FUNCTION SYMBOL-MACROLET 
; --> SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET LET SB-PCL::BIND-ARGS 
; --> LET* SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 SB-PCL::PV-ENV LET LET BLOCK 
; --> LET SYMBOL-MACROLET IF IF IF = 
; --> (LAMBDA (#:G3465 #:G3464 #:G3463) (DECLARE (TYPE NUMBER #:G3465 #:G3464 #:G3463)) (IF (= #:G3465 #:G3464) (IF (= #:G3464 #:G3463) T NIL) NIL)) 
; --> IF 
; ==>
;   (= #:G3465 #:G3464)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.

; --> PROGN SB-PCL::LOAD-DEFMETHOD SB-INT:NAMED-LAMBDA FUNCTION SYMBOL-MACROLET 
; --> SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET LET SB-PCL::BIND-ARGS 
; --> LET* SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 SB-PCL::PV-ENV LET LET BLOCK 
; --> LET SYMBOL-MACROLET IF IF IF IF 
; ==>
;   (EQL
;    (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 6)
;                           CL-PPCRE::REPETITION
;                           0
;                           'CL-PPCRE::MINIMUM
;                           '#<STANDARD-CLASS CL-PPCRE::REPETITION>)
;    (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 4)
;                           CL-PPCRE::REPETITION
;                           0
;                           'CL-PPCRE::MAXIMUM
;                           '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

; --> PROGN SB-PCL::LOAD-DEFMETHOD SB-INT:NAMED-LAMBDA FUNCTION SYMBOL-MACROLET 
; --> SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET LET SB-PCL::BIND-ARGS 
; --> LET* SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 SB-PCL::PV-ENV LET LET BLOCK 
; --> LET SYMBOL-MACROLET IF IF IF IF IF IF IF LET PLUSP > IF 
; ==>
;   (>
;    (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 5)
;                           CL-PPCRE::REPETITION
;                           0
;                           'CL-PPCRE::MIN-LEN
;                           '#<STANDARD-CLASS CL-PPCRE::REPETITION>)
;    0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> PROGN SB-PCL::LOAD-DEFMETHOD SB-INT:NAMED-LAMBDA FUNCTION SYMBOL-MACROLET 
; --> SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET LET SB-PCL::BIND-ARGS 
; --> LET* SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 SB-PCL::PV-ENV LET LET BLOCK 
; --> LET SYMBOL-MACROLET IF IF IF IF IF IF IF IF IF IF PLUSP 
; ==>
;   (>
;    (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 3)
;                           CL-PPCRE::REPETITION
;                           0
;                           'CL-PPCRE::LEN
;                           '#<STANDARD-CLASS CL-PPCRE::REPETITION>)
;    0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> PROGN SB-PCL::LOAD-DEFMETHOD SB-INT:NAMED-LAMBDA FUNCTION SYMBOL-MACROLET 
; --> SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET LET SB-PCL::BIND-ARGS 
; --> LET* SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 SB-PCL::PV-ENV LET LET BLOCK 
; --> LET SYMBOL-MACROLET IF IF IF IF IF IF IF IF IF LET PLUSP > IF 
; ==>
;   (>
;    (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 5)
;                           CL-PPCRE::REPETITION
;                           0
;                           'CL-PPCRE::MIN-LEN
;                           '#<STANDARD-CLASS CL-PPCRE::REPETITION>)
;    0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.


; /var/cache/common-lisp-controller/1000/sbcl/cl-ppcre/repetition-closures.fasl written
; compilation finished in 0:00:06
; compiling file "/usr/share/common-lisp/source/cl-ppcre/scanner.lisp" (written 12 JUN 2006 10:18:57 PM):
; compiling (IN-PACKAGE #:CL-PPCRE)
; compiling (DEFMACRO BMH-MATCHER-AUX ...)
; compiling (DEFUN CREATE-BMH-MATCHER ...)
; file: /usr/share/common-lisp/source/cl-ppcre/scanner.lisp
; in: DEFUN CREATE-BMH-MATCHER
;     (CL-PPCRE::BMH-MATCHER-AUX :CASE-INSENSITIVE-P T)
; --> LAMBDA FUNCTION IF LOOP BLOCK LET SB-LOOP::LOOP-BODY TAGBODY LOOP BLOCK 
; --> LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS COND IF NOT IF AND IF AND 
; ==>
;   (CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::I)
;               (SCHAR CL-PPCRE::PATTERN CL-PPCRE::J))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (LENGTH CL-PPCRE::PATTERN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CHAR-UPCASE (SCHAR CL-PPCRE::PATTERN CL-PPCRE::K))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (CHAR-DOWNCASE (SCHAR CL-PPCRE::PATTERN CL-PPCRE::K))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (SEARCH CL-PPCRE::PATTERN
;           CL-PPCRE::*STRING*
;           :START2
;           CL-PPCRE::START-POS
;           :END2
;           CL-PPCRE::*END-POS*
;           :TEST
;           CL-PPCRE::TEST)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-STRING.

; compiling (DEFMACRO CHAR-SEARCHER-AUX ...)
; compiling (DEFUN CREATE-CHAR-SEARCHER ...)
; file: /usr/share/common-lisp/source/cl-ppcre/scanner.lisp
; in: DEFUN CREATE-CHAR-SEARCHER
;     (CL-PPCRE::CHAR-SEARCHER-AUX :CASE-INSENSITIVE-P T)
; --> LAMBDA FUNCTION AND IF AND LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY 
; --> WHEN COND IF SETQ THE AND IF 
; ==>
;   (CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::I) CL-PPCRE::CHR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

; compiling (DECLAIM (INLINE NEWLINE-SKIPPER))
; compiling (DEFUN NEWLINE-SKIPPER ...)
; compiling (DEFMACRO INSERT-ADVANCE-FN ...)
; compiling (DEFUN CREATE-SCANNER-AUX ...)
; file: /usr/share/common-lisp/source/cl-ppcre/scanner.lisp
; in: DEFMACRO INSERT-ADVANCE-FN
;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STARTS-WITH-STR
;                             CL-PPCRE::*START-POS*
;                             (+ CL-PPCRE::*START-POS* CL-PPCRE::STARTS-WITH-LEN)
;                             0
;                             CL-PPCRE::STARTS-WITH-LEN)
; --> BLOCK LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS COND IF NOT IF 
; ==>
;   (CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;               (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G301)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STARTS-WITH-STR
;                             CL-PPCRE::*START-POS*
;                             (+ CL-PPCRE::*START-POS* CL-PPCRE::STARTS-WITH-LEN)
;                             0
;                             CL-PPCRE::STARTS-WITH-LEN)
; --> BLOCK LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS COND IF NOT IF 
; ==>
;   (CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;               (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G291)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STARTS-WITH-STR
;                             CL-PPCRE::*START-POS*
;                             (+ CL-PPCRE::*START-POS* CL-PPCRE::STARTS-WITH-LEN)
;                             0
;                             CL-PPCRE::STARTS-WITH-LEN)
; --> BLOCK LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS COND IF NOT IF 
; ==>
;   (CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;               (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G281)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STARTS-WITH-STR
;                             CL-PPCRE::*START-POS*
;                             (+ CL-PPCRE::*START-POS* CL-PPCRE::STARTS-WITH-LEN)
;                             0
;                             CL-PPCRE::STARTS-WITH-LEN)
; --> BLOCK LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS COND IF NOT IF 
; ==>
;   (CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;               (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G271)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STARTS-WITH-STR
;                             CL-PPCRE::*START-POS*
;                             (+ CL-PPCRE::*START-POS* CL-PPCRE::STARTS-WITH-LEN)
;                             0
;                             CL-PPCRE::STARTS-WITH-LEN)
; --> BLOCK LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS COND IF NOT IF 
; ==>
;   (CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;               (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G261)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STARTS-WITH-STR
;                             CL-PPCRE::*START-POS*
;                             (+ CL-PPCRE::*START-POS* CL-PPCRE::STARTS-WITH-LEN)
;                             0
;                             CL-PPCRE::STARTS-WITH-LEN)
; --> BLOCK LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS COND IF NOT IF 
; ==>
;   (CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;               (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G251)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STARTS-WITH-STR
;                             CL-PPCRE::*START-POS*
;                             (+ CL-PPCRE::*START-POS* CL-PPCRE::STARTS-WITH-LEN)
;                             0
;                             CL-PPCRE::STARTS-WITH-LEN)
; --> BLOCK LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS COND IF NOT IF 
; ==>
;   (CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;               (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G241)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STARTS-WITH-STR
;                             CL-PPCRE::*START-POS*
;                             (+ CL-PPCRE::*START-POS* CL-PPCRE::STARTS-WITH-LEN)
;                             0
;                             CL-PPCRE::STARTS-WITH-LEN)
; --> BLOCK LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS COND IF NOT IF 
; ==>
;   (CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;               (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G227)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (<= CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; --> IF 
; ==>
;   (> CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G241)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; --> IF 
; ==>
;   (> CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G227)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; --> IF 
; ==>
;   (> CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G251)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; --> IF 
; ==>
;   (> CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G261)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; --> IF 
; ==>
;   (> CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G271)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; --> IF 
; ==>
;   (> CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G281)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; --> IF 
; ==>
;   (> CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G291)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; --> IF 
; ==>
;   (> CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G301)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;    (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS) CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND
;    '#<SB-C::GLOBAL-VAR
;       :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;       :KIND :SPECIAL {B8AD439}>
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {B8AD439}> {BEB6611}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

; in: DEFMACRO INSERT-ADVANCE-FN
;     (FUNCALL CL-PPCRE::END-STRING-TEST (1- CL-PPCRE::END-TEST-POS))
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G635)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;    (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;                          (DECLARE (TYPE FUNCTION CL-PPCRE::END-STRING-TEST))
;                          (IF
;                           (<= (THE FIXNUM CL-PPCRE::POS)
;                               (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;                           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;                          (UNLESS
;                              (SETQ CL-PPCRE::*END-STRING-POS*
;                                      (FUNCALL CL-PPCRE::END-STRING-TEST
;                                               CL-PPCRE::POS))
;                            (RETURN-FROM CL-PPCRE:SCAN NIL))
;                          CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND
;    '#<SB-C::GLOBAL-VAR
;       :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;       :KIND :SPECIAL {B8AD439}>
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {B8AD439}> {BEB6B89}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

; in: DEFMACRO INSERT-ADVANCE-FN
;     (FUNCALL CL-PPCRE::END-STRING-TEST (1- CL-PPCRE::END-TEST-POS))
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G882)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;    (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;                          (UNLESS
;                              (SETQ CL-PPCRE::POS
;                                      (CL-PPCRE::NEWLINE-SKIPPER CL-PPCRE::POS))
;                            (RETURN-FROM CL-PPCRE:SCAN NIL))
;                          CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND
;    '#<SB-C::GLOBAL-VAR
;       :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;       :KIND :SPECIAL {B8AD439}>
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {B8AD439}> {BEB7089}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

; in: DEFMACRO INSERT-ADVANCE-FN
;     (FUNCALL CL-PPCRE::END-STRING-TEST (1- CL-PPCRE::END-TEST-POS))
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G1129)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;    (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;                          (DECLARE (TYPE FUNCTION CL-PPCRE::START-STRING-TEST))
;                          (UNLESS
;                              (SETQ CL-PPCRE::POS
;                                      (FUNCALL CL-PPCRE::START-STRING-TEST
;                                               CL-PPCRE::POS))
;                            (RETURN-FROM CL-PPCRE:SCAN NIL))
;                          CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND
;    '#<SB-C::GLOBAL-VAR
;       :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;       :KIND :SPECIAL {B8AD439}>
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {B8AD439}> {BEB75B9}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

; in: DEFMACRO INSERT-ADVANCE-FN
;     (FUNCALL CL-PPCRE::END-STRING-TEST (1- CL-PPCRE::END-TEST-POS))
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G1376)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;    (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;                          (DECLARE (TYPE FUNCTION CL-PPCRE::END-STRING-TEST))
;                          (UNLESS
;                              (SETQ CL-PPCRE::POS
;                                      (CL-PPCRE::NEWLINE-SKIPPER CL-PPCRE::POS))
;                            (RETURN-FROM CL-PPCRE:SCAN NIL))
;                          (IF
;                           (<= (THE FIXNUM CL-PPCRE::POS)
;                               (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;                           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;                          (UNLESS
;                              (SETQ CL-PPCRE::*END-STRING-POS*
;                                      (FUNCALL CL-PPCRE::END-STRING-TEST
;                                               CL-PPCRE::POS))
;                            (RETURN-FROM CL-PPCRE:SCAN NIL))
;                          CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND
;    '#<SB-C::GLOBAL-VAR
;       :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;       :KIND :SPECIAL {B8AD439}>
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {B8AD439}> {BEB7AE9}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

; in: DEFMACRO INSERT-ADVANCE-FN
;     (FUNCALL CL-PPCRE::END-STRING-TEST (1- CL-PPCRE::END-TEST-POS))
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G1624)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;    (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;                          (DECLARE
;                           (TYPE FUNCTION
;                                 CL-PPCRE::START-STRING-TEST
;                                 CL-PPCRE::END-STRING-TEST))
;                          (UNLESS
;                              (SETQ CL-PPCRE::POS
;                                      (FUNCALL CL-PPCRE::START-STRING-TEST
;                                               CL-PPCRE::POS))
;                            (RETURN-FROM CL-PPCRE:SCAN NIL))
;                          (IF
;                           (<= (THE FIXNUM CL-PPCRE::POS)
;                               (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;                           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;                          (UNLESS
;                              (SETQ CL-PPCRE::*END-STRING-POS*
;                                      (FUNCALL CL-PPCRE::END-STRING-TEST
;                                               CL-PPCRE::POS))
;                            (RETURN-FROM CL-PPCRE:SCAN NIL))
;                          CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND
;    '#<SB-C::GLOBAL-VAR
;       :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;       :KIND :SPECIAL {B8AD439}>
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {B8AD439}> {BEB8001}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

; in: DEFMACRO INSERT-ADVANCE-FN
;     (FUNCALL CL-PPCRE::END-STRING-TEST (1- CL-PPCRE::END-TEST-POS))
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G1873)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;    (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;                          (DECLARE (TYPE FIXNUM CL-PPCRE::END-STRING-OFFSET)
;                                   (TYPE FUNCTION CL-PPCRE::END-STRING-TEST))
;                          (LOOP
;                           (UNLESS (SETQ CL-PPCRE::POS #)
;                             (RETURN-FROM CL-PPCRE:SCAN NIL))
;                           (LOCALLY
;                            (DECLARE #)
;                            (WHEN # #)
;                            (LET #
;                              #)))))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND
;    '#<SB-C::GLOBAL-VAR
;       :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;       :KIND :SPECIAL {B8AD439}>
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {B8AD439}> {BEB8501}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

;     (SETQ CL-PPCRE::TRY-POS (1+ CL-PPCRE::*END-STRING-POS*))
; 
; note: doing signed word to integer coercion (cost 20) to TRY-POS
; 
; note: doing signed word to integer coercion (cost 20) to TRY-POS

; in: DEFMACRO INSERT-ADVANCE-FN
;     (FUNCALL CL-PPCRE::END-STRING-TEST (1- CL-PPCRE::END-TEST-POS))
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G2122)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;    (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;                          (DECLARE
;                           (TYPE FIXNUM
;                                 CL-PPCRE::END-STRING-OFFSET
;                                 CL-PPCRE::STARTS-WITH-LEN)
;                           (TYPE FUNCTION
;                                 CL-PPCRE::START-STRING-TEST
;                                 CL-PPCRE::END-STRING-TEST))
;                          (LOOP
;                           (UNLESS (SETQ CL-PPCRE::POS #)
;                             (RETURN-FROM CL-PPCRE:SCAN NIL))
;                           (LOCALLY
;                            (DECLARE #)
;                            (WHEN # #)
;                            (LET #
;                              #)))))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND
;    '#<SB-C::GLOBAL-VAR
;       :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;       :KIND :SPECIAL {B8AD439}>
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {B8AD439}> {BEB89D1}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

;     (FUNCALL CL-PPCRE::END-STRING-TEST CL-PPCRE::TRY-POS)
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G2376)
; 
; note: doing signed word to integer coercion (cost 20) from TRY-POS

; ==>
;   (SB-C::%FUNCALL FUNCTION #:G2128)
; 
; note: doing signed word to integer coercion (cost 20) from TRY-POS

; in: DEFMACRO INSERT-ADVANCE-FN
;     (FUNCALL CL-PPCRE::END-STRING-TEST (1- CL-PPCRE::END-TEST-POS))
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G2371)
; 
; note: doing signed word to integer coercion (cost 20)


; /var/cache/common-lisp-controller/1000/sbcl/cl-ppcre/scanner.fasl written
; compilation finished in 0:00:04
; compiling file "/usr/share/common-lisp/source/cl-ppcre/api.lisp" (written 12 JUN 2006 10:18:57 PM):
; compiling (IN-PACKAGE #:CL-PPCRE)
; compiling (DEFGENERIC CREATE-SCANNER ...)
; compiling (DEFMETHOD CREATE-SCANNER ...)
; file: /usr/share/common-lisp/source/cl-ppcre/api.lisp
; in: DEFMETHOD CREATE-SCANNER (STRING)
;     (COPY-SEQ CL-PPCRE::QUOTED-REGEX-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES SIMPLE-BASE-STRING &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY CHARACTER (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY SINGLE-FLOAT (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-BIT-VECTOR.
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES SIMPLE-BIT-VECTOR &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 2) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 2)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 4) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 4)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 7) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 7)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 8)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 15) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 15)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 16) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 16)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 29) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 29)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 31) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 31)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 32) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 32)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 8) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (SIGNED-BYTE 8) (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 16) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (SIGNED-BYTE 16)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY FIXNUM (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES (SIMPLE-ARRAY FIXNUM (*))
;                                                     &REST
;                                                     T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 32) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (SIGNED-BYTE 32)
;                                                            (*))
;                                              &REST
;                                              T).

; compiling (DEFMETHOD CREATE-SCANNER ...)
; compiling (DEFMETHOD CREATE-SCANNER ...)
; file: /usr/share/common-lisp/source/cl-ppcre/api.lisp
; in: DEFMETHOD CREATE-SCANNER (T)
;     (PLUSP (CL-PPCRE::LEN CL-PPCRE::END-STRING))
; ==>
;   (> (CL-PPCRE::LEN CL-PPCRE::END-STRING) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (= 1 (CL-PPCRE::LEN CL-PPCRE::END-STRING))
; --> = IF 
; ==>
;   (= SB-C::Y 1)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

;     (PLUSP (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH))
; ==>
;   (> (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (= 1 (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH))
; --> = IF 
; ==>
;   (= SB-C::Y 1)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

;     (PLUSP (CL-PPCRE::LEN CL-PPCRE::END-STRING))
; ==>
;   (> (CL-PPCRE::LEN CL-PPCRE::END-STRING) 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (PLUSP (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH))
; ==>
;   (> (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH) 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; compiling (DEFGENERIC SCAN ...)
; compiling (DEFMETHOD SCAN ...)
; file: /usr/share/common-lisp/source/cl-ppcre/api.lisp
; in: DEFMETHOD SCAN (STRING T)
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (FUNCALL (CL-PPCRE:CREATE-SCANNER CL-PPCRE::REGEX-STRING)
;            (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING CL-PPCRE::TARGET-STRING)
;            CL-PPCRE::START
;            CL-PPCRE::END)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR FUNCTION SYMBOL), not a FUNCTION.

; compiling (DEFMETHOD SCAN ...)
; file: /usr/share/common-lisp/source/cl-ppcre/api.lisp
; in: DEFMETHOD SCAN #'T
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFMETHOD SCAN ...)
; file: /usr/share/common-lisp/source/cl-ppcre/api.lisp
; in: DEFMETHOD SCAN (T T)
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (FUNCALL (CL-PPCRE:CREATE-SCANNER CL-PPCRE::PARSE-TREE)
;            (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING CL-PPCRE::TARGET-STRING)
;            CL-PPCRE::START
;            CL-PPCRE::END)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR FUNCTION SYMBOL), not a FUNCTION.

; compiling (DEFINE-COMPILER-MACRO SCAN ...)
; compiling (DEFUN SCAN-TO-STRINGS ...)
; file: /usr/share/common-lisp/source/cl-ppcre/api.lisp
; in: DEFUN SCAN-TO-STRINGS
;     (MAP 'VECTOR
;        (LAMBDA (CL-PPCRE::REG-START CL-PPCRE::REG-END)
;          (IF CL-PPCRE::REG-START
;              (FUNCALL CL-PPCRE::SUBSTR-FN
;                       CL-PPCRE::TARGET-STRING
;                       CL-PPCRE::REG-START
;                       CL-PPCRE::REG-END)
;              NIL))
;        CL-PPCRE::REG-STARTS
;        CL-PPCRE::REG-ENDS)
; --> TRULY-THE 
; ==>
;   (SB-KERNEL:%MAP SB-C::RESULT-TYPE-ARG SB-C::FUN #:G129 #:G130)
; 
; note: unable to open code because: can't determine sequence argument type

;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFINE-COMPILER-MACRO SCAN-TO-STRINGS ...)
; compiling (DEFMACRO REGISTER-GROUPS-BIND ...); in: LAMBDA NIL
;     (LOOP CL-PPCRE::FOR
;         #'CL-PPCRE::VAR
;         CL-PPCRE::IN
;         (CL-PPCRE::NORMALIZE-VAR-LIST CL-PPCRE::VAR-LIST)
;         CL-PPCRE::FOR
;         CL-PPCRE::COUNTER
;         CL-PPCRE::FROM
;         0
;         WHEN
;         CL-PPCRE::VAR
;         CL-PPCRE::COLLECT
;         ...)
; --> BLOCK LET LET SB-LOOP::WITH-LOOP-LIST-COLLECTION-HEAD LET* 
; --> SB-LOOP::LOOP-BODY LET TAGBODY IF SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 1+ 
; ==>
;   (+ CL-PPCRE::COUNTER 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1)
;                               &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1)
;                               &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; file: /usr/share/common-lisp/source/cl-ppcre/api.lisp
; in: DEFMACRO REGISTER-GROUPS-BIND
;     (LOOP CL-PPCRE::FOR
;         #'CL-PPCRE::VAR
;         CL-PPCRE::IN
;         (CL-PPCRE::NORMALIZE-VAR-LIST CL-PPCRE::VAR-LIST)
;         CL-PPCRE::FOR
;         CL-PPCRE::COUNTER
;         CL-PPCRE::FROM
;         0
;         WHEN
;         CL-PPCRE::VAR
;         CL-PPCRE::COLLECT
;         ...)
; --> BLOCK LET LET SB-LOOP::WITH-LOOP-LIST-COLLECTION-HEAD LET* 
; --> SB-LOOP::LOOP-BODY LET TAGBODY IF SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 1+ 
; ==>
;   (+ CL-PPCRE::COUNTER 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1)
;                               &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1)
;                               &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFMACRO DO-SCANS ...)
; compiling (DEFMACRO DO-MATCHES ...)
; compiling (DEFMACRO DO-MATCHES-AS-STRINGS ...)
; compiling (DEFMACRO DO-REGISTER-GROUPS ...); in: LAMBDA NIL
;     (LOOP CL-PPCRE::FOR
;         #'CL-PPCRE::VAR
;         CL-PPCRE::IN
;         (CL-PPCRE::NORMALIZE-VAR-LIST CL-PPCRE::VAR-LIST)
;         CL-PPCRE::FOR
;         CL-PPCRE::COUNTER
;         CL-PPCRE::FROM
;         0
;         WHEN
;         CL-PPCRE::VAR
;         CL-PPCRE::COLLECT
;         ...)
; --> BLOCK LET LET SB-LOOP::WITH-LOOP-LIST-COLLECTION-HEAD LET* 
; --> SB-LOOP::LOOP-BODY LET TAGBODY IF SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 1+ 
; ==>
;   (+ CL-PPCRE::COUNTER 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1)
;                               &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1)
;                               &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; file: /usr/share/common-lisp/source/cl-ppcre/api.lisp
; in: DEFMACRO DO-REGISTER-GROUPS
;     (LOOP CL-PPCRE::FOR
;         #'CL-PPCRE::VAR
;         CL-PPCRE::IN
;         (CL-PPCRE::NORMALIZE-VAR-LIST CL-PPCRE::VAR-LIST)
;         CL-PPCRE::FOR
;         CL-PPCRE::COUNTER
;         CL-PPCRE::FROM
;         0
;         WHEN
;         CL-PPCRE::VAR
;         CL-PPCRE::COLLECT
;         ...)
; --> BLOCK LET LET SB-LOOP::WITH-LOOP-LIST-COLLECTION-HEAD LET* 
; --> SB-LOOP::LOOP-BODY LET TAGBODY IF SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 1+ 
; ==>
;   (+ CL-PPCRE::COUNTER 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1)
;                               &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1)
;                               &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN ALL-MATCHES ...)
; file: /usr/share/common-lisp/source/cl-ppcre/api.lisp
; in: DEFUN ALL-MATCHES
;     (CL-PPCRE:DO-MATCHES
;    (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                           CL-PPCRE::REGEX
;                           CL-PPCRE::TARGET-STRING
;                           (NREVERSE CL-PPCRE::RESULT-LIST)
;                           :START
;                           CL-PPCRE::START
;                           :END
;                           CL-PPCRE::END)
;    (PUSH CL-PPCRE::MATCH-START CL-PPCRE::RESULT-LIST)
;    (PUSH CL-PPCRE::MATCH-END CL-PPCRE::RESULT-LIST))
; --> CL-PPCRE:DO-SCANS LET BLOCK LET* BLOCK TAGBODY MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==>
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; --> CL-PPCRE:DO-SCANS LET BLOCK LET* BLOCK TAGBODY MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE:DO-MATCHES
;    (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                           CL-PPCRE::REGEX
;                           CL-PPCRE::TARGET-STRING
;                           (NREVERSE CL-PPCRE::RESULT-LIST)
;                           :START
;                           CL-PPCRE::START
;                           :END
;                           CL-PPCRE::END)
;    (PUSH CL-PPCRE::MATCH-START CL-PPCRE::RESULT-LIST)
;    (PUSH CL-PPCRE::MATCH-END CL-PPCRE::RESULT-LIST))
; --> CL-PPCRE:DO-SCANS LET BLOCK LET* OR LET IF OR 
; ==>
;   (LENGTH #:TARGET-STRING230)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> CL-PPCRE:DO-SCANS LET BLOCK LET* BLOCK TAGBODY MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==>
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.

; --> CL-PPCRE:DO-SCANS LET BLOCK LET* BLOCK TAGBODY MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFINE-COMPILER-MACRO ALL-MATCHES ...)
; compiling (DEFUN ALL-MATCHES-AS-STRINGS ...)
; file: /usr/share/common-lisp/source/cl-ppcre/api.lisp
; in: DEFUN ALL-MATCHES-AS-STRINGS
;     (CL-PPCRE:DO-MATCHES-AS-STRINGS
;    (CL-PPCRE::MATCH CL-PPCRE::REGEX
;                     CL-PPCRE::TARGET-STRING
;                     (NREVERSE CL-PPCRE::RESULT-LIST)
;                     :START
;                     CL-PPCRE::START
;                     :END
;                     CL-PPCRE::END
;                     :SHAREDP
;                     CL-PPCRE::SHAREDP)
;    (PUSH CL-PPCRE::MATCH CL-PPCRE::RESULT-LIST))
; --> LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* BLOCK 
; --> TAGBODY MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==>
;   (= #:MATCH-START280 #:MATCH-END281)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* BLOCK 
; --> TAGBODY MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ #:MATCH-END281 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE:DO-MATCHES-AS-STRINGS
;    (CL-PPCRE::MATCH CL-PPCRE::REGEX
;                     CL-PPCRE::TARGET-STRING
;                     (NREVERSE CL-PPCRE::RESULT-LIST)
;                     :START
;                     CL-PPCRE::START
;                     :END
;                     CL-PPCRE::END
;                     :SHAREDP
;                     CL-PPCRE::SHAREDP)
;    (PUSH CL-PPCRE::MATCH CL-PPCRE::RESULT-LIST))
; --> LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* OR LET IF OR 
; ==>
;   (LENGTH #:TARGET-STRING285)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* BLOCK 
; --> TAGBODY MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==>
;   (= #:MATCH-START280 #:MATCH-END281)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.

; --> LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* BLOCK 
; --> TAGBODY MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ #:MATCH-END281 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFINE-COMPILER-MACRO ALL-MATCHES-AS-STRINGS ...)
; compiling (DEFUN SPLIT ...)
; file: /usr/share/common-lisp/source/cl-ppcre/api.lisp
; in: DEFUN SPLIT
;     (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

;     (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

;     (> CL-PPCRE::THIS-END CL-PPCRE::THIS-START)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

;     (LOOP CL-PPCRE::FOR
;         CL-PPCRE::REG-START
;         CL-PPCRE::ACROSS
;         CL-PPCRE::REG-STARTS
;         CL-PPCRE::FOR
;         CL-PPCRE::REG-END
;         CL-PPCRE::ACROSS
;         CL-PPCRE::REG-ENDS
;         IF
;         CL-PPCRE::REG-START
;         DO
;         ...)
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY SETQ THE 
; ==>
;   (LENGTH #:LOOP-ACROSS-VECTOR-349)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR NULL VECTOR), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR NULL VECTOR), not a VECTOR.

; ==>
;   (LENGTH #:LOOP-ACROSS-VECTOR-352)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR NULL VECTOR), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR NULL VECTOR), not a VECTOR.

; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> THE AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

;     (CL-PPCRE:DO-SCANS
;    (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                           CL-PPCRE::REG-STARTS
;                           CL-PPCRE::REG-ENDS
;                           CL-PPCRE::REGEX
;                           CL-PPCRE::TARGET-STRING
;                           NIL
;                           :START
;                           CL-PPCRE::START
;                           :END
;                           CL-PPCRE::END)
;    (UNLESS
;        (AND (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
;             (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST)))
;      (WHEN (AND CL-PPCRE::LIMIT (>= # CL-PPCRE::LIMIT)) (RETURN))
;      (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;      (WHEN CL-PPCRE::WITH-REGISTERS-P
;        (LOOP CL-PPCRE::FOR
;              CL-PPCRE::REG-START
;              CL-PPCRE::ACROSS
;              CL-PPCRE::REG-STARTS
;              CL-PPCRE::FOR
;              CL-PPCRE::REG-END
;              CL-PPCRE::ACROSS
;              CL-PPCRE::REG-ENDS
;              IF
;              CL-PPCRE::REG-START
;              DO
;              ...))
;      (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)))
; --> LET BLOCK LET* BLOCK TAGBODY MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> FUNCTION SETQ THE IF 
; ==>
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET BLOCK LET* BLOCK TAGBODY MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE:DO-SCANS
;    (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                           CL-PPCRE::REG-STARTS
;                           CL-PPCRE::REG-ENDS
;                           CL-PPCRE::REGEX
;                           CL-PPCRE::TARGET-STRING
;                           NIL
;                           :START
;                           CL-PPCRE::START
;                           :END
;                           CL-PPCRE::END)
;    (UNLESS
;        (AND (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
;             (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST)))
;      (WHEN (AND CL-PPCRE::LIMIT (>= # CL-PPCRE::LIMIT)) (RETURN))
;      (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;      (WHEN CL-PPCRE::WITH-REGISTERS-P
;        (LOOP CL-PPCRE::FOR
;              CL-PPCRE::REG-START
;              CL-PPCRE::ACROSS
;              CL-PPCRE::REG-STARTS
;              CL-PPCRE::FOR
;              CL-PPCRE::REG-END
;              CL-PPCRE::ACROSS
;              CL-PPCRE::REG-ENDS
;              IF
;              CL-PPCRE::REG-START
;              DO
;              ...))
;      (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)))
; --> LET BLOCK LET* OR LET IF OR 
; ==>
;   (LENGTH #:TARGET-STRING336)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.

;     (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST))
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.

;     (INCF CL-PPCRE::COUNTER)
; --> LET* 
; ==>
;   (+ CL-PPCRE::COUNTER #:G346)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1)
;                               &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1)
;                               &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (>= (INCF CL-PPCRE::COUNTER) CL-PPCRE::LIMIT)
; --> IF 
; ==>
;   (< (INCF CL-PPCRE::COUNTER) CL-PPCRE::LIMIT)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (CL-PPCRE:DO-SCANS
;    (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                           CL-PPCRE::REG-STARTS
;                           CL-PPCRE::REG-ENDS
;                           CL-PPCRE::REGEX
;                           CL-PPCRE::TARGET-STRING
;                           NIL
;                           :START
;                           CL-PPCRE::START
;                           :END
;                           CL-PPCRE::END)
;    (UNLESS
;        (AND (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
;             (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST)))
;      (WHEN (AND CL-PPCRE::LIMIT (>= # CL-PPCRE::LIMIT)) (RETURN))
;      (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;      (WHEN CL-PPCRE::WITH-REGISTERS-P
;        (LOOP CL-PPCRE::FOR
;              CL-PPCRE::REG-START
;              CL-PPCRE::ACROSS
;              CL-PPCRE::REG-STARTS
;              CL-PPCRE::FOR
;              CL-PPCRE::REG-END
;              CL-PPCRE::ACROSS
;              CL-PPCRE::REG-ENDS
;              IF
;              CL-PPCRE::REG-START
;              DO
;              ...))
;      (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)))
; --> LET BLOCK LET* BLOCK TAGBODY MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> FUNCTION SETQ THE IF 
; ==>
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.

; --> LET BLOCK LET* BLOCK TAGBODY MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (> CL-PPCRE::THIS-END CL-PPCRE::THIS-START)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFINE-COMPILER-MACRO SPLIT ...)
; compiling (DEFUN STRING-CASE-MODIFIER ...)
; file: /usr/share/common-lisp/source/cl-ppcre/api.lisp
; in: DEFUN STRING-CASE-MODIFIER
;     (CHAR CL-PPCRE::STR (1- CL-PPCRE::FROM))
; --> AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

;     (ALPHANUMERICP (CHAR CL-PPCRE::STR (1- CL-PPCRE::FROM)))
; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CHAR CL-PPCRE::STR CL-PPCRE::FROM)
; --> AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

;     (ALPHANUMERICP (CHAR CL-PPCRE::STR CL-PPCRE::FROM))
; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CHAR CL-PPCRE::STR CL-PPCRE::TO)
; --> AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

;     (CHAR CL-PPCRE::STR (1- CL-PPCRE::TO))
; --> AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

;     (ALPHANUMERICP (CHAR CL-PPCRE::STR (1- CL-PPCRE::TO)))
; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CHAR CL-PPCRE::STR CL-PPCRE::INDEX)
; --> AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

;     (ALPHANUMERICP (CHAR CL-PPCRE::STR CL-PPCRE::TO))
; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (BOTH-CASE-P CL-PPCRE::CHR)
; --> BLOCK < IF 
; ==>
;   (< (SB-IMPL::UCD-VALUE-0 CHAR) 2)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (UPPER-CASE-P CL-PPCRE::CHR)
; --> BLOCK = IF 
; ==>
;   (= (SB-IMPL::UCD-VALUE-0 CHAR) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

;     (ALPHANUMERICP (CHAR CL-PPCRE::STR (1- CL-PPCRE::FROM)))
; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (ALPHANUMERICP (CHAR CL-PPCRE::STR CL-PPCRE::FROM))
; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (ALPHANUMERICP (CHAR CL-PPCRE::STR CL-PPCRE::TO))
; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (ALPHANUMERICP (CHAR CL-PPCRE::STR (1- CL-PPCRE::TO)))
; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (BOTH-CASE-P CL-PPCRE::CHR)
; --> BLOCK < IF 
; ==>
;   (< (SB-IMPL::UCD-VALUE-0 CHAR) 2)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; compiling (DEFGENERIC BUILD-REPLACEMENT-TEMPLATE ...)
; compiling (LET* (# #) ...)
; file: /usr/share/common-lisp/source/cl-ppcre/api.lisp
; in: DEFMETHOD BUILD-REPLACEMENT-TEMPLATE (STRING)
;     (SUBSEQ CL-PPCRE::REPLACEMENT-STRING CL-PPCRE::FROM)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES SIMPLE-BASE-STRING &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY CHARACTER (*))
;                                              &REST
;                                              T).

;     (SUBSEQ CL-PPCRE::REPLACEMENT-STRING CL-PPCRE::FROM CL-PPCRE::MATCH-START)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES SIMPLE-BASE-STRING &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY CHARACTER (*))
;                                              &REST
;                                              T).

;     (POSITION-IF #'DIGIT-CHAR-P
;                CL-PPCRE::REPLACEMENT-STRING
;                :START
;                CL-PPCRE::MATCH-START
;                :END
;                CL-PPCRE::MATCH-END)
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%FIND-POSITION-IF
;    (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-C:PREDICATE)
;    SEQUENCE
;    SB-C::FROM-END
;    SB-C::START
;    SB-C::END
;    (SB-KERNEL:EFFECTIVE-FIND-POSITION-KEY SB-C::KEY))
; 
; note: unable to
;   expand inline
; because:
;   upgraded array element type not known at compile time

;     (CHAR CL-PPCRE::REPLACEMENT-STRING (1+ CL-PPCRE::MATCH-START))
; --> AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

;     (SUBSEQ CL-PPCRE::REPLACEMENT-STRING
;           CL-PPCRE::MATCH-START
;           CL-PPCRE::MATCH-END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES SIMPLE-BASE-STRING &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY CHARACTER (*))
;                                              &REST
;                                              T).

;     (< CL-PPCRE::FROM CL-PPCRE::MATCH-START)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (1-
;    (PARSE-INTEGER CL-PPCRE::REPLACEMENT-STRING
;                   :START
;                   CL-PPCRE::PARSE-START
;                   :JUNK-ALLOWED
;                   T))
; ==>
;   (-
;    (PARSE-INTEGER CL-PPCRE::REPLACEMENT-STRING
;                   :START
;                   CL-PPCRE::PARSE-START
;                   :JUNK-ALLOWED
;                   T)
;    1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (< CL-PPCRE::TOKEN 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

; compiling (DEFMETHOD BUILD-REPLACEMENT-TEMPLATE ...)
; compiling (DEFMETHOD BUILD-REPLACEMENT-TEMPLATE ...)
; compiling (DEFMETHOD BUILD-REPLACEMENT-TEMPLATE ...)
; compiling (DEFUN BUILD-REPLACEMENT ...)
; file: /usr/share/common-lisp/source/cl-ppcre/api.lisp
; in: DEFUN BUILD-REPLACEMENT
;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING
;                      CL-PPCRE::REG-START
;                      CL-PPCRE::REG-END)
; --> BLOCK MAKE-ARRAY 
; ==>
;   (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING
;                      CL-PPCRE::MATCH-START
;                      CL-PPCRE::MATCH-END)
; --> BLOCK MAKE-ARRAY 
; ==>
;   (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (ARRAY-DIMENSION CL-PPCRE::REG-STARTS 0)
; 
; note: unable to
;   optimize
; because:
;   The array dimensions are unknown; must call ARRAY-DIMENSION at runtime.

;     (MAP 'LIST
;        (LAMBDA (CL-PPCRE::REG-START CL-PPCRE::REG-END)
;          (AND CL-PPCRE::REG-START
;               (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING
;                                  CL-PPCRE::REG-START
;                                  CL-PPCRE::REG-END)))
;        CL-PPCRE::REG-STARTS
;        CL-PPCRE::REG-ENDS)
; --> TRULY-THE 
; ==>
;   (SB-KERNEL:%MAP SB-C::RESULT-TYPE-ARG SB-C::FUN #:G573 #:G574)
; 
; note: unable to open code because: can't determine sequence argument type

; ==>
;   (SB-KERNEL:%MAP SB-C::RESULT-TYPE-ARG SB-C::FUN #:G582 #:G583)
; 
; note: unable to open code because: can't determine sequence argument type

;     (>= CL-PPCRE::TOKEN CL-PPCRE::REG-BOUND)
; --> IF 
; ==>
;   (< CL-PPCRE::TOKEN CL-PPCRE::REG-BOUND)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.

;     (1+ CL-PPCRE::TOKEN)
; ==>
;   (+ CL-PPCRE::TOKEN 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1)
;                               &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1)
;                               &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING
;                      CL-PPCRE::MATCH-START
;                      CL-PPCRE::MATCH-END)
; --> BLOCK MAKE-ARRAY 
; ==>
;   (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING
;                      CL-PPCRE::REG-START
;                      CL-PPCRE::REG-END)
; --> BLOCK MAKE-ARRAY 
; ==>
;   (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN REPLACE-AUX ...)
; file: /usr/share/common-lisp/source/cl-ppcre/api.lisp
; in: DEFUN REPLACE-AUX
;     (FUNCALL
;    (CL-PPCRE::STRING-CASE-MODIFIER CL-PPCRE::TARGET-STRING
;                                    CL-PPCRE::FROM
;                                    CL-PPCRE::TO
;                                    CL-PPCRE::START
;                                    CL-PPCRE::END)
;    CL-PPCRE::CURR-REPLACEMENT)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR NULL FUNCTION), not a FUNCTION.

; compiling (DEFUN REGEX-REPLACE ...)
; file: /usr/share/common-lisp/source/cl-ppcre/api.lisp
; in: DEFUN REGEX-REPLACE
;     (SUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::START CL-PPCRE::END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES SIMPLE-BASE-STRING &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY CHARACTER (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY SINGLE-FLOAT (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-BIT-VECTOR.
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES SIMPLE-BIT-VECTOR &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 2) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 2)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 4) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 4)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 7) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 7)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 8)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 15) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 15)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 16) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 16)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 29) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 29)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 31) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 31)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 32) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 32)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 8) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (SIGNED-BYTE 8) (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 16) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (SIGNED-BYTE 16)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY FIXNUM (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES (SIMPLE-ARRAY FIXNUM (*))
;                                                     &REST
;                                                     T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 32) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (SIGNED-BYTE 32)
;                                                            (*))
;                                              &REST
;                                              T).

;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFINE-COMPILER-MACRO REGEX-REPLACE ...)
; compiling (DEFUN REGEX-REPLACE-ALL ...)
; file: /usr/share/common-lisp/source/cl-ppcre/api.lisp
; in: DEFUN REGEX-REPLACE-ALL
;     (SUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::START CL-PPCRE::END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES SIMPLE-BASE-STRING &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY CHARACTER (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY SINGLE-FLOAT (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-BIT-VECTOR.
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES SIMPLE-BIT-VECTOR &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 2) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 2)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 4) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 4)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 7) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 7)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 8)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 15) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 15)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 16) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 16)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 29) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 29)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 31) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 31)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 32) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (UNSIGNED-BYTE 32)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 8) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (SIGNED-BYTE 8) (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 16) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (SIGNED-BYTE 16)
;                                                            (*))
;                                              &REST
;                                              T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY FIXNUM (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES (SIMPLE-ARRAY FIXNUM (*))
;                                                     &REST
;                                                     T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 32) (*)).
;   The result is a (VALUES (OR CONS NULL (SIMPLE-ARRAY * (*)))
;                           &OPTIONAL), not a (VALUES
;                                              (SIMPLE-ARRAY (SIGNED-BYTE 32)
;                                                            (*))
;                                              &REST
;                                              T).

;     (CL-PPCRE:DO-SCANS
;    (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                           CL-PPCRE::REG-STARTS
;                           CL-PPCRE::REG-ENDS
;                           CL-PPCRE::REGEX
;                           CL-PPCRE::TARGET-STRING
;                           NIL
;                           :START
;                           CL-PPCRE::START
;                           :END
;                           CL-PPCRE::END)
;    (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;    (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)
;    (PUSH CL-PPCRE::REG-STARTS CL-PPCRE::REG-LIST)
;    (PUSH CL-PPCRE::REG-ENDS CL-PPCRE::REG-LIST))
; --> LET BLOCK LET* BLOCK TAGBODY MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> FUNCTION SETQ THE IF 
; ==>
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET BLOCK LET* BLOCK TAGBODY MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE:DO-SCANS
;    (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                           CL-PPCRE::REG-STARTS
;                           CL-PPCRE::REG-ENDS
;                           CL-PPCRE::REGEX
;                           CL-PPCRE::TARGET-STRING
;                           NIL
;                           :START
;                           CL-PPCRE::START
;                           :END
;                           CL-PPCRE::END)
;    (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;    (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)
;    (PUSH CL-PPCRE::REG-STARTS CL-PPCRE::REG-LIST)
;    (PUSH CL-PPCRE::REG-ENDS CL-PPCRE::REG-LIST))
; --> LET BLOCK LET* OR LET IF OR 
; ==>
;   (LENGTH #:TARGET-STRING677)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> LET BLOCK LET* BLOCK TAGBODY MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> FUNCTION SETQ THE IF 
; ==>
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.

; --> LET BLOCK LET* BLOCK TAGBODY MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFINE-COMPILER-MACRO REGEX-REPLACE-ALL ...)
; compiling (DEFMACRO REGEX-APROPOS-AUX ...)
; compiling (DEFUN REGEX-APROPOS-LIST ...)
; file: /usr/share/common-lisp/source/cl-ppcre/api.lisp
; in: DEFUN REGEX-APROPOS-LIST
;     (DEFUN CL-PPCRE:REGEX-APROPOS-LIST
;          (CL-PPCRE::REGEX
;           &OPTIONAL CL-PPCRE::PACKAGES
;           &KEY (CL-PPCRE::CASE-INSENSITIVE T))
;     (DECLARE
;      (OPTIMIZE SPEED (SAFETY 0) (SPACE 0) (DEBUG 1) (COMPILATION-SPEED 0)))
;     "Similar to the standard function APROPOS-LIST but returns a list of
; all symbols which match the regular expression REGEX. If
; CASE-INSENSITIVE is true and REGEX isn't already a scanner, a
; case-insensitive scanner is used."
;     (LET ((CL-PPCRE::COLLECTOR 'NIL))
;       (CL-PPCRE::REGEX-APROPOS-AUX
;        (CL-PPCRE::REGEX CL-PPCRE::PACKAGES
;                         CL-PPCRE::CASE-INSENSITIVE
;                         CL-PPCRE::COLLECTOR)
;        (PUSH SYMBOL CL-PPCRE::COLLECTOR))))
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA CL-PPCRE:REGEX-APROPOS-LIST
;                          (CL-PPCRE::REGEX &OPTIONAL
;                                           CL-PPCRE::PACKAGES
;                                           &KEY
;                                           (CL-PPCRE::CASE-INSENSITIVE T))
;                          (DECLARE
;                           (OPTIMIZE SPEED
;                                     (SAFETY 0)
;                                     (SPACE 0)
;                                     (DEBUG 1)
;                                     (COMPILATION-SPEED 0)))
;                          (BLOCK CL-PPCRE:REGEX-APROPOS-LIST
;                            (LET ((CL-PPCRE::COLLECTOR 'NIL))
;                              (CL-PPCRE::REGEX-APROPOS-AUX
;                               (CL-PPCRE::REGEX CL-PPCRE::PACKAGES
;                                                CL-PPCRE::CASE-INSENSITIVE
;                                                CL-PPCRE::COLLECTOR)
;                               (PUSH SYMBOL CL-PPCRE::COLLECTOR)))))
; 
; caught STYLE-WARNING:
;   &OPTIONAL and &KEY found in the same lambda list: (REGEX &OPTIONAL
;                                                            PACKAGES
;                                                            &KEY
;                                                            (CASE-INSENSITIVE T))
; in: LAMBDA (#:WHOLE760 #:ENVIRONMENT761)
;     (MEMBER SB-IMPL::THIS-KIND '(:INTERNAL :EXTERNAL :INHERITED))
; --> BLOCK LET DO BLOCK LET TAGBODY TAGBODY LET IF SB-IMPL::SATISFIES-THE-TEST 
; --> LET COND IF COND IF COND IF PROGN FUNCALL 
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G26 #:G27)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a SINGLE-FLOAT.
;   The second argument is a T, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a DOUBLE-FLOAT.
;   The second argument is a T, not a DOUBLE-FLOAT.
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

; compiling (DEFUN PRINT-SYMBOL-INFO ...)
; file: /usr/share/common-lisp/source/cl-ppcre/api.lisp
; in: DEFUN PRINT-SYMBOL-INFO
;     (FORMAT T "~&~S ~<~;~^~A~@{~:@_~A~}~;~:>" SYMBOL CL-PPCRE::OUTPUT-LIST)
; --> FORMAT FORMATTER FUNCTION BLOCK LET PPRINT-LOGICAL-BLOCK 
; --> SB-PRETTY::WITH-PRETTY-STREAM FLET BLOCK LET IF 
; --> SB-KERNEL:WITH-CIRCULARITY-DETECTION LABELS BLOCK SB-KERNEL:DESCEND-INTO 
; --> FLET COND IF AND IF AND IF AND >= IF 
; ==>
;   (< SB-KERNEL:*CURRENT-LEVEL-IN-PRINT* *PRINT-LEVEL*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> FORMAT FORMATTER FUNCTION BLOCK LET PPRINT-LOGICAL-BLOCK 
; --> SB-PRETTY::WITH-PRETTY-STREAM FLET BLOCK LET IF 
; --> SB-KERNEL:WITH-CIRCULARITY-DETECTION LABELS BLOCK SB-KERNEL:DESCEND-INTO 
; --> FLET COND IF COND IF PROGN LET 1+ 
; ==>
;   (+ SB-KERNEL:*CURRENT-LEVEL-IN-PRINT* 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

; --> FORMAT FORMATTER FUNCTION BLOCK LET PPRINT-LOGICAL-BLOCK 
; --> SB-PRETTY::WITH-PRETTY-STREAM 
; ==>
;   (FLET ((#:WITH-PRETTY-STREAM-1242 (STREAM)
;            (LET (#)
;              (IF # # #))))
;     (LET ((STREAM
;            (LET #
;              #)))
;       (IF (SB-PRETTY:PRETTY-STREAM-P STREAM)
;           (#:WITH-PRETTY-STREAM-1242 STREAM)
;           (CATCH 'SB-PRETTY::LINE-LIMIT-ABBREVIATION-HAPPENED
;             (LET #
;               #
;               #))))
;     NIL)
; 
; note: Return type not fixed values, so can't use known return convention:
;   *

; --> FORMAT FORMATTER FUNCTION BLOCK LET PPRINT-LOGICAL-BLOCK 
; --> SB-PRETTY::WITH-PRETTY-STREAM FLET BLOCK LET IF 
; --> SB-KERNEL:WITH-CIRCULARITY-DETECTION LABELS BLOCK SB-KERNEL:DESCEND-INTO 
; --> FLET BLOCK LET BLOCK FLET BLOCK WHEN COND IF AND IF AND 
; ==>
;   (EQL #:PPRINT-LOGICAL-BLOCK-LENGTH-1240 *PRINT-LENGTH*)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a (OR UNSIGNED-BYTE NULL), not a FIXNUM.

; --> FORMAT FORMATTER FUNCTION BLOCK LET PPRINT-LOGICAL-BLOCK 
; --> SB-PRETTY::WITH-PRETTY-STREAM FLET BLOCK LET IF 
; --> SB-KERNEL:WITH-CIRCULARITY-DETECTION LABELS BLOCK SB-KERNEL:DESCEND-INTO 
; --> FLET COND IF AND IF AND IF AND >= IF 
; ==>
;   (< SB-KERNEL:*CURRENT-LEVEL-IN-PRINT* *PRINT-LEVEL*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       The second argument is a UNSIGNED-BYTE, not a FIXNUM.

; --> FORMAT FORMATTER FUNCTION BLOCK LET PPRINT-LOGICAL-BLOCK 
; --> SB-PRETTY::WITH-PRETTY-STREAM FLET BLOCK LET IF 
; --> SB-KERNEL:WITH-CIRCULARITY-DETECTION LABELS BLOCK SB-KERNEL:DESCEND-INTO 
; --> FLET COND IF COND IF PROGN LET 1+ 
; ==>
;   (+ SB-KERNEL:*CURRENT-LEVEL-IN-PRINT* 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN REGEX-APROPOS ...)
; file: /usr/share/common-lisp/source/cl-ppcre/api.lisp
; in: DEFUN REGEX-APROPOS
;     (DEFUN CL-PPCRE:REGEX-APROPOS
;          (CL-PPCRE::REGEX
;           &OPTIONAL CL-PPCRE::PACKAGES
;           &KEY (CL-PPCRE::CASE-INSENSITIVE T))
;     "Similar to the standard function APROPOS but returns a list of all
; symbols which match the regular expression REGEX. If CASE-INSENSITIVE
; is true and REGEX isn't already a scanner, a case-insensitive scanner
; is used."
;     (DECLARE
;      (OPTIMIZE SPEED (SAFETY 0) (SPACE 0) (DEBUG 1) (COMPILATION-SPEED 0)))
;     (CL-PPCRE::REGEX-APROPOS-AUX
;      (CL-PPCRE::REGEX CL-PPCRE::PACKAGES CL-PPCRE::CASE-INSENSITIVE)
;      (CL-PPCRE::PRINT-SYMBOL-INFO SYMBOL))
;     (VALUES))
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA CL-PPCRE:REGEX-APROPOS
;                          (CL-PPCRE::REGEX &OPTIONAL
;                                           CL-PPCRE::PACKAGES
;                                           &KEY
;                                           (CL-PPCRE::CASE-INSENSITIVE T))
;                          (DECLARE
;                           (OPTIMIZE SPEED
;                                     (SAFETY 0)
;                                     (SPACE 0)
;                                     (DEBUG 1)
;                                     (COMPILATION-SPEED 0)))
;                          (BLOCK CL-PPCRE:REGEX-APROPOS
;                            (CL-PPCRE::REGEX-APROPOS-AUX
;                             (CL-PPCRE::REGEX CL-PPCRE::PACKAGES
;                                              CL-PPCRE::CASE-INSENSITIVE)
;                             (CL-PPCRE::PRINT-SYMBOL-INFO SYMBOL))
;                            (VALUES)))
; 
; caught STYLE-WARNING:
;   &OPTIONAL and &KEY found in the same lambda list: (REGEX &OPTIONAL
;                                                            PACKAGES
;                                                            &KEY
;                                                            (CASE-INSENSITIVE T))
; in: LAMBDA (#:WHOLE1308 #:ENVIRONMENT1309)
;     (MEMBER SB-IMPL::THIS-KIND '(:INTERNAL :EXTERNAL :INHERITED))
; --> BLOCK LET DO BLOCK LET TAGBODY TAGBODY LET IF SB-IMPL::SATISFIES-THE-TEST 
; --> LET COND IF COND IF COND IF PROGN FUNCALL 
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G26 #:G27)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a SINGLE-FLOAT.
;   The second argument is a T, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a DOUBLE-FLOAT.
;   The second argument is a T, not a DOUBLE-FLOAT.
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

; compiling (LET* (# #) ...)
; file: /usr/share/common-lisp/source/cl-ppcre/api.lisp
; in: DEFUN QUOTE-META-CHARS
;     (LENGTH STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; compiling (LET* (# # ...) ...)
; compiling (LET* (# # ...) ...)
; file: /usr/share/common-lisp/source/cl-ppcre/api.lisp
; in: DEFUN CLEAN-COMMENTS
;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING
;                      CL-PPCRE::MATCH-START
;                      CL-PPCRE::MATCH-END)
; --> BLOCK MAKE-ARRAY 
; ==>
;   (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER
;                               &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN PARSE-TREE-SYNONYM ...)
; compiling (DEFUN (SETF PARSE-TREE-SYNONYM) ...)
; compiling (DEFMACRO DEFINE-PARSE-TREE-SYNONYM ...)

; /var/cache/common-lisp-controller/1000/sbcl/cl-ppcre/api.fasl written
; compilation finished in 0:00:03
WARNING:
   COMPILE-FILE warned while performing #<COMPILE-OP NIL {A837631}> on
   #<CL-SOURCE-FILE "api" {A8377B1}>.
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
;   printed 1053 notes
; compiling file "/home/dunham/gp4/shootout/bench/hello/tmp/hello.sbcl" (written 23 JUL 2006 09:28:38 PM):
; compiling (DEFUN MAIN ...)

; /home/dunham/gp4/shootout/bench/hello/tmp/hello.fasl written
; compilation finished in 0:00:00
[doing purification: roots handlers stack bindings static cleanup done]
[undoing binding stack and other enclosing state... done]
[saving current Lisp image into /home/dunham/gp4/shootout/bench/hello/tmp/sbcl.core:
writing 22030480 bytes from the read-only space at 0x01000000
writing 5450248 bytes from the static space at 0x05000000
writing 4096 bytes from the dynamic space at 0x09000000
done]
### START hello.sbcl_run
(proclaim '(optimize (speed 3) (safety 0) (debug 0) (compilation-speed 0) (space 0)))
(main) (quit)
### END hello.sbcl_run


=================================================================
COMMAND LINE (%A is single numeric argument):

 repeat %A /usr/bin/sbcl --noinform --core sbcl.core --userinit /dev/null --sysinit /dev/null --disable-debugger --load hello.sbcl_run


PROGRAM OUTPUT
==============
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
===================================
!!! Note: Truncated to 50 lines !!!
===================================
