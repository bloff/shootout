<span class="com">{-# OPTIONS -fbang-patterns #-}</span>
<span class="slc">--</span>
<span class="slc">-- The Computer Language Shootout</span>
<span class="slc">-- http://shootout.alioth.debian.org/</span>
<span class="slc">--</span>
<span class="slc">-- Contributed by Don Stewart</span>
<span class="slc">--</span>

<span class="kwa">import qualified</span> Data.ByteString.Char8 <span class="kwa">as</span> S
<span class="kwa">import</span> Data.ByteString.Base
<span class="kwa">import</span> Foreign

main <span class="sym">=</span> <span class="kwa">do</span>
    <span class="sym">(</span>s<span class="sym">:</span>ss<span class="sym">) &lt;-</span> S.lines `fmap` S.getContents
    process s ss <span class="sym">[]</span>

process <span class="sym">!</span>s xs<span class="sym">&#64;(~(</span>x<span class="sym">:</span>xx<span class="sym">))</span> acc
    <span class="sym">|</span> S.null s      <span class="sym">=</span> writeFasta acc
    <span class="sym">|</span> null xs       <span class="sym">=</span> revcomp s <span class="sym">&gt;&gt;</span> writeFasta <span class="sym">(</span>s<span class="sym">:</span>acc<span class="sym">)</span>
    <span class="sym">|</span> h <span class="sym">==</span> '<span class="sym">&gt;</span>'      <span class="sym">=</span> writeFasta acc <span class="sym">&gt;&gt;</span> S.putStrLn s <span class="sym">&gt;&gt;</span> process x xx <span class="sym">[]</span>
    <span class="sym">|</span> otherwise     <span class="sym">=</span> revcomp s <span class="sym">&gt;&gt;</span> process x xx <span class="sym">(</span>s<span class="sym">:</span>acc<span class="sym">)</span>
  <span class="kwa">where</span>
    <span class="sym">(</span>h<span class="sym">,</span>t<span class="sym">)  =</span> uncons s

uncons s <span class="sym">= (</span>w2c <span class="sym">(</span>unsafeHead s<span class="sym">),</span> unsafeTail s<span class="sym">)</span>

comp c <span class="sym">=</span> c2w $ <span class="kwa">case</span> w2c c <span class="kwa">of</span>
    'A' <span class="sym">-&gt;</span> 'T'<span class="sym">;</span> 'a' <span class="sym">-&gt;</span> 'T'<span class="sym">;</span> 'C' <span class="sym">-&gt;</span> 'G'<span class="sym">;</span> 'c' <span class="sym">-&gt;</span> 'G'<span class="sym">;</span> 'G' <span class="sym">-&gt;</span> 'C'
    'g' <span class="sym">-&gt;</span> 'C'<span class="sym">;</span> 'T' <span class="sym">-&gt;</span> 'A'<span class="sym">;</span> 't' <span class="sym">-&gt;</span> 'A'<span class="sym">;</span> 'U' <span class="sym">-&gt;</span> 'A'<span class="sym">;</span> 'u' <span class="sym">-&gt;</span> 'A'
    'M' <span class="sym">-&gt;</span> 'K'<span class="sym">;</span> 'm' <span class="sym">-&gt;</span> 'K'<span class="sym">;</span> 'R' <span class="sym">-&gt;</span> 'Y'<span class="sym">;</span> 'r' <span class="sym">-&gt;</span> 'Y'<span class="sym">;</span> 'Y' <span class="sym">-&gt;</span> 'R'
    'y' <span class="sym">-&gt;</span> 'R'<span class="sym">;</span> 'K' <span class="sym">-&gt;</span> 'M'<span class="sym">;</span> 'k' <span class="sym">-&gt;</span> 'M'<span class="sym">;</span> 'V' <span class="sym">-&gt;</span> 'B'<span class="sym">;</span> 'v' <span class="sym">-&gt;</span> 'B'
    'H' <span class="sym">-&gt;</span> 'D'<span class="sym">;</span> 'h' <span class="sym">-&gt;</span> 'D'<span class="sym">;</span> 'D' <span class="sym">-&gt;</span> 'H'<span class="sym">;</span> 'd' <span class="sym">-&gt;</span> 'H'<span class="sym">;</span> 'B' <span class="sym">-&gt;</span> 'V'<span class="sym">;</span> 'b' <span class="sym">-&gt;</span> 'V'<span class="sym">;</span> x  <span class="sym">-&gt;</span> x

writeFasta <span class="sym">[]     =</span> return <span class="sym">()</span>
writeFasta <span class="sym">(</span>t<span class="sym">:</span>ts<span class="sym">) =</span> go ts t
  <span class="kwa">where</span>
    go <span class="sym">[] !</span>s
        <span class="sym">|</span> S.null s  <span class="sym">=</span> return <span class="sym">()</span>
        <span class="sym">|</span> otherwise <span class="sym">=</span> S.putStrLn l <span class="sym">&gt;&gt;</span> go <span class="sym">[]</span> r
        <span class="kwa">where</span> <span class="sym">(</span>l<span class="sym">,</span>r<span class="sym">) =</span> S.splitAt <span class="num">60</span> s
    go ss <span class="sym">!</span>s
        <span class="sym">|</span> ln <span class="sym">&gt;=</span> <span class="num">60</span>  <span class="sym">=</span> S.putStrLn l               <span class="sym">&gt;&gt;</span> go ss r
        <span class="sym">|</span> otherwise <span class="sym">=</span> S.putStr s <span class="sym">&gt;&gt;</span> S.putStrLn a <span class="sym">&gt;&gt;</span> go <span class="sym">(</span>tail ss<span class="sym">)</span> b
        <span class="kwa">where</span>
            ln    <span class="sym">=</span> S.length s
            <span class="sym">(</span>l<span class="sym">,</span>r<span class="sym">) =</span> S.splitAt <span class="num">60</span> s
            <span class="sym">(</span>a<span class="sym">,</span>b<span class="sym">) =</span> S.splitAt <span class="sym">(</span><span class="num">60</span><span class="sym">-</span>ln<span class="sym">) (</span>head ss<span class="sym">)</span>

<span class="slc">--</span>
<span class="slc">-- An inplace reverse. Since we have a uniquness here, just use the FFI as an ST monad</span>
<span class="slc">--</span>
revcomp <span class="sym">(</span>PS fp s l<span class="sym">) =</span> withForeignPtr fp $ \p <span class="sym">-&gt;</span> rc <span class="sym">(</span>p `plusPtr` s<span class="sym">)</span> <span class="num">0</span> <span class="sym">(</span>l<span class="sym">-</span><span class="num">1</span><span class="sym">)</span>
  <span class="kwa">where</span>
    rc <span class="sym">::</span> Ptr Word8 <span class="sym">-&gt;</span> <span class="kwb">Int</span> <span class="sym">-&gt;</span> <span class="kwb">Int</span> <span class="sym">-&gt;</span> IO <span class="sym">()</span>
    rc <span class="sym">!</span>p <span class="sym">!</span>i <span class="sym">!</span>j
        <span class="sym">|</span> i <span class="sym">&lt;</span> j <span class="sym">=</span> <span class="kwa">do</span>
            x <span class="sym">&lt;-</span> peekByteOff p i
            pokeByteOff p i . comp <span class="sym">=&lt;&lt;</span> peekByteOff p j
            pokeByteOff p j <span class="sym">(</span>comp x<span class="sym">)</span>
            rc p <span class="sym">(</span>i<span class="sym">+</span><span class="num">1</span><span class="sym">) (</span>j<span class="sym">-</span><span class="num">1</span><span class="sym">)</span>
        <span class="sym">|</span> otherwise <span class="sym">=</span> if i <span class="sym">==</span> j <span class="kwa">then</span> pokeByteOff p i . comp <span class="sym">=&lt;&lt;</span> peekByteOff p i
                                <span class="kwa">else</span> return <span class="sym">()</span>
