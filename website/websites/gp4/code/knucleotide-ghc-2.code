<span class="com">{-# OPTIONS -funbox-strict-fields #-}</span>
<span class="slc">--</span>
<span class="slc">-- http://shootout.alioth.debian.org/</span>
<span class="slc">--</span>
<span class="slc">-- By Chris Kuklewicz and Don Stewart</span>
<span class="slc">--</span>
<span class="kwa">import</span> Control.Monad
<span class="kwa">import</span> Foreign
<span class="kwa">import</span> Text.Printf      <span class="sym">(</span>printf<span class="sym">)</span>

<span class="kwa">import</span> Data.List
<span class="kwa">import</span> Data.Maybe       <span class="sym">(</span>maybe<span class="sym">,</span>fromMaybe<span class="sym">)</span>
<span class="kwa">import</span> Data.<span class="kwb">Char</span>        <span class="sym">(</span>ord<span class="sym">,</span>chr<span class="sym">,</span>toUpper<span class="sym">)</span>
<span class="kwa">import qualified</span> Data.HashTable <span class="kwa">as</span> Table

<span class="kwa">import</span> GHC.Exts
<span class="kwa">import</span> GHC.IOBase

<span class="kwa">type</span> Base <span class="sym">=</span> Word8
c2b <span class="sym">::</span> <span class="kwb">Char</span> <span class="sym">-&gt;</span> Base <span class="sym">=</span> fromIntegral . ord . toUpper
b2c <span class="sym">::</span> Base <span class="sym">-&gt;</span> <span class="kwb">Char</span> <span class="sym">=</span> chr . fromIntegral

<span class="slc">-- The ptr are usually into the main fasta data, which is read-only</span>
<span class="kwa">data</span> Seq <span class="sym">=</span> Seq <span class="sym">!</span><span class="kwb">Int</span> <span class="sym">!(</span>Ptr Base<span class="sym">)</span>

seqStrings <span class="sym">= [</span><span class="str">&quot;GGT&quot;</span><span class="sym">,</span><span class="str">&quot;GGTA&quot;</span><span class="sym">,</span><span class="str">&quot;GGTATT&quot;</span><span class="sym">,</span><span class="str">&quot;GGTATTTTAATT&quot;</span><span class="sym">,</span><span class="str">&quot;GGTATTTTAATTTATAGT&quot;</span><span class="sym">]</span>

main <span class="sym">=</span> <span class="kwa">do</span> section <span class="sym">&lt;-</span> getSection <span class="str">&quot;&gt;THREE&quot;</span>
          mapM_ <span class="sym">(</span>writeFreq section<span class="sym">) [</span><span class="num">1</span><span class="sym">,</span><span class="num">2</span><span class="sym">]</span>
          mapM_ <span class="sym">(</span>writeFrame section<span class="sym">) =&lt;&lt;</span> mapM stringToSeq seqStrings

<span class="slc">-- allocate, read, and return the main fasta data</span>
getSection prefix <span class="sym">=</span> <span class="kwa">do</span> findPrefix
                       baseArray <span class="sym">&lt;-</span> newArray0 <span class="num">0</span> <span class="sym">=&lt;&lt;</span> getRest <span class="sym">=&lt;&lt;</span> skipComments
                       size      <span class="sym">&lt;-</span> lengthArray0 <span class="num">0</span> baseArray
                       return <span class="sym">(</span>Seq size baseArray<span class="sym">)</span>

  <span class="kwa">where</span> findPrefix   <span class="sym">=</span> <span class="kwa">do</span> line <span class="sym">&lt;-</span> getLine<span class="sym">;</span> unless <span class="sym">(</span>isPrefixOf prefix line<span class="sym">)</span> findPrefix
        skipComments <span class="sym">=</span> <span class="kwa">do</span> line <span class="sym">&lt;-</span> getLine
                          if <span class="str">';'</span> <span class="sym">==</span> head line <span class="kwa">then</span> skipComments <span class="kwa">else</span> return line
        getRest fl   <span class="sym">=</span> <span class="kwa">do</span> all <span class="sym">&lt;-</span> getContents
                          <span class="kwa">let</span> asLines <span class="sym">=</span> takeWhile <span class="sym">((</span><span class="str">'&gt;'</span><span class="sym">/=)</span>.head<span class="sym">) (</span>fl <span class="sym">:</span> lines all<span class="sym">)</span>
                          return $ concatMap <span class="sym">(</span>map c2b<span class="sym">)</span> asLines

<span class="slc">-- Apply f at every subsequence of length frameSize inside bases</span>
mapSeq <span class="sym">(</span>Seq size bases<span class="sym">)</span> frameSize f <span class="sym">=</span> mapM_ act <span class="sym">[</span><span class="num">0</span>..size<span class="sym">-</span>frameSize<span class="sym">]</span>
    <span class="kwa">where</span> act i <span class="sym">=</span> f <span class="sym">(</span>Seq frameSize <span class="sym">(</span>advancePtr bases i<span class="sym">))</span>

<span class="slc">-- This is most of the program time and memory</span>
<span class="slc">-- HashTable needs a spiffier API</span>
countFrame table frame <span class="sym">=</span> <span class="kwa">do</span> mOld <span class="sym">&lt;-</span> Table.lookup table frame
                            Table.update table frame $<span class="sym">!</span> maybe <span class="num">1</span> succ mOld

<span class="slc">-- This nails down the type 'Int' for counting the frames</span>
newTable <span class="sym">=</span> Table.new eqSeq hashSeq <span class="sym">::</span> IO <span class="sym">(</span>Table.HashTable Seq <span class="kwb">Int</span><span class="sym">)</span>

<span class="slc">-- (countFreq sb) satisfies &quot;define a procedure/function to update a</span>
<span class="slc">-- hashtable of k-nucleotide keys and count values, for a particular</span>
<span class="slc">-- reading-frame&quot;</span>
countFreq sb frameSize table <span class="sym">=</span> mapSeq sb frameSize <span class="sym">(</span>countFrame table<span class="sym">)</span>

<span class="slc">-- This builds the table for a given frameSize and prints the table</span>
writeFreq sb&#64;<span class="sym">(</span>Seq size bases<span class="sym">)</span> frameSize <span class="sym">=</span> <span class="kwa">do</span>
    table    <span class="sym">&lt;-</span> newTable
    countFreq sb frameSize table
    unsorted <span class="sym">&lt;-</span> Table.toList table
    mapM_ printBSF <span class="sym">(</span>mySort unsorted<span class="sym">) &gt;&gt;</span> putChar <span class="str">'\n'</span>

  <span class="kwa">where</span> printBSF <span class="sym">(</span>bs<span class="sym">,</span>f<span class="sym">) =</span> printf <span class="str">&quot;%s %.3f\n&quot;</span> <span class="sym">(</span>showSeq bs<span class="sym">) (</span>percent f<span class="sym">)</span>
        total     <span class="sym">=</span> fromIntegral <span class="sym">(</span>size <span class="sym">-</span> frameSize <span class="sym">+</span> <span class="num">1</span><span class="sym">)</span>
        percent n <span class="sym">=</span> <span class="num">100</span> <span class="sym">* (</span>fromIntegral n<span class="sym">) /</span> total <span class="sym">::</span> <span class="kwb">Double</span>
        mySort    <span class="sym">=</span> sortBy $ \<span class="sym">(</span>k1<span class="sym">,</span>x<span class="sym">) (</span>k2<span class="sym">,</span>y<span class="sym">) -&gt;</span> <span class="kwa">case</span> compare y x <span class="kwa">of</span>
                                                    EQ <span class="sym">-&gt;</span> cmpSeq k1 k2
                                                    z  <span class="sym">-&gt;</span> z

<span class="slc">-- This builds the table for the size of the given frame and prints</span>
<span class="slc">-- that frame's frequency</span>
writeFrame sb&#64;<span class="sym">(</span>Seq size bases<span class="sym">)</span> frame&#64;<span class="sym">(</span>Seq frameSize _<span class="sym">) =</span> <span class="kwa">do</span>
    table   <span class="sym">&lt;-</span> newTable
    countFreq sb frameSize table
    mAnswer <span class="sym">&lt;-</span> Table.lookup table frame
    putStrLn $ show <span class="sym">(</span>fromMaybe <span class="num">0</span> mAnswer<span class="sym">) ++</span> <span class="str">'\t'</span> <span class="sym">:</span> showSeq frame

<span class="slc">-- Routines to convert strings to Seq and back</span>
stringToSeq str <span class="sym">=</span>
    newArray0 <span class="num">0</span> <span class="sym">(</span>map c2b str<span class="sym">) &gt;&gt;=</span> \b <span class="sym">-&gt;</span> lengthArray0 <span class="num">0</span> b <span class="sym">&gt;&gt;=</span> \s <span class="sym">-&gt;</span> return <span class="sym">(</span>Seq s b<span class="sym">)</span>

showSeq <span class="sym">(</span>Seq size ptr<span class="sym">) =</span> inlinePerformIO $ peekArray size ptr <span class="sym">&gt;&gt;=</span> return.<span class="sym">(</span>map b2c<span class="sym">)</span>

<span class="slc">--</span>
<span class="slc">-- Performance tweaked routines for (HashTable Seq Int)</span>
<span class="slc">--</span>

<span class="com">{-# INLINE inlinePerformIO #-}</span>
inlinePerformIO <span class="sym">(</span>IO m<span class="sym">) =</span> <span class="kwa">case</span> m realWorld# <span class="kwa">of</span> <span class="sym">(</span># _<span class="sym">,</span> r #<span class="sym">) -&gt;</span> r

hashSeq <span class="sym">(</span>Seq <span class="sym">(</span>I# size<span class="sym">) (</span>Ptr ptr<span class="sym">)) =</span> inlinePerformIO . IO $ hashmem size ptr <span class="num">0</span>#

eqSeq <span class="sym">(</span>Seq <span class="sym">(</span>I# size1<span class="sym">) (</span>Ptr ptr1<span class="sym">)) (</span>Seq <span class="sym">(</span>I# size2<span class="sym">) (</span>Ptr ptr2<span class="sym">)) =</span>
    if size1 <span class="sym">/=</span># size2 <span class="kwa">then False</span>
                       <span class="kwa">else</span> inlinePerformIO . IO $ eqmem size1 ptr1 ptr2

cmpSeq <span class="sym">(</span>Seq size1 ptr1<span class="sym">) (</span>Seq size2 ptr2<span class="sym">) =</span> <span class="kwa">case</span> compare size1 size2 <span class="kwa">of</span>
    EQ <span class="sym">-&gt;</span> inlinePerformIO $ cmpmem size1 ptr1 ptr2
    z  <span class="sym">-&gt;</span> z

<span class="com">{-# INLINE hashmem #-}</span>
hashmem i p h s <span class="sym">=</span> if i <span class="sym">==</span># <span class="num">0</span># <span class="kwa">then</span> <span class="sym">(</span># s<span class="sym">,</span> toEnum <span class="sym">(</span>I# h<span class="sym">)</span> #<span class="sym">)</span> <span class="kwa">else</span>
    <span class="kwa">case</span> readInt8OffAddr# p <span class="num">0</span># s <span class="kwa">of</span>
         <span class="sym">(</span># s<span class="sym">,</span> i8  #<span class="sym">) -&gt;</span> hashmem <span class="sym">(</span>i <span class="sym">-</span># <span class="num">1</span>#<span class="sym">) (</span>plusAddr# p <span class="num">1</span>#<span class="sym">) (</span><span class="num">17</span># <span class="sym">*</span># h <span class="sym">+</span># i8<span class="sym">)</span> s

<span class="com">{-# INLINE eqmem #-}</span>
eqmem i ptr1 ptr2 s <span class="sym">=</span> if i <span class="sym">==</span># <span class="num">0</span># <span class="kwa">then</span> <span class="sym">(</span># s <span class="sym">,</span> <span class="kwa">True</span> #<span class="sym">)</span> <span class="kwa">else</span>
    <span class="kwa">case</span> readInt8OffAddr# ptr1 <span class="num">0</span># s <span class="kwa">of</span> { <span class="sym">(</span># s<span class="sym">,</span> i8a #<span class="sym">) -&gt;</span>
    <span class="kwa">case</span> readInt8OffAddr# ptr2 <span class="num">0</span># s <span class="kwa">of</span> { <span class="sym">(</span># s<span class="sym">,</span> i8b #<span class="sym">) -&gt;</span>
    if i8a <span class="sym">==</span># i8b
        <span class="kwa">then</span> eqmem <span class="sym">(</span>i <span class="sym">-</span># <span class="num">1</span>#<span class="sym">) (</span>plusAddr# ptr1 <span class="num">1</span>#<span class="sym">) (</span>plusAddr# ptr2 <span class="num">1</span>#<span class="sym">)</span> s
        <span class="kwa">else</span> <span class="sym">(</span># s<span class="sym">,</span> <span class="kwa">False</span> #<span class="sym">)</span> } }

<span class="com">{-# INLINE cmpmem #-}</span>
cmpmem i ptr1 ptr2 <span class="sym">=</span> if i <span class="sym">==</span> <span class="num">0</span> <span class="kwa">then</span> return EQ <span class="kwa">else do</span>
    cmp <span class="sym">&lt;-</span> liftM2 compare <span class="sym">(</span>peek ptr1<span class="sym">) (</span>peek ptr2<span class="sym">)</span>
    <span class="kwa">case</span> cmp <span class="kwa">of</span> EQ <span class="sym">-&gt;</span> cmpmem <span class="sym">(</span>pred i<span class="sym">) (</span>ptr1 `advancePtr` <span class="num">1</span><span class="sym">) (</span>ptr2 `advancePtr` <span class="num">1</span><span class="sym">)</span>
                z  <span class="sym">-&gt;</span> return z

