<span class="slc">% ----------------------------------------------------------------------</span>
<span class="slc">% The Great Computer Language Shootout</span>
<span class="slc">% http://shootout.alioth.debian.org/</span>
<span class="slc">%</span>
<span class="slc">% Assumes execution using the following command-line usage:</span>
<span class="slc">%</span>
<span class="slc">%   erl -noshell -run MODULENAME ENTRYPOINT USERARG1 ... &lt; in &gt; out</span>
<span class="slc">%</span>
<span class="slc">% Based on SWI Prolog implementation by Anthony Borla</span>
<span class="slc">%</span>
<span class="slc">% Contributed by Anthony Borla</span>
<span class="slc">% ----------------------------------------------------------------------</span>

<span class="sym">-</span><span class="kwa">module</span><span class="sym">(</span>revcomp<span class="sym">).</span>
<span class="sym">-</span><span class="kwa">export</span><span class="sym">([</span>main<span class="sym">/</span><span class="num">0</span><span class="sym">]).</span>

<span class="slc">% ------------------------------- %</span>

<span class="kwd">main</span><span class="sym">() -&gt;</span>
  <span class="kwd">revcomp</span><span class="sym">(</span><span class="kwd">get_line</span><span class="sym">(), []),</span>
  <span class="kwb">halt</span><span class="sym">().</span>

<span class="slc">% ------------------------------- %</span>

<span class="kwd">revcomp</span><span class="sym">(</span>eof<span class="sym">,</span> Seg<span class="sym">) -&gt;</span> <span class="kwd">dump_segment</span><span class="sym">(</span>Seg<span class="sym">),</span> io<span class="sym">:</span><span class="kwd">nl</span><span class="sym">();</span>

<span class="kwd">revcomp</span><span class="sym">(</span>Seq<span class="sym">,</span> Seg<span class="sym">) -&gt;</span>
  <span class="kwa">case</span> Seq <span class="kwa">of</span>
    <span class="sym">[</span>$<span class="sym">&gt;|</span>_<span class="sym">] -&gt;</span> <span class="kwd">dump_segment</span><span class="sym">(</span>Seg<span class="sym">),</span> io<span class="sym">:</span><span class="kwd">format</span><span class="sym">(</span><span class="str">'~n~s~n'</span><span class="sym">, [</span>Seq<span class="sym">]),</span> <span class="kwd">revcomp</span><span class="sym">(</span><span class="kwd">get_line</span><span class="sym">(), []);</span>
    _      <span class="sym">-&gt;</span> <span class="kwd">revcomp</span><span class="sym">(</span><span class="kwd">get_line</span><span class="sym">(),</span> lists<span class="sym">:</span><span class="kwd">append</span><span class="sym">(</span>Seg<span class="sym">,</span> Seq<span class="sym">))</span>
  <span class="kwa">end</span><span class="sym">.</span>

<span class="slc">% ------------------------------- %</span>

<span class="slc">%% 60 is output line length</span>

<span class="kwd">dump_segment</span><span class="sym">(</span>Seg<span class="sym">) -&gt;</span> <span class="kwd">dump_segment_</span><span class="sym">(</span>lists<span class="sym">:</span><span class="kwd">reverse</span><span class="sym">(</span>Seg<span class="sym">),</span> <span class="num">1</span><span class="sym">,</span> <span class="num">60</span><span class="sym">).</span>

<span class="slc">% ------------- %</span>

<span class="kwd">dump_segment_</span><span class="sym">([],</span> _<span class="sym">,</span> _<span class="sym">) -&gt; [];</span>

<span class="kwd">dump_segment_</span><span class="sym">([</span>H<span class="sym">|</span>T<span class="sym">],</span> A<span class="sym">,</span> N<span class="sym">) -&gt;</span>
  <span class="kwd">put_complement</span><span class="sym">(</span>H<span class="sym">),</span>
  <span class="kwa">if</span>
     A <span class="sym">&lt;</span> N           <span class="sym">-&gt;</span> <span class="kwd">dump_segment_</span><span class="sym">(</span>T<span class="sym">, (</span>A <span class="sym">+</span> <span class="num">1</span><span class="sym">),</span> N<span class="sym">);</span>
     A <span class="sym">==</span> N<span class="sym">,</span> T <span class="sym">== [] -&gt; [];</span>
     true            <span class="sym">-&gt;</span> io<span class="sym">:</span><span class="kwd">nl</span><span class="sym">(),</span> <span class="kwd">dump_segment_</span><span class="sym">(</span>T<span class="sym">,</span> <span class="num">1</span><span class="sym">,</span> N<span class="sym">)</span>
  <span class="kwa">end</span><span class="sym">.</span>

<span class="slc">% ------------------------------- %</span>

<span class="slc">%% Return line with trailing newline removed [Note: There probably</span>
<span class="slc">%% exists a more efficient means of chopping the trailing newline]</span>

<span class="kwd">get_line</span><span class="sym">() -&gt;</span>
  Line <span class="sym">=</span> io<span class="sym">:</span><span class="kwd">get_line</span><span class="sym">(</span><span class="str">''</span><span class="sym">),</span>
  <span class="kwa">case</span> Line <span class="kwa">of</span>
    eof <span class="sym">-&gt;</span> eof<span class="sym">;</span>
    _   <span class="sym">-&gt;</span> lists<span class="sym">:</span><span class="kwd">reverse</span><span class="sym">(</span>lists<span class="sym">:</span><span class="kwd">nthtail</span><span class="sym">(</span><span class="num">1</span><span class="sym">,</span> lists<span class="sym">:</span><span class="kwd">reverse</span><span class="sym">(</span>Line<span class="sym">)))</span>
  <span class="kwa">end</span><span class="sym">.</span>

<span class="slc">% ------------------------------- %</span>

<span class="kwd">put_complement</span><span class="sym">(</span>Code<span class="sym">) -&gt;</span> io<span class="sym">:</span><span class="kwd">put_chars</span><span class="sym">([</span><span class="kwd">complement</span><span class="sym">(</span>Code<span class="sym">)]).</span>

<span class="slc">% ------------- %</span>

<span class="slc">%%      &quot;wsatug cyrkmb dhvnAT UGCYRK MBDHVN&quot;</span>
<span class="slc">%%  to:</span>
<span class="slc">%%      &quot;WSTAAC GRYMKV HDBNTA ACGRYM KVHDBN&quot;</span>

<span class="kwd">complement</span><span class="sym">(</span>Code<span class="sym">) -&gt;</span>
  <span class="kwa">case</span> <span class="kwd">to_upper</span><span class="sym">(</span>Code<span class="sym">)</span> <span class="kwa">of</span>
    $A <span class="sym">-&gt;</span> $T<span class="sym">;</span> $C <span class="sym">-&gt;</span> $G<span class="sym">;</span> $G <span class="sym">-&gt;</span> $C<span class="sym">;</span> $T <span class="sym">-&gt;</span> $A<span class="sym">;</span> $M <span class="sym">-&gt;</span> $K<span class="sym">;</span>
    $R <span class="sym">-&gt;</span> $Y<span class="sym">;</span> $W <span class="sym">-&gt;</span> $W<span class="sym">;</span> $S <span class="sym">-&gt;</span> $S<span class="sym">;</span> $Y <span class="sym">-&gt;</span> $R<span class="sym">;</span> $K <span class="sym">-&gt;</span> $M<span class="sym">;</span>
    $V <span class="sym">-&gt;</span> $B<span class="sym">;</span> $H <span class="sym">-&gt;</span> $D<span class="sym">;</span> $D <span class="sym">-&gt;</span> $H<span class="sym">;</span> $B <span class="sym">-&gt;</span> $V<span class="sym">;</span> $N <span class="sym">-&gt;</span> $N<span class="sym">;</span>
    _  <span class="sym">-&gt;</span> <span class="num">0</span>
  <span class="kwa">end</span><span class="sym">.</span>

<span class="slc">% ------------- %</span>

<span class="kwd">to_upper</span><span class="sym">(</span>Code<span class="sym">) -&gt;</span>
  <span class="kwa">if</span>
     Code <span class="sym">&gt;</span> $Z <span class="sym">-&gt;</span> Code <span class="sym">-</span> <span class="num">32</span><span class="sym">;</span>
     true      <span class="sym">-&gt;</span> Code
  <span class="kwa">end</span><span class="sym">.</span>

