<span class="slc">--
</span><span class="slc">-- http://shootout.alioth.debian.org/
</span><span class="slc">-- k-nucleotide for SE2.1 by jos&eacute;
</span><span class="slc">--
</span><span class="kwa">class</span> KNUCLEOTIDE <span class="kwa">inherit</span> ABSTRACT_SORTER<span class="sym">[</span><span class="kwa">TUPLE</span><span class="sym">[</span><span class="kwb">INTEGER</span><span class="sym">,</span>STRING<span class="sym">]]</span> creation make <span class="kwa">feature

</span>	make <span class="kwa">is do
		create</span> array.make<span class="sym">(</span><span class="num">100000</span><span class="sym">)
</span>		<span class="kwa">create</span> sequence.make<span class="sym">(</span><span class="num">100000</span><span class="sym">)
</span>		<span class="kwa">create</span> dictionary.with_capacity<span class="sym">(</span><span class="num">10000</span><span class="sym">)
</span>		read
		write_frequencies<span class="sym">(</span><span class="num">1</span><span class="sym">)
</span>		write_frequencies<span class="sym">(</span><span class="num">2</span><span class="sym">)
</span>		write_count<span class="sym">(</span><span class="kwa">once</span> <span class="str">&quot;GGT&quot;</span><span class="sym">)
</span>		write_count<span class="sym">(</span><span class="kwa">once</span> <span class="str">&quot;GGTA&quot;</span><span class="sym">)
</span>		write_count<span class="sym">(</span><span class="kwa">once</span> <span class="str">&quot;GGTATT&quot;</span><span class="sym">)
</span>		write_count<span class="sym">(</span><span class="kwa">once</span> <span class="str">&quot;GGTATTTTAATT&quot;</span><span class="sym">)
</span>		write_count<span class="sym">(</span><span class="kwa">once</span> <span class="str">&quot;GGTATTTTAATTTATAGT&quot;</span><span class="sym">)
</span>	<span class="kwa">end

</span>	write_frequencies<span class="sym">(</span>length<span class="sym">:</span> <span class="kwb">INTEGER</span><span class="sym">)</span> <span class="kwa">is local</span> i<span class="sym">:</span> <span class="kwb">INTEGER</span> coef<span class="sym">:</span> REAL_64 <span class="kwa">do
</span>		count<span class="sym">(</span>length<span class="sym">)
</span>		array.clear_count
		dictionary.item_map_in<span class="sym">(</span>array<span class="sym">)
</span>		sort<span class="sym">(</span>array<span class="sym">)
</span>		coef <span class="sym">:= {</span><span class="kwb">INTEGER</span> <span class="num">100</span><span class="sym">} / (</span><span class="num">1</span> <span class="sym">+</span> sequence.count <span class="sym">-</span> length<span class="sym">)
</span>		<span class="kwa">from</span> i<span class="sym">:=</span>array.lower until i<span class="sym">&gt;</span>array.upper <span class="kwa">loop
</span>			io.put_string<span class="sym">(</span>array.item<span class="sym">(</span>i<span class="sym">)</span>.second<span class="sym">)
</span>			io.put_character<span class="sym">(</span><span class="str">' '</span><span class="sym">)
</span>			io.put_real_format<span class="sym">(</span>coef <span class="sym">*</span> array.item<span class="sym">(</span>i<span class="sym">)</span>.first<span class="sym">,</span> <span class="num">3</span><span class="sym">)
</span>			io.put_character<span class="sym">(</span><span class="str">'%N'</span><span class="sym">)
</span>			i <span class="sym">:=</span> i <span class="sym">+</span> <span class="num">1
</span>		<span class="kwa">end
</span>		io.put_character<span class="sym">(</span><span class="str">'%N'</span><span class="sym">)
</span>	<span class="kwa">end

</span>	write_count<span class="sym">(</span>match<span class="sym">:</span> STRING<span class="sym">)</span> <span class="kwa">is local</span> n<span class="sym">:</span> <span class="kwb">INTEGER</span> <span class="kwa">do
</span>		count<span class="sym">(</span>match.count<span class="sym">)
</span>		<span class="kwa">tuple</span> <span class="sym">:=</span> dictionary.reference_at<span class="sym">(</span>match<span class="sym">)
</span>		<span class="kwa">if tuple</span> <span class="sym">/=</span> Void <span class="kwa">then</span> n <span class="sym">:=</span> <span class="kwa">tuple</span>.first <span class="kwa">end
</span>		io.put_integer<span class="sym">(</span>n<span class="sym">)
</span>		io.put_character<span class="sym">(</span><span class="str">'%T'</span><span class="sym">)
</span>		io.put_string<span class="sym">(</span>match<span class="sym">)
</span>		io.put_character<span class="sym">(</span><span class="str">'%N'</span><span class="sym">)
</span>	<span class="kwa">end

</span>	sequence<span class="sym">:</span> STRING
	part<span class="sym">:</span> STRING
	<span class="kwa">tuple</span><span class="sym">:</span> <span class="kwa">TUPLE</span><span class="sym">[</span><span class="kwb">INTEGER</span><span class="sym">,</span>STRING<span class="sym">]
</span>	dictionary<span class="sym">:</span> HASHED_DICTIONARY<span class="sym">[</span><span class="kwa">like tuple</span><span class="sym">,</span><span class="kwa">like</span> part<span class="sym">]
</span>	array<span class="sym">:</span> FAST_ARRAY<span class="sym">[</span><span class="kwa">like tuple</span><span class="sym">]

</span>	read <span class="kwa">is do
		from</span> io.read_line until io.end_of_input <span class="kwa">or else</span> io.last_string.has_prefix<span class="sym">(</span><span class="kwa">once</span> <span class="str">&quot;&gt;THREE&quot;</span><span class="sym">)</span> <span class="kwa">loop
</span>			io.read_line
		<span class="kwa">end
		if not</span> io.end_of_input <span class="kwa">then
			from</span> io.read_line until io.end_of_input <span class="kwa">or else</span> io.last_string.first <span class="sym">=</span> <span class="str">'&gt;'</span> <span class="kwa">loop
				if</span> io.last_string.first <span class="sym">/=</span> <span class="str">';'</span> <span class="kwa">then</span> sequence.append<span class="sym">(</span>io.last_string<span class="sym">)</span> <span class="kwa">end
</span>				io.read_line
			<span class="kwa">end
</span>			sequence.to_upper
		<span class="kwa">end
	end

</span>	count<span class="sym">(</span>length<span class="sym">:</span> <span class="kwb">INTEGER</span><span class="sym">)</span> <span class="kwa">is local</span> pos<span class="sym">,</span> i<span class="sym">,</span> j<span class="sym">:</span> <span class="kwb">INTEGER</span> <span class="kwa">do
</span>		dictionary.clear_count
		<span class="kwa">from
</span>			part <span class="sym">:=</span> sequence.substring<span class="sym">(</span><span class="num">1</span><span class="sym">,</span>length<span class="sym">)
</span>			<span class="kwa">tuple</span> <span class="sym">:= [{</span><span class="kwb">INTEGER</span> <span class="num">1</span><span class="sym">},</span> part.twin<span class="sym">]
</span>			dictionary.add<span class="sym">(</span><span class="kwa">tuple</span><span class="sym">,</span><span class="kwa">tuple</span>.second<span class="sym">)
</span>			pos <span class="sym">:=</span> length
		until
			pos <span class="sym">&gt;=</span> sequence.upper
		<span class="kwa">loop
</span>			pos <span class="sym">:=</span> pos <span class="sym">+</span> <span class="num">1
</span>			<span class="kwa">from</span> i<span class="sym">:=</span><span class="num">1</span> until i<span class="sym">=</span>length <span class="kwa">loop</span> j<span class="sym">:=</span>i<span class="sym">+</span><span class="num">1</span> part.put<span class="sym">(</span>part.item<span class="sym">(</span>j<span class="sym">),</span>i<span class="sym">)</span> i<span class="sym">:=</span>j <span class="kwa">end
</span>			part.put<span class="sym">(</span>sequence.item<span class="sym">(</span>pos<span class="sym">),</span>length<span class="sym">)
</span>			<span class="kwa">tuple</span> <span class="sym">:=</span> dictionary.reference_at<span class="sym">(</span>part<span class="sym">)
</span>			<span class="kwa">if tuple</span> <span class="sym">=</span> Void <span class="kwa">then
				tuple</span> <span class="sym">:= [{</span><span class="kwb">INTEGER</span> <span class="num">1</span><span class="sym">},</span> part.twin<span class="sym">]
</span>				dictionary.add<span class="sym">(</span><span class="kwa">tuple</span><span class="sym">,</span><span class="kwa">tuple</span>.second<span class="sym">)
</span>			<span class="kwa">else
				tuple</span>.set_first<span class="sym">(</span><span class="num">1</span> <span class="sym">+</span> <span class="kwa">tuple</span>.first<span class="sym">)
</span>			<span class="kwa">end
		end
	end

</span>	lt<span class="sym">(</span>a<span class="sym">,</span>b<span class="sym">:</span> <span class="kwa">like tuple</span><span class="sym">):</span> <span class="kwb">BOOLEAN</span> <span class="kwa">is do
		Result</span> <span class="sym">:=</span> b.first<span class="sym">&lt;</span>a.first
			<span class="kwa">or else</span> <span class="sym">(</span>a.first<span class="sym">=</span>b.first <span class="kwa">and then</span> a.second<span class="sym">&lt;</span>b.second<span class="sym">)
</span>	<span class="kwa">end

end
</span>
