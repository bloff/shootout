<span class="com">{-  The Computer Language Shootout</span>
<span class="com">    http://shootout.alioth.debian.org/</span>
<span class="com">    compile with:  ghc -O2 -o fannkuch fannkuch.hs</span>
<span class="com">    contributed by Josh Goldfoot, &quot;fixing&quot; the version by Greg Buchholz</span>
<span class="com">     permutations function translated from the C version by Heiner Marxen -}</span>

<span class="kwa">import</span> System<span class="sym">(</span>getArgs<span class="sym">)</span>
<span class="kwa">import</span> Data.<span class="kwb">Int</span>

main <span class="sym">=</span> <span class="kwa">do</span>   <span class="sym">[</span>n<span class="sym">] &lt;-</span> getArgs
            <span class="kwa">let</span> p <span class="sym">=</span> permutations <span class="sym">[</span><span class="num">1</span>..<span class="sym">(</span>read n<span class="sym">)]</span>
            mapM putStrLn $ map <span class="sym">((</span>concat<span class="sym">)</span>.<span class="sym">(</span>map show<span class="sym">))</span> $ take <span class="num">30</span> <span class="sym">(</span>permutations <span class="sym">[</span><span class="num">1</span>..<span class="sym">(</span>read n<span class="sym">)])</span>
            putStr $ <span class="str">&quot;Pfannkuchen(&quot;</span> <span class="sym">++</span> n <span class="sym">++</span> <span class="str">&quot;) = &quot;</span>
            print $ findmax <span class="num">0</span> p

findmax <span class="sym">::</span> Int8 <span class="sym">-&gt; [[</span>Int8<span class="sym">]] -&gt;</span> Int8
findmax soFar <span class="sym">[] =</span> soFar
findmax soFar <span class="sym">(</span>x<span class="sym">:</span>xs<span class="sym">) =</span>
   max <span class="sym">(</span>flop <span class="num">0</span> x<span class="sym">) (</span>findmax soFar xs<span class="sym">)</span>

flop <span class="sym">::</span> Int8 <span class="sym">-&gt; [</span>Int8<span class="sym">] -&gt;</span> Int8
flop acc <span class="sym">(</span><span class="num">1</span><span class="sym">:</span>xs<span class="sym">) =</span> acc
flop acc list&#64;<span class="sym">(</span>x<span class="sym">:</span>xs<span class="sym">) =</span> flop <span class="sym">(</span>acc<span class="sym">+</span><span class="num">1</span><span class="sym">)</span> mangle
    <span class="kwa">where</span>   mangle <span class="sym">= (</span>reverse front<span class="sym">) ++</span> back
            <span class="sym">(</span>front<span class="sym">,</span>back<span class="sym">) =</span> splitAt <span class="sym">(</span>fromIntegral x<span class="sym">)</span> list

permutations <span class="sym">:: [</span>Int8<span class="sym">] -&gt; [[</span>Int8<span class="sym">]]</span>
permutations arry <span class="sym">=</span>
   arry <span class="sym">: (</span>permuteloop arry <span class="sym">[</span><span class="num">1</span>..n<span class="sym">]</span> <span class="num">1</span><span class="sym">)</span>
   <span class="kwa">where</span> n <span class="sym">=</span> fromIntegral <span class="sym">(</span>length arry<span class="sym">)</span>

permuteloop <span class="sym">:: [</span>a<span class="sym">] -&gt; [</span>Int8<span class="sym">] -&gt;</span> Int8 <span class="sym">-&gt; [[</span>a<span class="sym">]]</span>
permuteloop arry count r
   <span class="sym">|</span> r <span class="sym">== ((</span>fromIntegral . length<span class="sym">)</span> arry<span class="sym">) = []</span>
   <span class="sym">|</span> count<span class="str">' !! (fromIntegral r) &gt; 0 = arry'</span> <span class="sym">: (</span>permuteloop arry<span class="str">' (reload r count'</span><span class="sym">)</span> <span class="num">1</span><span class="sym">)</span>
   <span class="sym">|</span> otherwise <span class="sym">=</span> permuteloop arry<span class="str">' count'</span> <span class="sym">(</span>r<span class="sym">+</span><span class="num">1</span><span class="sym">)</span>
   <span class="kwa">where</span> count<span class="str">' = (take (fromIntegral r) count) ++ ((count !! (fromIntegral r)) - 1):(drop (fromIntegral r+1) count)</span>
<span class="str">         arry'</span> <span class="sym">=</span> rotate <span class="sym">(</span>fromIntegral r<span class="sym">)</span> arry

rotate <span class="sym">::</span> Int8 <span class="sym">-&gt; [</span>a<span class="sym">] -&gt; [</span>a<span class="sym">]</span>
rotate r <span class="sym">(</span>x<span class="sym">:</span>xs<span class="sym">) =</span>
   begin <span class="sym">++</span> x<span class="sym">:</span>end
   <span class="kwa">where</span> <span class="sym">(</span>begin<span class="sym">,</span> end<span class="sym">) =</span> splitAt <span class="sym">(</span>fromIntegral r<span class="sym">)</span> xs

reload <span class="sym">::</span> Int8 <span class="sym">-&gt; [</span>Int8<span class="sym">] -&gt; [</span>Int8<span class="sym">]</span>
reload r count
   <span class="sym">|</span> r <span class="sym">==</span> <span class="num">1</span> <span class="sym">=</span> count
   <span class="sym">|</span> otherwise <span class="sym">= [</span><span class="num">1</span>..r<span class="sym">] ++ (</span>drop <span class="sym">(</span>fromIntegral r<span class="sym">)</span> count<span class="sym">)</span>
