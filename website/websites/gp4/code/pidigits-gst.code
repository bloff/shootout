<span class="com">&quot;  The Great Computer Language Shootout</span>
<span class="com">   http://shootout.alioth.debian.org/</span>
<span class="com"></span>
<span class="com">   contributed by Isaac Gouy</span>
<span class="com"></span>
<span class="com">   To run: gst -QI /usr/share/gnu-smalltalk/gst.im pidigits.st -a 100</span>
<span class="com">&quot;</span>
<span class="com"></span>
<span class="com">Object subclass: #Transformation</span>
<span class="com">instanceVariableNames: 'q r s t k'</span>
<span class="com">classVariableNames: ''</span>
<span class="com">poolDictionaries: ''</span>
<span class="com">category: nil !</span>
<span class="com"></span>
<span class="com">!Transformation class methodsFor: 'instance creation'!</span>
<span class="com"></span>
<span class="com">new</span>
<span class="com">   ^super new initialize !</span>
<span class="com"></span>
<span class="com">q: anInteger1 r: anInteger2 s: anInteger3 t: anInteger4</span>
<span class="com">   ^(super new) q: anInteger1 r: anInteger2 s: anInteger3 t: anInteger4 !</span>
<span class="com"></span>
<span class="com">unity</span>
<span class="com">   ^self q: 1 r: 0 s: 0 t: 1 ! !</span>
<span class="com"></span>
<span class="com"></span>
<span class="com">!Transformation methodsFor: 'initialize-release'!</span>
<span class="com"></span>
<span class="com">initialize</span>
<span class="com">   q := 0.</span>
<span class="com">   r := 0.</span>
<span class="com">   s := 0.</span>
<span class="com">   t := 0.</span>
<span class="com">   k := 0. ! !</span>
<span class="com"></span>
<span class="com">!Transformation methodsFor: 'accessing'!</span>
<span class="com"></span>
<span class="com">* aTransformation</span>
<span class="com">   ^self species</span>
<span class="com">      q: q * aTransformation q</span>
<span class="com">      r: q * aTransformation r + (r * aTransformation t)</span>
<span class="com">      s: s * aTransformation q + (t * aTransformation s)</span>
<span class="com">      t: s * aTransformation r + (t * aTransformation t) !</span>
<span class="com"></span>
<span class="com">extract: anInteger</span>
<span class="com">   ^(q * anInteger + r) // (s * anInteger + t) !</span>
<span class="com"></span>
<span class="com">next</span>
<span class="com">   k := k +1.</span>
<span class="com">   q := k.</span>
<span class="com">   r := 4 * k + 2.</span>
<span class="com">   s := 0.</span>
<span class="com">   t := 2 * k + 1. !</span>
<span class="com"></span>
<span class="com">q</span>
<span class="com">   ^q !</span>
<span class="com"></span>
<span class="com">r</span>
<span class="com">   ^r !</span>
<span class="com"></span>
<span class="com">s</span>
<span class="com">   ^s !</span>
<span class="com"></span>
<span class="com">t</span>
<span class="com">   ^t !</span>
<span class="com"></span>
<span class="com">q: anInteger1 r: anInteger2 s: anInteger3 t: anInteger4</span>
<span class="com">   q := anInteger1.</span>
<span class="com">   r := anInteger2.</span>
<span class="com">   s := anInteger3.</span>
<span class="com">   t := anInteger4.</span>
<span class="com">   k := 0. ! !</span>
<span class="com"></span>
<span class="com"></span>
<span class="com"></span>
<span class="com">Object subclass: #PiDigitSpigot</span>
<span class="com">instanceVariableNames: 'z x inverse'</span>
<span class="com">classVariableNames: ''</span>
<span class="com">poolDictionaries: ''</span>
<span class="com">category: nil !</span>
<span class="com"></span>
<span class="com"></span>
<span class="com">!PiDigitSpigot class methodsFor: 'instance creation'!</span>
<span class="com"></span>
<span class="com">new</span>
<span class="com">   ^super new initialize ! !</span>
<span class="com"></span>
<span class="com"></span>
<span class="com">!PiDigitSpigot methodsFor: 'initialize-release'!</span>
<span class="com"></span>
<span class="com">initialize</span>
<span class="com">   z := Transformation unity.</span>
<span class="com">   x := Transformation new.</span>
<span class="com">   inverse := Transformation new. ! !</span>
<span class="com"></span>
<span class="com">!PiDigitSpigot methodsFor: 'accessing'!</span>
<span class="com"></span>
<span class="com">next</span>
<span class="com">   | y |</span>
<span class="com">   ^(self isSafe: (y := self digit))</span>
<span class="com">      ifTrue: [z := self produce: y. y]</span>
<span class="com">      ifFalse: [z := self consume: x next. self next] ! !</span>
<span class="com"></span>
<span class="com"></span>
<span class="com">!PiDigitSpigot methodsFor: 'private'!</span>
<span class="com"></span>
<span class="com">consume: aTransformation</span>
<span class="com">   ^z * aTransformation !</span>
<span class="com"></span>
<span class="com">digit</span>
<span class="com">   ^(z extract: 3) floor !</span>
<span class="com"></span>
<span class="com">isSafe: aDigit</span>
<span class="com">   ^aDigit = (z extract: 4) floor !</span>
<span class="com"></span>
<span class="com">produce: anInteger</span>
<span class="com">   inverse q: 10 r: -10 * anInteger s: 0 t: 1.</span>
<span class="com">   ^inverse * z ! !</span>
<span class="com"></span>
<span class="com"></span>
<span class="com"></span>
<span class="com">| i length n pidigits stream |</span>
<span class="com">n := Smalltalk arguments first asInteger.</span>
<span class="com">i := 0.</span>
<span class="com">length := 10.</span>
<span class="com">pidigits := PiDigitSpigot new.</span>
<span class="com"></span>
<span class="com">stream := ReadWriteStream on: (String new: 30).</span>
<span class="com"></span>
<span class="com">[n &gt; 0] whileTrue: [</span>
<span class="com"></span>
<span class="com">   (n &lt; length)</span>
<span class="com">      ifTrue: [</span>
<span class="com">         n timesRepeat: [</span>
<span class="com">            stream nextPut: (Character digitValue: pidigits next)</span>
<span class="com">            ].</span>
<span class="com"></span>
<span class="com">         n to: length do: [:each| stream space].</span>
<span class="com">         i := i + n.</span>
<span class="com">         ]</span>
<span class="com"></span>
<span class="com">      ifFalse: [</span>
<span class="com">         length timesRepeat: [</span>
<span class="com">            stream nextPut: (Character digitValue: pidigits next)</span>
<span class="com">            ].</span>
<span class="com"></span>
<span class="com">         i := i + length.</span>
<span class="com">         ].</span>
<span class="com"></span>
<span class="com">   stream tab nextPut: $:.</span>
<span class="com">   i printOn: stream.</span>
<span class="com">   stream nl.</span>
<span class="com"></span>
<span class="com">   Transcript nextPutAll: (stream contents).</span>
<span class="com">   stream reset.</span>
<span class="com">   n := n - length.</span>
<span class="com">] !</span>
