<span class="str">&quot;  The Great Computer Language Shootout
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy

   To run: gst -QI /usr/local/share/smalltalk/gst.im nsievebits.st -a 7
&quot;</span>


Object subclass<span class="sym">:</span> <span class="slc">#BitArray
</span>instanceVariableNames<span class="sym">:</span> <span class="str">'bits'</span>
classVariableNames<span class="sym">:</span> <span class="str">''</span>
poolDictionaries<span class="sym">:</span> <span class="str">''</span>
category<span class="sym">:</span> nil <span class="sym">!

!</span>BitArray class methodsFor<span class="sym">:</span> <span class="str">'instance creation'</span><span class="sym">!

</span>new<span class="sym">:</span> size
   ^super new withSize<span class="sym">:</span> size <span class="sym">!

!</span>BitArray methodsFor<span class="sym">:</span> <span class="str">'initialize-release'</span><span class="sym">!

</span>withSize<span class="sym">:</span> size
   bits <span class="sym">:=</span> Array new<span class="sym">: (</span>size <span class="num">- 1</span> <span class="sym">//</span> <span class="num">30</span><span class="sym">) +</span> <span class="num">1</span> withAll<span class="sym">:</span> <span class="num">0</span> <span class="sym">!

!</span>BitArray methodsFor<span class="sym">:</span> <span class="str">'accessing'</span><span class="sym">!

</span>at<span class="sym">:</span> index
   <span class="sym">|</span> wordIndex bitIndex <span class="sym">|
</span>   wordIndex <span class="sym">:= ((</span>index <span class="num">- 1</span><span class="sym">) //</span> <span class="num">30</span><span class="sym">) +</span> <span class="num">1</span>.
   bitIndex <span class="sym">:= (</span><span class="num">30</span> <span class="sym">-</span> index<span class="sym">)</span>  \\ <span class="num">30</span>.
   ^<span class="sym">((</span>bits at<span class="sym">:</span> wordIndex<span class="sym">)</span> bitShift<span class="sym">:</span> bitIndex negated<span class="sym">)</span> bitAnd<span class="sym">:</span> <span class="num">1</span> <span class="sym">!

</span>at<span class="sym">:</span> index put<span class="sym">:</span> bit
   <span class="sym">|</span> wordIndex bitIndex word <span class="sym">|
</span>   wordIndex <span class="sym">:= ((</span>index <span class="num">- 1</span><span class="sym">) //</span> <span class="num">30</span><span class="sym">) +</span> <span class="num">1</span>.
   bitIndex <span class="sym">:= (</span><span class="num">30</span> <span class="sym">-</span> index<span class="sym">)</span> \\ <span class="num">30</span>.
   word <span class="sym">:=</span> bits at<span class="sym">:</span> wordIndex.

	word <span class="sym">:=
</span>	   bit <span class="sym">=</span> <span class="num">1
</span>	      ifTrue<span class="sym">: [</span>word bitOr<span class="sym">: (</span><span class="num">1</span> bitShift<span class="sym">:</span> bitIndex<span class="sym">)]
</span>	      ifFalse<span class="sym">: [</span>word bitAnd<span class="sym">: (</span><span class="num">1</span> bitShift<span class="sym">:</span> bitIndex<span class="sym">)</span> bitInvert<span class="sym">]</span>.

   bits at<span class="sym">:</span> wordIndex put<span class="sym">:</span> word <span class="sym">! !


!</span>Integer methodsFor<span class="sym">:</span> <span class="str">'shootout'</span><span class="sym">!

</span>nsieve
   <span class="sym">|</span> count isPrime <span class="sym">|
</span>   count <span class="sym">:=</span> <span class="num">0</span>.
   isPrime <span class="sym">:=</span> BitArray new<span class="sym">:</span> self.

   <span class="num">2</span> to<span class="sym">:</span> self <span class="kwa">do</span><span class="sym">: [:</span>i<span class="sym">|
      (</span>isPrime at<span class="sym">:</span> i<span class="sym">) ==</span> <span class="num">0</span> ifTrue<span class="sym">: [
</span>         i<span class="sym">+</span>i to<span class="sym">:</span> self by<span class="sym">:</span> i <span class="kwa">do</span><span class="sym">: [:</span>k<span class="sym">|</span> isPrime at<span class="sym">:</span> k put<span class="sym">:</span> <span class="num">1</span><span class="sym">]</span>.
         count <span class="sym">:=</span> count <span class="sym">+</span> <span class="num">1</span>.
         <span class="sym">]</span>.
      <span class="sym">]</span>.

   ^count <span class="sym">!


</span>asPaddedString<span class="sym">:</span> anInteger
   <span class="sym">|</span> s <span class="sym">|
</span>   s <span class="sym">:=</span> self printString.
   ^<span class="sym">(</span>String new<span class="sym">: (</span>anInteger <span class="sym">-</span> s size<span class="sym">)</span> withAll<span class="sym">:</span> <span class="kwb">$</span> <span class="sym">),</span> s <span class="sym">!


</span>primes
   <span class="sym">|</span> m <span class="sym">|
</span>   m <span class="sym">:= (</span><span class="num">2</span> raisedTo<span class="sym">:</span> self<span class="sym">) *</span> <span class="num">10000</span>.
   Transcript
      show<span class="sym">:</span> <span class="str">'Primes up to '</span><span class="sym">;</span> show<span class="sym">: (</span>m asPaddedString<span class="sym">:</span> <span class="num">8</span><span class="sym">);
</span>      show<span class="sym">: ((</span>m nsieve<span class="sym">)</span> asPaddedString<span class="sym">:</span> <span class="num">9</span><span class="sym">);</span> nl <span class="sym">! !


|</span> n <span class="sym">|
</span>n <span class="sym">:=</span> Smalltalk arguments first asInteger.
<span class="sym">(</span>n <span class="sym">&lt;</span> <span class="num">2</span><span class="sym">)</span> ifTrue<span class="sym">: [</span>n <span class="sym">:=</span> <span class="num">2</span><span class="sym">]</span>.

 n      primes.
<span class="sym">(</span>n <span class="num">- 1</span><span class="sym">)</span> primes.
<span class="sym">(</span>n <span class="num">- 2</span><span class="sym">)</span> primes <span class="sym">!</span>
