<span class="hl com">(* binarytrees1.ml</span>
<span class="hl com"> *</span>
<span class="hl com"> * The Great Computer Language Shootout</span>
<span class="hl com"> * http://shootout.alioth.debian.org/</span>
<span class="hl com"> *</span>
<span class="hl com"> * Contributed by Troestler Christophe</span>
<span class="hl com"> *)</span>

<span class="hl kwa">type</span> <span class="hl str">'a tree = Empty of '</span>a <span class="hl sym">|</span> Node <span class="hl kwa">of</span> <span class="hl str">'a tree * '</span>a <span class="hl sym">*</span> <span class="hl str">'a tree</span>
<span class="hl str"></span>
<span class="hl str">let rec make i d =</span>
<span class="hl str">  if d = 0 then Empty i</span>
<span class="hl str">  else let i2 = 2 * i and d = d - 1 in Node(make (i2 - 1) d, i, make i2 d)</span>
<span class="hl str"></span>
<span class="hl str">let rec check = function Empty i -&gt; i | Node(l, i, r) -&gt; i + check l - check r</span>
<span class="hl str"></span>
<span class="hl str"></span>
<span class="hl str">let min_depth = 4</span>
<span class="hl str">let max_depth = (let n = try int_of_string(Array.get Sys.argv 1) with _ -&gt; 10 in</span>
<span class="hl str">                 max (min_depth + 2) n)</span>
<span class="hl str">let stretch_depth = max_depth + 1</span>
<span class="hl str"></span>
<span class="hl str">let () =</span>
<span class="hl str">  Gc.set { (Gc.get()) with Gc.minor_heap_size = 1024 * 1024 };</span>
<span class="hl str">  let c = check (make 0 stretch_depth) in</span>
<span class="hl str">  Printf.printf &quot;stretch tree of depth %i</span><span class="hl esc">\t</span> <span class="hl str">check: %i</span><span class="hl esc">\n</span><span class="hl str">&quot; stretch_depth c</span>
<span class="hl str"></span>
<span class="hl str">let long_lived_tree = make 0 max_depth</span>
<span class="hl str"></span>
<span class="hl str">let rec loop_depths d =</span>
<span class="hl str">  if d &lt;= max_depth then</span>
<span class="hl str">    let niter = 1 lsl (max_depth - d + min_depth) and c = ref 0 in</span>
<span class="hl str">    for i = 1 to niter do c := !c + check(make i d) + check(make (-i) d) done;</span>
<span class="hl str">    Printf.printf &quot;%i</span><span class="hl esc">\t</span> <span class="hl str">trees of depth %i</span><span class="hl esc">\t</span> <span class="hl str">check: %i</span><span class="hl esc">\n</span><span class="hl str">&quot; (2 * niter) d !c;</span>
<span class="hl str">    loop_depths (d + 2)</span>
<span class="hl str"></span>
<span class="hl str">let () =</span>
<span class="hl str">  loop_depths min_depth;</span>
<span class="hl str">  Printf.printf &quot;long lived tree of depth %i</span><span class="hl esc">\t</span> <span class="hl str">check: %i</span><span class="hl esc">\n</span><span class="hl str">&quot;</span>
<span class="hl str">    max_depth (check long_lived_tree)</span>
<span class="hl str"></span>
