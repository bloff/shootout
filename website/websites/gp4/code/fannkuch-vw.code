<span class="com">&quot;  The Computer Language Shootout</span>
<span class="com">   http://shootout.alioth.debian.org/</span>
<span class="com">   contributed by Paolo Bonzini&quot;!</span>
<span class="com"></span>
<span class="com">Smalltalk.Shootout defineClass: #PermGenerator</span>
<span class="com">	superclass: #{Core.Object}</span>
<span class="com">	indexedType: #none</span>
<span class="com">	private: false</span>
<span class="com">	instanceVariableNames: 'timesRotated perm atEnd '</span>
<span class="com">	classInstanceVariableNames: ''</span>
<span class="com">	imports: ''</span>
<span class="com">	category: 'Shootout'!</span>
<span class="com"></span>
<span class="com"></span>
<span class="com">!Shootout.PermGenerator class methodsFor: 'instance creation'!</span>
<span class="com"></span>
<span class="com">new: size</span>
<span class="com">    ^self new</span>
<span class="com">	initialize: size;</span>
<span class="com">	yourself ! !</span>
<span class="com"></span>
<span class="com"></span>
<span class="com">!Shootout.PermGenerator methodsFor: 'initialize-release'!</span>
<span class="com"></span>
<span class="com">initialize: size</span>
<span class="com">    perm := (1 to: size) asArray.</span>
<span class="com">    timesRotated := Array new: size withAll: 0.</span>
<span class="com">    atEnd := false !</span>
<span class="com"></span>
<span class="com">makeNext</span>
<span class="com">    | temp remainder |</span>
<span class="com">    &quot;Generate the next permutation.&quot;</span>
<span class="com">    2 to: perm size do: [ :r |</span>
<span class="com">	&quot;Rotate the first r items to the left.&quot;</span>
<span class="com">        temp := perm at: 1.</span>
<span class="com">        1 to: r - 1 do: [ :i | perm at: i put: (perm at: i + 1) ].</span>
<span class="com">        perm at: r put: temp.</span>
<span class="com"></span>
<span class="com">        remainder := timesRotated at: r put: ((timesRotated at: r) + 1) \\ r.</span>
<span class="com">        remainder = 0 ifFalse: [ ^self ].</span>
<span class="com"></span>
<span class="com">	&quot;After r rotations, the first r items are in their original positions.</span>
<span class="com">	 Go on rotating the first r+1 items.&quot;</span>
<span class="com">    ].</span>
<span class="com"></span>
<span class="com">    &quot;We are past the final permutation.&quot;</span>
<span class="com">    atEnd := true ! !</span>
<span class="com"></span>
<span class="com">!Shootout.PermGenerator methodsFor: 'accessing'!</span>
<span class="com"></span>
<span class="com">atEnd</span>
<span class="com">    ^atEnd !</span>
<span class="com"></span>
<span class="com">next</span>
<span class="com">    | result |</span>
<span class="com">    result := perm copy.</span>
<span class="com">    self makeNext.</span>
<span class="com">    ^result ! !</span>
<span class="com"></span>
<span class="com"></span>
<span class="com">!Core.Array methodsFor: 'computer language shootout'!</span>
<span class="com"></span>
<span class="com">pfannkuchen</span>
<span class="com">    | first complement a b k |</span>
<span class="com">    k := 0.</span>
<span class="com">    [ (first := self at: 1) == 1 ] whileFalse: [</span>
<span class="com">	k := k + 1.</span>
<span class="com">	complement := first + 1.</span>
<span class="com">	1 to: first // 2 do: [ :i |</span>
<span class="com">	    a := self at: i.</span>
<span class="com">	    b := self at: complement - i.</span>
<span class="com">	    self at: i put: b.</span>
<span class="com">	    self at: complement - i put: a.</span>
<span class="com">	]</span>
<span class="com">    ].</span>
<span class="com">    ^k ! !</span>
<span class="com"></span>
<span class="com"></span>
<span class="com">!Core.SmallInteger methodsFor: 'computer language shootout'!</span>
<span class="com"></span>
<span class="com">maxPfannkuchen</span>
<span class="com">    | max gen perm check |</span>
<span class="com">    max := 0.</span>
<span class="com">    check := 0.</span>
<span class="com">    gen := ComputerLanguageShootout.PermGenerator new: self.</span>
<span class="com">    [ gen atEnd ] whileFalse: [</span>
<span class="com">	perm := gen next.</span>
<span class="com">        check &lt; 30 ifTrue: [</span>
<span class="com">	    perm do: [ :each | OS.Stdout nextPutAll: each printString ].</span>
<span class="com">	    OS.Stdout cr.</span>
<span class="com">	    check := check + 1 ].</span>
<span class="com">	max := max max: perm pfannkuchen</span>
<span class="com">    ].</span>
<span class="com">    ^max ! !</span>
<span class="com"></span>
<span class="com"></span>
<span class="com">!Shootout.Tests class methodsFor: 'benchmarking'!</span>
<span class="com"></span>
<span class="com">fannkuch</span>
<span class="com">   | n |</span>
<span class="com">   n := CEnvironment argv first asNumber.</span>
<span class="com">   ^'Pfannkuchen(', n printString, ') = ',  n maxPfannkuchen printString withNl ! !</span>
