<span class="hl com">{-# OPTIONS -O2 -fbang-patterns -optc-O3 #-}</span>

<span class="hl com">{- The Computer Language Benchmarks Game</span>
<span class="hl com">   http://shootout.alioth.debian.org/</span>
<span class="hl com"></span>
<span class="hl com">   Sterling Clover's translation of Tim Hochberg's Clean implementation -}</span>

<span class="hl kwa">module</span> Main <span class="hl kwa">where</span>
<span class="hl kwa">import</span> System.Environment
<span class="hl kwa">import</span> Data.Bits
<span class="hl kwa">import</span> Data.List
<span class="hl kwa">import</span> Data.Array.IArray
<span class="hl kwa">import</span> Data.Array.Unboxed
<span class="hl kwa">import</span> Control.Arrow

<span class="hl slc">--- The Board ---</span>
n_elem <span class="hl sym">=</span> <span class="hl num">5</span>
n_col <span class="hl sym">=</span> <span class="hl num">5</span>
n_row <span class="hl sym">=</span> <span class="hl num">10</span>

m_top <span class="hl sym">::</span> Mask
m_top <span class="hl sym">=</span> <span class="hl num">0x1F</span>

cells <span class="hl sym">:: [</span>Cell<span class="hl sym">]</span>
cells <span class="hl sym">= [</span><span class="hl num">0</span>.<span class="hl num">.49</span><span class="hl sym">]</span>

colors <span class="hl sym">:: [</span>Color<span class="hl sym">]</span>
colors <span class="hl sym">= [</span><span class="hl num">0</span>.<span class="hl num">.9</span><span class="hl sym">]</span>

cellAt x y <span class="hl sym">=</span> x <span class="hl sym">+</span> n_col <span class="hl sym">*</span> y
coordOf i <span class="hl sym">=</span> snd <span class="hl sym">&amp;&amp;&amp;</span> fst $ i `quotRem` n_col
isValid x y <span class="hl sym">=</span> <span class="hl num">0</span> <span class="hl sym">&lt;=</span> x <span class="hl sym">&amp;&amp;</span> x <span class="hl sym">&lt;</span> n_col <span class="hl sym">&amp;&amp;</span> <span class="hl num">0</span> <span class="hl sym">&lt;=</span> y <span class="hl sym">&amp;&amp;</span> y <span class="hl sym">&lt;</span> n_row

<span class="hl slc">--- Piece Operations ---</span>
<span class="hl kwa">data</span> Direction <span class="hl sym">=</span> E <span class="hl sym">|</span> SE <span class="hl sym">|</span> SW <span class="hl sym">|</span> W <span class="hl sym">|</span> NW <span class="hl sym">|</span> NE <span class="hl kwa">deriving</span> <span class="hl sym">(</span>Enum<span class="hl sym">,</span> Eq<span class="hl sym">,</span> Ord<span class="hl sym">)</span>
<span class="hl kwa">type</span> Piece <span class="hl sym">= [</span>Direction<span class="hl sym">]</span>
<span class="hl kwa">type</span> CellCoord <span class="hl sym">= (</span><span class="hl kwb">Int</span><span class="hl sym">,</span> <span class="hl kwb">Int</span><span class="hl sym">)</span>
<span class="hl kwa">type</span> Mask <span class="hl sym">=</span> <span class="hl kwb">Int</span><span class="hl sym">;</span> <span class="hl kwa">type</span> Color <span class="hl sym">=</span> <span class="hl kwb">Int</span><span class="hl sym">;</span> <span class="hl kwa">type</span> Row <span class="hl sym">=</span> <span class="hl kwb">Int</span><span class="hl sym">;</span> <span class="hl kwa">type</span> Col <span class="hl sym">=</span> <span class="hl kwb">Int</span><span class="hl sym">;</span>
   <span class="hl kwa">type</span> Tag <span class="hl sym">=</span> <span class="hl kwb">Int</span><span class="hl sym">;</span> <span class="hl kwa">type</span> Cell <span class="hl sym">=</span> <span class="hl kwb">Int</span>
<span class="hl kwa">type</span> Solution <span class="hl sym">= [</span>Mask<span class="hl sym">]</span>

pieces <span class="hl sym">::</span> Array <span class="hl kwb">Int</span> Piece
pieces <span class="hl sym">=</span> array <span class="hl sym">(</span><span class="hl num">0</span><span class="hl sym">,</span><span class="hl num">9</span><span class="hl sym">)</span> $ zip <span class="hl sym">[</span><span class="hl num">0</span>.<span class="hl num">.9</span><span class="hl sym">]</span> $
         <span class="hl sym">[[</span>E<span class="hl sym">,</span>  E<span class="hl sym">,</span>  E<span class="hl sym">,</span>  SE<span class="hl sym">],</span>
	  <span class="hl sym">[</span>SE<span class="hl sym">,</span> SW<span class="hl sym">,</span> W<span class="hl sym">,</span>  SW<span class="hl sym">],</span>
	  <span class="hl sym">[</span>W<span class="hl sym">,</span>  W<span class="hl sym">,</span>  SW<span class="hl sym">,</span> SE<span class="hl sym">],</span>
	  <span class="hl sym">[</span>E<span class="hl sym">,</span>  E<span class="hl sym">,</span>  SW<span class="hl sym">,</span> SE<span class="hl sym">],</span>
	  <span class="hl sym">[</span>NW<span class="hl sym">,</span> W<span class="hl sym">,</span>  NW<span class="hl sym">,</span> SE<span class="hl sym">,</span> SW<span class="hl sym">],</span>
	  <span class="hl sym">[</span>E<span class="hl sym">,</span>  E<span class="hl sym">,</span>  NE<span class="hl sym">,</span> W<span class="hl sym">],</span>
	  <span class="hl sym">[</span>NW<span class="hl sym">,</span> NE<span class="hl sym">,</span> NE<span class="hl sym">,</span> W<span class="hl sym">],</span>
	  <span class="hl sym">[</span>NE<span class="hl sym">,</span> SE<span class="hl sym">,</span> E<span class="hl sym">,</span>  NE<span class="hl sym">],</span>
	  <span class="hl sym">[</span>SE<span class="hl sym">,</span> SE<span class="hl sym">,</span> E<span class="hl sym">,</span>  SE<span class="hl sym">],</span>
	  <span class="hl sym">[</span>E<span class="hl sym">,</span>  NW<span class="hl sym">,</span> NW<span class="hl sym">,</span> NW<span class="hl sym">]]</span>

permutations <span class="hl sym">::</span> Piece <span class="hl sym">-&gt; [</span>Piece<span class="hl sym">]</span>
permutations p <span class="hl sym">=</span> take <span class="hl num">12</span> <span class="hl sym">(</span>perms p<span class="hl sym">)</span>
    <span class="hl kwa">where</span>
      perms p <span class="hl sym">=</span> p<span class="hl sym">:(</span>flip p<span class="hl sym">) :</span> perms <span class="hl sym">(</span>rotate p<span class="hl sym">)</span>
      rotate piece <span class="hl sym">=</span> map r piece
          <span class="hl kwa">where</span> r E  <span class="hl sym">=</span> NE
                r NE <span class="hl sym">=</span> NW
                r NW <span class="hl sym">=</span> W
                r W  <span class="hl sym">=</span> SW
                r SW <span class="hl sym">=</span> SE
                r SE <span class="hl sym">=</span> E
      flip piece <span class="hl sym">=</span> map f piece
          <span class="hl kwa">where</span> f E  <span class="hl sym">=</span> W
                f NE <span class="hl sym">=</span> NW
                f NW <span class="hl sym">=</span> NE
                f W  <span class="hl sym">=</span> E
                f SW <span class="hl sym">=</span> SE
                f SE <span class="hl sym">=</span> SW

<span class="hl slc">--- Mask Operations ----</span>
untag <span class="hl sym">::</span> Mask <span class="hl sym">-&gt;</span> Mask
untag mask   <span class="hl sym">=</span> mask .<span class="hl sym">&amp;</span>. <span class="hl num">0x1ffffff</span>

retag <span class="hl sym">::</span> Mask <span class="hl sym">-&gt;</span> Tag <span class="hl sym">-&gt;</span> Mask
retag mask n <span class="hl sym">=</span> untag mask .<span class="hl sym">|</span>. n `shiftL` <span class="hl num">25</span>

tagof <span class="hl sym">::</span> Mask <span class="hl sym">-&gt;</span> Tag
tagof mask   <span class="hl sym">=</span> mask `shiftR` <span class="hl num">25</span>

tag <span class="hl sym">::</span> Mask <span class="hl sym">-&gt;</span> Tag <span class="hl sym">-&gt;</span> Mask
tag   mask n <span class="hl sym">=</span> mask .<span class="hl sym">|</span>. n `shiftL` <span class="hl num">25</span>

count1s <span class="hl sym">::</span> Mask <span class="hl sym">-&gt;</span> <span class="hl kwb">Int</span>
count1s i
    <span class="hl sym">|</span> i <span class="hl sym">==</span> <span class="hl num">0</span> <span class="hl sym">=</span> <span class="hl num">0</span>
    <span class="hl sym">|</span> i .<span class="hl sym">&amp;</span>. <span class="hl num">1</span> <span class="hl sym">==</span> <span class="hl num">1</span> <span class="hl sym">=</span> <span class="hl num">1</span> <span class="hl sym">+</span> count1s <span class="hl sym">(</span>i `shiftR` <span class="hl num">1</span><span class="hl sym">)</span>
    <span class="hl sym">|</span> otherwise <span class="hl sym">=</span> count1s <span class="hl sym">(</span>i `shiftR` <span class="hl num">1</span><span class="hl sym">)</span>

first0 <span class="hl sym">::</span> Mask <span class="hl sym">-&gt;</span> <span class="hl kwb">Int</span>
first0 i
    <span class="hl sym">|</span> i .<span class="hl sym">&amp;</span>. <span class="hl num">1</span> <span class="hl sym">==</span> <span class="hl num">0</span> <span class="hl sym">=</span> <span class="hl num">0</span>
    <span class="hl sym">|</span> otherwise <span class="hl sym">=</span> <span class="hl num">1</span> <span class="hl sym">+</span> first0 <span class="hl sym">(</span>i `shiftR` <span class="hl num">1</span><span class="hl sym">)</span>

<span class="hl slc">--- Making the Bitmasks ---</span>
mod2 x <span class="hl sym">=</span> x .<span class="hl sym">&amp;</span>. <span class="hl num">1</span>
packSize a b <span class="hl sym">=</span> a<span class="hl sym">*</span><span class="hl num">5</span><span class="hl sym">+</span>b
unpackSize n <span class="hl sym">=</span> quotRem n <span class="hl num">5</span>

move <span class="hl sym">::</span> Direction <span class="hl sym">-&gt;</span> CellCoord <span class="hl sym">-&gt;</span> CellCoord
move E  <span class="hl sym">(</span>x<span class="hl sym">,</span> y<span class="hl sym">) = (</span>x<span class="hl sym">+</span><span class="hl num">1</span><span class="hl sym">,</span> y<span class="hl sym">)</span>
move W  <span class="hl sym">(</span>x<span class="hl sym">,</span> y<span class="hl sym">) = (</span>x<span class="hl sym">-</span><span class="hl num">1</span><span class="hl sym">,</span> y<span class="hl sym">)</span>
move NE <span class="hl sym">(</span>x<span class="hl sym">,</span> y<span class="hl sym">) = (</span>x<span class="hl sym">+(</span>mod2 y<span class="hl sym">),</span>   y<span class="hl sym">-</span><span class="hl num">1</span><span class="hl sym">)</span>
move NW <span class="hl sym">(</span>x<span class="hl sym">,</span> y<span class="hl sym">) = (</span>x<span class="hl sym">+(</span>mod2 y<span class="hl sym">)-</span><span class="hl num">1</span><span class="hl sym">,</span> y<span class="hl sym">-</span><span class="hl num">1</span><span class="hl sym">)</span>
move SE <span class="hl sym">(</span>x<span class="hl sym">,</span> y<span class="hl sym">) = (</span>x<span class="hl sym">+(</span>mod2 y<span class="hl sym">),</span>   y<span class="hl sym">+</span><span class="hl num">1</span><span class="hl sym">)</span>
move SW <span class="hl sym">(</span>x<span class="hl sym">,</span> y<span class="hl sym">) = (</span>x<span class="hl sym">+(</span>mod2 y<span class="hl sym">)-</span><span class="hl num">1</span><span class="hl sym">,</span> y<span class="hl sym">+</span><span class="hl num">1</span><span class="hl sym">)</span>

pieceBounds <span class="hl sym">::</span> Piece <span class="hl sym">-&gt;</span> <span class="hl kwb">Bool</span> <span class="hl sym">-&gt; (</span><span class="hl kwb">Int</span><span class="hl sym">,</span> <span class="hl kwb">Int</span><span class="hl sym">,</span> <span class="hl kwb">Int</span><span class="hl sym">,</span> <span class="hl kwb">Int</span><span class="hl sym">)</span>
pieceBounds piece isodd <span class="hl sym">=</span> bnds piece <span class="hl num">0</span> y0 <span class="hl num">0</span> y0 <span class="hl num">0</span> y0
  <span class="hl kwa">where</span>
    y0 <span class="hl sym">|</span> isodd <span class="hl sym">=</span> <span class="hl num">1</span> <span class="hl sym">|</span> otherwise <span class="hl sym">=</span> <span class="hl num">0</span>
    bnds <span class="hl sym">[]</span> _ _ xmin ymin xmax ymax <span class="hl sym">= (</span>xmin<span class="hl sym">,</span> ymin<span class="hl sym">,</span> xmax<span class="hl sym">,</span> ymax<span class="hl sym">)</span>
    bnds <span class="hl sym">(</span>d<span class="hl sym">:</span>rest<span class="hl sym">)</span> x y xmin ymin xmax ymax <span class="hl sym">=</span>
        bnds rest x<span class="hl str">' y'</span> <span class="hl sym">(</span>min x<span class="hl str">' xmin) (min y'</span> ymin<span class="hl sym">) (</span>max x<span class="hl str">' xmax) (max y'</span> ymax<span class="hl sym">)</span>
            <span class="hl kwa">where</span> <span class="hl sym">(</span>x<span class="hl str">', y'</span><span class="hl sym">) =</span> move d <span class="hl sym">(</span>x<span class="hl sym">,</span> y<span class="hl sym">)</span>

pieceMask <span class="hl sym">::</span> Piece <span class="hl sym">-&gt; (</span>Mask<span class="hl sym">,</span> Mask<span class="hl sym">)</span>
pieceMask piece
    <span class="hl sym">|</span> odd y1    <span class="hl sym">= (</span>tag <span class="hl sym">(</span>msk piece x2 y2 <span class="hl num">0</span><span class="hl sym">) (</span>packSize w2 h2<span class="hl sym">),</span>
                      tag <span class="hl sym">(</span>msk piece x1 <span class="hl sym">(</span>y1<span class="hl sym">+</span><span class="hl num">1</span><span class="hl sym">)</span> <span class="hl num">0</span> `shiftR` n_col<span class="hl sym">) (</span>packSize w1 h1<span class="hl sym">))</span>
    <span class="hl sym">|</span> otherwise <span class="hl sym">= (</span>tag <span class="hl sym">(</span>msk piece x1 y1 <span class="hl num">0</span><span class="hl sym">) (</span>packSize w1 h1<span class="hl sym">),</span>
                      tag <span class="hl sym">(</span>msk piece x2 <span class="hl sym">(</span>y2<span class="hl sym">+</span><span class="hl num">1</span><span class="hl sym">)</span> <span class="hl num">0</span> `shiftR` n_col<span class="hl sym">) (</span>packSize w2 h2<span class="hl sym">))</span>
    <span class="hl kwa">where</span>
      <span class="hl sym">(</span>xmin<span class="hl sym">,</span> ymin<span class="hl sym">,</span> xmax<span class="hl sym">,</span> ymax<span class="hl sym">) =</span> pieceBounds piece <span class="hl kwa">False</span>
      <span class="hl sym">(</span>x1<span class="hl sym">,</span> y1<span class="hl sym">) = (-</span>xmin<span class="hl sym">, -</span>ymin<span class="hl sym">)</span>
      w1 <span class="hl sym">=</span> xmax <span class="hl sym">-</span> xmin
      h1 <span class="hl sym">=</span> ymax <span class="hl sym">-</span> ymin
      <span class="hl sym">(</span>xmin<span class="hl str">', ymin'</span><span class="hl sym">,</span> xmax<span class="hl str">', ymax'</span><span class="hl sym">) =</span> pieceBounds piece <span class="hl kwa">True</span>
      <span class="hl sym">(</span>x2<span class="hl sym">,</span> y2<span class="hl sym">) = (-</span>xmin<span class="hl str">', (-ymin'</span><span class="hl sym">)+</span><span class="hl num">1</span><span class="hl sym">)</span>
      w2 <span class="hl sym">=</span> xmax<span class="hl str">' - xmin'</span>
      h2 <span class="hl sym">=</span> ymax<span class="hl str">' - ymin'</span>
      msk <span class="hl sym">::</span> Piece <span class="hl sym">-&gt;</span> Col <span class="hl sym">-&gt;</span> Row <span class="hl sym">-&gt;</span> Mask <span class="hl sym">-&gt;</span> Mask
      msk <span class="hl sym">[]</span> x y m <span class="hl sym">=</span> m `setBit` cellAt x y
      msk <span class="hl sym">(</span>d<span class="hl sym">:</span>rest<span class="hl sym">)</span> x y m <span class="hl sym">=</span> msk rest x<span class="hl str">' y'</span> <span class="hl sym">(</span>m `setBit` cellAt x y<span class="hl sym">)</span>
          <span class="hl kwa">where</span> <span class="hl sym">(</span>x<span class="hl str">', y'</span><span class="hl sym">) =</span> move d <span class="hl sym">(</span>x<span class="hl sym">,</span> y<span class="hl sym">)</span>

templatesForColor <span class="hl sym">::</span> Color <span class="hl sym">-&gt; ([</span>Mask<span class="hl sym">], [</span>Mask<span class="hl sym">])</span>
templatesForColor c <span class="hl sym">= (</span>unzip . map pieceMask<span class="hl sym">)</span> perms
    <span class="hl kwa">where</span> perms <span class="hl sym">|</span> c <span class="hl sym">==</span> <span class="hl num">5</span> <span class="hl sym">=</span> take <span class="hl num">6</span> ps <span class="hl sym">|</span> otherwise <span class="hl sym">=</span> ps
          ps <span class="hl sym">=</span> permutations $ pieces <span class="hl sym">!</span> c

<span class="hl slc">--- Looking for Islands ---</span>
noLineIslands <span class="hl sym">::</span> Mask <span class="hl sym">-&gt;</span> Cell <span class="hl sym">-&gt;</span> Cell <span class="hl sym">-&gt;</span> <span class="hl kwb">Int</span> <span class="hl sym">-&gt;</span> <span class="hl kwb">Bool</span>
noLineIslands mask start stop step
    <span class="hl sym">| (</span>fnd testBit . fnd <span class="hl sym">((</span>not .<span class="hl sym">)</span> . testBit<span class="hl sym">)</span> . fnd testBit<span class="hl sym">)</span>  start <span class="hl sym">&gt;</span> stop  <span class="hl sym">=</span> <span class="hl kwa">True</span>
    <span class="hl sym">|</span> otherwise <span class="hl sym">=</span> <span class="hl kwa">False</span>
  <span class="hl kwa">where</span>
    fnd test <span class="hl sym">!</span>x
        <span class="hl sym">|</span> x <span class="hl sym">&gt;=</span> <span class="hl num">25</span>     <span class="hl sym">=</span> <span class="hl num">25</span>
        <span class="hl sym">|</span> test mask x <span class="hl sym">=</span> x
        <span class="hl sym">|</span> otherwise   <span class="hl sym">=</span> fnd test <span class="hl sym">(</span>x<span class="hl sym">+</span>step<span class="hl sym">)</span>

noLeftIslands <span class="hl sym">::</span> Mask <span class="hl sym">-&gt;</span> <span class="hl kwb">Bool</span>
noLeftIslands  mask  <span class="hl sym">=</span> noLineIslands mask <span class="hl num">0 20 5</span>
noRightIslands mask  <span class="hl sym">=</span> noLineIslands mask <span class="hl num">4 24 5</span>

noIslands <span class="hl sym">::</span> Mask <span class="hl sym">-&gt;</span> <span class="hl kwb">Bool</span>
noIslands board <span class="hl sym">=</span> noisles board <span class="hl sym">(</span>count1s board<span class="hl sym">)</span>

noisles <span class="hl sym">::</span> Mask <span class="hl sym">-&gt;</span> <span class="hl kwb">Int</span> <span class="hl sym">-&gt;</span> <span class="hl kwb">Bool</span>
noisles _ <span class="hl num">30</span> <span class="hl sym">=</span> <span class="hl kwa">True</span>
noisles board ones
    <span class="hl sym">| (</span>ones<span class="hl str">' - ones) `rem` n_elem /= 0 = False</span>
<span class="hl str">    | otherwise = noisles board'</span> ones<span class="hl str">'</span>
<span class="hl str">    where board'</span> <span class="hl sym">=</span> fill board <span class="hl sym">(</span>coordOf <span class="hl sym">(</span>first0 board<span class="hl sym">))</span>
          ones<span class="hl str">' = count1s board'</span>

fill <span class="hl sym">::</span> Mask <span class="hl sym">-&gt;</span> CellCoord <span class="hl sym">-&gt;</span> Mask
fill m cc&#64;<span class="hl sym">(</span>x<span class="hl sym">,</span> y<span class="hl sym">)</span>
    <span class="hl sym">|</span> x <span class="hl sym">&lt;</span> <span class="hl num">0</span> <span class="hl sym">||</span> x <span class="hl sym">&gt;=</span> n_col <span class="hl sym">=</span> m
    <span class="hl sym">|</span> y <span class="hl sym">&lt;</span> <span class="hl num">0</span> <span class="hl sym">||</span> y <span class="hl sym">&gt;=</span> <span class="hl num">6</span>     <span class="hl sym">=</span> m
    <span class="hl sym">|</span> testBit m i <span class="hl sym">=</span> m
    <span class="hl sym">|</span> otherwise <span class="hl sym">=</span> foldl <span class="hl sym">(</span>\m d <span class="hl sym">-&gt;</span> fill m <span class="hl sym">(</span>move d cc<span class="hl sym">)) (</span>setBit m i<span class="hl sym">) [</span>E<span class="hl sym">,</span> NE<span class="hl sym">,</span> NW<span class="hl sym">,</span> W<span class="hl sym">,</span> SW<span class="hl sym">,</span> SE<span class="hl sym">]</span>
    <span class="hl kwa">where</span> i <span class="hl sym">=</span> cellAt x y

<span class="hl slc">--- More Mask Generation ---</span>
masksForColor <span class="hl sym">::</span> Color <span class="hl sym">-&gt; [(</span>Row<span class="hl sym">,</span> Mask<span class="hl sym">)]</span>
masksForColor c <span class="hl sym">=</span> concatMap atCell cells
  <span class="hl kwa">where</span>
    <span class="hl sym">(</span>evens<span class="hl sym">,</span> odds<span class="hl sym">) =</span> templatesForColor c
    atCell n
        <span class="hl sym">|</span> even y <span class="hl sym">= [(</span>y<span class="hl sym">,</span> retag <span class="hl sym">(</span>m `shiftL` x<span class="hl sym">)</span> c<span class="hl sym">) |</span> m <span class="hl sym">&lt;-</span> evens <span class="hl sym">,</span> isok m x y<span class="hl sym">]</span>
        <span class="hl sym">|</span> odd  y <span class="hl sym">= [(</span>y<span class="hl sym">,</span> retag <span class="hl sym">(</span>m `shiftL` x<span class="hl sym">)</span> c<span class="hl sym">) |</span> m <span class="hl sym">&lt;-</span> odds  <span class="hl sym">,</span> isok m x y<span class="hl sym">]</span>
        <span class="hl kwa">where</span> <span class="hl sym">(</span>x<span class="hl sym">,</span> y<span class="hl sym">) =</span> coordOf n

isok <span class="hl sym">::</span> Mask <span class="hl sym">-&gt;</span> Row <span class="hl sym">-&gt;</span> Col <span class="hl sym">-&gt;</span> <span class="hl kwb">Bool</span>
isok mask x y <span class="hl sym">=</span>
    isValid <span class="hl sym">(</span>x<span class="hl sym">+</span>width<span class="hl sym">) (</span>y<span class="hl sym">+</span>height<span class="hl sym">) &amp;&amp;</span>
            <span class="hl kwa">case</span> <span class="hl sym">(</span>y <span class="hl sym">==</span> <span class="hl num">0</span><span class="hl sym">,</span> y<span class="hl sym">+</span>height<span class="hl sym">==</span><span class="hl num">9</span><span class="hl sym">)</span> <span class="hl kwa">of</span>
              <span class="hl sym">(</span><span class="hl kwa">False</span><span class="hl sym">,</span> <span class="hl kwa">False</span><span class="hl sym">) -&gt;</span> noLeftIslands mask<span class="hl str">' &amp;&amp; noRightIslands mask'</span>
              <span class="hl sym">(</span><span class="hl kwa">False</span><span class="hl sym">,</span> <span class="hl kwa">True</span><span class="hl sym">)  -&gt;</span> noIslands <span class="hl sym">(</span>mask<span class="hl str">' `shiftL` (n_col * (y - 4)))</span>
<span class="hl str">              (True, _ ) -&gt; noIslands mask'</span>
    <span class="hl kwa">where</span> <span class="hl sym">(</span>width<span class="hl sym">,</span> height<span class="hl sym">) =</span> unpackSize <span class="hl sym">(</span>tagof mask<span class="hl sym">)</span>
          mask<span class="hl str">' = untag mask `shiftL` x</span>
<span class="hl str"></span>
<span class="hl str">masksAtCell :: Array (Row,Col) (Array Color [Mask])</span>
<span class="hl str">masksAtCell = trps $ map (masksAt cells . masksForColor) colors</span>
<span class="hl str"></span>
<span class="hl str">masksAt :: [Int] -&gt; [(Row,Mask)]-&gt; [[Mask]]</span>
<span class="hl str">masksAt [] _ = []</span>
<span class="hl str">masksAt (n:ns) !masks = map snd t : masksAt ns f</span>
<span class="hl str">    where</span>
<span class="hl str">      (t, f) = partition test masks</span>
<span class="hl str">      test (r, m) = n'</span> <span class="hl sym">&gt;=</span> <span class="hl num">0</span> <span class="hl sym">&amp;&amp;</span> n<span class="hl str">' &lt; 25 &amp;&amp;  m `testBit` n'</span>
          <span class="hl kwa">where</span> n<span class="hl str">' = n - (n_col * r)</span>
<span class="hl str"></span>
<span class="hl str">trps :: [[[Mask]]] -&gt; Array (Row, Col) (Array Color [Mask])</span>
<span class="hl str">trps !a = array ((0,0),(9,4)) $ concatMap (uncurry (map . first . (,))) $</span>
<span class="hl str">      zip [0..9] [copy !! y | y &lt;- [1,0,1,0,1,2,3,4,5,6]]</span>
<span class="hl str">    where</span>
<span class="hl str">      copy = [ [(x,copy'</span> <span class="hl sym">(</span>cellAt x y<span class="hl sym">)) |</span> x <span class="hl sym">&lt;- [</span><span class="hl num">0</span>..n_col<span class="hl sym">-</span><span class="hl num">1</span><span class="hl sym">]] |</span>  y <span class="hl sym">&lt;- [</span><span class="hl num">1</span><span class="hl sym">,</span><span class="hl num">2</span><span class="hl sym">,</span><span class="hl num">5</span><span class="hl sym">,</span><span class="hl num">6</span><span class="hl sym">,</span><span class="hl num">7</span><span class="hl sym">,</span><span class="hl num">8</span><span class="hl sym">,</span><span class="hl num">9</span><span class="hl sym">]]</span>
      copy<span class="hl str">' cell = array (0,9) $ map (\clr -&gt; (clr,a !! clr !! cell)) colors</span>
<span class="hl str"></span>
<span class="hl str">--- Formatting ---</span>
<span class="hl str">format :: Bool -&gt; String -&gt; String</span>
<span class="hl str">format _ [] = &quot;&quot;</span>
<span class="hl str">format isodd chars | isodd = &quot; &quot; ++ str | otherwise = str</span>
<span class="hl str">        where</span>
<span class="hl str">          (cur, rest) = splitAt 5 chars</span>
<span class="hl str">          str =  intersperse '</span> <span class="hl str">' cur ++ &quot;\n&quot; ++ format (not isodd) rest</span>
<span class="hl str"></span>
<span class="hl str">toString :: Solution -&gt; String</span>
<span class="hl str">toString !masks = map color cells</span>
<span class="hl str">    where</span>
<span class="hl str">      masksWithRows = withRows 0 0 (reverse masks)</span>
<span class="hl str">      withRows _ _ [] = []</span>
<span class="hl str">      withRows board r (m:rest) = (r'</span><span class="hl sym">,</span> m<span class="hl sym">) :</span> withRows board<span class="hl str">' r'</span> rest
          <span class="hl kwa">where</span> delta <span class="hl sym">=</span> first0 board `quot` n_col
                board<span class="hl str">' = board `shiftR`  (delta * n_col) .|. untag m</span>
<span class="hl str">                r'</span> <span class="hl sym">=</span> r<span class="hl sym">+</span>delta
      color n <span class="hl sym">=</span> maybe <span class="hl str">'.'</span> <span class="hl sym">((</span><span class="hl str">&quot;0123456789&quot;</span> <span class="hl sym">!!)</span> . tagof . snd<span class="hl sym">)</span>
             <span class="hl sym">(</span>find matches masksWithRows<span class="hl sym">)</span>
          <span class="hl kwa">where</span>
            matches <span class="hl sym">(</span>r<span class="hl sym">,</span> m<span class="hl sym">)</span>
              <span class="hl sym">|</span> n<span class="hl str">' &lt; 0 || n'</span> <span class="hl sym">&gt;</span> <span class="hl num">30</span>  <span class="hl sym">=</span> <span class="hl kwa">False</span>
              <span class="hl sym">|</span> otherwise  <span class="hl sym">= (</span>untag m<span class="hl sym">)</span> `testBit` n<span class="hl str">'</span>
<span class="hl str">              where n'</span> <span class="hl sym">=</span> n <span class="hl sym">- (</span>n_col <span class="hl sym">*</span> r<span class="hl sym">)</span>

<span class="hl slc">--- Generate the solutions ---</span>
firstZero <span class="hl sym">::</span> UArray <span class="hl kwb">Int Int</span>
firstZero <span class="hl sym">=</span> array <span class="hl sym">(</span><span class="hl num">0</span><span class="hl sym">,</span><span class="hl num">31</span><span class="hl sym">)</span> $ zip <span class="hl sym">[</span><span class="hl num">0</span>.<span class="hl num">.31</span><span class="hl sym">]</span>
   <span class="hl sym">[</span><span class="hl num">0</span><span class="hl sym">,</span><span class="hl num">1</span><span class="hl sym">,</span><span class="hl num">0</span><span class="hl sym">,</span><span class="hl num">2</span><span class="hl sym">,</span><span class="hl num">0</span><span class="hl sym">,</span><span class="hl num">1</span><span class="hl sym">,</span><span class="hl num">0</span><span class="hl sym">,</span><span class="hl num">3</span><span class="hl sym">,</span><span class="hl num">0</span><span class="hl sym">,</span><span class="hl num">1</span><span class="hl sym">,</span><span class="hl num">0</span><span class="hl sym">,</span><span class="hl num">2</span><span class="hl sym">,</span><span class="hl num">0</span><span class="hl sym">,</span><span class="hl num">1</span><span class="hl sym">,</span><span class="hl num">0</span><span class="hl sym">,</span><span class="hl num">4</span><span class="hl sym">,</span><span class="hl num">0</span><span class="hl sym">,</span><span class="hl num">1</span><span class="hl sym">,</span><span class="hl num">0</span><span class="hl sym">,</span><span class="hl num">2</span><span class="hl sym">,</span><span class="hl num">0</span><span class="hl sym">,</span><span class="hl num">1</span><span class="hl sym">,</span><span class="hl num">0</span><span class="hl sym">,</span><span class="hl num">3</span><span class="hl sym">,</span><span class="hl num">0</span><span class="hl sym">,</span><span class="hl num">1</span><span class="hl sym">,</span><span class="hl num">0</span><span class="hl sym">,</span><span class="hl num">2</span><span class="hl sym">,</span><span class="hl num">0</span><span class="hl sym">,</span><span class="hl num">1</span><span class="hl sym">,</span><span class="hl num">0</span><span class="hl sym">,</span><span class="hl num">5</span><span class="hl sym">]</span>

solutions <span class="hl sym">:: [</span>String<span class="hl sym">]</span>
solutions <span class="hl sym">=</span> solveCell <span class="hl num">0</span> colors <span class="hl num">0</span> <span class="hl sym">[] []</span>

solveCell <span class="hl sym">::</span> Row <span class="hl sym">-&gt; [</span>Color<span class="hl sym">] -&gt;</span> Mask <span class="hl sym">-&gt;</span> Solution <span class="hl sym">-&gt; [</span>String<span class="hl sym">] -&gt; [</span>String<span class="hl sym">]</span>
solveCell _ <span class="hl sym">[]</span> board soln results <span class="hl sym">=</span> <span class="hl kwa">let</span> s <span class="hl sym">=</span> toString soln <span class="hl kwa">in</span>  s<span class="hl sym">:(</span>reverse s<span class="hl sym">):</span>results
solveCell <span class="hl sym">!</span>row <span class="hl sym">!</span>todo <span class="hl sym">!</span>board <span class="hl sym">!</span>soln results
    <span class="hl sym">|</span> top<span class="hl sym">/=</span>m_top <span class="hl sym">=</span> foldr solveMask results <span class="hl sym">[(</span>m<span class="hl sym">,</span> c<span class="hl sym">) |</span> c <span class="hl sym">&lt;-</span> todo<span class="hl sym">,</span>
        m  <span class="hl sym">&lt;-</span> masks <span class="hl sym">!</span> c<span class="hl sym">,</span>  board .<span class="hl sym">&amp;</span>. m <span class="hl sym">==</span> <span class="hl num">0</span><span class="hl sym">]</span>
    <span class="hl sym">|</span> otherwise  <span class="hl sym">=</span> solveCell <span class="hl sym">(</span>row<span class="hl sym">+</span><span class="hl num">1</span><span class="hl sym">)</span> todo <span class="hl sym">(</span>board `shiftR` n_col<span class="hl sym">)</span> soln results
    <span class="hl kwa">where</span> top <span class="hl sym">=</span> board .<span class="hl sym">&amp;</span>. m_top
          masks <span class="hl sym">=</span> masksAtCell <span class="hl sym">! (</span>row<span class="hl sym">, (</span>firstZero <span class="hl sym">!</span> top<span class="hl sym">) )</span>
          solveMask <span class="hl sym">(!</span>m<span class="hl sym">,!</span>c<span class="hl sym">)</span> results <span class="hl sym">=</span> solveCell row <span class="hl sym">(</span>delete c todo<span class="hl sym">)</span>
             <span class="hl sym">(</span>untag m .<span class="hl sym">|</span>. board<span class="hl sym">) (</span>m<span class="hl sym">:</span>soln<span class="hl sym">)</span> results

main <span class="hl sym">=</span> <span class="hl kwa">do</span>
    n <span class="hl sym">&lt;-</span> return.read.head <span class="hl sym">=&lt;&lt;</span> getArgs
    <span class="hl kwa">let</span> nsolutions <span class="hl sym">=</span> take n solutions
    putStrLn $ <span class="hl sym">(</span>show $ length nsolutions<span class="hl sym">) ++</span> <span class="hl str">&quot; solutions found\n&quot;</span>
    putStrLn . format <span class="hl kwa">False</span> . minimum $ nsolutions
    putStrLn . format <span class="hl kwa">False</span> . maximum $ nsolutions
