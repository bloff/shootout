<span class="str">&quot;  The Computer Language Shootout</span>
<span class="str">   http://shootout.alioth.debian.org/</span>
<span class="str">   contributed by Isaac Gouy&quot;</span><span class="sym">!</span>

<span class="sym">!</span>Shootout.Tests class methodsFor<span class="sym">:</span> <span class="str">'benchmarking'</span><span class="sym">!</span>

pidigits
   <span class="sym">|</span> i length n pidigits stream <span class="sym">|</span>
   n <span class="sym">:=</span> CEnvironment argv first asNumber.
   i <span class="sym">:=</span> <span class="num">0</span>.
   length <span class="sym">:=</span> <span class="num">10</span>.
   pidigits <span class="sym">:=</span> PiDigitSpigot new.

   stream <span class="sym">:=</span> ReadWriteStream on<span class="sym">: (</span>String new<span class="sym">:</span> <span class="num">30</span><span class="sym">)</span>.

   <span class="sym">[</span>n <span class="sym">&gt;</span> <span class="num">0</span><span class="sym">]</span> whileTrue<span class="sym">: [</span>

      <span class="sym">(</span>n <span class="sym">&lt;</span> length<span class="sym">)</span>
         ifTrue<span class="sym">: [</span>
            n timesRepeat<span class="sym">: [</span>
               stream nextPut<span class="sym">: (</span>Character digitValue<span class="sym">:</span> pidigits <span class="kwa">next</span><span class="sym">)</span>
               <span class="sym">]</span>.

            n to<span class="sym">:</span> length <span class="kwa">do</span><span class="sym">: [:</span>each<span class="sym">|</span> stream space<span class="sym">]</span>.
            i <span class="sym">:=</span> i <span class="sym">+</span> n.
            <span class="sym">]</span>

         ifFalse<span class="sym">: [</span>
            length timesRepeat<span class="sym">: [</span>
               stream nextPut<span class="sym">: (</span>Character digitValue<span class="sym">:</span> pidigits <span class="kwa">next</span><span class="sym">)</span>
               <span class="sym">]</span>.

            i <span class="sym">:=</span> i <span class="sym">+</span> length.
            <span class="sym">]</span>.

     stream tab nextPut<span class="sym">: $:</span>.
      i printOn<span class="sym">:</span> stream.
      stream cr.

      OS.Stdout nextPutAll<span class="sym">:</span> stream contents.
      stream reset.
      n <span class="sym">:=</span> n <span class="sym">-</span> length.
   <span class="sym">]</span>.
   ^<span class="str">''</span> <span class="sym">! !</span>


Smalltalk.Shootout defineClass<span class="sym">:</span> <span class="slc">#PiDigitSpigot</span>
	superclass<span class="sym">:</span> <span class="slc">#{Core.Object}</span>
	indexedType<span class="sym">:</span> <span class="slc">#none</span>
	private<span class="sym">:</span> false
	instanceVariableNames<span class="sym">:</span> <span class="str">'z x inverse '</span>
	classInstanceVariableNames<span class="sym">:</span> <span class="str">''</span>
	imports<span class="sym">:</span> <span class="str">''</span>
	category<span class="sym">:</span> <span class="str">'Shootout'</span><span class="sym">!</span>


<span class="sym">!</span>Shootout.PiDigitSpigot class methodsFor<span class="sym">:</span> <span class="str">'instance creation'</span><span class="sym">!</span>

new
   ^super new initialize <span class="sym">! !</span>


<span class="sym">!</span>Shootout.PiDigitSpigot methodsFor<span class="sym">:</span> <span class="str">'initialize-release'</span><span class="sym">!</span>

initialize
   z <span class="sym">:=</span> Transformation unity.
   x <span class="sym">:=</span> Transformation new.
   inverse <span class="sym">:=</span> Transformation new. <span class="sym">! !</span>

<span class="sym">!</span>Shootout.PiDigitSpigot methodsFor<span class="sym">:</span> <span class="str">'accessing'</span><span class="sym">!</span>

<span class="kwa">next</span>
   <span class="sym">|</span> y <span class="sym">|</span>
   ^<span class="sym">(</span>self isSafe<span class="sym">: (</span>y <span class="sym">:=</span> self digit<span class="sym">))</span>
      ifTrue<span class="sym">: [</span>z <span class="sym">:=</span> self produce<span class="sym">:</span> y. y<span class="sym">]</span>
      ifFalse<span class="sym">: [</span>z <span class="sym">:=</span> self consume<span class="sym">:</span> x <span class="kwa">next</span>. self <span class="kwa">next</span><span class="sym">] ! !</span>

<span class="sym">!</span>Shootout.PiDigitSpigot methodsFor<span class="sym">:</span> <span class="str">'private'</span><span class="sym">!</span>

consume<span class="sym">:</span> aTransformation
   ^z <span class="sym">*</span> aTransformation <span class="sym">!</span>

digit
   ^<span class="sym">(</span>z extract<span class="sym">:</span> <span class="num">3</span><span class="sym">)</span> floor <span class="sym">!</span>

isSafe<span class="sym">:</span> aDigit
   ^aDigit <span class="sym">= (</span>z extract<span class="sym">:</span> <span class="num">4</span><span class="sym">)</span> floor <span class="sym">!</span>

produce<span class="sym">:</span> anInteger
   inverse q<span class="sym">:</span> <span class="num">10</span> r<span class="sym">: -</span><span class="num">10</span> <span class="sym">*</span> anInteger s<span class="sym">:</span> <span class="num">0</span> t<span class="sym">:</span> <span class="num">1</span>.
   ^inverse <span class="sym">*</span> z <span class="sym">! !</span>


Smalltalk.Shootout defineClass<span class="sym">:</span> <span class="slc">#Transformation</span>
	superclass<span class="sym">:</span> <span class="slc">#{Core.Object}</span>
	indexedType<span class="sym">:</span> <span class="slc">#none</span>
	private<span class="sym">:</span> false
	instanceVariableNames<span class="sym">:</span> <span class="str">'q r s t k '</span>
	classInstanceVariableNames<span class="sym">:</span> <span class="str">''</span>
	imports<span class="sym">:</span> <span class="str">''</span>
	category<span class="sym">:</span> <span class="str">'Shootout'</span><span class="sym">!</span>


<span class="sym">!</span>Shootout.Transformation class methodsFor<span class="sym">:</span> <span class="str">'instance creation'</span><span class="sym">!</span>

new
   ^super new initialize<span class="sym">!</span>

q<span class="sym">:</span> anInteger1 r<span class="sym">:</span> anInteger2 s<span class="sym">:</span> anInteger3 t<span class="sym">:</span> anInteger4
   ^<span class="sym">(</span>super new<span class="sym">)</span> q<span class="sym">:</span> anInteger1 r<span class="sym">:</span> anInteger2 s<span class="sym">:</span> anInteger3 t<span class="sym">:</span> anInteger4 <span class="sym">!</span>

unity
   ^self q<span class="sym">:</span> <span class="num">1</span> r<span class="sym">:</span> <span class="num">0</span> s<span class="sym">:</span> <span class="num">0</span> t<span class="sym">:</span> <span class="num">1</span> <span class="sym">! !</span>



<span class="sym">!</span>Shootout.Transformation methodsFor<span class="sym">:</span> <span class="str">'initialize-release'</span><span class="sym">!</span>

initialize
   q <span class="sym">:=</span> <span class="num">0</span>.
   r <span class="sym">:=</span> <span class="num">0</span>.
   s <span class="sym">:=</span> <span class="num">0</span>.
   t <span class="sym">:=</span> <span class="num">0</span>.
   k <span class="sym">:=</span> <span class="num">0</span>. <span class="sym">! !</span>

<span class="sym">!</span>Shootout.Transformation methodsFor<span class="sym">:</span> <span class="str">'accessing'</span><span class="sym">!</span>

<span class="sym">*</span> aTransformation
   ^self species
      q<span class="sym">:</span> q <span class="sym">*</span> aTransformation q
      r<span class="sym">:</span> q <span class="sym">*</span> aTransformation r <span class="sym">+ (</span>r <span class="sym">*</span> aTransformation t<span class="sym">)</span>
      s<span class="sym">:</span> s <span class="sym">*</span> aTransformation q <span class="sym">+ (</span>t <span class="sym">*</span> aTransformation s<span class="sym">)</span>
      t<span class="sym">:</span> s <span class="sym">*</span> aTransformation r <span class="sym">+ (</span>t <span class="sym">*</span> aTransformation t<span class="sym">) !</span>

extract<span class="sym">:</span> anInteger
   ^<span class="sym">(</span>q <span class="sym">*</span> anInteger <span class="sym">+</span> r<span class="sym">) // (</span>s <span class="sym">*</span> anInteger <span class="sym">+</span> t<span class="sym">) !</span>

<span class="kwa">next</span>
   k <span class="sym">:=</span> k <span class="sym">+</span><span class="num">1</span>.
   q <span class="sym">:=</span> k.
   r <span class="sym">:=</span> <span class="num">4</span> <span class="sym">*</span> k <span class="sym">+</span> <span class="num">2</span>.
   s <span class="sym">:=</span> <span class="num">0</span>.
   t <span class="sym">:=</span> <span class="num">2</span> <span class="sym">*</span> k <span class="sym">+</span> <span class="num">1</span>. <span class="sym">!</span>

q
   ^q <span class="sym">!</span>

q<span class="sym">:</span> anInteger1 r<span class="sym">:</span> anInteger2 s<span class="sym">:</span> anInteger3 t<span class="sym">:</span> anInteger4
   q <span class="sym">:=</span> anInteger1.
   r <span class="sym">:=</span> anInteger2.
   s <span class="sym">:=</span> anInteger3.
   t <span class="sym">:=</span> anInteger4.
   k <span class="sym">:=</span> <span class="num">0</span>. <span class="sym">!</span>

r
   ^r <span class="sym">!</span>

s
   ^s <span class="sym">!</span>

t
   ^t <span class="sym">! !</span>
