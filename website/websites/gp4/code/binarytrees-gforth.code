<span class="slc">\ binary-tree.gforth</span>
<span class="slc">\ http://shootout.alioth.debian.org/</span>
<span class="slc">\ contributed by Ian Osgood</span>

<span class="num">4</span> constant min<span class="sym">-</span>depth

<span class="slc">\ read NUM from last command line argument</span>
<span class="num">0</span><span class="sym">.</span> argc <span class="sym">&#64;</span> <span class="num">1</span><span class="sym">-</span> arg <span class="sym">&gt;</span>number <span class="num">2</span>drop drop min<span class="sym">-</span>depth <span class="num">2</span> <span class="sym">+</span> max constant NUM

struct
  cell<span class="sym">%</span> field left
  cell<span class="sym">%</span> field right
  cell<span class="sym">%</span> field item
end<span class="sym">-</span>struct node<span class="sym">%</span>

<span class="sym">:</span> bottom<span class="sym">-</span>up<span class="sym">-</span>tree <span class="com">( item depth -- tree )</span>
  dup if
    over <span class="num">2</span><span class="sym">*</span> <span class="num">1</span><span class="sym">-</span> over <span class="num">1</span><span class="sym">-</span> recurse  <span class="sym">&gt;</span>r
    over <span class="num">2</span><span class="sym">*</span>    swap <span class="num">1</span><span class="sym">-</span> recurse  r<span class="sym">&gt;</span>
  else <span class="num">0</span> then <span class="com">( item right left )</span>
  node<span class="sym">%</span> nip allocate throw
  tuck left <span class="sym">!</span>  tuck right <span class="sym">!</span>  tuck item <span class="sym">! ;</span>

<span class="sym">:</span> item<span class="sym">-</span>check <span class="com">( tree -- n )</span>
  dup item <span class="sym">&#64;</span>
  over left <span class="sym">&#64;</span> if
    over left <span class="sym">&#64;</span> recurse <span class="sym">+</span>  over right <span class="sym">&#64;</span> recurse <span class="sym">-</span>
  then nip <span class="sym">;</span>

<span class="sym">:</span> free<span class="sym">-</span>tree <span class="com">( tree -- )</span>
  dup right <span class="sym">&#64;</span> if
    dup right <span class="sym">&#64;</span> recurse  dup left <span class="sym">&#64;</span> recurse
  then free throw <span class="sym">;</span>

<span class="sym">: .</span>check <span class="com">( check depth -- )</span>
  <span class="sym">.</span><span class="str">&quot;  of depth &quot;</span> <span class="num">1</span> u<span class="sym">.</span>r <span class="sym">#</span>tab emit <span class="sym">.</span><span class="str">&quot;  check: &quot;</span> <span class="num">1</span> <span class="sym">.</span>r <span class="sym">;</span>

<span class="sym">:</span> main
  <span class="num">0</span> NUM <span class="num">1</span><span class="sym">+</span> bottom<span class="sym">-</span>up<span class="sym">-</span>tree
  <span class="sym">.</span><span class="str">&quot; stretch tree&quot;</span> dup item<span class="sym">-</span>check NUM <span class="num">1</span><span class="sym">+ .</span>check cr
  free<span class="sym">-</span>tree
  <span class="num">0</span> NUM bottom<span class="sym">-</span>up<span class="sym">-</span>tree
  NUM <span class="num">1</span><span class="sym">+</span> min<span class="sym">-</span>depth do
    <span class="num">1</span>  NUM min<span class="sym">-</span>depth <span class="sym">+</span> i <span class="sym">-</span>  lshift  <span class="num">0</span> <span class="com">( iterations check )</span>
    over <span class="num">1</span><span class="sym">+</span> <span class="num">1</span> do
      i        j bottom<span class="sym">-</span>up<span class="sym">-</span>tree dup item<span class="sym">-</span>check swap free<span class="sym">-</span>tree <span class="sym">+</span>
      i negate j bottom<span class="sym">-</span>up<span class="sym">-</span>tree dup item<span class="sym">-</span>check swap free<span class="sym">-</span>tree <span class="sym">+</span>
    loop
    swap <span class="num">2</span><span class="sym">*</span> <span class="num">1</span> u<span class="sym">.</span>r <span class="sym">#</span>tab emit <span class="sym">.</span><span class="str">&quot;  trees&quot;</span> i <span class="sym">.</span>check cr
  <span class="num">2</span> <span class="sym">+</span>loop
  <span class="sym">.</span><span class="str">&quot; long lived tree&quot;</span> dup item<span class="sym">-</span>check NUM <span class="sym">.</span>check cr
  free<span class="sym">-</span>tree <span class="sym">;</span>

main bye  <span class="slc">\ done!</span>
