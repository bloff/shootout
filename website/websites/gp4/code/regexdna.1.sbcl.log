BUILD COMMANDS FOR: regexdna.sbcl

Wed Jun 25 21:50:09 PDT 2008

SBCL built with: /usr/bin/sbcl --userinit /dev/null --sysinit /etc/sbclrc -batch -eval '(load "regexdna.sbcl_compile")'
### START regexdna.sbcl_compile
(proclaim '(optimize (speed 3) (safety 0) (debug 0) (compilation-speed 0) (space 0)))
(handler-bind ((sb-ext:defconstant-uneql      (lambda (c) (abort c))))      (load (compile-file "regexdna.sbcl" ))) (save-lisp-and-die "sbcl.core" :purify t)
### END regexdna.sbcl_compile

; loading system definition from
; /usr/share/common-lisp/systems/asdf-binary-locations.asd into
; #<PACKAGE "ASDF0">
; registering #<SYSTEM ASDF-BINARY-LOCATIONS {AEBF859}> as ASDF-BINARY-LOCATIONS

; compiling file "/home/dunham/gp4/shootout/bench/regexdna/tmp/regexdna.sbcl" (written 25 JUN 2008 09:50:09 PM):
; compiling (REQUIRE :CL-PPCRE)
; compiling file "/usr/share/common-lisp/source/cl-ppcre/packages.lisp" (written 10 NOV 2006 09:18:57 AM):

; /home/dunham/.fasls/sbcl-1.0.15-gentoo-linux-x86/usr/share/common-lisp/source/cl-ppcre/packages.fasl written
; compilation finished in 0:00:00
; compiling file "/usr/share/common-lisp/source/cl-ppcre/specials.lisp" (written 10 NOV 2006 09:18:57 AM):
; in: LAMBDA (#:WHOLE66 #:ENVIRONMENT67)
;     (MEMBER SB-IMPL::THIS-KIND '(:EXTERNAL))
; --> BLOCK LET DO BLOCK LET TAGBODY TAGBODY LET WHEN IF 
; --> SB-IMPL::SATISFIES-THE-TEST LET COND IF COND IF COND PROGN FUNCALL 
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G27 #:G28)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a SINGLE-FLOAT.
;   The second argument is a T, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a DOUBLE-FLOAT.
;   The second argument is a T, not a DOUBLE-FLOAT.
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

; file: /usr/share/common-lisp/source/cl-ppcre/specials.lisp
; in:
;      LET ((EXPORTED-SYMBOLS-ALIST
;        (LOOP FOR SYMBOL BEING THE EXTERNAL-SYMBOLS OF :CL-PPCRE COLLECT
;              (CONS SYMBOL (CONCATENATE 'STRING "#" #)))))
;     (LOOP CL-PPCRE::FOR SYMBOL CL-PPCRE::BEING THE CL-PPCRE::EXTERNAL-SYMBOLS
;         CL-PPCRE::OF :CL-PPCRE CL-PPCRE::COLLECT
;         (CONS SYMBOL (CONCATENATE 'STRING "#" (STRING-DOWNCASE SYMBOL))))
; --> BLOCK LET WITH-PACKAGE-ITERATOR LET* MACROLET WHEN IF PROGN FLET BLOCK > 
; --> IF 
; ==>
;   (> NUMBER 1)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; /home/dunham/.fasls/sbcl-1.0.15-gentoo-linux-x86/usr/share/common-lisp/source/cl-ppcre/specials.fasl written
; compilation finished in 0:00:00
; compiling file "/usr/share/common-lisp/source/cl-ppcre/util.lisp" (written 10 NOV 2006 09:18:57 AM):
; in: LAMBDA NIL
;     (FUNCALL CL-PPCRE::TEST CL-PPCRE::CHR)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR FUNCTION SYMBOL), not a FUNCTION.

; file: /usr/share/common-lisp/source/cl-ppcre/util.lisp
; in: DEFUN MAKE-CHAR-HASH
;     (FUNCALL CL-PPCRE::TEST CL-PPCRE::CHR)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR FUNCTION SYMBOL), not a FUNCTION.
; in: LAMBDA NIL
;     (ALPHANUMERICP CL-PPCRE::CHR)
; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; in: DEFUN WORD-CHAR-P
;     (ALPHANUMERICP CL-PPCRE::CHR)
; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; in: DEFUN CREATE-RANGES-FROM-HASH
;     (CHAR-DOWNCASE CL-PPCRE::CHR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

; in: DEFUN NSUBSEQ
;     (LENGTH SEQUENCE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; in: DEFUN STRING-LIST-TO-SIMPLE-STRING
;     (REPLACE CL-PPCRE::RESULT-STRING STRING :START1 CL-PPCRE::CURR-POS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a STRING, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a STRING, not a SIMPLE-BASE-STRING.

; /home/dunham/.fasls/sbcl-1.0.15-gentoo-linux-x86/usr/share/common-lisp/source/cl-ppcre/util.fasl written
; compilation finished in 0:00:01
; compiling file "/usr/share/common-lisp/source/cl-ppcre/errors.lisp" (written 10 NOV 2006 09:18:57 AM):

; file: /usr/share/common-lisp/source/cl-ppcre/errors.lisp
; in: DEFINE-CONDITION PPCRE-SYNTAX-ERROR
;     (FORMAT STREAM "~?~@[ at position ~A~]~@[ in string ~S~]"
;           (SIMPLE-CONDITION-FORMAT-CONTROL CONDITION)
;           (SIMPLE-CONDITION-FORMAT-ARGUMENTS CONDITION)
;           (CL-PPCRE:PPCRE-SYNTAX-ERROR-POS CONDITION)
;           (CL-PPCRE:PPCRE-SYNTAX-ERROR-STRING CONDITION))
; ==>
;   (FORMAT SB-C::DEST (FORMATTER "~?~@[ at position ~A~]~@[ in string ~S~]")
;           #:G3 #:G4 #:G5 #:G6)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (MEMBER NIL T) STREAM (VECTOR CHARACTER)
;                               (VECTOR NIL) BASE-STRING), not a STREAM.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (MEMBER NIL T) STREAM (VECTOR CHARACTER)
;                               (VECTOR NIL) BASE-STRING), not a (MEMBER T).

; /home/dunham/.fasls/sbcl-1.0.15-gentoo-linux-x86/usr/share/common-lisp/source/cl-ppcre/errors.fasl written
; compilation finished in 0:00:01
; compiling file "/usr/share/common-lisp/source/cl-ppcre/lexer.lisp" (written 10 NOV 2006 09:18:57 AM):

; file: /usr/share/common-lisp/source/cl-ppcre/lexer.lisp
; in: DEFUN NEXT-CHAR
;     (CL-PPCRE::SIGNAL-PPCRE-SYNTAX-ERROR* CL-PPCRE::ERROR-POS
;                                         "Comment group not closed")
; ==>
;   (ERROR 'CL-PPCRE:PPCRE-SYNTAX-ERROR :POS CL-PPCRE::ERROR-POS :FORMAT-CONTROL
;          "Comment group not closed" :FORMAT-ARGUMENTS (LIST))
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN GET-NUMBER
;     (IF (< CL-PPCRE::END-POS CL-PPCRE::LEXER-LEN) CL-PPCRE::END-POS
;       CL-PPCRE::LEXER-LEN)
; ==>
;   CL-PPCRE::END-POS
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN MAKE-CHAR-FROM-CODE
;     (CL-PPCRE::SIGNAL-PPCRE-SYNTAX-ERROR* CL-PPCRE::ERROR-POS
;                                         "No character for hex-code ~X" NUMBER)
; --> ERROR 
; ==>
;   CL-PPCRE::ERROR-POS
; 
; note: deleting unreachable code

; ==>
;   "No character for hex-code ~X"
; 
; note: deleting unreachable code
; 
; note: deleting unreachable code

; in: DEFUN UNESCAPE-CHAR
;     (CHAR-UPCASE CL-PPCRE::NEXT-CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

; in: DEFUN MAKE-CHAR-FROM-CODE
;     (CL-PPCRE::SIGNAL-PPCRE-SYNTAX-ERROR* CL-PPCRE::ERROR-POS
;                                         "No character for hex-code ~X" NUMBER)
; --> ERROR 
; ==>
;   "No character for hex-code ~X"
; 
; note: deleting unreachable code

; ==>
;   CL-PPCRE::ERROR-POS
; 
; note: deleting unreachable code

; in: DEFUN GET-TOKEN
;     (CL-PPCRE::SIGNAL-PPCRE-SYNTAX-ERROR*
;    (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER))
;    "Character '~A' may not follow '(?<'" CL-PPCRE::NEXT-CHAR)
; ==>
;   (ERROR 'CL-PPCRE:PPCRE-SYNTAX-ERROR :POS
;          (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER)) :FORMAT-CONTROL
;          "Character '~A' may not follow '(?<'" :FORMAT-ARGUMENTS
;          (LIST CL-PPCRE::NEXT-CHAR))
; 
; note: doing signed word to integer coercion (cost 20)

;     (CL-PPCRE::SIGNAL-PPCRE-SYNTAX-ERROR*
;    (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER))
;    "Character '~A' may not follow '(?'" CL-PPCRE::NEXT-CHAR)
; ==>
;   (ERROR 'CL-PPCRE:PPCRE-SYNTAX-ERROR :POS
;          (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER)) :FORMAT-CONTROL
;          "Character '~A' may not follow '(?'" :FORMAT-ARGUMENTS
;          (LIST CL-PPCRE::NEXT-CHAR))
; 
; note: doing signed word to integer coercion (cost 20)

;     (CL-PPCRE::SIGNAL-PPCRE-SYNTAX-ERROR*
;    (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER)) "Quantifier '~A' not allowed"
;    CL-PPCRE::NEXT-CHAR)
; ==>
;   (ERROR 'CL-PPCRE:PPCRE-SYNTAX-ERROR :POS
;          (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER)) :FORMAT-CONTROL
;          "Quantifier '~A' not allowed" :FORMAT-ARGUMENTS
;          (LIST CL-PPCRE::NEXT-CHAR))
; 
; note: doing signed word to integer coercion (cost 20)

; /home/dunham/.fasls/sbcl-1.0.15-gentoo-linux-x86/usr/share/common-lisp/source/cl-ppcre/lexer.fasl written
; compilation finished in 0:00:00
; compiling file "/usr/share/common-lisp/source/cl-ppcre/parser.lisp" (written 10 NOV 2006 09:18:57 AM):

; file: /usr/share/common-lisp/source/cl-ppcre/parser.lisp
; in: DEFUN GROUP
;     (CL-PPCRE::SIGNAL-PPCRE-SYNTAX-ERROR* (+ CL-PPCRE::OPEN-PAREN-POS 2)
;                                         "Opening paren has no matching closing paren")
; ==>
;   (ERROR 'CL-PPCRE:PPCRE-SYNTAX-ERROR :POS (+ CL-PPCRE::OPEN-PAREN-POS 2)
;          :FORMAT-CONTROL "Opening paren has no matching closing paren"
;          :FORMAT-ARGUMENTS (LIST))
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN SEQ
;     (CL-PPCRE::START-OF-SUBEXPR-P CL-PPCRE::LEXER)
; --> BLOCK LET* NOT IF OR LET IF OR PROG1 LET MEMBER BLOCK LET AND IF AND 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-IMPL::KEY)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR FUNCTION SYMBOL), not a FUNCTION.

; --> BLOCK LET* NOT IF OR LET IF OR PROG1 LET MEMBER BLOCK LET IF 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-IMPL::TEST)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR FUNCTION SYMBOL), not a FUNCTION.

; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-IMPL::TEST-NOT)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR FUNCTION SYMBOL), not a FUNCTION.

;     (SETF (AREF STRING 0) CL-PPCRE::CHAR1)
; --> SB-KERNEL:%ASET SB-KERNEL:HAIRY-DATA-VECTOR-SET MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR CHARACTER), not a SIMPLE-ARRAY.

;     (SETF (AREF STRING 1) CL-PPCRE::CHAR2)
; --> SB-KERNEL:%ASET SB-KERNEL:HAIRY-DATA-VECTOR-SET MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR CHARACTER), not a SIMPLE-ARRAY.

; /home/dunham/.fasls/sbcl-1.0.15-gentoo-linux-x86/usr/share/common-lisp/source/cl-ppcre/parser.fasl written
; compilation finished in 0:00:01
; compiling file "/usr/share/common-lisp/source/cl-ppcre/regex-class.lisp" (written 10 NOV 2006 09:18:57 AM):

; file: /usr/share/common-lisp/source/cl-ppcre/regex-class.lisp
; in: DEFMETHOD INITIALIZE-INSTANCE :AFTER (CHAR-CLASS)
;     (> (HASH-TABLE-COUNT CL-PPCRE::HASH) (/ CL-PPCRE:*REGEX-CHAR-CODE-LIMIT* 2))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a (RATIONAL -268435456 536870911/2), not a FIXNUM.

; in: DEFMETHOD INITIALIZE-INSTANCE :AFTER (STR)
;     (LENGTH (CL-PPCRE::STR CL-PPCRE::STR))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; in: DEFMETHOD CASE-MODE (STR T)
;     (ZEROP (CL-PPCRE::LEN CL-PPCRE::STR))
; ==>
;   (= (CL-PPCRE::LEN CL-PPCRE::STR) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; in: DEFMETHOD EVERYTHINGP (SEQ)
;     (LENGTH CL-PPCRE::CLEANED-ELEMENTS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY
;                                                                    * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

; in: DEFMETHOD EVERYTHINGP (ALTERNATION)
;     (DEFMETHOD CL-PPCRE::EVERYTHINGP
;              ((CL-PPCRE::ALTERNATION CL-PPCRE::ALTERNATION))
;              (WITH-SLOTS ((CL-PPCRE::CHOICES CL-PPCRE::CHOICES))
;                          CL-PPCRE::ALTERNATION
;                          (AND (= 1 (LENGTH CL-PPCRE::CHOICES))
;                               (CL-PPCRE::EVERYTHINGP
;                                (FIRST CL-PPCRE::CHOICES)))))
; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF = 
; ==>
;   (LENGTH
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G322 'CL-PPCRE::CHOICES)
;                                  CL-PPCRE::ALTERNATION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 0)
;                                                         CL-PPCRE::ALTERNATION 0
;                                                         'CL-PPCRE::CHOICES
;                                                         '#<STANDARD-CLASS CL-PPCRE::ALTERNATION>)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; in: DEFMETHOD EVERYTHINGP (REPETITION)
;     (DEFMETHOD CL-PPCRE::EVERYTHINGP
;              ((CL-PPCRE::REPETITION CL-PPCRE::REPETITION))
;              (WITH-SLOTS
;               ((CL-PPCRE::MAXIMUM CL-PPCRE::MAXIMUM)
;                (CL-PPCRE::MINIMUM CL-PPCRE::MINIMUM)
;                (CL-PPCRE::REGEX CL-PPCRE::REGEX))
;               CL-PPCRE::REPETITION
;               (AND CL-PPCRE::MAXIMUM (= 1 CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM)
;                    (CL-PPCRE::EVERYTHINGP CL-PPCRE::REGEX))))
; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF = 
; --> (LAMBDA (#:G349 #:G348 #:G347) (DECLARE (TYPE NUMBER #:G349 #:G348 #:G347)) (IF (= #:G349 #:G348) (IF (= #:G348 #:G347) T NIL) NIL)) 
; --> IF = = IF 
; ==>
;   (= SB-C::Y SB-C::X)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF = 
; --> (LAMBDA (#:G349 #:G348 #:G347) (DECLARE (TYPE NUMBER #:G349 #:G348 #:G347)) (IF (= #:G349 #:G348) (IF (= #:G348 #:G347) T NIL) NIL)) 
; --> IF IF 
; ==>
;   (= #:G348 #:G347)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.

; in: DEFMETHOD REGEX-LENGTH (SEQ)
;     (LOOP CL-PPCRE::FOR CL-PPCRE::SUB-REGEX CL-PPCRE::IN
;         (CL-PPCRE::ELEMENTS CL-PPCRE::SEQ) CL-PPCRE::FOR CL-PPCRE::LEN =
;         (CL-PPCRE::REGEX-LENGTH CL-PPCRE::SUB-REGEX) IF (NOT CL-PPCRE::LEN) DO
;         ...)
; --> BLOCK LET LET LET SB-LOOP::LOOP-BODY TAGBODY SETQ THE 
; ==>
;   (+ #:LOOP-SUM-380 CL-PPCRE::LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; in: DEFMETHOD REGEX-LENGTH (ALTERNATION)
;     (/= CL-PPCRE::LEN CL-PPCRE::OLD-LEN)
; --> IF 
; ==>
;   (= CL-PPCRE::LEN CL-PPCRE::OLD-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.

; in: DEFMETHOD REGEX-LENGTH (BRANCH)
;     (EQL CL-PPCRE::THEN-LENGTH
;        (CL-PPCRE::REGEX-LENGTH (CL-PPCRE::ELSE-REGEX CL-PPCRE::BRANCH)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a SINGLE-FLOAT.
;   The second argument is a T, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a DOUBLE-FLOAT.
;   The second argument is a T, not a DOUBLE-FLOAT.
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

; in: DEFMETHOD REGEX-LENGTH (REPETITION)
;     (DEFMETHOD CL-PPCRE::REGEX-LENGTH
;              ((CL-PPCRE::REPETITION CL-PPCRE::REPETITION))
;              (WITH-SLOTS
;               ((CL-PPCRE::LEN CL-PPCRE::LEN)
;                (CL-PPCRE::MINIMUM CL-PPCRE::MINIMUM)
;                (CL-PPCRE::MAXIMUM CL-PPCRE::MAXIMUM))
;               CL-PPCRE::REPETITION
;               (IF (AND CL-PPCRE::LEN (EQL CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM))
;                   (* CL-PPCRE::MINIMUM CL-PPCRE::LEN) NIL)))
; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF 
; ==>
;   (EQL
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G397 'CL-PPCRE::MINIMUM)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 4)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MINIMUM
;                                                         '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G397 'CL-PPCRE::MAXIMUM)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 2)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MAXIMUM
;                                                         '#<STANDARD-CLASS CL-PPCRE::REPETITION>)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a SINGLE-FLOAT.
;   The second argument is a T, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a DOUBLE-FLOAT.
;   The second argument is a T, not a DOUBLE-FLOAT.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF 
; ==>
;   (*
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G397 'CL-PPCRE::MINIMUM)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 4)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MINIMUM
;                                                         '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G397 'CL-PPCRE::LEN)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 0)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::LEN
;                                                         '#<STANDARD-CLASS CL-PPCRE::REPETITION>)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF 
; ==>
;   (EQL
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G397 'CL-PPCRE::MINIMUM)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 4)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MINIMUM
;                                                         '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G397 'CL-PPCRE::MAXIMUM)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 2)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MAXIMUM
;                                                         '#<STANDARD-CLASS CL-PPCRE::REPETITION>)))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF 
; ==>
;   (*
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G397 'CL-PPCRE::MINIMUM)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 4)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MINIMUM
;                                                         '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G397 'CL-PPCRE::LEN)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 0)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::LEN
;                                                         '#<STANDARD-CLASS CL-PPCRE::REPETITION>)))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       etc.

; in: DEFMETHOD REGEX-MIN-LENGTH (SEQ)
;     (LOOP CL-PPCRE::FOR CL-PPCRE::SUB-REGEX CL-PPCRE::IN
;         (CL-PPCRE::ELEMENTS CL-PPCRE::SEQ) CL-PPCRE::FOR CL-PPCRE::LEN =
;         (CL-PPCRE::REGEX-MIN-LENGTH CL-PPCRE::SUB-REGEX) CL-PPCRE::SUM
;         CL-PPCRE::LEN)
; --> BLOCK LET LET LET SB-LOOP::LOOP-BODY TAGBODY SETQ THE 
; ==>
;   (+ #:LOOP-SUM-458 CL-PPCRE::LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; in: DEFMETHOD REGEX-MIN-LENGTH (ALTERNATION)
;     (LOOP CL-PPCRE::FOR CL-PPCRE::SUB-REGEX CL-PPCRE::IN
;         (CL-PPCRE::CHOICES CL-PPCRE::ALTERNATION) CL-PPCRE::FOR CL-PPCRE::LEN =
;         (CL-PPCRE::REGEX-MIN-LENGTH CL-PPCRE::SUB-REGEX) CL-PPCRE::MINIMIZE
;         CL-PPCRE::LEN)
; --> BLOCK LET LET SB-LOOP::WITH-MINIMAX-VALUE LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF OR < IF 
; ==>
;   (< #:LOOP-MAXMIN-TEMP-470 #:LOOP-MAXMIN-469)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       etc.

; in: DEFMETHOD REGEX-MIN-LENGTH (BRANCH)
;     (MIN (CL-PPCRE::REGEX-MIN-LENGTH (CL-PPCRE::THEN-REGEX CL-PPCRE::BRANCH))
;        (CL-PPCRE::REGEX-MIN-LENGTH (CL-PPCRE::ELSE-REGEX CL-PPCRE::BRANCH)))
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

; --> LET LET IF <= OR LET IF OR = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       etc.

; --> LET LET IF <= OR LET IF OR = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; in: DEFMETHOD REGEX-MIN-LENGTH (REPETITION)
;     (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;      (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (ALTERNATION T)
;     (/= CL-PPCRE::CURR-OFFSET CL-PPCRE::OLD-OFFSET)
; --> IF 
; ==>
;   (= CL-PPCRE::CURR-OFFSET CL-PPCRE::OLD-OFFSET)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.

; in: DEFMETHOD COMPUTE-OFFSETS (BRANCH T)
;     (EQL CL-PPCRE::THEN-OFFSET
;        (CL-PPCRE::COMPUTE-OFFSETS (CL-PPCRE::ELSE-REGEX CL-PPCRE::BRANCH)
;         CL-PPCRE::START-POS))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a SINGLE-FLOAT.
;   The second argument is a T, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a DOUBLE-FLOAT.
;   The second argument is a T, not a DOUBLE-FLOAT.
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

; in: DEFMETHOD COMPUTE-OFFSETS (REPETITION T)
;     (DEFMETHOD CL-PPCRE::COMPUTE-OFFSETS
;              ((CL-PPCRE::REPETITION CL-PPCRE::REPETITION) CL-PPCRE::START-POS)
;              (WITH-SLOTS
;               ((CL-PPCRE::LEN CL-PPCRE::LEN)
;                (CL-PPCRE::MINIMUM CL-PPCRE::MINIMUM)
;                (CL-PPCRE::MAXIMUM CL-PPCRE::MAXIMUM))
;               CL-PPCRE::REPETITION
;               (IF (AND CL-PPCRE::LEN (EQ CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM))
;                   (+ CL-PPCRE::START-POS (* CL-PPCRE::MINIMUM CL-PPCRE::LEN))
;                   NIL)))
; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF + 
; ==>
;   (*
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G540 'CL-PPCRE::MINIMUM)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 4)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MINIMUM
;                                                         '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G540 'CL-PPCRE::LEN)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 0)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::LEN
;                                                         '#<STANDARD-CLASS CL-PPCRE::REPETITION>)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF 
; ==>
;   (+ CL-PPCRE::START-POS
;      (*
;       (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G540 'CL-PPCRE::MINIMUM)
;                                     CL-PPCRE::REPETITION
;                                     (SB-PCL::INSTANCE-READ
;                                      (SB-PCL::PV-OFFSET 4) CL-PPCRE::REPETITION
;                                      0 'CL-PPCRE::MINIMUM
;                                      '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
;       (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G540 'CL-PPCRE::LEN)
;                                     CL-PPCRE::REPETITION
;                                     (SB-PCL::INSTANCE-READ
;                                      (SB-PCL::PV-OFFSET 0) CL-PPCRE::REPETITION
;                                      0 'CL-PPCRE::LEN
;                                      '#<STANDARD-CLASS CL-PPCRE::REPETITION>))))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF + 
; ==>
;   (*
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G540 'CL-PPCRE::MINIMUM)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 4)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MINIMUM
;                                                         '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G540 'CL-PPCRE::LEN)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 0)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::LEN
;                                                         '#<STANDARD-CLASS CL-PPCRE::REPETITION>)))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       etc.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF 
; ==>
;   (+ CL-PPCRE::START-POS
;      (*
;       (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G540 'CL-PPCRE::MINIMUM)
;                                     CL-PPCRE::REPETITION
;                                     (SB-PCL::INSTANCE-READ
;                                      (SB-PCL::PV-OFFSET 4) CL-PPCRE::REPETITION
;                                      0 'CL-PPCRE::MINIMUM
;                                      '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
;       (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G540 'CL-PPCRE::LEN)
;                                     CL-PPCRE::REPETITION
;                                     (SB-PCL::INSTANCE-READ
;                                      (SB-PCL::PV-OFFSET 0) CL-PPCRE::REPETITION
;                                      0 'CL-PPCRE::LEN
;                                      '#<STANDARD-CLASS CL-PPCRE::REPETITION>))))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (CHAR-CLASS T)
;     (1+ CL-PPCRE::START-POS)
; ==>
;   (+ CL-PPCRE::START-POS 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (EVERYTHING T)
;     (1+ CL-PPCRE::START-POS)
; ==>
;   (+ CL-PPCRE::START-POS 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (STR T)
;     (+ CL-PPCRE::START-POS (CL-PPCRE::LEN CL-PPCRE::STR))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (FILTER T)
;     (+ CL-PPCRE::START-POS CL-PPCRE::LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; /home/dunham/.fasls/sbcl-1.0.15-gentoo-linux-x86/usr/share/common-lisp/source/cl-ppcre/regex-class.fasl written
; compilation finished in 0:00:01
; compiling file "/usr/share/common-lisp/source/cl-ppcre/convert.lisp" (written 10 NOV 2006 09:18:57 AM):

; file: /usr/share/common-lisp/source/cl-ppcre/convert.lisp
; in: DEFUN ADD-RANGE-TO-HASH
;     (CHAR-UPCASE CL-PPCRE::CHR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (CHAR-DOWNCASE CL-PPCRE::CHR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

; in: DEFUN CONVERT-CHAR-CLASS-TO-HASH
;     (CEILING (EXPT CL-PPCRE:*REGEX-CHAR-CODE-LIMIT* (/ 1 4)))
; --> CEILING BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL TRUNCATE LET VALUES 
; ==>
;   (- SB-C::X SB-C::RES)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR SINGLE-FLOAT RATIONAL), not a FLOAT.

; --> CEILING BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF 
; --> NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR RATIONAL SINGLE-FLOAT), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> CEILING BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF 
; --> AND IF PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR SINGLE-FLOAT RATIONAL), not a FLOAT.

; --> CEILING BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL TRUNCATE LET 
; ==>
;   (SB-KERNEL:%UNARY-TRUNCATE SB-C::X)
; 
; note: forced to do full call
;       unable to do inline float truncate (cost 5) because:
;       The first argument is a (OR SINGLE-FLOAT RATIONAL), not a SINGLE-FLOAT.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       unable to do inline float truncate (cost 5) because:
;       The first argument is a (OR SINGLE-FLOAT RATIONAL), not a SINGLE-FLOAT.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (SIGNED-BYTE 32) &REST
;                                                          T).

; --> CEILING BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL TRUNCATE LET VALUES 
; ==>
;   (- SB-C::X SB-C::RES)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR SINGLE-FLOAT RATIONAL), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES (OR RATIONAL SINGLE-FLOAT)
;                               &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 32) arithmetic (cost 5) because:
;       The first argument is a (OR SINGLE-FLOAT RATIONAL), not a (SIGNED-BYTE
;                                                                  32).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 32).
;       The result is a (VALUES (OR RATIONAL SINGLE-FLOAT)
;                               &OPTIONAL), not a (VALUES (SIGNED-BYTE 32) &REST
;                                                         T).
;       etc.

; --> CEILING BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF 
; --> AND IF PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a (OR SINGLE-FLOAT RATIONAL), not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (OR SINGLE-FLOAT RATIONAL), not a FIXNUM.
;       etc.

; --> CEILING BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF VALUES 
; ==>
;   (+ SB-KERNEL::TRU 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (FLOAT (EXPT CL-PPCRE:*REGEX-CHAR-CODE-LIMIT* (/ 1 4)))
; --> IF 
; ==>
;   (SB-KERNEL:%SINGLE-FLOAT SB-C::N)
; 
; note: forced to do full call
;       unable to do inline float coercion (cost 5) because:
;       The first argument is a RATIONAL, not a (SIGNED-BYTE 32).
;       unable to do inline float coercion (cost 6) because:
;       The first argument is a RATIONAL, not a (UNSIGNED-BYTE 32).

; in: DEFUN MAYBE-SPLIT-REPETITION
;     (- CL-PPCRE::MAXIMUM CL-PPCRE::MINIMUM)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN MAYBE-ACCUMULATE
;     (SETF (SUBSEQ (SLOT-VALUE CL-PPCRE::STARTS-WITH 'CL-PPCRE::STR)
;                 (- (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH)
;                    (CL-PPCRE::LEN CL-PPCRE::STR)))
;           (CL-PPCRE::STR CL-PPCRE::STR)
;         (CL-PPCRE::SKIP CL-PPCRE::STR)
;           T)
; --> PROGN SETF LET* MULTIPLE-VALUE-BIND LET PROGN 
; ==>
;   (REPLACE #:G77 #:G79 :START1 #:G78 :END1 NIL)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES SIMPLE-BASE-STRING
;                                                              &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY CHARACTER
;                                                        (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        SINGLE-FLOAT (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY DOUBLE-FLOAT (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY DOUBLE-FLOAT (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        DOUBLE-FLOAT (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-BIT-VECTOR.
;   The second argument is a SEQUENCE, not a SIMPLE-BIT-VECTOR.
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES SIMPLE-BIT-VECTOR
;                                                              &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 2) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 2) (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 2) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 4) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 4) (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 4) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 7) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 7) (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 7) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 8) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 15) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 15)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 15) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 16) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 16)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 16) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 29) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 29)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 29) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 31) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 31)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 31) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 32) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 32)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 32) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 8) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 8) (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (SIGNED-BYTE 8) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 16) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 16) (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (SIGNED-BYTE 16) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY FIXNUM (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY FIXNUM (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY FIXNUM (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 32) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 32) (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (SIGNED-BYTE 32) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (COMPLEX SINGLE-FLOAT)
;                                            (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (COMPLEX SINGLE-FLOAT)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (COMPLEX SINGLE-FLOAT)
;                                                        (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (COMPLEX DOUBLE-FLOAT)
;                                            (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (COMPLEX DOUBLE-FLOAT)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (COMPLEX DOUBLE-FLOAT)
;                                                        (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-VECTOR.
;   The second argument is a SEQUENCE, not a SIMPLE-VECTOR.
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES SIMPLE-VECTOR
;                                                              &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES SIMPLE-BASE-STRING
;                                                              &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY CHARACTER
;                                                        (*))
;                                                       &REST T).

;     (SETF (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH)
;           (+ (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH)
;              (CL-PPCRE::LEN CL-PPCRE::STR)))
; --> LET* MULTIPLE-VALUE-BIND LET FUNCALL SB-C::%FUNCALL 
; ==>
;   (#<SB-C::GLOBAL-VAR
;      :%SOURCE-NAME (SETF CL-PPCRE::LEN)
;      :TYPE #<SB-KERNEL:FUN-TYPE (FUNCTION # *)>
;      :WHERE-FROM :DECLARED
;      :KIND :GLOBAL-FUNCTION {ABA7669}>
;    #:G75 #:G76)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN CONVERT-AUX
;     (EVERY (LAMBDA (CL-PPCRE::ITEM) (EQ CL-PPCRE::ITEM :NON-WORD-CHAR-CLASS))
;          CL-PPCRE::ITEM-LIST)
; --> LET BLOCK MAP TRULY-THE 
; ==>
;   (SB-KERNEL:%MAP SB-C::RESULT-TYPE-ARG SB-C::FUN #:G232)
; 
; note: unable to open code because: can't determine sequence argument type

;     (MEMBER CL-PPCRE::PARSE-TREE
;           '(:NON-DIGIT-CLASS :NON-WORD-CHAR-CLASS :NON-WHITESPACE-CHAR-CLASS)
;           :TEST #'EQ)
; --> BLOCK LET AND IF AND 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-IMPL::KEY)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR FUNCTION SYMBOL), not a FUNCTION.

; --> BLOCK LET IF 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-IMPL::TEST)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR FUNCTION SYMBOL), not a FUNCTION.

; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-IMPL::TEST-NOT)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR FUNCTION SYMBOL), not a FUNCTION.

;     (LENGTH (CL-PPCRE::CHOICES CL-PPCRE::ALTERNATIONS))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (ZEROP LENGTH)
; --> = IF 
; ==>
;   (= LENGTH 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

;     (EVERY (LAMBDA (CL-PPCRE::ITEM) (EQ CL-PPCRE::ITEM :WORD-CHAR-CLASS))
;          CL-PPCRE::ITEM-LIST)
; --> LET BLOCK MAP TRULY-THE 
; ==>
;   (SB-KERNEL:%MAP SB-C::RESULT-TYPE-ARG SB-C::FUN #:G242)
; 
; note: unable to open code because: can't determine sequence argument type

;     (1- (THE FIXNUM CL-PPCRE::TEST-CANDIDATE))
; ==>
;   (- (THE FIXNUM CL-PPCRE::TEST-CANDIDATE) 1)
; 
; note: doing signed word to integer coercion (cost 20)

;     (1- CL-PPCRE::MAXIMUM)
; ==>
;   (- CL-PPCRE::MAXIMUM 1)
; 
; note: doing signed word to integer coercion (cost 20)

; /home/dunham/.fasls/sbcl-1.0.15-gentoo-linux-x86/usr/share/common-lisp/source/cl-ppcre/convert.fasl written
; compilation finished in 0:00:01
; compiling file "/usr/share/common-lisp/source/cl-ppcre/optimize.lisp" (written 10 NOV 2006 09:18:57 AM):

; file: /usr/share/common-lisp/source/cl-ppcre/optimize.lisp
; in: DEFMETHOD GATHER-STRINGS (SEQ)
;     (INCF CL-PPCRE::COLLECTOR-LENGTH (CL-PPCRE::LEN CL-PPCRE::ELEMENT))
; --> LET* 
; ==>
;   (+ CL-PPCRE::COLLECTOR-LENGTH #:G217)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (SETF (SUBSEQ CL-PPCRE::COLLECTOR CL-PPCRE::OLD-COLLECTOR-LENGTH)
;           (CL-PPCRE::STR CL-PPCRE::ELEMENT)
;         CL-PPCRE::SKIP
;           (CL-PPCRE::SKIP CL-PPCRE::ELEMENT))
; --> PROGN SETF LET* MULTIPLE-VALUE-BIND LET PROGN 
; ==>
;   (REPLACE #:G218 #:G220 :START1 #:G219 :END1 NIL)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-BASE-STRING.
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES SIMPLE-BASE-STRING
;                                                            &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY CHARACTER
;                                                      (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY SINGLE-FLOAT
;                                                      (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY DOUBLE-FLOAT (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY DOUBLE-FLOAT (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY DOUBLE-FLOAT
;                                                      (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-BIT-VECTOR.
;   The second argument is a SEQUENCE, not a SIMPLE-BIT-VECTOR.
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES SIMPLE-BIT-VECTOR
;                                                            &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 2) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 2) (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 2) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 4) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 4) (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 4) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 7) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 7) (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 7) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 8) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 15) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 15)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 15) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 16) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 16)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 16) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 29) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 29)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 29) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 31) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 31)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 31) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 32) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 32)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 32) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (SIGNED-BYTE 8) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 8) (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (SIGNED-BYTE 8) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (SIGNED-BYTE 16) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 16) (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (SIGNED-BYTE 16) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY FIXNUM (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY FIXNUM (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY FIXNUM (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (SIGNED-BYTE 32) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 32) (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (SIGNED-BYTE 32) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (COMPLEX SINGLE-FLOAT)
;                                          (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (COMPLEX SINGLE-FLOAT)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (COMPLEX SINGLE-FLOAT)
;                                                      (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (COMPLEX DOUBLE-FLOAT)
;                                          (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (COMPLEX DOUBLE-FLOAT)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (COMPLEX DOUBLE-FLOAT)
;                                                      (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-VECTOR.
;   The second argument is a SEQUENCE, not a SIMPLE-VECTOR.
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES SIMPLE-VECTOR &REST
;                                                            T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-BASE-STRING.
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES SIMPLE-BASE-STRING
;                                                            &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY CHARACTER
;                                                      (*))
;                                                     &REST T).

;     (INCF CL-PPCRE::COLLECTOR-LENGTH (CL-PPCRE::LEN CL-PPCRE::ELEMENT))
; --> LET* 
; ==>
;   (+ CL-PPCRE::COLLECTOR-LENGTH #:G217)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a NUMBER, not a FIXNUM.
;       unable to do inline (signed-byte 32) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 32).
;       etc.

; in: DEFMETHOD START-ANCHORED-P (REPETITION)
;     (PLUSP (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION))
; ==>
;   (> (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; in: DEFMETHOD START-ANCHORED-P (REGEX)
;     (ZEROP (CL-PPCRE::LEN CL-PPCRE::REGEX))
; ==>
;   (= (CL-PPCRE::LEN CL-PPCRE::REGEX) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; in: DEFMETHOD END-STRING-AUX (SEQ)
;     (ZEROP (CL-PPCRE::LEN CL-PPCRE::ELEMENT-END))
; --> = IF 
; ==>
;   (= (CL-PPCRE::LEN CL-PPCRE::ELEMENT-END) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

;     (CHAR CL-PPCRE::STR CL-PPCRE::I)
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

; in: DEFMETHOD COMPUTE-MIN-REST (ALTERNATION T)
;     (LOOP CL-PPCRE::FOR CL-PPCRE::CHOICE CL-PPCRE::IN
;         (CL-PPCRE::CHOICES CL-PPCRE::ALTERNATION) CL-PPCRE::MINIMIZE
;         (CL-PPCRE::COMPUTE-MIN-REST CL-PPCRE::CHOICE
;          CL-PPCRE::CURRENT-MIN-REST))
; --> BLOCK LET SB-LOOP::WITH-MINIMAX-VALUE LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF OR < IF 
; ==>
;   (< #:LOOP-MAXMIN-TEMP-477 #:LOOP-MAXMIN-476)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       etc.

; in: DEFMETHOD COMPUTE-MIN-REST (BRANCH T)
;     (MIN
;    (CL-PPCRE::COMPUTE-MIN-REST (CL-PPCRE::THEN-REGEX CL-PPCRE::BRANCH)
;     CL-PPCRE::CURRENT-MIN-REST)
;    (CL-PPCRE::COMPUTE-MIN-REST (CL-PPCRE::ELSE-REGEX CL-PPCRE::BRANCH)
;     CL-PPCRE::CURRENT-MIN-REST))
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

; --> LET LET IF <= OR LET IF OR = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       etc.

; --> LET LET IF <= OR LET IF OR = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; in: DEFMETHOD COMPUTE-MIN-REST (STR T)
;     (+ CL-PPCRE::CURRENT-MIN-REST (CL-PPCRE::LEN CL-PPCRE::STR))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; in: DEFMETHOD COMPUTE-MIN-REST (FILTER T)
;     (+ CL-PPCRE::CURRENT-MIN-REST (OR (CL-PPCRE::LEN CL-PPCRE::FILTER) 0))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; in: DEFMETHOD COMPUTE-MIN-REST (REPETITION T)
;     (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;      (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.

;     (+ CL-PPCRE::CURRENT-MIN-REST
;      (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;         (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;      (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       etc.

;     (+ CL-PPCRE::CURRENT-MIN-REST
;      (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;         (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; in: DEFMETHOD COMPUTE-MIN-REST (LOOKBEHIND T)
;     (+ CL-PPCRE::CURRENT-MIN-REST (CL-PPCRE::LEN CL-PPCRE::LOOKBEHIND))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; in: DEFMETHOD COMPUTE-MIN-REST (REGEX T)
;     (1+ CL-PPCRE::CURRENT-MIN-REST)
; ==>
;   (+ CL-PPCRE::CURRENT-MIN-REST 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; /home/dunham/.fasls/sbcl-1.0.15-gentoo-linux-x86/usr/share/common-lisp/source/cl-ppcre/optimize.fasl written
; compilation finished in 0:00:01
; compiling file "/usr/share/common-lisp/source/cl-ppcre/closures.lisp" (written 10 NOV 2006 09:18:57 AM):

; file: /usr/share/common-lisp/source/cl-ppcre/closures.lisp
; in: DEFMETHOD CREATE-MATCHER-AUX (LOOKBEHIND T)
;     (FUNCALL CL-PPCRE::TEST-MATCHER (- CL-PPCRE::START-POS CL-PPCRE::LEN))
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G147)
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (SB-C::%FUNCALL FUNCTION #:G149)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFMETHOD CREATE-MATCHER-AUX (CHAR-CLASS T)
;     (FUNCALL CL-PPCRE::NEXT-FN (1+ CL-PPCRE::START-POS))
; ==>
;   CL-PPCRE::NEXT-FN
; 
; note: deleting unreachable code

;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER
;    (CL-PPCRE::CHAR-CLASS (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS))
;    (IF (CL-PPCRE::INVERTEDP CL-PPCRE::CHAR-CLASS)
;        (LAMBDA (CL-PPCRE::START-POS)
;          (DECLARE (TYPE FIXNUM CL-PPCRE::START-POS))
;          (AND (< CL-PPCRE::START-POS CL-PPCRE::*END-POS*) (NOT #)
;               (FUNCALL CL-PPCRE::NEXT-FN #)))
;        (LAMBDA (CL-PPCRE::START-POS)
;          (DECLARE (TYPE FIXNUM CL-PPCRE::START-POS))
;          (AND (< CL-PPCRE::START-POS CL-PPCRE::*END-POS*)
;               (CL-PPCRE::CHAR-CLASS-TEST) (FUNCALL CL-PPCRE::NEXT-FN #)))))
; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF LAMBDA FUNCTION AND IF AND IF CL-PPCRE::WORD-CHAR-P 
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF LAMBDA FUNCTION AND IF AND IF CL-PPCRE::WORD-CHAR-P 
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF LAMBDA FUNCTION AND IF AND IF NOT IF 
; --> CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF LAMBDA FUNCTION AND IF AND IF NOT IF 
; --> CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = 
; --> IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF LAMBDA FUNCTION AND IF AND IF NOT IF 
; --> CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF LAMBDA FUNCTION AND IF AND IF CL-PPCRE::WORD-CHAR-P 
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; in: DEFMETHOD CREATE-MATCHER-AUX (STR T)
;     (LENGTH CL-PPCRE::END-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (FUNCALL CL-PPCRE::NEXT-FN (+ CL-PPCRE::START-POS CL-PPCRE::LEN))
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G500)
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (SB-C::%FUNCALL FUNCTION #:G501)
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (SB-C::%FUNCALL FUNCTION #:G502)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN WORD-BOUNDARY-P
;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::1-START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::1-START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::1-START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::1-START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::1-START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::1-START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::1-START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::1-START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (CL-PPCRE::WORD-CHAR-P (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS))
; --> BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; in: DEFMETHOD CREATE-MATCHER-AUX (FILTER T)
;     (FUNCALL CL-PPCRE::FN CL-PPCRE::START-POS)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR FUNCTION SYMBOL), not a FUNCTION.

;     (FUNCALL CL-PPCRE::NEXT-FN CL-PPCRE::NEXT-POS)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR FUNCTION SYMBOL), not a FUNCTION.

; /home/dunham/.fasls/sbcl-1.0.15-gentoo-linux-x86/usr/share/common-lisp/source/cl-ppcre/closures.fasl written
; compilation finished in 0:00:01
; compiling file "/usr/share/common-lisp/source/cl-ppcre/repetition-closures.lisp" (written 10 NOV 2006 09:18:57 AM):

; file: /usr/share/common-lisp/source/cl-ppcre/repetition-closures.lisp
; in: DEFMACRO GREEDY-CONSTANT-LENGTH-CLOSURE
;     (INCF CL-PPCRE::CURR-POS CL-PPCRE::LEN)
; --> LET* 
; ==>
;   CL-PPCRE::LEN
; 
; note: deleting unreachable code

; --> LET* + 
; ==>
;   CL-PPCRE::CURR-POS
; 
; note: deleting unreachable code

;     (GO CL-PPCRE::FORWARD-LOOP)
; 
; note: deleting unreachable code

;     (INCF CL-PPCRE::CURR-POS CL-PPCRE::LEN)
; --> LET* 
; ==>
;   CL-PPCRE::LEN
; 
; note: deleting unreachable code

; --> LET* + 
; ==>
;   CL-PPCRE::CURR-POS
; 
; note: deleting unreachable code

;     (GO CL-PPCRE::FORWARD-LOOP)
; 
; note: deleting unreachable code

; in: DEFMETHOD CREATE-GREEDY-CONSTANT-LENGTH-MATCHER (REPETITION T)
;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER
;    (CL-PPCRE::REGEX (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
;    (IF (CL-PPCRE::INVERTEDP CL-PPCRE::REGEX)
;        (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;         (NOT (CL-PPCRE::CHAR-CLASS-TEST)))
;        (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE (CL-PPCRE::CHAR-CLASS-TEST))))
; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET BLOCK TAGBODY WHEN IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET 
; --> ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET BLOCK TAGBODY WHEN IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET 
; --> ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET BLOCK TAGBODY WHEN IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET 
; --> ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET BLOCK TAGBODY WHEN IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET 
; --> ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET BLOCK TAGBODY WHEN IF NOT IF CL-PPCRE::WORD-CHAR-P BLOCK OR 
; --> LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET BLOCK TAGBODY WHEN IF NOT IF CL-PPCRE::WORD-CHAR-P BLOCK OR 
; --> LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET BLOCK TAGBODY WHEN IF NOT IF CL-PPCRE::WORD-CHAR-P BLOCK OR 
; --> LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET BLOCK TAGBODY WHEN IF NOT IF CL-PPCRE::WORD-CHAR-P BLOCK OR 
; --> LET ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET BLOCK TAGBODY WHEN IF NOT IF CL-PPCRE::WORD-CHAR-P BLOCK OR 
; --> LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET BLOCK TAGBODY WHEN IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET 
; --> ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; in: DEFMETHOD CREATE-GREEDY-NO-ZERO-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0)
; --> SB-KERNEL:%ASET SB-KERNEL:HAIRY-DATA-VECTOR-SET MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; --> SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* + AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET SB-KERNEL:HAIRY-DATA-VECTOR-SET MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* - AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET SB-KERNEL:HAIRY-DATA-VECTOR-SET MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; in: DEFMETHOD CREATE-GREEDY-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
;           0
;         (SVREF CL-PPCRE::*LAST-POS-STORES* CL-PPCRE::ZERO-LENGTH-NUM)
;           NIL)
; --> PROGN SETF SB-KERNEL:%ASET SB-KERNEL:HAIRY-DATA-VECTOR-SET 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; --> SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* + AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET SB-KERNEL:HAIRY-DATA-VECTOR-SET MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* - AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET SB-KERNEL:HAIRY-DATA-VECTOR-SET MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; in: DEFMETHOD CREATE-NON-GREEDY-CONSTANT-LENGTH-MATCHER (REPETITION T)
;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER
;    (CL-PPCRE::REGEX (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
;    (IF (CL-PPCRE::INVERTEDP CL-PPCRE::REGEX)
;        (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;         (NOT (CL-PPCRE::CHAR-CLASS-TEST)))
;        (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;         (CL-PPCRE::CHAR-CLASS-TEST))))
; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS IF 
; --> CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS IF 
; --> CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = 
; --> IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS IF 
; --> CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS IF 
; --> CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF OR = 
; --> IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS IF NOT 
; --> IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS IF NOT 
; --> IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF 
; --> OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS IF NOT 
; --> IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS IF NOT 
; --> IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET IF 
; --> OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS IF NOT 
; --> IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA 
; --> FUNCTION LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS IF 
; --> CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; in: DEFMETHOD CREATE-NON-GREEDY-NO-ZERO-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0)
; --> SB-KERNEL:%ASET SB-KERNEL:HAIRY-DATA-VECTOR-SET MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; --> SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* + AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET SB-KERNEL:HAIRY-DATA-VECTOR-SET MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* - AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET SB-KERNEL:HAIRY-DATA-VECTOR-SET MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; in: DEFMETHOD CREATE-NON-GREEDY-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
;           0
;         (SVREF CL-PPCRE::*LAST-POS-STORES* CL-PPCRE::ZERO-LENGTH-NUM)
;           NIL)
; --> PROGN SETF SB-KERNEL:%ASET SB-KERNEL:HAIRY-DATA-VECTOR-SET 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; --> SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* + AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET SB-KERNEL:HAIRY-DATA-VECTOR-SET MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* - AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET SB-KERNEL:HAIRY-DATA-VECTOR-SET MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; in:
;      DEFMETHOD CREATE-CONSTANT-REPETITION-CONSTANT-LENGTH-MATCHER (REPETITION T)
;     (1+ CL-PPCRE::CURR-POS)
; --> + 
; ==>
;   CL-PPCRE::CURR-POS
; 
; note: deleting unreachable code

;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER
;    (CL-PPCRE::REGEX (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
;    (IF (CL-PPCRE::INVERTEDP CL-PPCRE::REGEX)
;        (CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE
;         (AND (NOT #) (1+ CL-PPCRE::CURR-POS)))
;        (CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE
;         (AND (CL-PPCRE::CHAR-CLASS-TEST) (1+ CL-PPCRE::CURR-POS)))))
; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE 
; --> LAMBDA FUNCTION LET AND IF AND IF LOOP BLOCK LET SB-LOOP::LOOP-BODY 
; --> TAGBODY UNLESS IF AND IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP 
; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE 
; --> LAMBDA FUNCTION LET AND IF AND IF LOOP BLOCK LET SB-LOOP::LOOP-BODY 
; --> TAGBODY UNLESS IF AND IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP 
; --> BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE 
; --> LAMBDA FUNCTION LET AND IF AND IF LOOP BLOCK LET SB-LOOP::LOOP-BODY 
; --> TAGBODY UNLESS IF AND IF NOT IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET 
; --> ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE 
; --> LAMBDA FUNCTION LET AND IF AND IF LOOP BLOCK LET SB-LOOP::LOOP-BODY 
; --> TAGBODY UNLESS IF AND IF NOT IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET 
; --> ALPHANUMERICP BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE 
; --> LAMBDA FUNCTION LET AND IF AND IF LOOP BLOCK LET SB-LOOP::LOOP-BODY 
; --> TAGBODY UNLESS IF AND IF NOT IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET 
; --> ALPHANUMERICP BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> LET* MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION COND IF COND IF 
; --> COND IF PROGN IF CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE 
; --> LAMBDA FUNCTION LET AND IF AND IF LOOP BLOCK LET SB-LOOP::LOOP-BODY 
; --> TAGBODY UNLESS IF AND IF CL-PPCRE::WORD-CHAR-P BLOCK OR LET ALPHANUMERICP 
; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; in: DEFMETHOD CREATE-CONSTANT-REPETITION-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0)
; --> SB-KERNEL:%ASET SB-KERNEL:HAIRY-DATA-VECTOR-SET MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; --> SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* + AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET SB-KERNEL:HAIRY-DATA-VECTOR-SET MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* - AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET SB-KERNEL:HAIRY-DATA-VECTOR-SET MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
;           0
;         (AREF CL-PPCRE::*LAST-POS-STORES* CL-PPCRE::ZERO-LENGTH-NUM)
;           NIL)
; --> PROGN SETF SB-KERNEL:%ASET SB-KERNEL:HAIRY-DATA-VECTOR-SET 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (ZEROP (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION))
; ==>
;   (= (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; --> SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* + AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET SB-KERNEL:HAIRY-DATA-VECTOR-SET MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* - AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET SB-KERNEL:HAIRY-DATA-VECTOR-SET MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%DATA-VECTOR-AND-INDEX ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; in: DEFMETHOD CREATE-MATCHER-AUX (REPETITION T)
;     (DEFMETHOD CL-PPCRE::CREATE-MATCHER-AUX
;              ((CL-PPCRE::REPETITION CL-PPCRE::REPETITION) CL-PPCRE::NEXT-FN)
;              (WITH-SLOTS
;               ((CL-PPCRE::MINIMUM CL-PPCRE::MINIMUM)
;                (CL-PPCRE::MAXIMUM CL-PPCRE::MAXIMUM)
;                (CL-PPCRE::LEN CL-PPCRE::LEN)
;                (CL-PPCRE::MIN-LEN CL-PPCRE::MIN-LEN)
;                (CL-PPCRE::GREEDYP CL-PPCRE::GREEDYP)
;                (CL-PPCRE::CONTAINS-REGISTER-P CL-PPCRE::CONTAINS-REGISTER-P))
;               CL-PPCRE::REPETITION
;               (COND
;                ((AND CL-PPCRE::MAXIMUM #)
;                 (ERROR "Got REPETITION with MAXIMUM 0 (should not happen)"))
;                ((AND CL-PPCRE::MAXIMUM #)
;                 (ERROR
;                  "Got REPETITION with MAXIMUM 1 and MINIMUM 1 (should not happen)"))
;                ((AND # CL-PPCRE::LEN #)
;                 (CL-PPCRE::CREATE-CONSTANT-REPETITION-CONSTANT-LENGTH-MATCHER
;                  CL-PPCRE::REPETITION CL-PPCRE::NEXT-FN))
;                ((EQL CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM)
;                 (CL-PPCRE::CREATE-CONSTANT-REPETITION-MATCHER
;                  CL-PPCRE::REPETITION CL-PPCRE::NEXT-FN))
;                ((AND CL-PPCRE::GREEDYP CL-PPCRE::LEN #)
;                 (CL-PPCRE::CREATE-GREEDY-CONSTANT-LENGTH-MATCHER
;                  CL-PPCRE::REPETITION CL-PPCRE::NEXT-FN))
;                ((AND CL-PPCRE::GREEDYP #)
;                 (CL-PPCRE::CREATE-GREEDY-NO-ZERO-MATCHER CL-PPCRE::REPETITION
;                  CL-PPCRE::NEXT-FN))
;                (CL-PPCRE::GREEDYP
;                 (CL-PPCRE::CREATE-GREEDY-MATCHER CL-PPCRE::REPETITION
;                  CL-PPCRE::NEXT-FN))
;                ((AND CL-PPCRE::LEN # #)
;                 (CL-PPCRE::CREATE-NON-GREEDY-CONSTANT-LENGTH-MATCHER
;                  CL-PPCRE::REPETITION CL-PPCRE::NEXT-FN))
;                ((OR # #)
;                 (CL-PPCRE::CREATE-NON-GREEDY-NO-ZERO-MATCHER
;                  CL-PPCRE::REPETITION CL-PPCRE::NEXT-FN))
;                (T
;                 (CL-PPCRE::CREATE-NON-GREEDY-MATCHER CL-PPCRE::REPETITION
;                  CL-PPCRE::NEXT-FN)))))
; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF ZEROP 
; ==>
;   (=
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G3361 'CL-PPCRE::MAXIMUM)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 6)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MAXIMUM
;                                                         '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
;    0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF IF = 
; --> (LAMBDA (#:G3418 #:G3417 #:G3416) (DECLARE (TYPE NUMBER #:G3418 #:G3417 #:G3416)) (IF (= #:G3418 #:G3417) (IF (= #:G3417 #:G3416) T NIL) NIL)) 
; --> IF 
; ==>
;   (= #:G3418 #:G3417)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF IF = 
; --> (LAMBDA (#:G3418 #:G3417 #:G3416) (DECLARE (TYPE NUMBER #:G3418 #:G3417 #:G3416)) (IF (= #:G3418 #:G3417) (IF (= #:G3417 #:G3416) T NIL) NIL)) 
; --> IF IF 
; ==>
;   (= #:G3417 #:G3416)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF IF IF 
; ==>
;   (EQL
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G3361 'CL-PPCRE::MINIMUM)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 10)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MINIMUM
;                                                         '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G3361 'CL-PPCRE::MAXIMUM)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 6)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MAXIMUM
;                                                         '#<STANDARD-CLASS CL-PPCRE::REPETITION>)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a SINGLE-FLOAT.
;   The second argument is a T, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a DOUBLE-FLOAT.
;   The second argument is a T, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a SINGLE-FLOAT.
;   The second argument is a T, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a DOUBLE-FLOAT.
;   The second argument is a T, not a DOUBLE-FLOAT.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF IF IF IF IF IF 
; --> LET PLUSP > IF 
; ==>
;   (>
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G3361 'CL-PPCRE::MIN-LEN)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 8)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MIN-LEN
;                                                         '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
;    0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF IF IF IF IF IF 
; --> IF IF IF PLUSP 
; ==>
;   (>
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G3361 'CL-PPCRE::LEN)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 4)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::LEN
;                                                         '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
;    0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF IF IF IF IF IF 
; --> IF IF LET PLUSP > IF 
; ==>
;   (>
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G3361 'CL-PPCRE::MIN-LEN)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 8)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MIN-LEN
;                                                         '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
;    0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF IF = 
; --> (LAMBDA (#:G3418 #:G3417 #:G3416) (DECLARE (TYPE NUMBER #:G3418 #:G3417 #:G3416)) (IF (= #:G3418 #:G3417) (IF (= #:G3417 #:G3416) T NIL) NIL)) 
; --> IF 
; ==>
;   (= #:G3418 #:G3417)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF IF IF 
; ==>
;   (EQL
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G3361 'CL-PPCRE::MINIMUM)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 10)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MINIMUM
;                                                         '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G3361 'CL-PPCRE::MAXIMUM)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 6)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MAXIMUM
;                                                         '#<STANDARD-CLASS CL-PPCRE::REPETITION>)))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF IF IF IF IF IF 
; --> LET PLUSP > IF 
; ==>
;   (>
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G3361 'CL-PPCRE::MIN-LEN)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 8)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MIN-LEN
;                                                         '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
;    0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF IF IF IF IF IF 
; --> IF IF IF PLUSP 
; ==>
;   (>
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G3361 'CL-PPCRE::LEN)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 4)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::LEN
;                                                         '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
;    0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF IF IF IF IF IF 
; --> IF IF LET PLUSP > IF 
; ==>
;   (>
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G3361 'CL-PPCRE::MIN-LEN)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 8)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MIN-LEN
;                                                         '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
;    0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; /home/dunham/.fasls/sbcl-1.0.15-gentoo-linux-x86/usr/share/common-lisp/source/cl-ppcre/repetition-closures.fasl written
; compilation finished in 0:00:05
; compiling file "/usr/share/common-lisp/source/cl-ppcre/scanner.lisp" (written 10 NOV 2006 09:18:57 AM):

; file: /usr/share/common-lisp/source/cl-ppcre/scanner.lisp
; in: DEFUN CREATE-BMH-MATCHER
;     (LENGTH CL-PPCRE::PATTERN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CHAR-UPCASE (SCHAR CL-PPCRE::PATTERN CL-PPCRE::K))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (CHAR-DOWNCASE (SCHAR CL-PPCRE::PATTERN CL-PPCRE::K))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (SEARCH CL-PPCRE::PATTERN CL-PPCRE::*STRING* :START2 CL-PPCRE::START-POS
;           :END2 CL-PPCRE::*END-POS* :TEST CL-PPCRE::TEST)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; in: DEFMACRO INSERT-ADVANCE-FN
;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G288)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G278)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G268)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G258)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G248)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G238)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G228)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G214)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (<= CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; --> OR LET IF OR = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: unable to open code because: The operands might not be the same type.

; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G288)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G278)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G268)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G258)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G248)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G238)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G214)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G228)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;    (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS) CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND
;    '#<SB-C::GLOBAL-VAR
;       :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;       :KIND :SPECIAL {CF09229}>
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {CF09229}> {D1A5099}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

; in: DEFMACRO INSERT-ADVANCE-FN
;     (FUNCALL CL-PPCRE::END-STRING-TEST (1- CL-PPCRE::END-TEST-POS))
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G610)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;    (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;     (DECLARE (TYPE FUNCTION CL-PPCRE::END-STRING-TEST))
;     (IF (<= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;         (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;     (UNLESS
;         (SETQ CL-PPCRE::*END-STRING-POS*
;                 (FUNCALL CL-PPCRE::END-STRING-TEST CL-PPCRE::POS))
;       (RETURN-FROM CL-PPCRE:SCAN NIL))
;     CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND
;    '#<SB-C::GLOBAL-VAR
;       :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;       :KIND :SPECIAL {CF09229}>
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {CF09229}> {D1A5521}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

; in: DEFMACRO INSERT-ADVANCE-FN
;     (FUNCALL CL-PPCRE::END-STRING-TEST (1- CL-PPCRE::END-TEST-POS))
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G846)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;    (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;     (UNLESS (SETQ CL-PPCRE::POS (CL-PPCRE::NEWLINE-SKIPPER CL-PPCRE::POS))
;       (RETURN-FROM CL-PPCRE:SCAN NIL))
;     CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND
;    '#<SB-C::GLOBAL-VAR
;       :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;       :KIND :SPECIAL {CF09229}>
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {CF09229}> {D1A6511}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

; in: DEFMACRO INSERT-ADVANCE-FN
;     (FUNCALL CL-PPCRE::END-STRING-TEST (1- CL-PPCRE::END-TEST-POS))
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G1082)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;    (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;     (DECLARE (TYPE FUNCTION CL-PPCRE::START-STRING-TEST))
;     (UNLESS
;         (SETQ CL-PPCRE::POS
;                 (FUNCALL CL-PPCRE::START-STRING-TEST CL-PPCRE::POS))
;       (RETURN-FROM CL-PPCRE:SCAN NIL))
;     CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND
;    '#<SB-C::GLOBAL-VAR
;       :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;       :KIND :SPECIAL {CF09229}>
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {CF09229}> {D1A6D19}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

; in: DEFMACRO INSERT-ADVANCE-FN
;     (FUNCALL CL-PPCRE::END-STRING-TEST (1- CL-PPCRE::END-TEST-POS))
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G1318)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;    (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;     (DECLARE (TYPE FUNCTION CL-PPCRE::END-STRING-TEST))
;     (UNLESS (SETQ CL-PPCRE::POS (CL-PPCRE::NEWLINE-SKIPPER CL-PPCRE::POS))
;       (RETURN-FROM CL-PPCRE:SCAN NIL))
;     (IF (<= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;         (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;     (UNLESS
;         (SETQ CL-PPCRE::*END-STRING-POS*
;                 (FUNCALL CL-PPCRE::END-STRING-TEST CL-PPCRE::POS))
;       (RETURN-FROM CL-PPCRE:SCAN NIL))
;     CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND
;    '#<SB-C::GLOBAL-VAR
;       :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;       :KIND :SPECIAL {CF09229}>
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {CF09229}> {D1A7B19}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

; in: DEFMACRO INSERT-ADVANCE-FN
;     (FUNCALL CL-PPCRE::END-STRING-TEST (1- CL-PPCRE::END-TEST-POS))
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G1555)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;    (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;     (DECLARE
;      (TYPE FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;     (UNLESS
;         (SETQ CL-PPCRE::POS
;                 (FUNCALL CL-PPCRE::START-STRING-TEST CL-PPCRE::POS))
;       (RETURN-FROM CL-PPCRE:SCAN NIL))
;     (IF (<= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;         (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;     (UNLESS
;         (SETQ CL-PPCRE::*END-STRING-POS*
;                 (FUNCALL CL-PPCRE::END-STRING-TEST CL-PPCRE::POS))
;       (RETURN-FROM CL-PPCRE:SCAN NIL))
;     CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND
;    '#<SB-C::GLOBAL-VAR
;       :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;       :KIND :SPECIAL {CF09229}>
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {CF09229}> {D1A8379}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

; in: DEFMACRO INSERT-ADVANCE-FN
;     (FUNCALL CL-PPCRE::END-STRING-TEST (1- CL-PPCRE::END-TEST-POS))
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G1793)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;    (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;     (DECLARE (TYPE FIXNUM CL-PPCRE::END-STRING-OFFSET)
;      (TYPE FUNCTION CL-PPCRE::END-STRING-TEST))
;     (LOOP (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;           (LOCALLY
;            (DECLARE #)
;            (WHEN # #)
;            (LET #
;              #)))))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND
;    '#<SB-C::GLOBAL-VAR
;       :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;       :KIND :SPECIAL {CF09229}>
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {CF09229}> {D1A89F9}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

;     (SETQ CL-PPCRE::TRY-POS (1+ CL-PPCRE::*END-STRING-POS*))
; 
; note: doing signed word to integer coercion (cost 20) to TRY-POS
; 
; note: doing signed word to integer coercion (cost 20) to TRY-POS

; in: DEFMACRO INSERT-ADVANCE-FN
;     (FUNCALL CL-PPCRE::END-STRING-TEST (1- CL-PPCRE::END-TEST-POS))
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G2031)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;    (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;     (DECLARE
;      (TYPE FIXNUM CL-PPCRE::END-STRING-OFFSET CL-PPCRE::STARTS-WITH-LEN)
;      (TYPE FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;     (LOOP (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;           (LOCALLY
;            (DECLARE #)
;            (WHEN # #)
;            (LET #
;              #)))))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND
;    '#<SB-C::GLOBAL-VAR
;       :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;       :KIND :SPECIAL {CF09229}>
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {CF09229}> {D1A92D1}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

;     (FUNCALL CL-PPCRE::END-STRING-TEST CL-PPCRE::TRY-POS)
; ==>
;   CL-PPCRE::TRY-POS
; 
; note: doing signed word to integer coercion (cost 20) from TRY-POS
; 
; note: doing signed word to integer coercion (cost 20) from TRY-POS

; in: DEFMACRO INSERT-ADVANCE-FN
;     (FUNCALL CL-PPCRE::END-STRING-TEST (1- CL-PPCRE::END-TEST-POS))
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G2269)
; 
; note: doing signed word to integer coercion (cost 20)

; /home/dunham/.fasls/sbcl-1.0.15-gentoo-linux-x86/usr/share/common-lisp/source/cl-ppcre/scanner.fasl written
; compilation finished in 0:00:03
; compiling file "/usr/share/common-lisp/source/cl-ppcre/api.lisp" (written 10 NOV 2006 09:18:57 AM):

; file: /usr/share/common-lisp/source/cl-ppcre/api.lisp
; in: DEFMETHOD CREATE-SCANNER (STRING)
;     (COPY-SEQ CL-PPCRE::QUOTED-REGEX-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

; in: DEFMETHOD CREATE-SCANNER (T)
;     (PLUSP (CL-PPCRE::LEN CL-PPCRE::END-STRING))
; ==>
;   (> (CL-PPCRE::LEN CL-PPCRE::END-STRING) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (= 1 (CL-PPCRE::LEN CL-PPCRE::END-STRING))
; --> = IF 
; ==>
;   (= SB-C::Y SB-C::X)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

;     (PLUSP (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH))
; ==>
;   (> (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (= 1 (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH))
; --> = IF 
; ==>
;   (= SB-C::Y SB-C::X)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

;     (PLUSP (CL-PPCRE::LEN CL-PPCRE::END-STRING))
; ==>
;   (> (CL-PPCRE::LEN CL-PPCRE::END-STRING) 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (PLUSP (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH))
; ==>
;   (> (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH) 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; in: DEFMETHOD SCAN (STRING T)
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (FUNCALL (CL-PPCRE:CREATE-SCANNER CL-PPCRE::REGEX-STRING)
;            (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING CL-PPCRE::TARGET-STRING)
;            CL-PPCRE::START CL-PPCRE::END)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR FUNCTION SYMBOL), not a FUNCTION.

; in: DEFMETHOD SCAN #'T
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; in: DEFMETHOD SCAN (T T)
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (FUNCALL (CL-PPCRE:CREATE-SCANNER CL-PPCRE::PARSE-TREE)
;            (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING CL-PPCRE::TARGET-STRING)
;            CL-PPCRE::START CL-PPCRE::END)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR FUNCTION SYMBOL), not a FUNCTION.

; in: DEFUN SCAN-TO-STRINGS
;     (MAP 'VECTOR
;        (LAMBDA (CL-PPCRE::REG-START CL-PPCRE::REG-END)
;          (IF CL-PPCRE::REG-START
;              (FUNCALL CL-PPCRE::SUBSTR-FN CL-PPCRE::TARGET-STRING
;                       CL-PPCRE::REG-START CL-PPCRE::REG-END)
;              NIL))
;        CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS)
; --> TRULY-THE 
; ==>
;   (SB-KERNEL:%MAP SB-C::RESULT-TYPE-ARG SB-C::FUN #:G244 #:G245)
; 
; note: unable to open code because: can't determine sequence argument type

;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; in: LAMBDA NIL
;     (LOOP CL-PPCRE::FOR #'CL-PPCRE::VAR CL-PPCRE::IN
;         (CL-PPCRE::NORMALIZE-VAR-LIST CL-PPCRE::VAR-LIST) CL-PPCRE::FOR
;         CL-PPCRE::COUNTER CL-PPCRE::FROM 0 WHEN CL-PPCRE::VAR CL-PPCRE::COLLECT
;         ...)
; --> BLOCK LET LET SB-LOOP::WITH-LOOP-LIST-COLLECTION-HEAD LET* 
; --> SB-LOOP::LOOP-BODY LET TAGBODY IF SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 1+ 
; ==>
;   (+ CL-PPCRE::COUNTER 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; in: DEFMACRO REGISTER-GROUPS-BIND
;     (LOOP CL-PPCRE::FOR #'CL-PPCRE::VAR CL-PPCRE::IN
;         (CL-PPCRE::NORMALIZE-VAR-LIST CL-PPCRE::VAR-LIST) CL-PPCRE::FOR
;         CL-PPCRE::COUNTER CL-PPCRE::FROM 0 WHEN CL-PPCRE::VAR CL-PPCRE::COLLECT
;         ...)
; --> BLOCK LET LET SB-LOOP::WITH-LOOP-LIST-COLLECTION-HEAD LET* 
; --> SB-LOOP::LOOP-BODY LET TAGBODY IF SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 1+ 
; ==>
;   (+ CL-PPCRE::COUNTER 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.
; in: LAMBDA NIL
;     (LOOP CL-PPCRE::FOR #'CL-PPCRE::VAR CL-PPCRE::IN
;         (CL-PPCRE::NORMALIZE-VAR-LIST CL-PPCRE::VAR-LIST) CL-PPCRE::FOR
;         CL-PPCRE::COUNTER CL-PPCRE::FROM 0 WHEN CL-PPCRE::VAR CL-PPCRE::COLLECT
;         ...)
; --> BLOCK LET LET SB-LOOP::WITH-LOOP-LIST-COLLECTION-HEAD LET* 
; --> SB-LOOP::LOOP-BODY LET TAGBODY IF SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 1+ 
; ==>
;   (+ CL-PPCRE::COUNTER 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; in: DEFMACRO DO-REGISTER-GROUPS
;     (LOOP CL-PPCRE::FOR #'CL-PPCRE::VAR CL-PPCRE::IN
;         (CL-PPCRE::NORMALIZE-VAR-LIST CL-PPCRE::VAR-LIST) CL-PPCRE::FOR
;         CL-PPCRE::COUNTER CL-PPCRE::FROM 0 WHEN CL-PPCRE::VAR CL-PPCRE::COLLECT
;         ...)
; --> BLOCK LET LET SB-LOOP::WITH-LOOP-LIST-COLLECTION-HEAD LET* 
; --> SB-LOOP::LOOP-BODY LET TAGBODY IF SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 1+ 
; ==>
;   (+ CL-PPCRE::COUNTER 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; in: DEFUN ALL-MATCHES
;     (CL-PPCRE:DO-MATCHES
;    (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END CL-PPCRE::REGEX
;     CL-PPCRE::TARGET-STRING (NREVERSE CL-PPCRE::RESULT-LIST) :START
;     CL-PPCRE::START :END CL-PPCRE::END)
;    (PUSH CL-PPCRE::MATCH-START CL-PPCRE::RESULT-LIST)
;    (PUSH CL-PPCRE::MATCH-END CL-PPCRE::RESULT-LIST))
; --> CL-PPCRE:DO-SCANS LET BLOCK LET* BLOCK TAGBODY MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==>
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; --> CL-PPCRE:DO-SCANS LET BLOCK LET* BLOCK TAGBODY MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE:DO-MATCHES
;    (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END CL-PPCRE::REGEX
;     CL-PPCRE::TARGET-STRING (NREVERSE CL-PPCRE::RESULT-LIST) :START
;     CL-PPCRE::START :END CL-PPCRE::END)
;    (PUSH CL-PPCRE::MATCH-START CL-PPCRE::RESULT-LIST)
;    (PUSH CL-PPCRE::MATCH-END CL-PPCRE::RESULT-LIST))
; --> CL-PPCRE:DO-SCANS LET BLOCK LET* OR LET IF OR 
; ==>
;   (LENGTH #:TARGET-STRING364)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> CL-PPCRE:DO-SCANS LET BLOCK LET* BLOCK TAGBODY MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==>
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.

; --> CL-PPCRE:DO-SCANS LET BLOCK LET* BLOCK TAGBODY MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; in: DEFUN ALL-MATCHES-AS-STRINGS
;     (CL-PPCRE:DO-MATCHES-AS-STRINGS
;    (CL-PPCRE::MATCH CL-PPCRE::REGEX CL-PPCRE::TARGET-STRING
;     (NREVERSE CL-PPCRE::RESULT-LIST) :START CL-PPCRE::START :END CL-PPCRE::END
;     :SHAREDP CL-PPCRE::SHAREDP)
;    (PUSH CL-PPCRE::MATCH CL-PPCRE::RESULT-LIST))
; --> LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* BLOCK 
; --> TAGBODY MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==>
;   (= #:MATCH-START415 #:MATCH-END416)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* BLOCK 
; --> TAGBODY MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ #:MATCH-END416 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE:DO-MATCHES-AS-STRINGS
;    (CL-PPCRE::MATCH CL-PPCRE::REGEX CL-PPCRE::TARGET-STRING
;     (NREVERSE CL-PPCRE::RESULT-LIST) :START CL-PPCRE::START :END CL-PPCRE::END
;     :SHAREDP CL-PPCRE::SHAREDP)
;    (PUSH CL-PPCRE::MATCH CL-PPCRE::RESULT-LIST))
; --> LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* OR LET IF OR 
; ==>
;   (LENGTH #:TARGET-STRING420)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* BLOCK 
; --> TAGBODY MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==>
;   (= #:MATCH-START415 #:MATCH-END416)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.

; --> LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* BLOCK 
; --> TAGBODY MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ #:MATCH-END416 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; in: DEFUN SPLIT
;     (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

;     (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

;     (LOOP CL-PPCRE::FOR CL-PPCRE::REG-START CL-PPCRE::ACROSS CL-PPCRE::REG-STARTS
;         CL-PPCRE::FOR CL-PPCRE::REG-END CL-PPCRE::ACROSS CL-PPCRE::REG-ENDS IF
;         CL-PPCRE::REG-START DO ...)
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY SETQ THE 
; ==>
;   (LENGTH #:LOOP-ACROSS-VECTOR-485)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR NULL VECTOR), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR NULL VECTOR), not a VECTOR.

; ==>
;   (LENGTH #:LOOP-ACROSS-VECTOR-488)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR NULL VECTOR), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR NULL VECTOR), not a VECTOR.

; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> THE AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

;     (CL-PPCRE:DO-SCANS
;    (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END CL-PPCRE::REG-STARTS
;     CL-PPCRE::REG-ENDS CL-PPCRE::REGEX CL-PPCRE::TARGET-STRING NIL :START
;     CL-PPCRE::START :END CL-PPCRE::END)
;    (UNLESS
;        (AND (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
;             (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST)))
;      (WHEN (AND CL-PPCRE::LIMIT (>= # CL-PPCRE::LIMIT)) (RETURN))
;      (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;      (WHEN CL-PPCRE::WITH-REGISTERS-P
;        (LOOP CL-PPCRE::FOR CL-PPCRE::REG-START CL-PPCRE::ACROSS
;              CL-PPCRE::REG-STARTS CL-PPCRE::FOR CL-PPCRE::REG-END
;              CL-PPCRE::ACROSS CL-PPCRE::REG-ENDS IF CL-PPCRE::REG-START DO
;              ...))
;      (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)))
; --> LET BLOCK LET* BLOCK TAGBODY MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> FUNCTION SETQ THE IF 
; ==>
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET BLOCK LET* BLOCK TAGBODY MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (> CL-PPCRE::THIS-END CL-PPCRE::THIS-START)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE:DO-SCANS
;    (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END CL-PPCRE::REG-STARTS
;     CL-PPCRE::REG-ENDS CL-PPCRE::REGEX CL-PPCRE::TARGET-STRING NIL :START
;     CL-PPCRE::START :END CL-PPCRE::END)
;    (UNLESS
;        (AND (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
;             (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST)))
;      (WHEN (AND CL-PPCRE::LIMIT (>= # CL-PPCRE::LIMIT)) (RETURN))
;      (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;      (WHEN CL-PPCRE::WITH-REGISTERS-P
;        (LOOP CL-PPCRE::FOR CL-PPCRE::REG-START CL-PPCRE::ACROSS
;              CL-PPCRE::REG-STARTS CL-PPCRE::FOR CL-PPCRE::REG-END
;              CL-PPCRE::ACROSS CL-PPCRE::REG-ENDS IF CL-PPCRE::REG-START DO
;              ...))
;      (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)))
; --> LET BLOCK LET* OR LET IF OR 
; ==>
;   (LENGTH #:TARGET-STRING472)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (>= (INCF CL-PPCRE::COUNTER) CL-PPCRE::LIMIT)
; --> OR LET IF OR = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.

;     (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST))
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.

;     (INCF CL-PPCRE::COUNTER)
; --> LET* 
; ==>
;   (+ CL-PPCRE::COUNTER #:G482)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

;     (>= (INCF CL-PPCRE::COUNTER) CL-PPCRE::LIMIT)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (CL-PPCRE:DO-SCANS
;    (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END CL-PPCRE::REG-STARTS
;     CL-PPCRE::REG-ENDS CL-PPCRE::REGEX CL-PPCRE::TARGET-STRING NIL :START
;     CL-PPCRE::START :END CL-PPCRE::END)
;    (UNLESS
;        (AND (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
;             (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST)))
;      (WHEN (AND CL-PPCRE::LIMIT (>= # CL-PPCRE::LIMIT)) (RETURN))
;      (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;      (WHEN CL-PPCRE::WITH-REGISTERS-P
;        (LOOP CL-PPCRE::FOR CL-PPCRE::REG-START CL-PPCRE::ACROSS
;              CL-PPCRE::REG-STARTS CL-PPCRE::FOR CL-PPCRE::REG-END
;              CL-PPCRE::ACROSS CL-PPCRE::REG-ENDS IF CL-PPCRE::REG-START DO
;              ...))
;      (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)))
; --> LET BLOCK LET* BLOCK TAGBODY MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> FUNCTION SETQ THE IF 
; ==>
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.

; --> LET BLOCK LET* BLOCK TAGBODY MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (> CL-PPCRE::THIS-END CL-PPCRE::THIS-START)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       etc.

; in: DEFUN STRING-CASE-MODIFIER
;     (CHAR CL-PPCRE::STR (1- CL-PPCRE::FROM))
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

;     (ALPHANUMERICP (CHAR CL-PPCRE::STR (1- CL-PPCRE::FROM)))
; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CHAR CL-PPCRE::STR CL-PPCRE::FROM)
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

;     (ALPHANUMERICP (CHAR CL-PPCRE::STR CL-PPCRE::FROM))
; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CHAR CL-PPCRE::STR CL-PPCRE::TO)
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

;     (CHAR CL-PPCRE::STR (1- CL-PPCRE::TO))
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

;     (ALPHANUMERICP (CHAR CL-PPCRE::STR (1- CL-PPCRE::TO)))
; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CHAR CL-PPCRE::STR CL-PPCRE::INDEX)
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

;     (ALPHANUMERICP (CHAR CL-PPCRE::STR CL-PPCRE::TO))
; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK LET OR LET IF OR = IF 
; ==>
;   (= GC 12)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (UPPER-CASE-P CL-PPCRE::CHR)
; --> BLOCK = IF 
; ==>
;   (= (SB-IMPL::UCD-VALUE-0 CHAR) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

;     (BOTH-CASE-P CL-PPCRE::CHR)
; --> BLOCK < IF 
; ==>
;   (< (SB-IMPL::UCD-VALUE-0 CHAR) 2)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (ALPHANUMERICP (CHAR CL-PPCRE::STR (1- CL-PPCRE::FROM)))
; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (ALPHANUMERICP (CHAR CL-PPCRE::STR CL-PPCRE::FROM))
; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (ALPHANUMERICP (CHAR CL-PPCRE::STR CL-PPCRE::TO))
; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (ALPHANUMERICP (CHAR CL-PPCRE::STR (1- CL-PPCRE::TO)))
; --> BLOCK LET OR LET < IF 
; ==>
;   (< GC 5)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (BOTH-CASE-P CL-PPCRE::CHR)
; --> BLOCK < IF 
; ==>
;   (< (SB-IMPL::UCD-VALUE-0 CHAR) 2)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; in: DEFMETHOD BUILD-REPLACEMENT-TEMPLATE (STRING)
;     (POSITION-IF #'DIGIT-CHAR-P CL-PPCRE::REPLACEMENT-STRING :START
;                CL-PPCRE::MATCH-START :END CL-PPCRE::MATCH-END)
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%FIND-POSITION-IF
;    (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-C:PREDICATE) SEQUENCE SB-C::FROM-END
;    SB-C::START SB-C::END (SB-KERNEL:EFFECTIVE-FIND-POSITION-KEY SB-C::KEY))
; 
; note: unable to
;   expand inline
; because:
;   upgraded array element type not known at compile time

;     (CHAR CL-PPCRE::REPLACEMENT-STRING (1+ CL-PPCRE::MATCH-START))
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

;     (< CL-PPCRE::FROM CL-PPCRE::MATCH-START)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (1-
;    (PARSE-INTEGER CL-PPCRE::REPLACEMENT-STRING :START CL-PPCRE::PARSE-START
;                   :JUNK-ALLOWED T))
; ==>
;   (-
;    (PARSE-INTEGER CL-PPCRE::REPLACEMENT-STRING :START CL-PPCRE::PARSE-START
;                   :JUNK-ALLOWED T)
;    1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (< CL-PPCRE::TOKEN 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

; in: DEFUN BUILD-REPLACEMENT
;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::REG-START
;                      CL-PPCRE::REG-END)
; --> BLOCK MAKE-ARRAY 
; ==>
;   (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::MATCH-START
;                      CL-PPCRE::MATCH-END)
; --> BLOCK MAKE-ARRAY 
; ==>
;   (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (ARRAY-DIMENSION CL-PPCRE::REG-STARTS 0)
; 
; note: unable to
;   optimize
; because:
;   The array dimensions are unknown; must call ARRAY-DIMENSION at runtime.

;     (MAP 'LIST
;        (LAMBDA (CL-PPCRE::REG-START CL-PPCRE::REG-END)
;          (AND CL-PPCRE::REG-START
;               (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::REG-START
;                                  CL-PPCRE::REG-END)))
;        CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS)
; --> TRULY-THE 
; ==>
;   (SB-KERNEL:%MAP SB-C::RESULT-TYPE-ARG SB-C::FUN #:G708 #:G709)
; 
; note: unable to open code because: can't determine sequence argument type

; ==>
;   (SB-KERNEL:%MAP SB-C::RESULT-TYPE-ARG SB-C::FUN #:G717 #:G718)
; 
; note: unable to open code because: can't determine sequence argument type

;     (>= CL-PPCRE::TOKEN CL-PPCRE::REG-BOUND)
; --> IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.

;     (1+ CL-PPCRE::TOKEN)
; ==>
;   (+ CL-PPCRE::TOKEN 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::MATCH-START
;                      CL-PPCRE::MATCH-END)
; --> BLOCK MAKE-ARRAY 
; ==>
;   (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::REG-START
;                      CL-PPCRE::REG-END)
; --> BLOCK MAKE-ARRAY 
; ==>
;   (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; in: DEFUN REPLACE-AUX
;     (FUNCALL
;    (CL-PPCRE::STRING-CASE-MODIFIER CL-PPCRE::TARGET-STRING CL-PPCRE::FROM
;     CL-PPCRE::TO CL-PPCRE::START CL-PPCRE::END)
;    CL-PPCRE::CURR-REPLACEMENT)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; due to type uncertainty:
;   The first argument is a (OR NULL FUNCTION), not a FUNCTION.

; in: DEFUN REGEX-REPLACE
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (SUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::START CL-PPCRE::END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

; in: DEFUN REGEX-REPLACE-ALL
;     (CL-PPCRE:DO-SCANS
;    (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END CL-PPCRE::REG-STARTS
;     CL-PPCRE::REG-ENDS CL-PPCRE::REGEX CL-PPCRE::TARGET-STRING NIL :START
;     CL-PPCRE::START :END CL-PPCRE::END)
;    (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;    (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)
;    (PUSH CL-PPCRE::REG-STARTS CL-PPCRE::REG-LIST)
;    (PUSH CL-PPCRE::REG-ENDS CL-PPCRE::REG-LIST))
; --> LET BLOCK LET* BLOCK TAGBODY MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> FUNCTION SETQ THE IF 
; ==>
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET BLOCK LET* BLOCK TAGBODY MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (SUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::START CL-PPCRE::END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE:DO-SCANS
;    (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END CL-PPCRE::REG-STARTS
;     CL-PPCRE::REG-ENDS CL-PPCRE::REGEX CL-PPCRE::TARGET-STRING NIL :START
;     CL-PPCRE::START :END CL-PPCRE::END)
;    (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;    (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)
;    (PUSH CL-PPCRE::REG-STARTS CL-PPCRE::REG-LIST)
;    (PUSH CL-PPCRE::REG-ENDS CL-PPCRE::REG-LIST))
; --> LET BLOCK LET* OR LET IF OR 
; ==>
;   (LENGTH #:TARGET-STRING803)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> LET BLOCK LET* BLOCK TAGBODY MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> FUNCTION SETQ THE IF 
; ==>
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.

; --> LET BLOCK LET* BLOCK TAGBODY MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.
; in:
;      LAMBDA (#:WHOLE[REGEX-APROPOS-LIST]892 #:ENVIRONMENT[REGEX-APROPOS-LIST]893)
;     (MEMBER SB-IMPL::THIS-KIND '(:INTERNAL :EXTERNAL :INHERITED))
; --> BLOCK LET DO BLOCK LET TAGBODY TAGBODY LET WHEN IF 
; --> SB-IMPL::SATISFIES-THE-TEST LET COND IF COND IF COND PROGN FUNCALL 
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G27 #:G28)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a SINGLE-FLOAT.
;   The second argument is a T, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a DOUBLE-FLOAT.
;   The second argument is a T, not a DOUBLE-FLOAT.
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

; in: DEFUN PRINT-SYMBOL-INFO
;     (FORMAT T "~&~S ~<~;~^~A~@{~:@_~A~}~;~:>" SYMBOL CL-PPCRE::OUTPUT-LIST)
; --> FORMAT FORMATTER FUNCTION BLOCK LET PPRINT-LOGICAL-BLOCK 
; --> SB-PRETTY::WITH-PRETTY-STREAM FLET BLOCK LET IF 
; --> SB-KERNEL:WITH-CIRCULARITY-DETECTION LABELS BLOCK SB-KERNEL:DESCEND-INTO 
; --> FLET COND IF COND PROGN LET 1+ 
; ==>
;   (+ SB-KERNEL:*CURRENT-LEVEL-IN-PRINT* 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

; --> FORMAT FORMATTER FUNCTION BLOCK LET PPRINT-LOGICAL-BLOCK 
; --> SB-PRETTY::WITH-PRETTY-STREAM FLET BLOCK LET IF 
; --> SB-KERNEL:WITH-CIRCULARITY-DETECTION LABELS BLOCK SB-KERNEL:DESCEND-INTO 
; --> FLET COND IF AND IF AND IF AND >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> FORMAT FORMATTER FUNCTION BLOCK LET PPRINT-LOGICAL-BLOCK 
; --> SB-PRETTY::WITH-PRETTY-STREAM FLET BLOCK LET IF 
; --> SB-KERNEL:WITH-CIRCULARITY-DETECTION LABELS BLOCK SB-KERNEL:DESCEND-INTO 
; --> FLET COND IF AND IF AND IF AND >= OR LET IF OR = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> FORMAT FORMATTER FUNCTION BLOCK LET PPRINT-LOGICAL-BLOCK 
; --> SB-PRETTY::WITH-PRETTY-STREAM 
; ==>
;   (FLET ((#:WITH-PRETTY-STREAM-1314 (STREAM)
;            (LET (#)
;              (IF # # #))))
;     (LET ((STREAM
;            (LET #
;              #)))
;       (IF (SB-PRETTY:PRETTY-STREAM-P STREAM) (#:WITH-PRETTY-STREAM-1314 STREAM)
;           (CATCH 'SB-PRETTY::LINE-LIMIT-ABBREVIATION-HAPPENED
;             (LET #
;               #
;               #))))
;     NIL)
; 
; note: Return type not fixed values, so can't use known return convention:
;   *

; --> FORMAT FORMATTER FUNCTION BLOCK LET PPRINT-LOGICAL-BLOCK 
; --> SB-PRETTY::WITH-PRETTY-STREAM FLET BLOCK LET IF 
; --> SB-KERNEL:WITH-CIRCULARITY-DETECTION LABELS BLOCK SB-KERNEL:DESCEND-INTO 
; --> FLET BLOCK LET BLOCK FLET BLOCK WHEN IF AND IF AND 
; ==>
;   (EQL #:PPRINT-LOGICAL-BLOCK-LENGTH-1312 *PRINT-LENGTH*)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a (OR UNSIGNED-BYTE NULL), not a FIXNUM.

; --> FORMAT FORMATTER FUNCTION BLOCK LET PPRINT-LOGICAL-BLOCK 
; --> SB-PRETTY::WITH-PRETTY-STREAM FLET BLOCK LET IF 
; --> SB-KERNEL:WITH-CIRCULARITY-DETECTION LABELS BLOCK SB-KERNEL:DESCEND-INTO 
; --> FLET COND IF AND IF AND IF AND >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       The second argument is a UNSIGNED-BYTE, not a FIXNUM.

; --> FORMAT FORMATTER FUNCTION BLOCK LET PPRINT-LOGICAL-BLOCK 
; --> SB-PRETTY::WITH-PRETTY-STREAM FLET BLOCK LET IF 
; --> SB-KERNEL:WITH-CIRCULARITY-DETECTION LABELS BLOCK SB-KERNEL:DESCEND-INTO 
; --> FLET COND IF COND PROGN LET 1+ 
; ==>
;   (+ SB-KERNEL:*CURRENT-LEVEL-IN-PRINT* 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.
; in:
;      LAMBDA (#:WHOLE[REGEX-APROPOS]1384 #:ENVIRONMENT[REGEX-APROPOS]1385)
;     (MEMBER SB-IMPL::THIS-KIND '(:INTERNAL :EXTERNAL :INHERITED))
; --> BLOCK LET DO BLOCK LET TAGBODY TAGBODY LET WHEN IF 
; --> SB-IMPL::SATISFIES-THE-TEST LET COND IF COND IF COND PROGN FUNCALL 
; ==>
;   (SB-C::%FUNCALL FUNCTION #:G27 #:G28)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a SINGLE-FLOAT.
;   The second argument is a T, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a DOUBLE-FLOAT.
;   The second argument is a T, not a DOUBLE-FLOAT.
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

; in: DEFUN QUOTE-META-CHARS
;     (LENGTH STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; in: DEFUN CLEAN-COMMENTS
;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::MATCH-START
;                      CL-PPCRE::MATCH-END)
; --> BLOCK MAKE-ARRAY 
; ==>
;   (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; /home/dunham/.fasls/sbcl-1.0.15-gentoo-linux-x86/usr/share/common-lisp/source/cl-ppcre/api.fasl written
; compilation finished in 0:00:03
; compiling (DEFPARAMETER *REGEX-LIST* ...)
; compiling (DEFPARAMETER *ALTERNATIVES* ...)
; compiling (DEFUN GET-INPUT-CHARS ...)
; compiling (DEFUN MAIN ...)
; file: /home/dunham/gp4/shootout/bench/regexdna/tmp/regexdna.sbcl
; in: DEFUN MAIN
;     (LENGTH SEQUENCE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (LENGTH (CL-PPCRE:ALL-MATCHES REGEX SEQUENCE))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; compilation unit finished
;   printed 1015 notes


; /home/dunham/gp4/shootout/bench/regexdna/tmp/regexdna.fasl written
; compilation finished in 0:00:21
[undoing binding stack and other enclosing state... done]
[saving current Lisp image into /home/dunham/gp4/shootout/bench/regexdna/tmp/sbcl.core:
writing 2976 bytes from the read-only space at 0x01000000
writing 2160 bytes from the static space at 0x01100000
writing 28999680 bytes from the dynamic space at 0x09000000
done]
### START regexdna.sbcl_run
(proclaim '(optimize (speed 3) (safety 0) (debug 0) (compilation-speed 0) (space 0)))
(main) (quit)
### END regexdna.sbcl_run


=================================================================
COMMAND LINE (%A is single numeric argument):

 /usr/bin/sbcl --noinform --core sbcl.core --userinit /dev/null --sysinit /etc/sbclrc --load regexdna.sbcl_run %A
STYLE-WARNING: redefining LISP-VERSION-STRING in DEFUN
STYLE-WARNING: redefining IMPLEMENTATION-SPECIFIC-DIRECTORY-NAME in DEFUN
STYLE-WARNING: redefining PATHNAME-PREFIX-P in DEFUN
STYLE-WARNING: redefining OUTPUT-FILES-FOR-SYSTEM-AND-OPERATION in DEFGENERIC
STYLE-WARNING:
   redefining OUTPUT-FILES-FOR-SYSTEM-AND-OPERATION (#<STANDARD-CLASS SYSTEM>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>) in DEFMETHOD
STYLE-WARNING: redefining OUTPUT-FILES-USING-MAPPINGS in DEFGENERIC
STYLE-WARNING:
   redefining OUTPUT-FILES-USING-MAPPINGS (#<BUILT-IN-CLASS T>
                                           #<BUILT-IN-CLASS T>
                                           #<BUILT-IN-CLASS T>) in DEFMETHOD
STYLE-WARNING:
   redefining OUTPUT-FILES :AROUND (#<STANDARD-CLASS COMPILE-OP>
                                    #<STANDARD-CLASS SOURCE-FILE>) in DEFMETHOD
STYLE-WARNING: redefining LISP-VERSION-STRING in DEFUN
STYLE-WARNING: redefining IMPLEMENTATION-SPECIFIC-DIRECTORY-NAME in DEFUN
STYLE-WARNING: redefining PATHNAME-PREFIX-P in DEFUN
STYLE-WARNING: redefining OUTPUT-FILES-FOR-SYSTEM-AND-OPERATION in DEFGENERIC
STYLE-WARNING:
   redefining OUTPUT-FILES-FOR-SYSTEM-AND-OPERATION (#<STANDARD-CLASS SYSTEM>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>) in DEFMETHOD
STYLE-WARNING: redefining OUTPUT-FILES-USING-MAPPINGS in DEFGENERIC
STYLE-WARNING:
   redefining OUTPUT-FILES-USING-MAPPINGS (#<BUILT-IN-CLASS T>
                                           #<BUILT-IN-CLASS T>
                                           #<BUILT-IN-CLASS T>) in DEFMETHOD
STYLE-WARNING:
   redefining OUTPUT-FILES :AROUND (#<STANDARD-CLASS COMPILE-OP>
                                    #<STANDARD-CLASS SOURCE-FILE>) in DEFMETHOD
STYLE-WARNING: redefining LISP-VERSION-STRING in DEFUN
STYLE-WARNING: redefining IMPLEMENTATION-SPECIFIC-DIRECTORY-NAME in DEFUN
STYLE-WARNING: redefining PATHNAME-PREFIX-P in DEFUN
STYLE-WARNING: redefining OUTPUT-FILES-FOR-SYSTEM-AND-OPERATION in DEFGENERIC
STYLE-WARNING:
   redefining OUTPUT-FILES-FOR-SYSTEM-AND-OPERATION (#<STANDARD-CLASS SYSTEM>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>) in DEFMETHOD
STYLE-WARNING: redefining OUTPUT-FILES-USING-MAPPINGS in DEFGENERIC
STYLE-WARNING:
   redefining OUTPUT-FILES-USING-MAPPINGS (#<BUILT-IN-CLASS T>
                                           #<BUILT-IN-CLASS T>
                                           #<BUILT-IN-CLASS T>) in DEFMETHOD
STYLE-WARNING:
   redefining OUTPUT-FILES :AROUND (#<STANDARD-CLASS COMPILE-OP>
                                    #<STANDARD-CLASS SOURCE-FILE>) in DEFMETHOD
STYLE-WARNING: redefining LISP-VERSION-STRING in DEFUN
STYLE-WARNING: redefining IMPLEMENTATION-SPECIFIC-DIRECTORY-NAME in DEFUN
STYLE-WARNING: redefining PATHNAME-PREFIX-P in DEFUN
STYLE-WARNING: redefining OUTPUT-FILES-FOR-SYSTEM-AND-OPERATION in DEFGENERIC
STYLE-WARNING:
   redefining OUTPUT-FILES-FOR-SYSTEM-AND-OPERATION (#<STANDARD-CLASS SYSTEM>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>) in DEFMETHOD
STYLE-WARNING: redefining OUTPUT-FILES-USING-MAPPINGS in DEFGENERIC
STYLE-WARNING:
   redefining OUTPUT-FILES-USING-MAPPINGS (#<BUILT-IN-CLASS T>
                                           #<BUILT-IN-CLASS T>
                                           #<BUILT-IN-CLASS T>) in DEFMETHOD
STYLE-WARNING:
   redefining OUTPUT-FILES :AROUND (#<STANDARD-CLASS COMPILE-OP>
                                    #<STANDARD-CLASS SOURCE-FILE>) in DEFMETHOD
STYLE-WARNING: redefining LISP-VERSION-STRING in DEFUN
STYLE-WARNING: redefining IMPLEMENTATION-SPECIFIC-DIRECTORY-NAME in DEFUN
STYLE-WARNING: redefining PATHNAME-PREFIX-P in DEFUN
STYLE-WARNING: redefining OUTPUT-FILES-FOR-SYSTEM-AND-OPERATION in DEFGENERIC
STYLE-WARNING:
   redefining OUTPUT-FILES-FOR-SYSTEM-AND-OPERATION (#<STANDARD-CLASS SYSTEM>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>) in DEFMETHOD
STYLE-WARNING: redefining OUTPUT-FILES-USING-MAPPINGS in DEFGENERIC
STYLE-WARNING:
   redefining OUTPUT-FILES-USING-MAPPINGS (#<BUILT-IN-CLASS T>
                                           #<BUILT-IN-CLASS T>
                                           #<BUILT-IN-CLASS T>) in DEFMETHOD
STYLE-WARNING:
   redefining OUTPUT-FILES :AROUND (#<STANDARD-CLASS COMPILE-OP>
                                    #<STANDARD-CLASS SOURCE-FILE>) in DEFMETHOD
STYLE-WARNING: redefining LISP-VERSION-STRING in DEFUN
STYLE-WARNING: redefining IMPLEMENTATION-SPECIFIC-DIRECTORY-NAME in DEFUN
STYLE-WARNING: redefining PATHNAME-PREFIX-P in DEFUN
STYLE-WARNING: redefining OUTPUT-FILES-FOR-SYSTEM-AND-OPERATION in DEFGENERIC
STYLE-WARNING:
   redefining OUTPUT-FILES-FOR-SYSTEM-AND-OPERATION (#<STANDARD-CLASS SYSTEM>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>) in DEFMETHOD
STYLE-WARNING: redefining OUTPUT-FILES-USING-MAPPINGS in DEFGENERIC
STYLE-WARNING:
   redefining OUTPUT-FILES-USING-MAPPINGS (#<BUILT-IN-CLASS T>
                                           #<BUILT-IN-CLASS T>
                                           #<BUILT-IN-CLASS T>) in DEFMETHOD
STYLE-WARNING:
   redefining OUTPUT-FILES :AROUND (#<STANDARD-CLASS COMPILE-OP>
                                    #<STANDARD-CLASS SOURCE-FILE>) in DEFMETHOD
STYLE-WARNING: redefining LISP-VERSION-STRING in DEFUN
STYLE-WARNING: redefining IMPLEMENTATION-SPECIFIC-DIRECTORY-NAME in DEFUN
STYLE-WARNING: redefining PATHNAME-PREFIX-P in DEFUN
STYLE-WARNING: redefining OUTPUT-FILES-FOR-SYSTEM-AND-OPERATION in DEFGENERIC
STYLE-WARNING:
   redefining OUTPUT-FILES-FOR-SYSTEM-AND-OPERATION (#<STANDARD-CLASS SYSTEM>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>) in DEFMETHOD
STYLE-WARNING: redefining OUTPUT-FILES-USING-MAPPINGS in DEFGENERIC
STYLE-WARNING:
   redefining OUTPUT-FILES-USING-MAPPINGS (#<BUILT-IN-CLASS T>
                                           #<BUILT-IN-CLASS T>
                                           #<BUILT-IN-CLASS T>) in DEFMETHOD
STYLE-WARNING:
   redefining OUTPUT-FILES :AROUND (#<STANDARD-CLASS COMPILE-OP>
                                    #<STANDARD-CLASS SOURCE-FILE>) in DEFMETHOD
STYLE-WARNING: redefining LISP-VERSION-STRING in DEFUN
STYLE-WARNING: redefining IMPLEMENTATION-SPECIFIC-DIRECTORY-NAME in DEFUN
STYLE-WARNING: redefining PATHNAME-PREFIX-P in DEFUN
STYLE-WARNING: redefining OUTPUT-FILES-FOR-SYSTEM-AND-OPERATION in DEFGENERIC
STYLE-WARNING:
   redefining OUTPUT-FILES-FOR-SYSTEM-AND-OPERATION (#<STANDARD-CLASS SYSTEM>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>) in DEFMETHOD
STYLE-WARNING: redefining OUTPUT-FILES-USING-MAPPINGS in DEFGENERIC
STYLE-WARNING:
   redefining OUTPUT-FILES-USING-MAPPINGS (#<BUILT-IN-CLASS T>
                                           #<BUILT-IN-CLASS T>
                                           #<BUILT-IN-CLASS T>) in DEFMETHOD
STYLE-WARNING:
   redefining OUTPUT-FILES :AROUND (#<STANDARD-CLASS COMPILE-OP>
                                    #<STANDARD-CLASS SOURCE-FILE>) in DEFMETHOD
STYLE-WARNING: redefining LISP-VERSION-STRING in DEFUN
STYLE-WARNING: redefining IMPLEMENTATION-SPECIFIC-DIRECTORY-NAME in DEFUN
STYLE-WARNING: redefining PATHNAME-PREFIX-P in DEFUN
STYLE-WARNING: redefining OUTPUT-FILES-FOR-SYSTEM-AND-OPERATION in DEFGENERIC
STYLE-WARNING:
   redefining OUTPUT-FILES-FOR-SYSTEM-AND-OPERATION (#<STANDARD-CLASS SYSTEM>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>
                                                     #<BUILT-IN-CLASS T>) in DEFMETHOD
STYLE-WARNING: redefining OUTPUT-FILES-USING-MAPPINGS in DEFGENERIC
STYLE-WARNING:
   redefining OUTPUT-FILES-USING-MAPPINGS (#<BUILT-IN-CLASS T>
                                           #<BUILT-IN-CLASS T>
                                           #<BUILT-IN-CLASS T>) in DEFMETHOD
STYLE-WARNING:
   redefining OUTPUT-FILES :AROUND (#<STANDARD-CLASS COMPILE-OP>
                                    #<STANDARD-CLASS SOURCE-FILE>) in DEFMETHOD


PROGRAM OUTPUT
==============
agggtaaa|tttaccct 36
[cgt]gggtaaa|tttaccc[acg] 125
a[act]ggtaaa|tttacc[agt]t 426
ag[act]gtaaa|tttac[agt]ct 290
agg[act]taaa|ttta[agt]cct 536
aggg[acg]aaa|ttt[cgt]ccct 153
agggt[cgt]aa|tt[acg]accct 143
agggta[cgt]a|t[acg]taccct 160
agggtaa[cgt]|[acg]ttaccct 219

5083411
5000000
6678892
