<span class="com">{-  The Computer Language Shootout</span>
<span class="com">    http://shootout.alioth.debian.org/</span>
<span class="com">    compile with:  ghc -O2 -o fannkuch fannkuch.hs</span>
<span class="com">    contributed by Josh Goldfoot, &quot;fixing&quot; the version by Greg Buchholz</span>
<span class="com">      permutations function translated from the C version by Heiner Marxen</span>
<span class="com">    Joel Koerwer changed the code to use the builtin function, maximum,</span>
<span class="com">      greatly improving performance. Also cleaned up a bit.</span>
<span class="com">-}</span>

<span class="kwa">import</span> System <span class="sym">(</span>getArgs<span class="sym">)</span>

main <span class="sym">=</span> <span class="kwa">do</span>   <span class="sym">[</span>n<span class="sym">] &lt;-</span> getArgs
            <span class="kwa">let</span> p <span class="sym">=</span> permutations <span class="sym">[</span><span class="num">1</span> .. read n<span class="sym">]</span>
            mapM putStrLn $ map <span class="sym">(&gt;&gt;=</span> show<span class="sym">)</span> $ take <span class="num">30</span> p
            putStr $ <span class="str">&quot;Pfannkuchen(&quot;</span> <span class="sym">++</span> n <span class="sym">++</span> <span class="str">&quot;) = &quot;</span>
            print $ findmax p

findmax <span class="sym">:: [[</span><span class="kwb">Int</span><span class="sym">]] -&gt;</span> <span class="kwb">Int</span>
findmax <span class="sym">=</span> maximum . map <span class="sym">(</span>flop <span class="num">0</span><span class="sym">)</span>

flop <span class="sym">::</span> <span class="kwb">Int</span> <span class="sym">-&gt; [</span><span class="kwb">Int</span><span class="sym">] -&gt;</span> <span class="kwb">Int</span>
flop acc <span class="sym">(</span><span class="num">1</span><span class="sym">:</span>xs<span class="sym">) =</span> acc
flop acc list&#64;<span class="sym">(</span>x<span class="sym">:</span>xs<span class="sym">) =</span> flop <span class="sym">(</span>acc<span class="sym">+</span><span class="num">1</span><span class="sym">)</span> mangle
    <span class="kwa">where</span>   mangle <span class="sym">= (</span>reverse front<span class="sym">) ++</span> back
            <span class="sym">(</span>front<span class="sym">,</span>back<span class="sym">) =</span> splitAt x list

permutations <span class="sym">:: [</span><span class="kwb">Int</span><span class="sym">] -&gt; [[</span><span class="kwb">Int</span><span class="sym">]]</span>
permutations arry <span class="sym">=</span>
    arry <span class="sym">: (</span>permuteloop n arry <span class="sym">[</span><span class="num">1</span>..n<span class="sym">]</span> <span class="num">1</span><span class="sym">)</span>
    <span class="kwa">where</span> n <span class="sym">=</span> length arry

permuteloop <span class="sym">::</span> <span class="kwb">Int</span> <span class="sym">-&gt; [</span>a<span class="sym">] -&gt; [</span><span class="kwb">Int</span><span class="sym">] -&gt;</span> <span class="kwb">Int</span> <span class="sym">-&gt; [[</span>a<span class="sym">]]</span>
permuteloop n arry count r
        <span class="sym">|</span> r <span class="sym">==</span> n <span class="sym">= []</span>
        <span class="sym">|</span> count<span class="str">' !! r &gt; 0 = arry'</span> <span class="sym">: (</span>permuteloop n arry<span class="str">' (reload r count'</span><span class="sym">)</span> <span class="num">1</span><span class="sym">)</span>
        <span class="sym">|</span> otherwise <span class="sym">=</span> permuteloop n arry<span class="str">' count'</span> <span class="sym">(</span>r<span class="sym">+</span><span class="num">1</span><span class="sym">)</span>
        <span class="kwa">where</span>
            count<span class="str">' = (take r count) ++ ((count !! r) - 1):(drop (r+1) count)</span>
<span class="str">            arry'</span> <span class="sym">=</span> rotate r arry


rotate <span class="sym">::</span> <span class="kwb">Int</span> <span class="sym">-&gt; [</span>a<span class="sym">] -&gt; [</span>a<span class="sym">]</span>
rotate r <span class="sym">(</span>x<span class="sym">:</span>xs<span class="sym">) =</span>
   begin <span class="sym">++</span> x<span class="sym">:</span>end
   <span class="kwa">where</span> <span class="sym">(</span>begin<span class="sym">,</span> end<span class="sym">) =</span> splitAt r xs

reload <span class="sym">::</span> <span class="kwb">Int</span> <span class="sym">-&gt; [</span><span class="kwb">Int</span><span class="sym">] -&gt; [</span><span class="kwb">Int</span><span class="sym">]</span>
reload r count
   <span class="sym">|</span> r <span class="sym">==</span> <span class="num">1</span> <span class="sym">=</span> count
   <span class="sym">|</span> otherwise <span class="sym">= [</span><span class="num">1</span>..r<span class="sym">] ++ (</span>drop r count<span class="sym">)</span>
