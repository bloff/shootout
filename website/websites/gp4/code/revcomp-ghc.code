<span class="slc">-- The Great Computer Language Shootout</span>
<span class="slc">-- http://shootout.alioth.debian.org/</span>
<span class="slc">-- contributed by Jeff Newbern</span>

<span class="slc">-- Note: This code has not been optimized *at all*.  It is written to be clear</span>
<span class="slc">-- and concise, using standard Haskell idioms.  Performance is decent with</span>
<span class="slc">-- ghc -O2, but if it can be improved without sacrificing the clarity of the</span>
<span class="slc">-- code, by all means go for it!</span>

<span class="kwa">import</span> Data.<span class="kwb">Char</span><span class="sym">(</span>toLower<span class="sym">)</span>

<span class="kwa">type</span> Base <span class="sym">=</span> <span class="kwb">Char</span>
<span class="kwa">type</span> Sequence <span class="sym">= [</span>Base<span class="sym">]</span>

complement <span class="sym">::</span> Base <span class="sym">-&gt;</span> Base
complement 'A' <span class="sym">=</span> 'T'
complement 'a' <span class="sym">=</span> 'T'
complement 'C' <span class="sym">=</span> 'G'
complement 'c' <span class="sym">=</span> 'G'
complement 'G' <span class="sym">=</span> 'C'
complement 'g' <span class="sym">=</span> 'C'
complement 'T' <span class="sym">=</span> 'A'
complement 't' <span class="sym">=</span> 'A'
complement 'U' <span class="sym">=</span> 'A'
complement 'u' <span class="sym">=</span> 'A'
complement 'M' <span class="sym">=</span> 'K'
complement 'm' <span class="sym">=</span> 'K'
complement 'R' <span class="sym">=</span> 'Y'
complement 'r' <span class="sym">=</span> 'Y'
complement 'Y' <span class="sym">=</span> 'R'
complement 'y' <span class="sym">=</span> 'R'
complement 'K' <span class="sym">=</span> 'M'
complement 'k' <span class="sym">=</span> 'M'
complement 'V' <span class="sym">=</span> 'B'
complement 'v' <span class="sym">=</span> 'B'
complement 'H' <span class="sym">=</span> 'D'
complement 'h' <span class="sym">=</span> 'D'
complement 'D' <span class="sym">=</span> 'H'
complement 'd' <span class="sym">=</span> 'H'
complement 'B' <span class="sym">=</span> 'V'
complement 'b' <span class="sym">=</span> 'V'
complement  x  <span class="sym">=</span> x

<span class="slc">-- write a sequence in Fasta format</span>
writeFasta <span class="sym">::</span> String <span class="sym">-&gt;</span> Sequence <span class="sym">-&gt;</span> IO <span class="sym">()</span>
writeFasta <span class="sym">[]</span>     _        <span class="sym">=</span> <span class="kwa">do</span> return <span class="sym">()</span>
writeFasta header sequence <span class="sym">=</span>
  <span class="kwa">do</span> putStrLn header
     writeWrapped <span class="num">60</span> sequence
  <span class="kwa">where</span> writeWrapped _   <span class="sym">[]  =</span> <span class="kwa">do</span> return <span class="sym">()</span>
        writeWrapped len str <span class="sym">=</span> <span class="kwa">do let</span> <span class="sym">(</span>s1<span class="sym">,</span>s2<span class="sym">) =</span> splitAt len str
                                  putStrLn s1
                                  writeWrapped len s2

<span class="slc">-- recurse over input stream, accumulating and writing processed sequences</span>
process <span class="sym">:: (</span>String<span class="sym">,[</span>Base<span class="sym">],</span>String<span class="sym">) -&gt;</span> IO<span class="sym">()</span>
process <span class="sym">(</span>header<span class="sym">,</span>bases<span class="sym">,[])         =</span> writeFasta header bases
process <span class="sym">(</span>header<span class="sym">,</span>bases<span class="sym">,</span>c<span class="sym">&#64;(</span>'<span class="sym">&gt;</span>'<span class="sym">:</span>cs<span class="sym">)) =</span> <span class="kwa">do</span> writeFasta header bases
                                       <span class="kwa">let</span> <span class="sym">(</span>header'<span class="sym">,</span>cs'<span class="sym">) =</span> break <span class="sym">(</span>\c<span class="sym">-&gt;</span>c <span class="sym">==</span> '\n'<span class="sym">)</span> c
                                       process <span class="sym">(</span>header'<span class="sym">,[],</span>cs'<span class="sym">)</span>
process <span class="sym">(</span>header<span class="sym">,</span>bases<span class="sym">,(</span>'\n'<span class="sym">:</span>cs<span class="sym">))  =</span> process <span class="sym">(</span>header<span class="sym">,</span>bases<span class="sym">,</span>cs<span class="sym">)</span>
process <span class="sym">(</span>header<span class="sym">,</span>bases<span class="sym">,(</span>c<span class="sym">:</span>cs<span class="sym">))     =</span> process <span class="sym">(</span>header<span class="sym">,((</span>complement c<span class="sym">):</span>bases<span class="sym">),</span>cs<span class="sym">)</span>

main <span class="sym">=</span> <span class="kwa">do</span> cs <span class="sym">&lt;-</span> getContents
          process <span class="sym">([],[],</span>cs<span class="sym">)</span>

