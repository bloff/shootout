<span class="hl slc">// The Computer Language Benchmarks Game</span>
<span class="hl slc">// http://shootout.alioth.debian.org/</span>
<span class="hl slc">//</span>
<span class="hl slc">// Contributed by The Anh Tran</span>

<span class="hl dir">#include &lt;omp.h&gt;</span>
<span class="hl dir">#include &lt;memory.h&gt;</span>
<span class="hl dir">#include &lt;cassert&gt;</span>
<span class="hl dir">#include &lt;sched.h&gt;</span>

<span class="hl dir">#include &lt;iostream&gt;</span>
<span class="hl dir">#include &lt;vector&gt;</span>
<span class="hl dir">#include &lt;iterator&gt;</span>

<span class="hl dir">#include &lt;boost/format.hpp&gt;</span>
<span class="hl dir">#include &lt;boost/scoped_array.hpp&gt;</span>
<span class="hl dir">#include &lt;boost/xpressive/xpressive.hpp&gt;</span>

<span class="hl kwa">using namespace</span> boost<span class="hl sym">::</span>xpressive<span class="hl sym">;</span>


<span class="hl kwc">typedef</span> std<span class="hl sym">::</span>vector<span class="hl sym">&lt;</span><span class="hl kwb">char</span><span class="hl sym">&gt;</span>                  Input_Type<span class="hl sym">;</span>

<span class="hl kwc">typedef</span> Input_Type<span class="hl sym">::</span>iterator               Ite_Type<span class="hl sym">;</span>
<span class="hl kwc">typedef</span> Input_Type<span class="hl sym">::</span>const_iterator            CIte_Type<span class="hl sym">;</span>
<span class="hl kwc">typedef</span> std<span class="hl sym">::</span>back_insert_iterator<span class="hl sym">&lt;</span>Input_Type<span class="hl sym">&gt;</span>   OIte_Type<span class="hl sym">;</span>

<span class="hl kwc">typedef</span> basic_regex<span class="hl sym">&lt;</span>CIte_Type<span class="hl sym">&gt;</span>               Regex_Type<span class="hl sym">;</span>


<span class="hl slc">// read all redirected data from stdin</span>
<span class="hl slc">// strip DNA headers and newline characters</span>
<span class="hl kwb">void</span> <span class="hl kwd">ReadInput_StripHeader</span><span class="hl sym">(</span>   <span class="hl kwb">size_t</span> <span class="hl sym">&amp;</span>file_size<span class="hl sym">,</span> <span class="hl kwb">size_t</span> <span class="hl sym">&amp;</span>strip_size<span class="hl sym">,</span> Input_Type <span class="hl sym">&amp;</span>output <span class="hl sym">)</span>
<span class="hl sym">{</span>
   <span class="hl slc">// get input size</span>
   file_size <span class="hl sym">=</span> std<span class="hl sym">::</span><span class="hl kwd">ftell</span><span class="hl sym">(</span>stdin<span class="hl sym">);</span>
   std<span class="hl sym">::</span><span class="hl kwd">fseek</span><span class="hl sym">(</span>stdin<span class="hl sym">,</span> <span class="hl num">0</span><span class="hl sym">,</span> SEEK_END<span class="hl sym">);</span>
   file_size <span class="hl sym">=</span> std<span class="hl sym">::</span><span class="hl kwd">ftell</span><span class="hl sym">(</span>stdin<span class="hl sym">) -</span> file_size<span class="hl sym">;</span>
   std<span class="hl sym">::</span><span class="hl kwd">fseek</span><span class="hl sym">(</span>stdin<span class="hl sym">,</span> <span class="hl num">0</span><span class="hl sym">,</span> SEEK_SET<span class="hl sym">);</span>


   <span class="hl slc">// load content into memory</span>
   boost<span class="hl sym">::</span>scoped_array<span class="hl sym">&lt;</span><span class="hl kwb">char</span><span class="hl sym">&gt;</span> <span class="hl kwd">p_input_buffer</span><span class="hl sym">(</span><span class="hl kwa">new</span> <span class="hl kwb">char</span><span class="hl sym">[</span>file_size <span class="hl sym">+</span><span class="hl num">1</span><span class="hl sym">]);</span>
   <span class="hl sym">{</span>
      <span class="hl kwb">size_t</span> sz <span class="hl sym">=</span> std<span class="hl sym">::</span><span class="hl kwd">fread</span><span class="hl sym">(</span>p_input_buffer<span class="hl sym">.</span><span class="hl kwd">get</span><span class="hl sym">(),</span> <span class="hl num">1</span><span class="hl sym">,</span> file_size<span class="hl sym">,</span> stdin<span class="hl sym">);</span>
      <span class="hl kwd">assert</span><span class="hl sym">(</span>sz <span class="hl sym">==</span> file_size<span class="hl sym">);</span>
      <span class="hl slc">// null terminate string</span>
      p_input_buffer<span class="hl sym">[</span>file_size<span class="hl sym">] =</span> <span class="hl num">0</span><span class="hl sym">;</span>
   <span class="hl sym">}</span>


   <span class="hl slc">// Rule: Strip pattern: &quot;&gt;.*\n | \n&quot;</span>
   cregex <span class="hl kwb">const</span><span class="hl sym">&amp;</span> <span class="hl kwd">search_ptn_regex</span><span class="hl sym">(</span> <span class="hl kwd">as_xpr</span><span class="hl sym">(</span><span class="hl str">'&gt;'</span><span class="hl sym">) &gt;&gt; *(~</span>_n<span class="hl sym">) &gt;&gt;</span> _n <span class="hl sym">|</span> _n <span class="hl sym">);</span>

   <span class="hl kwb">char const</span> <span class="hl sym">*</span> p_src_beg <span class="hl sym">=</span> p_input_buffer<span class="hl sym">.</span><span class="hl kwd">get</span><span class="hl sym">();</span>
   <span class="hl kwb">char const</span> <span class="hl sym">*</span> p_src_end <span class="hl sym">=</span> p_src_beg <span class="hl sym">+</span> file_size<span class="hl sym">;</span>

   OIte_Type <span class="hl kwd">output_ite</span><span class="hl sym">(</span>output<span class="hl sym">);</span>
   <span class="hl kwd">regex_replace</span> <span class="hl sym">(</span>output_ite<span class="hl sym">,</span> p_src_beg<span class="hl sym">,</span> p_src_end<span class="hl sym">,</span> search_ptn_regex<span class="hl sym">,</span> <span class="hl str">&quot;&quot;</span><span class="hl sym">);</span>

   strip_size <span class="hl sym">=</span> output<span class="hl sym">.</span><span class="hl kwd">size</span><span class="hl sym">();</span>
<span class="hl sym">}</span>


<span class="hl kwb">void</span> <span class="hl kwd">Count_Patterns</span><span class="hl sym">(</span>Input_Type <span class="hl kwb">const</span><span class="hl sym">&amp;</span> input<span class="hl sym">,</span> std<span class="hl sym">::</span>string<span class="hl sym">&amp;</span> result<span class="hl sym">)</span>
<span class="hl sym">{</span>
   <span class="hl kwb">static char const</span><span class="hl sym">*</span> search_ptn<span class="hl sym">[] =</span>
   <span class="hl sym">{</span>
      <span class="hl str">&quot;agggtaaa|tttaccct&quot;</span><span class="hl sym">,</span>
      <span class="hl str">&quot;[cgt]gggtaaa|tttaccc[acg]&quot;</span><span class="hl sym">,</span>
      <span class="hl str">&quot;a[act]ggtaaa|tttacc[agt]t&quot;</span><span class="hl sym">,</span>
      <span class="hl str">&quot;ag[act]gtaaa|tttac[agt]ct&quot;</span><span class="hl sym">,</span>
      <span class="hl str">&quot;agg[act]taaa|ttta[agt]cct&quot;</span><span class="hl sym">,</span>
      <span class="hl str">&quot;aggg[acg]aaa|ttt[cgt]ccct&quot;</span><span class="hl sym">,</span>
      <span class="hl str">&quot;agggt[cgt]aa|tt[acg]accct&quot;</span><span class="hl sym">,</span>
      <span class="hl str">&quot;agggta[cgt]a|t[acg]taccct&quot;</span><span class="hl sym">,</span>
      <span class="hl str">&quot;agggtaa[cgt]|[acg]ttaccct&quot;</span>
   <span class="hl sym">};</span>
   <span class="hl kwb">static int const</span> n_search_ptn <span class="hl sym">=</span> <span class="hl kwa">sizeof</span><span class="hl sym">(</span>search_ptn<span class="hl sym">) /</span> <span class="hl kwa">sizeof</span><span class="hl sym">(</span>search_ptn<span class="hl sym">[</span><span class="hl num">0</span><span class="hl sym">]);</span>
   <span class="hl kwb">static size_t</span> match_count<span class="hl sym">[</span>n_search_ptn<span class="hl sym">] = {</span><span class="hl num">0</span><span class="hl sym">};</span>


   <span class="hl dir">#pragma omp for schedule(dynamic, 1) nowait</span>
   <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> i <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> i <span class="hl sym">&lt;</span> n_search_ptn<span class="hl sym">; ++</span>i<span class="hl sym">)</span>
   <span class="hl sym">{</span>
      <span class="hl slc">// runtime compile regex</span>
      Regex_Type <span class="hl kwb">const</span><span class="hl sym">&amp;</span> <span class="hl kwd">search_ptn_regex</span><span class="hl sym">(</span>Regex_Type<span class="hl sym">::</span><span class="hl kwd">compile</span><span class="hl sym">(</span>search_ptn<span class="hl sym">[</span>i<span class="hl sym">],</span> regex_constants<span class="hl sym">::</span>nosubs<span class="hl sym">|</span>regex_constants<span class="hl sym">::</span>optimize<span class="hl sym">));</span>

      regex_iterator<span class="hl sym">&lt;</span>CIte_Type<span class="hl sym">&gt;</span> <span class="hl kwd">ite</span><span class="hl sym">(</span>input<span class="hl sym">.</span><span class="hl kwd">begin</span> <span class="hl sym">(),</span> input<span class="hl sym">.</span><span class="hl kwd">end</span><span class="hl sym">(),</span> search_ptn_regex<span class="hl sym">),</span> ite_end<span class="hl sym">;</span>
      match_count<span class="hl sym">[</span>i<span class="hl sym">] =</span> std<span class="hl sym">::</span><span class="hl kwd">distance</span> <span class="hl sym">(</span>ite<span class="hl sym">,</span> ite_end<span class="hl sym">);</span>
   <span class="hl sym">}</span>

   <span class="hl slc">// we want the last thread, reaching this code block, to print result</span>
   <span class="hl kwb">static int</span> thread_passed <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span>
   <span class="hl kwa">if</span> <span class="hl sym">(</span><span class="hl kwd">__sync_add_and_fetch</span><span class="hl sym">(&amp;</span>thread_passed<span class="hl sym">,</span> <span class="hl num">1</span><span class="hl sym">) ==</span> <span class="hl kwd">omp_get_num_threads</span><span class="hl sym">())</span>
   <span class="hl sym">{</span>
      boost<span class="hl sym">::</span>format <span class="hl kwd">format</span><span class="hl sym">(</span><span class="hl str">&quot;%1% %2%</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl sym">);</span>
      <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> i <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> i <span class="hl sym">&lt;</span> n_search_ptn<span class="hl sym">; ++</span>i<span class="hl sym">)</span>
      <span class="hl sym">{</span>
         format <span class="hl sym">%</span> search_ptn<span class="hl sym">[</span>i<span class="hl sym">] %</span> match_count<span class="hl sym">[</span>i<span class="hl sym">];</span>
         result <span class="hl sym">+=</span> format<span class="hl sym">.</span><span class="hl kwd">str</span><span class="hl sym">();</span>
      <span class="hl sym">}</span>
      thread_passed <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span>
   <span class="hl sym">}</span>
<span class="hl sym">}</span>


<span class="hl kwc">typedef</span> std<span class="hl sym">::</span>pair<span class="hl sym">&lt;</span><span class="hl kwb">char const</span><span class="hl sym">*,</span> <span class="hl kwb">char const</span><span class="hl sym">*&gt;</span> IUB<span class="hl sym">;</span>
IUB iub_table<span class="hl sym">[] =</span>
<span class="hl sym">{</span>
   <span class="hl kwd">IUB</span><span class="hl sym">(</span><span class="hl str">&quot;(c|g|t)&quot;</span><span class="hl sym">,</span>   <span class="hl num">0</span><span class="hl sym">),</span>
   <span class="hl kwd">IUB</span><span class="hl sym">(</span><span class="hl str">&quot;(a|g|t)&quot;</span><span class="hl sym">,</span>   <span class="hl num">0</span><span class="hl sym">),</span>
   <span class="hl kwd">IUB</span><span class="hl sym">(</span><span class="hl str">&quot;(a|c|t)&quot;</span><span class="hl sym">,</span>   <span class="hl num">0</span><span class="hl sym">),</span>
   <span class="hl kwd">IUB</span><span class="hl sym">(</span><span class="hl str">&quot;(g|t)&quot;</span><span class="hl sym">,</span>   <span class="hl num">0</span><span class="hl sym">),</span>
   <span class="hl kwd">IUB</span><span class="hl sym">(</span><span class="hl str">&quot;(a|c)&quot;</span><span class="hl sym">,</span>   <span class="hl num">0</span><span class="hl sym">),</span>
   <span class="hl kwd">IUB</span><span class="hl sym">(</span><span class="hl str">&quot;(a|c|g|t)&quot;</span><span class="hl sym">,</span> <span class="hl num">0</span><span class="hl sym">),</span>
   <span class="hl kwd">IUB</span><span class="hl sym">(</span><span class="hl str">&quot;(a|g)&quot;</span><span class="hl sym">,</span>   <span class="hl num">0</span><span class="hl sym">),</span>
   <span class="hl kwd">IUB</span><span class="hl sym">(</span><span class="hl str">&quot;(c|t)&quot;</span><span class="hl sym">,</span>   <span class="hl num">0</span><span class="hl sym">),</span>
   <span class="hl kwd">IUB</span><span class="hl sym">(</span><span class="hl str">&quot;(a|c|g)&quot;</span><span class="hl sym">,</span>   <span class="hl num">0</span><span class="hl sym">),</span>
   <span class="hl kwd">IUB</span><span class="hl sym">(</span><span class="hl str">&quot;(a|t)&quot;</span><span class="hl sym">,</span>   <span class="hl num">0</span><span class="hl sym">),</span>
   <span class="hl kwd">IUB</span><span class="hl sym">(</span><span class="hl str">&quot;(c|t)&quot;</span><span class="hl sym">,</span>   <span class="hl num">0</span><span class="hl sym">)</span>
<span class="hl sym">};</span>
<span class="hl kwb">int const</span> n_iub <span class="hl sym">=</span> <span class="hl kwa">sizeof</span><span class="hl sym">(</span>iub_table<span class="hl sym">)/</span><span class="hl kwa">sizeof</span><span class="hl sym">(</span>iub_table<span class="hl sym">[</span><span class="hl num">0</span><span class="hl sym">]);</span>

<span class="hl kwb">struct</span> RegexFormatter
<span class="hl sym">{</span>
   <span class="hl kwc">template</span><span class="hl sym">&lt;</span>typename Match<span class="hl sym">,</span> typename Out<span class="hl sym">&gt;</span>
   Out <span class="hl kwc">operator</span><span class="hl sym">()(</span>Match <span class="hl kwb">const</span> <span class="hl sym">&amp;</span>match<span class="hl sym">,</span> Out out<span class="hl sym">)</span> <span class="hl kwb">const</span>
   <span class="hl sym">{</span>
      <span class="hl kwb">int</span> i<span class="hl sym">;</span>
      <span class="hl kwa">switch</span> <span class="hl sym">( *(</span>match<span class="hl sym">[</span><span class="hl num">0</span><span class="hl sym">].</span>first<span class="hl sym">) )</span>
      <span class="hl sym">{</span>
      <span class="hl kwa">case</span> <span class="hl str">'B'</span><span class="hl sym">:</span>   i <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span>   <span class="hl kwa">break</span><span class="hl sym">;</span>
      <span class="hl kwa">case</span> <span class="hl str">'D'</span><span class="hl sym">:</span>   i <span class="hl sym">=</span> <span class="hl num">1</span><span class="hl sym">;</span>   <span class="hl kwa">break</span><span class="hl sym">;</span>
      <span class="hl kwa">case</span> <span class="hl str">'H'</span><span class="hl sym">:</span>   i <span class="hl sym">=</span> <span class="hl num">2</span><span class="hl sym">;</span>   <span class="hl kwa">break</span><span class="hl sym">;</span>
      <span class="hl kwa">case</span> <span class="hl str">'K'</span><span class="hl sym">:</span>   i <span class="hl sym">=</span> <span class="hl num">3</span><span class="hl sym">;</span>   <span class="hl kwa">break</span><span class="hl sym">;</span>
      <span class="hl kwa">case</span> <span class="hl str">'M'</span><span class="hl sym">:</span>   i <span class="hl sym">=</span> <span class="hl num">4</span><span class="hl sym">;</span>   <span class="hl kwa">break</span><span class="hl sym">;</span>
      <span class="hl kwa">case</span> <span class="hl str">'N'</span><span class="hl sym">:</span>   i <span class="hl sym">=</span> <span class="hl num">5</span><span class="hl sym">;</span>   <span class="hl kwa">break</span><span class="hl sym">;</span>
      <span class="hl kwa">case</span> <span class="hl str">'R'</span><span class="hl sym">:</span>   i <span class="hl sym">=</span> <span class="hl num">6</span><span class="hl sym">;</span>   <span class="hl kwa">break</span><span class="hl sym">;</span>
      <span class="hl kwa">case</span> <span class="hl str">'S'</span><span class="hl sym">:</span>   i <span class="hl sym">=</span> <span class="hl num">7</span><span class="hl sym">;</span>   <span class="hl kwa">break</span><span class="hl sym">;</span>
      <span class="hl kwa">case</span> <span class="hl str">'V'</span><span class="hl sym">:</span>   i <span class="hl sym">=</span> <span class="hl num">8</span><span class="hl sym">;</span>   <span class="hl kwa">break</span><span class="hl sym">;</span>
      <span class="hl kwa">case</span> <span class="hl str">'W'</span><span class="hl sym">:</span>   i <span class="hl sym">=</span> <span class="hl num">9</span><span class="hl sym">;</span>   <span class="hl kwa">break</span><span class="hl sym">;</span>
      <span class="hl kwa">case</span> <span class="hl str">'Y'</span><span class="hl sym">:</span>   i <span class="hl sym">=</span> <span class="hl num">10</span><span class="hl sym">;</span>   <span class="hl kwa">break</span><span class="hl sym">;</span>
      <span class="hl kwa">default</span><span class="hl sym">:</span>   <span class="hl kwd">assert</span><span class="hl sym">(</span><span class="hl kwa">false</span><span class="hl sym">);</span>
      <span class="hl sym">}</span>

      <span class="hl kwa">return</span> std<span class="hl sym">::</span><span class="hl kwd">copy</span><span class="hl sym">(</span>iub_table<span class="hl sym">[</span>i<span class="hl sym">].</span>first<span class="hl sym">,</span> iub_table<span class="hl sym">[</span>i<span class="hl sym">].</span>second<span class="hl sym">,</span> out<span class="hl sym">);</span>
   <span class="hl sym">}</span>
<span class="hl sym">};</span>

<span class="hl kwb">void</span> <span class="hl kwd">Replace_Patterns</span><span class="hl sym">(</span>Input_Type <span class="hl kwb">const</span><span class="hl sym">&amp;</span> input<span class="hl sym">,</span> <span class="hl kwb">size_t</span> <span class="hl sym">&amp;</span>replace_len<span class="hl sym">)</span>
<span class="hl sym">{</span>
   <span class="hl dir">#pragma omp single nowait</span>
   <span class="hl sym">{</span>
      <span class="hl slc">// &quot;[BDHKMNRSVWY]&quot;   // copy idea from Java#4 &amp; Perl#4</span>
      Regex_Type <span class="hl kwb">const</span><span class="hl sym">&amp;</span>   <span class="hl kwd">search_ptn_regex</span><span class="hl sym">( (</span>set <span class="hl sym">=</span> <span class="hl str">'B'</span><span class="hl sym">,</span><span class="hl str">'D'</span><span class="hl sym">,</span><span class="hl str">'H'</span><span class="hl sym">,</span><span class="hl str">'K'</span><span class="hl sym">,</span><span class="hl str">'M'</span><span class="hl sym">,</span><span class="hl str">'N'</span><span class="hl sym">,</span><span class="hl str">'R'</span><span class="hl sym">,</span><span class="hl str">'S'</span><span class="hl sym">,</span><span class="hl str">'V'</span><span class="hl sym">,</span><span class="hl str">'W'</span><span class="hl sym">,</span><span class="hl str">'Y'</span><span class="hl sym">) );</span>
      RegexFormatter      formatter<span class="hl sym">;</span>

      Input_Type         replacement<span class="hl sym">;</span>
      OIte_Type         <span class="hl kwd">back_ite</span><span class="hl sym">(</span>replacement<span class="hl sym">);</span>

      <span class="hl slc">// set pointer to the end of replacement string</span>
      <span class="hl kwa">for</span> <span class="hl sym">(</span> <span class="hl kwb">int</span> i <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> i <span class="hl sym">&lt;</span> n_iub<span class="hl sym">; ++</span>i <span class="hl sym">)</span>
         iub_table<span class="hl sym">[</span>i<span class="hl sym">].</span>second <span class="hl sym">=</span> iub_table<span class="hl sym">[</span>i<span class="hl sym">].</span>first <span class="hl sym">+</span> std<span class="hl sym">::</span><span class="hl kwd">strlen</span><span class="hl sym">(</span>iub_table<span class="hl sym">[</span>i<span class="hl sym">].</span>first<span class="hl sym">);</span>

      <span class="hl kwd">regex_replace</span><span class="hl sym">(</span>back_ite<span class="hl sym">,</span> input<span class="hl sym">.</span><span class="hl kwd">begin</span><span class="hl sym">(),</span> input<span class="hl sym">.</span><span class="hl kwd">end</span><span class="hl sym">(),</span> search_ptn_regex<span class="hl sym">,</span> formatter<span class="hl sym">);</span>
      replace_len <span class="hl sym">=</span> replacement<span class="hl sym">.</span><span class="hl kwd">size</span><span class="hl sym">();</span>
   <span class="hl sym">}</span>
<span class="hl sym">}</span>



<span class="hl slc">// Detect single - multi thread benchmark</span>
<span class="hl kwb">static</span>
<span class="hl kwb">int</span> <span class="hl kwd">GetThreadCount</span><span class="hl sym">()</span>
<span class="hl sym">{</span>
   cpu_set_t cs<span class="hl sym">;</span>
   <span class="hl kwd">CPU_ZERO</span><span class="hl sym">(&amp;</span>cs<span class="hl sym">);</span>
   <span class="hl kwd">sched_getaffinity</span><span class="hl sym">(</span><span class="hl num">0</span><span class="hl sym">,</span> <span class="hl kwa">sizeof</span><span class="hl sym">(</span>cs<span class="hl sym">), &amp;</span>cs<span class="hl sym">);</span>

   <span class="hl kwb">int</span> count <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span>
   <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> i <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> i <span class="hl sym">&lt;</span> <span class="hl num">16</span><span class="hl sym">; ++</span>i<span class="hl sym">)</span>
   <span class="hl sym">{</span>
      <span class="hl kwa">if</span> <span class="hl sym">(</span><span class="hl kwd">CPU_ISSET</span><span class="hl sym">(</span>i<span class="hl sym">, &amp;</span>cs<span class="hl sym">))</span>
      <span class="hl sym">++</span>count<span class="hl sym">;</span>
   <span class="hl sym">}</span>
   <span class="hl kwa">return</span> count<span class="hl sym">;</span>
<span class="hl sym">}</span>


<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl sym">()</span>
<span class="hl sym">{</span>
   <span class="hl kwb">size_t</span> initial_length <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span>
   <span class="hl kwb">size_t</span> striped_length <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span>
   <span class="hl kwb">size_t</span> replace_length <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span>

   Input_Type input<span class="hl sym">;</span>

   <span class="hl kwd">ReadInput_StripHeader</span> <span class="hl sym">(</span>initial_length<span class="hl sym">,</span> striped_length<span class="hl sym">,</span> input<span class="hl sym">);</span>

   std<span class="hl sym">::</span>string match_result<span class="hl sym">;</span>
   <span class="hl dir">#pragma omp parallel default(shared) num_threads(GetThreadCount())</span>
   <span class="hl sym">{</span>
      <span class="hl kwd">Count_Patterns</span>   <span class="hl sym">(</span>input<span class="hl sym">,</span> match_result<span class="hl sym">);</span>
      <span class="hl kwd">Replace_Patterns</span><span class="hl sym">(</span>input<span class="hl sym">,</span> replace_length<span class="hl sym">);</span>
   <span class="hl sym">}</span>

   std<span class="hl sym">::</span>cout <span class="hl sym">&lt;&lt; (</span>   boost<span class="hl sym">::</span><span class="hl kwd">format</span><span class="hl sym">(</span><span class="hl str">&quot;%1%</span><span class="hl esc">\n</span><span class="hl str">%2%</span><span class="hl esc">\n</span><span class="hl str">%3%</span><span class="hl esc">\n</span><span class="hl str">%4%</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl sym">)</span>
      <span class="hl sym">%</span> match_result
      <span class="hl sym">%</span> initial_length <span class="hl sym">%</span> striped_length <span class="hl sym">%</span> replace_length <span class="hl sym">);</span>

   <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl sym">;</span>
<span class="hl sym">}</span>

