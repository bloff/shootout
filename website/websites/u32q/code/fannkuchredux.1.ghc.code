<span class="hl com">{-  The Computer Language Benchmarks Game</span>
<span class="hl com">    http://shootout.alioth.debian.org/</span>
<span class="hl com">    contributed by Miha Vučkovič</span>
<span class="hl com">-}</span>

module Main where
   import Prelude hiding <span class="hl sym">(</span>flip<span class="hl sym">)</span>
   import System

   flip <span class="hl sym">(</span><span class="hl num">2</span><span class="hl sym">:</span>x1<span class="hl sym">:</span>t<span class="hl sym">) =</span> x1<span class="hl sym">:</span><span class="hl num">2</span><span class="hl sym">:</span>t
   flip <span class="hl sym">(</span><span class="hl num">3</span><span class="hl sym">:</span>x1<span class="hl sym">:</span>x2<span class="hl sym">:</span>t<span class="hl sym">) =</span> x2<span class="hl sym">:</span>x1<span class="hl sym">:</span><span class="hl num">3</span><span class="hl sym">:</span>t
   flip <span class="hl sym">(</span><span class="hl num">4</span><span class="hl sym">:</span>x1<span class="hl sym">:</span>x2<span class="hl sym">:</span>x3<span class="hl sym">:</span>t<span class="hl sym">) =</span> x3<span class="hl sym">:</span>x2<span class="hl sym">:</span>x1<span class="hl sym">:</span><span class="hl num">4</span><span class="hl sym">:</span>t
   flip <span class="hl sym">(</span><span class="hl num">5</span><span class="hl sym">:</span>x1<span class="hl sym">:</span>x2<span class="hl sym">:</span>x3<span class="hl sym">:</span>x4<span class="hl sym">:</span>t<span class="hl sym">) =</span> x4<span class="hl sym">:</span>x3<span class="hl sym">:</span>x2<span class="hl sym">:</span>x1<span class="hl sym">:</span><span class="hl num">5</span><span class="hl sym">:</span>t

   flip lst<span class="hl sym">&#64;(</span>h<span class="hl sym">:</span>t<span class="hl sym">) =</span> flip' h <span class="hl sym">([],</span>lst<span class="hl sym">)</span> where
      flip' <span class="hl num">0</span> <span class="hl sym">(</span>l<span class="hl sym">,</span> r<span class="hl sym">) =</span> l <span class="hl sym">++</span> r
      flip' n <span class="hl sym">(</span>l<span class="hl sym">, (</span>h2<span class="hl sym">:</span>t2<span class="hl sym">)) =</span> flip' <span class="hl sym">(</span>n<span class="hl sym">-</span><span class="hl num">1</span><span class="hl sym">) (</span>h2<span class="hl sym">:</span>l<span class="hl sym">,</span> t2<span class="hl sym">)</span>

   runFlip lst <span class="hl sym">=</span> runFlip' <span class="hl num">0</span> lst where
      runFlip' n <span class="hl sym">(</span><span class="hl num">1</span><span class="hl sym">:</span>_<span class="hl sym">) =</span> n
      runFlip' n lst <span class="hl sym">=</span> runFlip' <span class="hl sym">(</span>n<span class="hl sym">+</span><span class="hl num">1</span><span class="hl sym">)</span> $ flip lst

   rotate n lst<span class="hl sym">&#64;(</span>h<span class="hl sym">:</span>t<span class="hl sym">) =</span> rotate' n t h where
      rotate' <span class="hl num">1</span> lst e <span class="hl sym">=</span> e<span class="hl sym">:</span>lst
      rotate' n <span class="hl sym">(</span>h<span class="hl sym">:</span>t<span class="hl sym">)</span> e <span class="hl sym">=</span> h<span class="hl sym">:(</span>rotate' <span class="hl sym">(</span>n<span class="hl sym">-</span><span class="hl num">1</span><span class="hl sym">)</span> t e<span class="hl sym">)</span>

   skip <span class="hl sym">:: [</span>Int<span class="hl sym">] -&gt;</span> Bool
   skip p<span class="hl sym">&#64;(</span>h'<span class="hl sym">:</span>_<span class="hl sym">) =</span> h' <span class="hl sym">==</span> <span class="hl num">1</span> <span class="hl sym">||</span> h <span class="hl sym">==</span> l where
      <span class="hl sym">(</span>h<span class="hl sym">:</span>_<span class="hl sym">) =</span> reverse p
      l <span class="hl sym">=</span> length p

   permut n <span class="hl sym">=</span> filter <span class="hl sym">(</span>\<span class="hl sym">(</span>_<span class="hl sym">,</span>p<span class="hl sym">) -&gt;</span> not.skip $ p<span class="hl sym">)</span> $ zip <span class="hl sym">(</span>concat.repeat $ <span class="hl sym">[(+),(-)]) (</span>foldr perm' <span class="hl sym">[[</span><span class="hl num">1</span>..n<span class="hl sym">]] [</span><span class="hl num">2</span>..n<span class="hl sym">])</span> where
      perm' x lst <span class="hl sym">=</span> concat <span class="hl sym">[</span>take x $ iterate <span class="hl sym">(</span>rotate x<span class="hl sym">)</span> l <span class="hl sym">|</span> l <span class="hl sym">&lt;-</span> lst<span class="hl sym">]</span>

   main <span class="hl sym">=</span>
      do   <span class="hl sym">[</span>f<span class="hl sym">] &lt;-</span> getArgs
         let n <span class="hl sym">=</span> read f
         let checksum <span class="hl sym">=</span> sum $ map <span class="hl sym">(</span>\<span class="hl sym">(</span>f<span class="hl sym">,</span> flps<span class="hl sym">) -&gt;</span> f <span class="hl num">0</span> flps<span class="hl sym">) (</span>zip <span class="hl sym">(</span>fst $ unzipped n<span class="hl sym">) (</span>map runFlip <span class="hl sym">(</span>snd $ unzipped n<span class="hl sym">)))</span>
         let maxflips <span class="hl sym">=</span> maximum <span class="hl sym">(</span>map runFlip $ <span class="hl sym">(</span>snd $ unzipped n<span class="hl sym">))</span>
         putStrLn $ show checksum
         putStrLn $ <span class="hl str">&quot;Pfannkuchen(&quot;</span> <span class="hl sym">++</span> f <span class="hl sym">++</span> <span class="hl str">&quot;) = &quot;</span> <span class="hl sym">++ (</span>show maxflips<span class="hl sym">)</span>
      where
         unzipped n <span class="hl sym">=</span> unzip $ permut n
