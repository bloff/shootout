<span class="hl com">(*</span>
<span class="hl com">** The Computer Language Benchmarks Game</span>
<span class="hl com">** http://shootout.alioth.debian.org/</span>
<span class="hl com">**</span>
<span class="hl com">** contributed by Hongwei Xi</span>
<span class="hl com">**</span>
<span class="hl com">** compilation command:</span>
<span class="hl com">**   atscc -D_GNU_SOURCE -D_ATS_MULTITHREAD -D_ATS_GCATS -O3 -o k-nucleotide3_smp -lpthread k-nucleotide3_smp.dats</span>
<span class="hl com">*)</span>

<span class="hl com">(* ****** ****** *)</span>

staload <span class="hl str">&quot;libc/SATS/stdio.sats&quot;</span>
staload <span class="hl str">&quot;libc/SATS/stdlib.sats&quot;</span>
staload <span class="hl str">&quot;libc/SATS/string.sats&quot;</span>
staload _<span class="hl com">(*anonymous*)</span> <span class="hl sym">=</span> <span class="hl str">&quot;prelude/DATS/array.dats&quot;</span>
staload _<span class="hl com">(*anonymous*)</span> <span class="hl sym">=</span> <span class="hl str">&quot;prelude/DATS/list_vt.dats&quot;</span>

<span class="hl com">(* ****** ****** *)</span>

staload H <span class="hl sym">=</span> <span class="hl str">&quot;libats/SATS/hashtable_chain.sats&quot;</span>
staload _<span class="hl com">(*anon*)</span> <span class="hl sym">=</span> <span class="hl str">&quot;libats/DATS/hashtable_chain.dats&quot;</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl sym">%{</span>^
<span class="hl kwa">typedef</span> char <span class="hl sym">*</span>symbol_t <span class="hl sym">;</span>
<span class="hl sym">%}</span> <span class="hl slc">// end of [%{^]</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl kwa">abstype</span> dna_t <span class="hl slc">// boxed type</span>
abst&#64;ype symbol_t <span class="hl sym">=</span> $extype <span class="hl str">&quot;symbol_t&quot;</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl sym">%{</span>^

ats_void_type print_symbol
  <span class="hl sym">(</span>symbol_t sym<span class="hl sym">,</span> ats_size_type len<span class="hl sym">) {</span>
  <span class="hl kwa">while</span> <span class="hl sym">(</span>len <span class="hl sym">&gt;</span> <span class="hl num">0</span><span class="hl sym">) {</span> fputc <span class="hl com">(*sym, stdout) ; --len ; ++sym ; }</span>
<span class="hl com">  return ;</span>
<span class="hl com">} // end of [print_symbol]</span>
<span class="hl com"></span>
<span class="hl com">%} // end of [%{^]</span>
<span class="hl com"></span>
<span class="hl com">extern fun print_symbol</span>
<span class="hl com">  (sym: symbol_t, len: size_t): void = &quot;print_symbol&quot;</span>
<span class="hl com">// end of [print_symbol]</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">%{^</span>
<span class="hl com"></span>
<span class="hl com">size_t the_symlen = 0 ;</span>
<span class="hl com">ats_size_type symlen_get () { return the_symlen ; }</span>
<span class="hl com">ats_void_type symlen_set</span>
<span class="hl com">  (ats_size_type len) { the_symlen = len ; return ; }</span>
<span class="hl com">// end of [symlen_set]</span>
<span class="hl com"></span>
<span class="hl com">%} // end of [%{^]</span>
<span class="hl com">extern fun symlen_get ():&lt;&gt; size_t = &quot;symlen_get&quot;</span>
<span class="hl com">extern fun symlen_set (len: size_t):&lt;&gt; void = &quot;symlen_set&quot;</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">%{^</span>
<span class="hl com"></span>
<span class="hl com">// a commonly used simple hash function</span>
<span class="hl com"></span>
<span class="hl com">static // inline</span>
<span class="hl com">ats_ulint_type hash_symbol_len (</span>
<span class="hl com">  symbol_t sym, ats_size_type len</span>
<span class="hl com">) {</span>
<span class="hl com">  unsigned long int hash_val = 31415927UL ;</span>
<span class="hl com">  while (len &gt;= 4) {</span>
<span class="hl com">    hash_val += hash_val * 33 ;</span>
<span class="hl com">    hash_val += sym[0] &lt;&lt; 24 ;</span>
<span class="hl com">    hash_val += sym[1] &lt;&lt; 16 ;</span>
<span class="hl com">    hash_val += sym[2] &lt;&lt;  8 ;</span>
<span class="hl com">    hash_val += sym[3] ;</span>
<span class="hl com">    sym += 4 ; len -= 4 ;</span>
<span class="hl com">  } // end of [while]</span>
<span class="hl com">  if (len &gt;= 2) {</span>
<span class="hl com">    hash_val = hash_val * 33 + (sym[0] &lt;&lt; 8) + sym[1] ;</span>
<span class="hl com">    sym += 2 ; len -= 2 ;</span>
<span class="hl com">  } // end of [if]</span>
<span class="hl com">  if (len &gt;= 1) {</span>
<span class="hl com">    hash_val = hash_val * 33 + sym[0] ;</span>
<span class="hl com">  } // end of [while]</span>
<span class="hl com">  return hash_val ;</span>
<span class="hl com">} // end of [hash_symbol_len]</span>
<span class="hl com"></span>
<span class="hl com">%} // end of [%{^]</span>
<span class="hl com"></span>
<span class="hl com">extern fun hash_symbol_len</span>
<span class="hl com">  (sym: symbol_t, len: size_t):&lt;&gt; ulint = &quot;hash_symbol_len&quot;</span>
<span class="hl com">// end of [hash_symbol]</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">implement $H.hash_key&lt;symbol_t&gt;</span>
<span class="hl com">  (x, _) = hash_symbol_len (x, symlen_get ())</span>
<span class="hl com">// end of [implement]</span>
<span class="hl com"></span>
<span class="hl com">implement</span>
<span class="hl com">$H.equal_key_key&lt;symbol_t&gt; (x1, x2, _) = let</span>
<span class="hl com">  extern castfn __cast (x: symbol_t):&lt;&gt; string</span>
<span class="hl com">  val x1 = __cast x1 and x2 = __cast x2</span>
<span class="hl com">  val k = symlen_get ()</span>
<span class="hl com">  val k = size1_of_size (k)</span>
<span class="hl com">in</span>
<span class="hl com">  strncmp (x1, x2, k) = 0</span>
<span class="hl com">end // end of [implement]</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">viewtypedef symtbl (l:addr) = $H.HASHTBLptr (symbol_t, int, l)</span>
<span class="hl com">viewtypedef symtbl0 = [l:addr] symtbl l</span>
<span class="hl com">viewtypedef symtbl1 = [l:anz] symtbl l</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">extern fun succ_symbol</span>
<span class="hl com">  (x: symbol_t): symbol_t = &quot;#atspre_psucc&quot;</span>
<span class="hl com">extern fun add_symbol_size</span>
<span class="hl com">  (x: symbol_t, n: size_t): symbol_t = &quot;#atspre_padd_size&quot;</span>
<span class="hl com"></span>
<span class="hl com">fn dna_count_one {l:anz} {n1,n2:nat}</span>
<span class="hl com">  (tbl: !symtbl l, dna: dna_t, n1: size_t n1, n2: size_t n2): void = let</span>
<span class="hl com">  var n1: size_t = n1</span>
<span class="hl com">  val sym0: symbol_t =</span>
<span class="hl com">    __cast (dna) where { extern castfn __cast (x: dna_t): symbol_t }</span>
<span class="hl com">  // end of [var]</span>
<span class="hl com">  var sym: symbol_t = add_symbol_size (sym0, n1)</span>
<span class="hl com">in</span>
<span class="hl com">  while (n1 &lt; n2) let</span>
<span class="hl com">    val [l_itm:addr] p_itm = $H.hashtbl_search_ref&lt;symbol_t,int&gt; (tbl, sym)</span>
<span class="hl com">    val () = if p_itm &lt;&gt; null then let</span>
<span class="hl com">      prval (fpf, pf) = __assert () where {</span>
<span class="hl com">        extern prfun __assert (): (int&#64;l_itm -&lt;prf&gt; void, int&#64;l_itm)</span>
<span class="hl com">      } // end of [prval]</span>
<span class="hl com">      val () = !p_itm := !p_itm + 1</span>
<span class="hl com">      prval () = fpf (pf)</span>
<span class="hl com">    in</span>
<span class="hl com">      // nothing</span>
<span class="hl com">    end else $H.hashtbl_insert (tbl, sym, 1)</span>
<span class="hl com">  in</span>
<span class="hl com">    n1 := n1 + 1; sym := succ_symbol sym</span>
<span class="hl com">  end // end of [while]</span>
<span class="hl com">end // end of [dna_count_one]</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">staload &quot;libats/SATS/parworkshop.sats&quot;</span>
<span class="hl com">staload _ = &quot;libats/DATS/parworkshop.dats&quot;</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">viewtypedef work = () -&lt;lincloptr1&gt; void</span>
<span class="hl com">viewtypedef WSptr (l:addr) = WORKSHOPptr (work, l)</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">fun fwork {l:addr}</span>
<span class="hl com">  (ws: !WSptr l, wk: &amp;work &gt;&gt; work?): int = let</span>
<span class="hl com">  val wk = wk</span>
<span class="hl com">  val pfun = __cast (wk) where {</span>
<span class="hl com">    extern castfn __cast</span>
<span class="hl com">      (wk: !work &gt;&gt; opt (work, i &gt;= 1)): #[i:nat] uintptr i</span>
<span class="hl com">  } // end of [val]</span>
<span class="hl com">in</span>
<span class="hl com">  if pfun &gt;= (uintptr1_of_uint1)1U then let</span>
<span class="hl com">    prval () = opt_unsome {work} (wk)</span>
<span class="hl com">    val () = wk ()</span>
<span class="hl com">    val () = cloptr_free (wk)</span>
<span class="hl com">  in</span>
<span class="hl com">    1 // the worker is to continue</span>
<span class="hl com">  end else let</span>
<span class="hl com">    val u = uint1_of_uintptr1 (pfun)</span>
<span class="hl com">    val i = int_of_uint (u)</span>
<span class="hl com">    prval () = opt_unnone {work} (wk)</span>
<span class="hl com">    prval () = cleanup_top {work} (wk)</span>
<span class="hl com">  in</span>
<span class="hl com">    ~i // the worker is to pause or quit</span>
<span class="hl com">  end // end of [if]</span>
<span class="hl com">end // end of [fwork]</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">val eqfn = $extval ($H.eq symbol_t, &quot;0&quot;)</span>
<span class="hl com">val fhash = $extval ($H.hash symbol_t, &quot;0&quot;)</span>
<span class="hl com">macdef hastbl_make () = $H.hashtbl_make_hint (fhash, eqfn, 24593)</span>
<span class="hl com"></span>
<span class="hl com">fn dna_count {lws:addr} {n:pos;k:pos} {N:pos} (</span>
<span class="hl com">    ws: !WSptr lws</span>
<span class="hl com">  , dna: dna_t</span>
<span class="hl com">  , n: size_t n</span>
<span class="hl com">  , k: size_t k</span>
<span class="hl com">  , N: int N // nthread</span>
<span class="hl com">  ) : List_vt (symtbl1) = let</span>
<span class="hl com">  val () = symlen_set (k)</span>
<span class="hl com">  val INC = ((n + N - 1) / N): size_t</span>
<span class="hl com">  val [inc:int] INC = size1_of_size (INC)</span>
<span class="hl com">  prval () = __assert () where {</span>
<span class="hl com">    extern prfun __assert (): [inc &gt; 0] void</span>
<span class="hl com">  }</span>
<span class="hl com">  fun split {n1,n2:nat} (</span>
<span class="hl com">      ws: !WSptr lws, n1: size_t n1, n2: size_t n2</span>
<span class="hl com">    ) :&lt;cloref1&gt; List_vt (symtbl1) =</span>
<span class="hl com">    if n1 &lt; n2 then let</span>
<span class="hl com">      val n11 = min (n1 + INC, n2)</span>
<span class="hl com">      val [l:addr] tbl = hastbl_make ()</span>
<span class="hl com">      extern castfn __ref (x: !symtbl l):&lt;&gt; symtbl l</span>
<span class="hl com">      val tbl1 = __ref (tbl)</span>
<span class="hl com">      val f = lam (): void =&lt;lincloptr1&gt; () where {</span>
<span class="hl com">        val () = dna_count_one (tbl1, dna, n1, n11)</span>
<span class="hl com">        prval () = __unref tbl1 where { extern prfun __unref (x: symtbl l): void }</span>
<span class="hl com">      } // end of [val]</span>
<span class="hl com">      val () = workshop_insert_work (ws, f)</span>
<span class="hl com">    in</span>
<span class="hl com">      list_vt_cons (tbl, split (ws, n11, n2))</span>
<span class="hl com">    end else list_vt_nil ()</span>
<span class="hl com">  // end of [split]</span>
<span class="hl com">  val res = split (ws, 0, n)</span>
<span class="hl com">  val () = workshop_wait_blocked_all (ws)</span>
<span class="hl com">in</span>
<span class="hl com">  res</span>
<span class="hl com">end // end of [dna_count]</span>
<span class="hl com"></span>
<span class="hl com">extern fun symtbls_merge (xs: List_vt symtbl1): symtbl0</span>
<span class="hl com">implement symtbls_merge (xs) = let</span>
<span class="hl com">  fun loop {l:addr} {l:anz}</span>
<span class="hl com">    (x: !symtbl l, xs: List_vt symtbl1): void =</span>
<span class="hl com">    case+ xs of</span>
<span class="hl com">    | ~list_vt_cons (x1, xs) =&gt; let</span>
<span class="hl com">        val xp = $H.ptr_of_HASHTBLptr (x)</span>
<span class="hl com">        var !p_clo = &#64;lam</span>
<span class="hl com">          (pf: !unit_v | k: symbol_t, i: &amp;int): void =&lt;clo&gt; let</span>
<span class="hl com">          val x = __ref (xp) where {</span>
<span class="hl com">            extern castfn __ref (x: ptr l):&lt;&gt; symtbl l</span>
<span class="hl com">          }</span>
<span class="hl com">          val [l_itm:addr] p_itm = $H.hashtbl_search_ref&lt;symbol_t,int&gt; (x, k)</span>
<span class="hl com">          val () = if p_itm &lt;&gt; null then let</span>
<span class="hl com">            prval (fpf, pf) = __assert () where {</span>
<span class="hl com">              extern prfun __assert (): (int&#64;l_itm -&lt;prf&gt; void, int&#64;l_itm)</span>
<span class="hl com">            } // end of [prval]</span>
<span class="hl com">            val () = !p_itm := !p_itm + i</span>
<span class="hl com">            prval () = fpf (pf)</span>
<span class="hl com">          in</span>
<span class="hl com">            // nothing</span>
<span class="hl com">          end else $H.hashtbl_insert (x, k, i)</span>
<span class="hl com">          prval () = __unref (x) where {</span>
<span class="hl com">            extern prfun __unref (x: symtbl l): void</span>
<span class="hl com">          }</span>
<span class="hl com">        in</span>
<span class="hl com">          // nothing</span>
<span class="hl com">        end // end of [var]</span>
<span class="hl com">        prval pf = unit_v ()</span>
<span class="hl com">        val () = $H.hashtbl_foreach_clo {unit_v} (pf | x1, !p_clo)</span>
<span class="hl com">        prval unit_v () = pf</span>
<span class="hl com">        val () = $H.hashtbl_free (x1)</span>
<span class="hl com">      in</span>
<span class="hl com">        loop (x, xs)</span>
<span class="hl com">      end // end of [list_vt_cons]</span>
<span class="hl com">    | ~list_vt_nil () =&gt; ()</span>
<span class="hl com">  // end of [loop]</span>
<span class="hl com">in</span>
<span class="hl com">  case+ xs of</span>
<span class="hl com">  | ~list_vt_cons (x, xs) =&gt;</span>
<span class="hl com">      let val () = loop (x, xs) in x end</span>
<span class="hl com">    // end of [list_vt_cons]</span>
<span class="hl com">  | ~list_vt_nil () =&gt; __cast (null) where {</span>
<span class="hl com">      extern castfn __cast (x: ptr null):&lt;&gt; $H.HASHTBLptr (symbol_t, int, null)</span>
<span class="hl com">    } // end of [list_vt_nil]</span>
<span class="hl com">end // end of [symtbls_merge]</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">typedef symflt = &#64;(symbol_t, float)</span>
<span class="hl com"></span>
<span class="hl com">fn compare_symflt_symflt // [&gt;=]</span>
<span class="hl com">  (x1: &amp;symflt, x2: &amp;symflt):&lt;&gt; Sgn = compare_float_float (x2.1, x1.1)</span>
<span class="hl com">// end of [compare_symflt_symflt]</span>
<span class="hl com"></span>
<span class="hl com">viewtypedef frqlst = List_vt symflt</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">// print and free</span>
<span class="hl com">fun print_free_frqlst</span>
<span class="hl com">  (kfs: frqlst, len: size_t): void = begin case+ kfs of</span>
<span class="hl com">  | ~list_vt_cons (kf, kfs) =&gt; begin print_symbol (kf.0, len);</span>
<span class="hl com">       printf (&quot; %.3f\n&quot;, &#64;(double_of kf.1)); print_free_frqlst (kfs, len)</span>
<span class="hl com">    end // end of [FRQLSTcons]</span>
<span class="hl com">  | ~list_vt_nil () =&gt; ()</span>
<span class="hl com">end // end of [print_free_frqlst]</span>
<span class="hl com"></span>
<span class="hl com">fn write_frequencies</span>
<span class="hl com">  {lws:addr} {n,k:pos | k &lt;= n} {N:pos} (</span>
<span class="hl com">    ws: !WSptr lws, dna: dna_t, n: size_t n, k: size_t k, N: int N</span>
<span class="hl com">  ) : void = let</span>
<span class="hl com">//</span>
<span class="hl com">  val tbls = dna_count (ws, dna, n-k+1, k, N)</span>
<span class="hl com">  val tbl = symtbls_merge (tbls)</span>
<span class="hl com">  val ptbl = $H.ptr_of_HASHTBLptr tbl</span>
<span class="hl com">  val () = assert_errmsg (ptbl &lt;&gt; null, #LOCATION)</span>
<span class="hl com">//</span>
<span class="hl com">  var total: int = 0</span>
<span class="hl com">  var !p_clo = &#64;lam (pf: !int&#64;total | k: symbol_t, i: &amp;int): void =&lt;clo&gt;</span>
<span class="hl com">    (total := total + i)</span>
<span class="hl com">  val () = $H.hashtbl_foreach_clo {int&#64;total} (view&#64; total | tbl, !p_clo)</span>
<span class="hl com">  val ftotal = float_of total</span>
<span class="hl com">  var frqs: frqlst = list_vt_nil ()</span>
<span class="hl com">  var !p_clo = &#64;lam</span>
<span class="hl com">    (pf: !frqlst &#64; frqs | k: symbol_t, cnt: &amp;int): void =&lt;clo&gt; let</span>
<span class="hl com">    val f = (float_of 100) * float_of cnt / ftotal; val kf = &#64;(k, f) in</span>
<span class="hl com">    frqs := list_vt_cons (kf, frqs)</span>
<span class="hl com">  end // end of [f]</span>
<span class="hl com">  val () = $H.hashtbl_foreach_clo {frqlst&#64;frqs} (view&#64; frqs | tbl, !p_clo)</span>
<span class="hl com">  val () = $H.hashtbl_free (tbl)</span>
<span class="hl com">  val () = list_vt_quicksort (frqs, compare_symflt_symflt)</span>
<span class="hl com">in</span>
<span class="hl com">  print_free_frqlst (frqs, symlen_get ())</span>
<span class="hl com">end // end of [write_frequencies]</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">fn write_count {lws:addr} {n,k:pos} {N:pos} (</span>
<span class="hl com">    ws: !WSptr lws, dna: dna_t, n: size_t n, seq: string k, N: int N</span>
<span class="hl com">  ): void = let</span>
<span class="hl com">  val k = string1_length seq</span>
<span class="hl com">  val () = assert_errmsg (k &lt;= n, #LOCATION)</span>
<span class="hl com">//</span>
<span class="hl com">  val tbls = dna_count (ws, dna, n-k+1, k, N)</span>
<span class="hl com">  val seq1 = __cast seq where {</span>
<span class="hl com">    extern castfn __cast (x: string): symbol_t</span>
<span class="hl com">  } // end of [var]</span>
<span class="hl com">  val cnt = loop (tbls, seq1, 0) where {</span>
<span class="hl com">    fun loop (xs: List_vt symtbl1, seq: symbol_t, cnt: int): int =</span>
<span class="hl com">      case+ xs of</span>
<span class="hl com">      | ~list_vt_cons (x, xs) =&gt; let</span>
<span class="hl com">          var res : int</span>
<span class="hl com">          val ans = $H.hashtbl_search (x, seq, res)</span>
<span class="hl com">          val () = $H.hashtbl_free (x)</span>
<span class="hl com">          val () = if ans then let</span>
<span class="hl com">            prval () = opt_unsome {int} (res) in (*none*)</span>
<span class="hl com">          end else let</span>
<span class="hl com">            prval () = opt_unnone {int} (res) in res := 0</span>
<span class="hl com">          end : void // end of [val]</span>
<span class="hl com">        in</span>
<span class="hl com">          loop (xs, seq, cnt + res)</span>
<span class="hl com">        end // end of [list_vt_cons]</span>
<span class="hl com">      | ~list_vt_nil () =&gt; cnt</span>
<span class="hl com">    // end of [loop]</span>
<span class="hl com">  } // end of [cnt]</span>
<span class="hl com">//</span>
<span class="hl com">in</span>
<span class="hl com">  printf (&quot;%d\t%s\n&quot;, &#64;(cnt, seq))</span>
<span class="hl com">end // end of [write_count]</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">extern fun getline (): string = &quot;__getline&quot;</span>
<span class="hl com">extern fun getrest (sz: &amp;size_t? &gt;&gt; size_t n): #[n:nat] string n = &quot;__getrest&quot;</span>
<span class="hl com"></span>
<span class="hl com">%{$</span>
<span class="hl com"></span>
<span class="hl com">#define LINEBUFSZ 1024</span>
<span class="hl com">char theLineBuffer[LINEBUFSZ] ;</span>
<span class="hl com">ats_ptr_type __getline () {</span>
<span class="hl com">  fgets (theLineBuffer, LINEBUFSZ, stdin) ; return theLineBuffer ;</span>
<span class="hl com">} /* end of [getline] */</span>
<span class="hl com"></span>
<span class="hl com">#define RESTBUFSZ (128 * 1024 * 1024)</span>
<span class="hl com">char theRestBuffer[RESTBUFSZ] ;</span>
<span class="hl com"></span>
<span class="hl com">ats_ptr_type __getrest (ats_ref_type p_n) {</span>
<span class="hl com">  int c ; size_t i ; char *s ;</span>
<span class="hl com">  s = theRestBuffer ; i = 0 ;</span>
<span class="hl com">  while ((c = fgetc(stdin)) != EOF) {</span>
<span class="hl com">    if (c != '\n') { *s++ = toupper(c) ; i++ ; }</span>
<span class="hl com">  }</span>
<span class="hl com">  *s = '\000' ; *((size_t*)p_n) = i ;</span>
<span class="hl com">  if (i &gt;= RESTBUFSZ) {</span>
<span class="hl com">    fprintf (stderr, &quot;exit(ATS): too much data for processing\n&quot;) ; exit(1) ;</span>
<span class="hl com">  }</span>
<span class="hl com">  return theRestBuffer ;</span>
<span class="hl com">} /* end of [__getrest] */</span>
<span class="hl com"></span>
<span class="hl com">%} // end of [%{^]</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">fun is_three (s: string): bool =</span>
<span class="hl com">  if strncmp (s, &quot;&gt;THREE&quot;, 6) = 0 then true else false</span>
<span class="hl com">// end of [is_three]</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">staload &quot;libc/SATS/sched.sats&quot;</span>
<span class="hl com">staload TYPES = &quot;libc/sys/SATS/types.sats&quot;</span>
<span class="hl com">macdef pid_t = $TYPES.pid_of_int</span>
<span class="hl com"></span>
<span class="hl com">extern fun ncore_get (): int</span>
<span class="hl com">implement ncore_get () = let</span>
<span class="hl com">  var cs: cpu_set0_t // uninitialized</span>
<span class="hl com">  prval () = cpusetinit (cs) // not a real initialization</span>
<span class="hl com">  stavar nset: int</span>
<span class="hl com">  val nset = cpusetsize_get (cs)</span>
<span class="hl com">  val () = assert_errmsg (nset &gt;= 2, #LOCATION)</span>
<span class="hl com">  val err = sched_getaffinity ((pid_t)0, nset, cs)</span>
<span class="hl com">  var count: Nat = 0</span>
<span class="hl com">  var i: natLte 16 // uninitialized</span>
<span class="hl com">  val () = for* (cs: cpu_set_t nset) =&gt;</span>
<span class="hl com">    (i := 0; i &lt; 16; i := i + 1)</span>
<span class="hl com">    if (CPU_ISSET (i, cs) &gt; 0) then count := count + 1</span>
<span class="hl com">  // end of [val]</span>
<span class="hl com">in</span>
<span class="hl com">  count</span>
<span class="hl com">end // end of [ncore_get]</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">extern fun dna_of_string (s: string): dna_t = &quot;dna_of_string&quot;</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">#define QSZ 1024</span>
<span class="hl com"></span>
<span class="hl com">implement main (argc, argv) = let</span>
<span class="hl com">//</span>
<span class="hl com">  val () = gc_chunk_count_limit_set (1 &lt;&lt; 15)</span>
<span class="hl com">  val () = gc_chunk_count_limit_max_set (~1) // no max</span>
<span class="hl com">//</span>
<span class="hl com">  val ncore = ncore_get ()</span>
<span class="hl com">  val nworker =</span>
<span class="hl com">    (if (argc &gt;= 2) then int_of argv.[1] else 0): int</span>
<span class="hl com">  val nworker : int = if nworker &gt; 0 then nworker else ncore</span>
<span class="hl com">  val nworker = int1_of_int (nworker)</span>
<span class="hl com">  val () = assert_errmsg (nworker &gt; 0, #LOCATION)</span>
<span class="hl com">//</span>
<span class="hl com">  fun dna_three_get</span>
<span class="hl com">    (n: &amp;size_t? &gt;&gt; size_t n): #[n:nat] string n = let</span>
<span class="hl com">    val s = getline (); val is3 = is_three (s)</span>
<span class="hl com">  in</span>
<span class="hl com">    if is3 then getrest (n) else dna_three_get (n)</span>
<span class="hl com">  end // end of [dna_three_get]</span>
<span class="hl com">  var n: size_t // uninitialized</span>
<span class="hl com">  val dna_three = dna_three_get (n)</span>
<span class="hl com">  val () = assert (n &gt;= 2)</span>
<span class="hl com">(*</span>
<span class="hl com">  val () = (prerr &quot;main: n = &quot;; prerr n; prerr_newline ())</span>
<span class="hl com">*)</span>
<span class="hl com">  val dna3 =</span>
<span class="hl com">    dna_of_string dna_three where {</span>
<span class="hl com">    extern castfn dna_of_string (str: string): dna_t</span>
<span class="hl com">  } // end of [val]</span>
<span class="hl com">//</span>
<span class="hl com">  // val () = (print &quot;nworker = &quot;; print nworker; print_newline ())</span>
<span class="hl com">//</span>
<span class="hl com">  val ws = workshop_make&lt;work&gt; (QSZ, fwork)</span>
<span class="hl com">  val _err = workshop_add_nworker (ws, nworker)</span>
<span class="hl com">  val () = assert_errmsg (_err = 0, #LOCATION)</span>
<span class="hl com">//</span>
<span class="hl com">  val () = write_frequencies (ws, dna3, n, 1, nworker)</span>
<span class="hl com">  val () = print_newline ()</span>
<span class="hl com">  val () = write_frequencies (ws, dna3, n, 2, nworker)</span>
<span class="hl com">  val () = print_newline ()</span>
<span class="hl com">  val () = write_count (ws, dna3, n, &quot;GGT&quot;, nworker)</span>
<span class="hl com">  val () = write_count (ws, dna3, n, &quot;GGTA&quot;, nworker)</span>
<span class="hl com">  val () = write_count (ws, dna3, n, &quot;GGTATT&quot;, nworker)</span>
<span class="hl com">  val () = write_count (ws, dna3, n, &quot;GGTATTTTAATT&quot;, nworker)</span>
<span class="hl com">  val () = write_count (ws, dna3, n, &quot;GGTATTTTAATTTATAGT&quot;, nworker)</span>
<span class="hl com">//</span>
<span class="hl com">  var i: Nat = 0</span>
<span class="hl com">  val () = while (i &lt; nworker) let</span>
<span class="hl com">    val _quit = $extval (work, &quot;(void*)0&quot;)</span>
<span class="hl com">    val () = workshop_insert_work (ws, _quit) in i := i + 1</span>
<span class="hl com">  end // end of [val]</span>
<span class="hl com">  val () = workshop_wait_quit_all (ws)</span>
<span class="hl com">  val () = workshop_free_vt_exn (ws)</span>
<span class="hl com">in</span>
<span class="hl com">  // nothing</span>
<span class="hl com">end (* end of [main] *)</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">(* end of [k-nucleotide3.dats] *)</span>
