<span class="hl com">(*</span>
<span class="hl com">** The Computer Language Benchmarks Game</span>
<span class="hl com">** http://shootout.alioth.debian.org/</span>
<span class="hl com">**</span>
<span class="hl com">** contributed by Hongwei Xi</span>
<span class="hl com">**</span>
<span class="hl com">** compilation command:</span>
<span class="hl com">**   atscc -O3 knucleotide.dats -o knucleotide -D_ATS_GCATS</span>
<span class="hl com">*)</span>

<span class="hl com">(*  SPLITFILE=knucleotide.dats *)</span>

<span class="hl com">(* ****** ****** *)</span>

staload <span class="hl str">&quot;libc/SATS/stdio.sats&quot;</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl sym">//</span> The hashtable implementation is based on linear<span class="hl sym">-</span>probing
<span class="hl dir">#include</span> <span class="hl dstr">&quot;symtbl.dats&quot;</span><span class="hl dir"></span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl kwa">extern fun</span> dna_count <span class="hl sym">{</span>n<span class="hl sym">,</span>k<span class="hl sym">:</span>nat <span class="hl sym">|</span> k <span class="hl sym">&lt;=</span> n<span class="hl sym">}</span>
  <span class="hl sym">(</span>tbl<span class="hl sym">:</span> symtbl_t<span class="hl sym">,</span> n<span class="hl sym">:</span> int n<span class="hl sym">,</span> k<span class="hl sym">:</span> int k<span class="hl sym">) :</span> symtbl_t <span class="hl sym">=</span> <span class="hl str">&quot;dna_count&quot;</span>

<span class="hl sym">//</span> a linear <span class="hl kwa">datatype</span>
<span class="hl kwa">dataviewtype</span> frqlst <span class="hl sym">=</span> FRQLSTnil <span class="hl sym">|</span> FRQLSTcons <span class="hl kwa">of</span> <span class="hl sym">(</span>symbol_t<span class="hl sym">,</span> float<span class="hl sym">,</span> frqlst<span class="hl sym">)</span>

<span class="hl sym">//</span> linear append
<span class="hl kwa">fun</span> frqlst_append
  <span class="hl sym">(</span>xs0<span class="hl sym">: &amp;</span>frqlst <span class="hl sym">&gt;&gt;</span> frqlst<span class="hl sym">,</span> ys<span class="hl sym">:</span> frqlst<span class="hl sym">):</span> void <span class="hl sym">=</span> <span class="hl kwa">begin case</span> xs0 <span class="hl kwa">of</span>
  <span class="hl sym">|</span> FRQLSTcons <span class="hl sym">(</span>k<span class="hl sym">,</span> f<span class="hl sym">, !</span>xs<span class="hl sym">) =&gt; (</span>frqlst_append <span class="hl sym">(!</span>xs<span class="hl sym">,</span> ys<span class="hl sym">);</span> fold&#64; xs0<span class="hl sym">)</span>
  <span class="hl sym">|</span> ~FRQLSTnil <span class="hl sym">() =&gt; (</span>xs0 <span class="hl sym">:=</span> ys<span class="hl sym">)</span>
<span class="hl kwa">end</span> <span class="hl sym">//</span> <span class="hl kwa">end of</span> <span class="hl sym">[</span>frqlst_append<span class="hl sym">]</span>

<span class="hl sym">//</span> quick sort
<span class="hl kwa">fun</span> qsort <span class="hl sym">(</span>xs<span class="hl sym">:</span> frqlst<span class="hl sym">):</span> frqlst <span class="hl sym">=</span> <span class="hl kwa">begin case</span><span class="hl sym">+</span> xs <span class="hl kwa">of</span>
  <span class="hl sym">|</span> FRQLSTcons <span class="hl sym">(!</span>k1_r<span class="hl sym">, !</span>f1_r<span class="hl sym">, !</span>xs1_r<span class="hl sym">) =&gt;</span> <span class="hl kwa">let</span>
      <span class="hl kwa">val</span> k1 <span class="hl sym">= !</span>k1_r <span class="hl kwa">and</span> f1 <span class="hl sym">= !</span>f1_r <span class="hl kwa">and</span> xs1 <span class="hl sym">= !</span>xs1_r
    <span class="hl kwa">in</span>
      partition <span class="hl sym">(</span>
        view&#64; <span class="hl sym">(!</span>k1_r<span class="hl sym">),</span> view&#64; <span class="hl sym">(!</span>f1_r<span class="hl sym">),</span> view&#64; <span class="hl sym">(!</span>xs1_r<span class="hl sym">)</span>
      <span class="hl sym">|</span> xs<span class="hl sym">,</span> xs1_r<span class="hl sym">,</span> k1<span class="hl sym">,</span> f1<span class="hl sym">,</span> xs1<span class="hl sym">,</span> FRQLSTnil <span class="hl sym">(),</span> FRQLSTnil <span class="hl sym">()</span>
      <span class="hl sym">) //</span> <span class="hl kwa">end of</span> <span class="hl sym">[</span>partition<span class="hl sym">]</span>
    <span class="hl kwa">end</span>
  <span class="hl sym">|</span> FRQLSTnil <span class="hl sym">() =&gt; (</span>fold&#64; xs<span class="hl sym">;</span> xs<span class="hl sym">)</span>
<span class="hl kwa">end</span> <span class="hl sym">//</span> <span class="hl kwa">end of</span> <span class="hl sym">[</span>qsort<span class="hl sym">]</span>

<span class="hl kwa">and</span> partition <span class="hl sym">{</span>l00<span class="hl sym">,</span>l01<span class="hl sym">,</span>l1<span class="hl sym">:</span>addr<span class="hl sym">}</span>
  <span class="hl sym">(</span>pf00<span class="hl sym">:</span> symbol_t &#64; l00<span class="hl sym">,</span> pf01<span class="hl sym">:</span> float &#64; l01<span class="hl sym">,</span> pf1<span class="hl sym">:</span> frqlst? &#64; l1 <span class="hl sym">|</span>
   node<span class="hl sym">:</span> FRQLSTcons_unfold <span class="hl sym">(</span>l00<span class="hl sym">,</span> l01<span class="hl sym">,</span> l1<span class="hl sym">),</span> node1<span class="hl sym">:</span> ptr l1<span class="hl sym">,</span>
   k0<span class="hl sym">:</span> symbol_t<span class="hl sym">,</span> f0<span class="hl sym">:</span> float<span class="hl sym">,</span> xs<span class="hl sym">:</span> frqlst<span class="hl sym">,</span> l<span class="hl sym">:</span> frqlst<span class="hl sym">,</span> r<span class="hl sym">:</span> frqlst<span class="hl sym">)</span>
  <span class="hl sym">:</span> frqlst <span class="hl sym">=</span> <span class="hl kwa">begin case</span><span class="hl sym">+</span> xs <span class="hl kwa">of</span>
  <span class="hl sym">|</span> FRQLSTcons <span class="hl sym">(</span>k1<span class="hl sym">,</span> f1<span class="hl sym">, !</span>xs1_r<span class="hl sym">) =&gt;</span>
    <span class="hl kwa">let val</span> xs1 <span class="hl sym">= !</span>xs1_r <span class="hl kwa">in</span>
      <span class="hl kwa">if</span> compare <span class="hl sym">(</span>f1<span class="hl sym">,</span> f0<span class="hl sym">) &gt;=</span> <span class="hl num">0</span> <span class="hl kwa">then begin</span>
        <span class="hl sym">!</span>xs1_r <span class="hl sym">:=</span> l<span class="hl sym">;</span> fold&#64; xs<span class="hl sym">;</span>
        partition <span class="hl sym">(</span>pf00<span class="hl sym">,</span> pf01<span class="hl sym">,</span> pf1 <span class="hl sym">|</span> node<span class="hl sym">,</span> node1<span class="hl sym">,</span> k0<span class="hl sym">,</span> f0<span class="hl sym">,</span> xs1<span class="hl sym">,</span> xs<span class="hl sym">,</span> r<span class="hl sym">)</span>
      <span class="hl kwa">end else begin</span>
        <span class="hl sym">!</span>xs1_r <span class="hl sym">:=</span> r<span class="hl sym">;</span> fold&#64; xs<span class="hl sym">;</span>
        partition <span class="hl sym">(</span>pf00<span class="hl sym">,</span> pf01<span class="hl sym">,</span> pf1 <span class="hl sym">|</span> node<span class="hl sym">,</span> node1<span class="hl sym">,</span> k0<span class="hl sym">,</span> f0<span class="hl sym">,</span> xs1<span class="hl sym">,</span> l<span class="hl sym">,</span> xs<span class="hl sym">)</span>
      <span class="hl kwa">end</span>
    <span class="hl kwa">end</span>
  <span class="hl sym">|</span> ~FRQLSTnil <span class="hl sym">() =&gt;</span>
    <span class="hl kwa">let var</span> l <span class="hl sym">=</span> qsort l <span class="hl kwa">and</span> r <span class="hl sym">=</span> qsort r <span class="hl kwa">in</span>
      <span class="hl sym">!</span>node1 <span class="hl sym">:=</span> r<span class="hl sym">;</span> fold&#64; node<span class="hl sym">;</span> frqlst_append <span class="hl sym">(</span>l<span class="hl sym">,</span> node<span class="hl sym">);</span> l
    <span class="hl kwa">end</span>
<span class="hl kwa">end</span> <span class="hl sym">//</span> <span class="hl kwa">end of</span> <span class="hl sym">[</span>partition<span class="hl sym">]</span>

<span class="hl sym">//</span> print <span class="hl kwa">and</span> free
<span class="hl kwa">fun</span> print_frqlst
  <span class="hl sym">(</span>dna<span class="hl sym">:</span> dna_t<span class="hl sym">,</span> kfs<span class="hl sym">:</span> frqlst<span class="hl sym">):</span> void <span class="hl sym">=</span> <span class="hl kwa">begin case</span><span class="hl sym">+</span> kfs <span class="hl kwa">of</span>
  <span class="hl sym">|</span> ~FRQLSTcons <span class="hl sym">(</span>k<span class="hl sym">,</span> f<span class="hl sym">,</span> kfs<span class="hl sym">) =&gt;</span> <span class="hl kwa">begin</span>
      print_symbol <span class="hl sym">(</span>dna<span class="hl sym">,</span> k<span class="hl sym">);</span> printf <span class="hl sym">(</span><span class="hl str">&quot; %.3f</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl sym">,</span> &#64;<span class="hl sym">(</span>double_of f<span class="hl sym">));</span>
      print_frqlst <span class="hl sym">(</span>dna<span class="hl sym">,</span> kfs<span class="hl sym">)</span>
    <span class="hl kwa">end</span>
  <span class="hl sym">|</span> ~FRQLSTnil <span class="hl sym">() =&gt; ()</span>
<span class="hl kwa">end</span> <span class="hl sym">//</span> <span class="hl kwa">end of</span> <span class="hl sym">[</span>print_frqlst<span class="hl sym">]</span>

<span class="hl kwa">fn</span> write_frequencies <span class="hl sym">{</span>n<span class="hl sym">,</span>k<span class="hl sym">:</span>nat <span class="hl sym">|</span> k <span class="hl sym">&lt;=</span> n<span class="hl sym">}</span>
  <span class="hl sym">(</span>tbl<span class="hl sym">:</span> symtbl_t<span class="hl sym">,</span> n<span class="hl sym">:</span> int n<span class="hl sym">,</span> k<span class="hl sym">:</span> int k<span class="hl sym">):</span> void <span class="hl sym">=</span> <span class="hl kwa">let</span>
  <span class="hl kwa">val</span> tbl <span class="hl sym">=</span> dna_count <span class="hl sym">(</span>tbl<span class="hl sym">,</span> n<span class="hl sym">,</span> k<span class="hl sym">)</span>
  <span class="hl kwa">var</span> total<span class="hl sym">:</span> int <span class="hl sym">= (</span><span class="hl num">0</span><span class="hl sym">:</span> int<span class="hl sym">)</span>
  <span class="hl kwa">fn</span> f <span class="hl sym">(</span>k<span class="hl sym">:</span> symbol_t<span class="hl sym">,</span> cnt<span class="hl sym">:</span> int<span class="hl sym">,</span> res<span class="hl sym">: &amp;</span>int<span class="hl sym">):&lt;</span>cloptr<span class="hl sym">&gt;</span> void <span class="hl sym">= (</span>res <span class="hl sym">:=</span> res <span class="hl sym">+</span> cnt<span class="hl sym">)</span>
  <span class="hl kwa">val</span> <span class="hl sym">() =</span> symtbl_fold <span class="hl sym">{</span>int<span class="hl sym">} (</span>tbl<span class="hl sym">,</span> f<span class="hl sym">,</span> total<span class="hl sym">)</span>
  <span class="hl kwa">val</span> ftotal <span class="hl sym">=</span> float_of total
  <span class="hl kwa">var</span> frqs<span class="hl sym">:</span> frqlst <span class="hl sym">=</span> FRQLSTnil <span class="hl sym">()</span>
  <span class="hl kwa">fn</span> f <span class="hl sym">(</span>k<span class="hl sym">:</span> symbol_t<span class="hl sym">,</span> cnt<span class="hl sym">:</span> int<span class="hl sym">,</span> res<span class="hl sym">: &amp;</span>frqlst<span class="hl sym">):&lt;</span>cloptr<span class="hl sym">&gt;</span> void <span class="hl sym">=</span>
    <span class="hl kwa">let val</span> fval <span class="hl sym">= (</span>float_of <span class="hl num">100</span><span class="hl sym">) *</span> float_of cnt <span class="hl sym">/</span> ftotal <span class="hl kwa">in</span>
      res <span class="hl sym">:=</span> FRQLSTcons <span class="hl sym">(</span>k<span class="hl sym">,</span> fval<span class="hl sym">,</span> res<span class="hl sym">)</span>
    <span class="hl kwa">end</span>
  <span class="hl kwa">val</span> <span class="hl sym">() =</span> symtbl_fold <span class="hl sym">{</span>frqlst<span class="hl sym">} (</span>tbl<span class="hl sym">,</span> f<span class="hl sym">,</span> frqs<span class="hl sym">)</span>
<span class="hl kwa">in</span>
  print_frqlst <span class="hl sym">(</span>symtbl_dna tbl<span class="hl sym">,</span> qsort frqs<span class="hl sym">)</span>
<span class="hl kwa">end</span> <span class="hl sym">//</span> <span class="hl kwa">end of</span> <span class="hl sym">[</span>write_frequencies<span class="hl sym">]</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl kwa">fn</span> write_count <span class="hl sym">{</span>n<span class="hl sym">,</span>k<span class="hl sym">:</span>nat<span class="hl sym">}</span>
  <span class="hl sym">(</span>tbl<span class="hl sym">:</span> symtbl_t<span class="hl sym">,</span> n<span class="hl sym">:</span> int n<span class="hl sym">,</span> seq<span class="hl sym">:</span> string k<span class="hl sym">):</span> void <span class="hl sym">=</span> <span class="hl kwa">let</span>
  <span class="hl kwa">val</span> k <span class="hl sym">=</span> length seq
  <span class="hl kwa">val</span> <span class="hl sym">() =</span> assert <span class="hl sym">(</span>k <span class="hl sym">&lt;=</span> n<span class="hl sym">)</span>
  <span class="hl kwa">val</span> tbl <span class="hl sym">=</span> dna_count <span class="hl sym">(</span>tbl<span class="hl sym">,</span> n<span class="hl sym">,</span> k<span class="hl sym">)</span>
  <span class="hl kwa">val</span> cnt <span class="hl sym">=</span> symtbl_search <span class="hl sym">(</span>tbl<span class="hl sym">,</span> seq<span class="hl sym">)</span>
<span class="hl kwa">in</span>
  printf <span class="hl sym">(</span><span class="hl str">&quot;%d</span><span class="hl esc">\t</span><span class="hl str">%s</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl sym">,</span> &#64;<span class="hl sym">(</span>cnt<span class="hl sym">,</span> seq<span class="hl sym">))</span>
<span class="hl kwa">end</span> <span class="hl sym">//</span> <span class="hl kwa">end of</span> <span class="hl sym">[</span>write_count<span class="hl sym">]</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl kwa">typedef</span> string_int <span class="hl sym">= [</span>n<span class="hl sym">:</span>nat<span class="hl sym">] (</span>string n<span class="hl sym">,</span> int n<span class="hl sym">)</span>

<span class="hl kwa">extern fun</span> getline <span class="hl sym">():</span> string
<span class="hl kwa">extern fun</span> getrest <span class="hl sym">():</span> string_int

<span class="hl kwa">dataviewtype</span> charlst <span class="hl sym">(</span>int<span class="hl sym">) =</span>
  <span class="hl sym">|</span> charlst_nil <span class="hl sym">(</span><span class="hl num">0</span><span class="hl sym">)</span>
  <span class="hl sym">| {</span>n<span class="hl sym">:</span>nat<span class="hl sym">}</span> charlst_cons <span class="hl sym">(</span>n<span class="hl sym">+</span><span class="hl num">1</span><span class="hl sym">)</span> <span class="hl kwa">of</span> <span class="hl sym">(</span>char<span class="hl sym">,</span> charlst n<span class="hl sym">)</span>

<span class="hl dir">#define nil charlst_nil</span>
<span class="hl dir">#define cons charlst_cons</span>
<span class="hl dir">#define :: charlst_cons</span>

<span class="hl kwa">extern fun</span> charlst_is_nil <span class="hl sym">{</span>n<span class="hl sym">:</span>nat<span class="hl sym">} (</span>cs<span class="hl sym">: &amp;</span>charlst n<span class="hl sym">):</span> bool <span class="hl sym">(</span>n <span class="hl sym">==</span> <span class="hl num">0</span><span class="hl sym">) =</span>
  <span class="hl str">&quot;charlst_is_nil&quot;</span>

<span class="hl kwa">implement</span> charlst_is_nil <span class="hl sym">(</span>cs<span class="hl sym">) =</span> <span class="hl kwa">case</span><span class="hl sym">+</span> cs <span class="hl kwa">of</span>
  <span class="hl sym">|</span> nil <span class="hl sym">() =&gt; (</span>fold&#64; cs<span class="hl sym">;</span> true<span class="hl sym">) |</span> cons <span class="hl sym">(</span>c<span class="hl sym">, !</span>cs_r<span class="hl sym">) =&gt; (</span>fold&#64; cs<span class="hl sym">;</span> false<span class="hl sym">)</span>

<span class="hl kwa">extern fun</span>
charlst_uncons <span class="hl sym">{</span>n<span class="hl sym">:</span>pos<span class="hl sym">} (</span>cs<span class="hl sym">: &amp;</span>charlst n <span class="hl sym">&gt;&gt;</span> charlst <span class="hl sym">(</span>n<span class="hl sym">-</span><span class="hl num">1</span><span class="hl sym">)):</span> char <span class="hl sym">=</span>
  <span class="hl str">&quot;charlst_uncons&quot;</span>

<span class="hl kwa">implement</span> charlst_uncons <span class="hl sym">(</span>cs<span class="hl sym">) =</span>
  <span class="hl kwa">let val</span> ~<span class="hl sym">(</span>c <span class="hl sym">::</span> cs_r<span class="hl sym">) =</span> cs <span class="hl kwa">in</span> cs <span class="hl sym">:=</span> cs_r<span class="hl sym">;</span> c <span class="hl kwa">end</span>

<span class="hl kwa">extern fun</span>
string_make_charlst_int <span class="hl sym">{</span>n<span class="hl sym">:</span>nat<span class="hl sym">} (</span>cs<span class="hl sym">:</span> charlst n<span class="hl sym">,</span> n<span class="hl sym">:</span> int n<span class="hl sym">):</span> string n <span class="hl sym">=</span>
  <span class="hl str">&quot;string_make_charlst_int&quot;</span>

<span class="hl dir">#define i2c char_of_int</span>

<span class="hl kwa">implement</span> getline <span class="hl sym">() =</span> <span class="hl kwa">let</span>
  <span class="hl kwa">fun</span> loop <span class="hl sym">{</span>n<span class="hl sym">:</span>nat<span class="hl sym">} (</span>cs<span class="hl sym">:</span> charlst n<span class="hl sym">,</span> n<span class="hl sym">:</span> int n<span class="hl sym">):</span> string <span class="hl sym">=</span>
    <span class="hl kwa">let val</span> i <span class="hl sym">=</span> getchar <span class="hl sym">()</span> <span class="hl kwa">in</span>
      <span class="hl kwa">if</span> i <span class="hl sym">&gt;=</span> <span class="hl num">0</span> <span class="hl kwa">then let</span>
        <span class="hl kwa">val</span> c <span class="hl sym">=</span> i2c i
      <span class="hl kwa">in</span>
        <span class="hl kwa">if</span> c <span class="hl sym">&lt;&gt;</span> '\n' <span class="hl kwa">then</span> loop <span class="hl sym">(</span>charlst_cons <span class="hl sym">(</span>c<span class="hl sym">,</span> cs<span class="hl sym">),</span> n<span class="hl sym">+</span><span class="hl num">1</span><span class="hl sym">)</span>
        <span class="hl kwa">else</span> string_make_charlst_int <span class="hl sym">(</span>cs<span class="hl sym">,</span> n<span class="hl sym">)</span>
      <span class="hl kwa">end else begin</span>
        string_make_charlst_int <span class="hl sym">(</span>cs<span class="hl sym">,</span> n<span class="hl sym">)</span>
      <span class="hl kwa">end</span>
   <span class="hl kwa">end</span> <span class="hl sym">//</span> <span class="hl kwa">end of</span> <span class="hl sym">[</span>loop<span class="hl sym">]</span>
<span class="hl kwa">in</span>
  loop <span class="hl sym">(</span>charlst_nil <span class="hl sym">(),</span> <span class="hl num">0</span><span class="hl sym">)</span>
<span class="hl kwa">end</span> <span class="hl sym">//</span> <span class="hl kwa">end of</span> <span class="hl sym">[</span>getline<span class="hl sym">]</span>

<span class="hl kwa">implement</span> getrest <span class="hl sym">() =</span> <span class="hl kwa">let</span>
  <span class="hl kwa">fun</span> loop <span class="hl sym">{</span>n<span class="hl sym">:</span>nat<span class="hl sym">} (</span>cs<span class="hl sym">:</span> charlst n<span class="hl sym">,</span> n<span class="hl sym">:</span> int n<span class="hl sym">):</span> string_int <span class="hl sym">=</span>
    <span class="hl kwa">let val</span> i <span class="hl sym">=</span> getchar <span class="hl sym">()</span> <span class="hl kwa">in</span>
      <span class="hl kwa">if</span> i <span class="hl sym">&gt;=</span> <span class="hl num">0</span> <span class="hl kwa">then let</span>
        <span class="hl kwa">val</span> c <span class="hl sym">=</span> i2c i
      <span class="hl kwa">in</span>
        <span class="hl kwa">if</span> c <span class="hl sym">&lt;&gt;</span> '\n' <span class="hl kwa">then</span>
          loop <span class="hl sym">(</span>charlst_cons <span class="hl sym">(</span>char_toupper c<span class="hl sym">,</span> cs<span class="hl sym">),</span> n<span class="hl sym">+</span><span class="hl num">1</span><span class="hl sym">)</span>
        <span class="hl kwa">else</span> loop <span class="hl sym">(</span>cs<span class="hl sym">,</span> n<span class="hl sym">)</span>
      <span class="hl kwa">end else begin</span>
        &#64;<span class="hl sym">(</span>string_make_charlst_int <span class="hl sym">(</span>cs<span class="hl sym">,</span> n<span class="hl sym">),</span> n<span class="hl sym">)</span>
      <span class="hl kwa">end</span>
    <span class="hl kwa">end</span> <span class="hl sym">//</span> <span class="hl kwa">end of</span> <span class="hl sym">[</span><span class="hl kwa">let</span><span class="hl sym">]</span>
<span class="hl kwa">in</span>
  loop <span class="hl sym">(</span>charlst_nil <span class="hl sym">(),</span> <span class="hl num">0</span><span class="hl sym">)</span>
<span class="hl kwa">end</span> <span class="hl sym">//</span> <span class="hl kwa">end of</span> <span class="hl sym">[</span>getrest<span class="hl sym">]</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl kwa">extern fun</span> dna_of_string <span class="hl sym">(</span>s<span class="hl sym">:</span> string<span class="hl sym">):</span> dna_t <span class="hl sym">=</span> <span class="hl str">&quot;dna_of_string&quot;</span>
<span class="hl kwa">extern fun</span> is_three <span class="hl sym">(</span>s<span class="hl sym">:</span> string<span class="hl sym">):</span> bool <span class="hl sym">=</span> <span class="hl str">&quot;is_three&quot;</span>

<span class="hl sym">%{</span>$

ats_ptr_type dna_of_string <span class="hl sym">(</span>ats_string_type s<span class="hl sym">) {</span> return s <span class="hl sym">; }</span>

ats_bool_type is_three <span class="hl sym">(</span>ats_ptr_type s0<span class="hl sym">) {</span>
  char <span class="hl sym">*</span>s <span class="hl sym">= (</span>char*) s0 <span class="hl sym">;</span>

  <span class="hl kwa">if</span> <span class="hl com">(*s != '&gt;') return ats_false_bool ; ++s ;</span>
<span class="hl com">  if (*s != 'T') return ats_false_bool ; ++s ;</span>
<span class="hl com">  if (*s != 'H') return ats_false_bool ; ++s ;</span>
<span class="hl com">  if (*s != 'R') return ats_false_bool ; ++s ;</span>
<span class="hl com">  if (*s != 'E') return ats_false_bool ; ++s ;</span>
<span class="hl com">  if (*s != 'E') return ats_false_bool ;</span>
<span class="hl com">  return ats_true_bool ;</span>
<span class="hl com">}</span>
<span class="hl com"></span>
<span class="hl com">%}</span>
<span class="hl com"></span>
<span class="hl com">implement main (argc, argv) = let</span>
<span class="hl com"></span>
<span class="hl com">fun dna_three_get (): string_int = let</span>
<span class="hl com">  val s = getline ()</span>
<span class="hl com">in</span>
<span class="hl com">  if s &lt;&gt; &quot;&quot; then</span>
<span class="hl com">    if is_three (s) then getrest () else dna_three_get ()</span>
<span class="hl com">  else begin</span>
<span class="hl com">    exit_errmsg {string_int} (1, &quot;[dna_three_get] failed.\n&quot;)</span>
<span class="hl com">  end</span>
<span class="hl com">end // end of [dna_three_get]</span>
<span class="hl com"></span>
<span class="hl com">val (dna_three, n) = dna_three_get ()</span>
<span class="hl com">val dna_three = dna_of_string dna_three</span>
<span class="hl com">val dna_table = symtbl_make (dna_three, 0x1000)</span>
<span class="hl com">val () = assert (n &gt;= 2)</span>
<span class="hl com"></span>
<span class="hl com">in</span>
<span class="hl com"></span>
<span class="hl com">write_frequencies (dna_table, n, 1) ;</span>
<span class="hl com">print_newline () ;</span>
<span class="hl com"></span>
<span class="hl com">write_frequencies (dna_table, n, 2) ;</span>
<span class="hl com">print_newline () ;</span>
<span class="hl com"></span>
<span class="hl com">write_count (dna_table, n, &quot;GGT&quot;) ;</span>
<span class="hl com">write_count (dna_table, n, &quot;GGTA&quot;) ;</span>
<span class="hl com">write_count (dna_table, n, &quot;GGTATT&quot;) ;</span>
<span class="hl com">write_count (dna_table, n, &quot;GGTATTTTAATT&quot;) ;</span>
<span class="hl com">write_count (dna_table, n, &quot;GGTATTTTAATTTATAGT&quot;) ;</span>
<span class="hl com"></span>
<span class="hl com">end</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">%{$</span>
<span class="hl com"></span>
<span class="hl com">ats_ptr_type</span>
<span class="hl com">dna_count (ats_ptr_type tbl, ats_int_type n, ats_int_type k) {</span>
<span class="hl com">  symbol_t sym ; int i, nk = n - k ;</span>
<span class="hl com"></span>
<span class="hl com">  symtbl_clear (tbl) ;</span>
<span class="hl com">  i = 0 ;</span>
<span class="hl com">  while (i &lt;= nk) {</span>
<span class="hl com">    ++i ; sym.beg = i ; sym.len= k ;</span>
<span class="hl com">    symtbl_insert (tbl, sym, 0) ;</span>
<span class="hl com">  }</span>
<span class="hl com">  return tbl ;</span>
<span class="hl com">}</span>
<span class="hl com"></span>
<span class="hl com">ats_ptr_type</span>
<span class="hl com">string_make_charlst_int (ats_ptr_type cs, const ats_int_type n) {</span>
<span class="hl com">  char *s0, *s;</span>
<span class="hl com">  s0 = ats_malloc_gc(n+1) ;</span>
<span class="hl com">  s = s0 + n ; *s = '\0' ; --s ;</span>
<span class="hl com">  while (!charlst_is_nil(&amp;cs)) { *s = charlst_uncons(&amp;cs) ; --s ; }</span>
<span class="hl com">  return s0 ;</span>
<span class="hl com">}</span>
<span class="hl com"></span>
<span class="hl com">%}</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">(* end of [k-nucleotide.dats] *)</span>
<span class="hl com"></span>
<span class="hl com">(*  SPLITFILE=symtbl.dats *)</span>
<span class="hl com"></span>
<span class="hl com">// Time: August 2007</span>
<span class="hl com">// Author: Hongwei Xi</span>
<span class="hl com"></span>
<span class="hl com">// The hashtable implementation is based on linear-probing</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">%{^</span>
<span class="hl com"></span>
<span class="hl com">// #include &quot;symtbl.hats&quot;</span>
<span class="hl com">typedef ats_ptr_type ats_string_type ;</span>
<span class="hl com">typedef struct { int beg ; int len ; } symbol_t ;</span>
<span class="hl com">typedef struct { symbol_t sym ; int cnt ; } tblent_t ;</span>
<span class="hl com"></span>
<span class="hl com">%}</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">// staload &quot;symtbl.sats&quot;</span>
<span class="hl com">abstype dna_t // boxed type</span>
<span class="hl com">abst&#64;ype symbol_t = $extype &quot;symbol_t&quot;</span>
<span class="hl com">abstype symtbl_t // boxed type</span>
<span class="hl com"></span>
<span class="hl com">extern fun print_symbol (dna: dna_t, sym: symbol_t): void</span>
<span class="hl com">extern fun symtbl_make (dna: dna_t, size: Nat) : symtbl_t</span>
<span class="hl com">extern fun symtbl_clear (tbl: symtbl_t) : void = &quot;symtbl_clear&quot;</span>
<span class="hl com">extern fun symtbl_search (tbl: symtbl_t, name: string) : int</span>
<span class="hl com">  = &quot;symtbl_search&quot;</span>
<span class="hl com">extern fun symtbl_insert (tbl: symtbl_t, sym: symbol_t, cnt: int) : void</span>
<span class="hl com">  = &quot;symtbl_insert&quot;</span>
<span class="hl com">extern fun symtbl_fold {a:viewt&#64;ype}</span>
<span class="hl com">  (tbl: symtbl_t, f: !(symbol_t, int, &amp;a) -&lt;cloptr1&gt; void, res: &amp;a) : void</span>
<span class="hl com">extern fun symtbl_dna (tbl: symtbl_t): dna_t</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">abst&#64;ype tblent_t = $extype &quot;tblent_t&quot;</span>
<span class="hl com"></span>
<span class="hl com">viewtypedef symtbl (sz:int, n:int, l:addr) = &#64;{</span>
<span class="hl com">  dna= dna_t</span>
<span class="hl com">, ptr= ptr l</span>
<span class="hl com">, view_arr= &#64;[tblent_t][sz] &#64; l</span>
<span class="hl com">, view_arr_gc= free_gc_v l</span>
<span class="hl com">, size= int sz</span>
<span class="hl com">, nitm= int n</span>
<span class="hl com">}</span>
<span class="hl com"></span>
<span class="hl com">viewtypedef symtbl0 = symtbl (0, 0, null)</span>
<span class="hl com">viewtypedef symtbl = [sz,n:nat | sz &gt; 0] [l:addr] symtbl (sz, n, l)</span>
<span class="hl com">assume symtbl_t = [l_tbl: addr] (vbox (symtbl &#64; l_tbl) | ptr l_tbl)</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">extern fun fprint_symbol {m:file_mode}</span>
<span class="hl com">  (pf: file_mode_lte (m, w) | out: &amp;FILE m, dna: dna_t, sym: symbol_t): void</span>
<span class="hl com">  = &quot;fprint_symbol&quot;</span>
<span class="hl com"></span>
<span class="hl com">%{</span>
<span class="hl com"></span>
<span class="hl com">ats_void_type fprint_symbol</span>
<span class="hl com">  (ats_ptr_type out, ats_ptr_type dna, symbol_t sym) {</span>
<span class="hl com">  char *s ; int i ;</span>
<span class="hl com"></span>
<span class="hl com">  s = (char*)dna + sym.beg - 1 ; i = 0 ;</span>
<span class="hl com"></span>
<span class="hl com">  while (i &lt; sym.len) {</span>
<span class="hl com">    fputc (*s, (FILE*)out) ; ++i ; ++s ;</span>
<span class="hl com">  }</span>
<span class="hl com"></span>
<span class="hl com">  return ;</span>
<span class="hl com"></span>
<span class="hl com">}</span>
<span class="hl com"></span>
<span class="hl com">%}</span>
<span class="hl com"></span>
<span class="hl com">implement print_symbol (dna, sym) =</span>
<span class="hl com">  let</span>
<span class="hl com">     val (pf_stdout | ptr_stdout) = stdout_get ()</span>
<span class="hl com">  in</span>
<span class="hl com">     fprint_symbol (file_mode_lte_w_w | !ptr_stdout, dna, sym);</span>
<span class="hl com">     stdout_view_set (pf_stdout | (*none*))</span>
<span class="hl com">  end</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">#define i2u uint1_of_int1</span>
<span class="hl com">extern fun hash_string_33 (s: string):&lt;&gt; uInt = &quot;hash_string_33&quot;</span>
<span class="hl com">extern fun hash_symbol_33 (dna: dna_t, sym: symbol_t):&lt;&gt; uInt = &quot;hash_symbol_33&quot;</span>
<span class="hl com"></span>
<span class="hl com">%{</span>
<span class="hl com"></span>
<span class="hl com">// a commonly used simple hash function</span>
<span class="hl com"></span>
<span class="hl com">ats_uint_type hash_string_33 (ats_ptr_type s0) {</span>
<span class="hl com">  unsigned int hash_val ; unsigned char *s ; int c ;</span>
<span class="hl com">  hash_val = 314159 ;</span>
<span class="hl com"></span>
<span class="hl com">  s = (unsigned char*)s0 ;</span>
<span class="hl com">  while (1) {</span>
<span class="hl com">    c = *s ;</span>
<span class="hl com">    if (!c) return hash_val ;</span>
<span class="hl com">    hash_val = ((hash_val &lt;&lt; 5) + hash_val) + c ;</span>
<span class="hl com">    s += 1 ;</span>
<span class="hl com">  }</span>
<span class="hl com">}</span>
<span class="hl com"></span>
<span class="hl com">ats_uint_type hash_symbol_33 (ats_ptr_type dna, symbol_t sym) {</span>
<span class="hl com"></span>
<span class="hl com">  unsigned int hash_val, n ; unsigned char *s ;</span>
<span class="hl com">  hash_val = 314159 ;</span>
<span class="hl com"></span>
<span class="hl com">  n = sym.len ;</span>
<span class="hl com">  s = (unsigned char*)dna + sym.beg - 1 ;</span>
<span class="hl com"></span>
<span class="hl com">  while (n &gt; 0) {</span>
<span class="hl com">    hash_val = ((hash_val &lt;&lt; 5) + hash_val) + *s ;</span>
<span class="hl com">    ++s ; --n ;</span>
<span class="hl com">  }</span>
<span class="hl com">/*</span>
<span class="hl com">  fprintf (stdout, &quot;has_symbol_33: \n&quot;) ;</span>
<span class="hl com">  fprintf (stdout, &quot;  sym = &quot;) ;</span>
<span class="hl com">  fprint_symbol (stdout, dna, sym) ;</span>
<span class="hl com">  fprintf (stdout, &quot;\n  hash_val = %u\n&quot;, hash_val) ;</span>
<span class="hl com">*/</span>
<span class="hl com">  return hash_val ;</span>
<span class="hl com">}</span>
<span class="hl com"></span>
<span class="hl com">%}</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">extern fun tblent_array_make {sz: nat}</span>
<span class="hl com">  (sz: int sz):&lt;&gt; [l:addr] (free_gc_v l, array_v (tblent_t, sz, l) | ptr l)</span>
<span class="hl com">  = &quot;tblent_array_make&quot;</span>
<span class="hl com"></span>
<span class="hl com">%{</span>
<span class="hl com"></span>
<span class="hl com">ats_ptr_type</span>
<span class="hl com">tblent_array_make (ats_int_type sz) {</span>
<span class="hl com">  return ats_calloc_gc (sz, sizeof(tblent_t)) ;</span>
<span class="hl com">}</span>
<span class="hl com"></span>
<span class="hl com">%}</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">implement symtbl_make (dna, sz) = let</span>
<span class="hl com">val sz = max (sz, 1)</span>
<span class="hl com">val (pf_tbl_gc, pf_tbl | p_tbl) = ptr_alloc_tsz {symtbl0} (sizeof&lt;symtbl0&gt;)</span>
<span class="hl com">val (pf_arr_gc, pf_arr | p_arr) = tblent_array_make (sz)</span>
<span class="hl com"></span>
<span class="hl com">val () = begin</span>
<span class="hl com">  p_tbl-&gt;dna := dna;</span>
<span class="hl com">  p_tbl-&gt;ptr := p_arr;</span>
<span class="hl com">  p_tbl-&gt;view_arr := pf_arr;</span>
<span class="hl com">  p_tbl-&gt;view_arr_gc := pf_arr_gc;</span>
<span class="hl com">  p_tbl-&gt;size := sz;</span>
<span class="hl com">  p_tbl-&gt;nitm := 0</span>
<span class="hl com">end</span>
<span class="hl com"></span>
<span class="hl com">val (pfbox | ()) = vbox_make_view_ptr_gc (pf_tbl_gc, pf_tbl | p_tbl)</span>
<span class="hl com"></span>
<span class="hl com">in</span>
<span class="hl com">  (pfbox | p_tbl)</span>
<span class="hl com">end // symtbl_make</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">extern fun tblent_array_clear {sz:nat} {l:addr}</span>
<span class="hl com">  (pf: !array_v (tblent_t, sz, l) | p: ptr l, sz: int sz):&lt;&gt; void</span>
<span class="hl com">  = &quot;tblent_array_clear&quot;</span>
<span class="hl com"></span>
<span class="hl com">%{</span>
<span class="hl com"></span>
<span class="hl com">ats_void_type</span>
<span class="hl com">tblent_array_clear (ats_ptr_type p, ats_int_type sz) {</span>
<span class="hl com">  memset (p, 0, sz * sizeof(tblent_t)) ;</span>
<span class="hl com">}</span>
<span class="hl com"></span>
<span class="hl com">%}</span>
<span class="hl com"></span>
<span class="hl com">implement symtbl_clear (tbl) = let</span>
<span class="hl com"></span>
<span class="hl com">val (vbox pf_tbl | p_tbl) = tbl</span>
<span class="hl com"></span>
<span class="hl com">in</span>
<span class="hl com"></span>
<span class="hl com">tblent_array_clear (p_tbl-&gt;view_arr |  p_tbl-&gt;ptr, p_tbl-&gt;size);</span>
<span class="hl com">p_tbl-&gt;nitm := 0</span>
<span class="hl com"></span>
<span class="hl com">end</span>
<span class="hl com"></span>
<span class="hl com">//</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">// linear probing</span>
<span class="hl com">extern fun symtbl_search_probe {sz,i:nat | i &lt; sz} {l:addr}</span>
<span class="hl com">  (pf: !array_v(tblent_t, sz, l) |</span>
<span class="hl com">  dna: dna_t, p: ptr l, sz: int sz, name: string, i: int i):&lt;&gt; int</span>
<span class="hl com">  = &quot;symtbl_search_probe&quot;</span>
<span class="hl com"></span>
<span class="hl com">%{</span>
<span class="hl com"></span>
<span class="hl com">ats_int_type symtbl_search_probe</span>
<span class="hl com">  (ats_string_type dna,</span>
<span class="hl com">   ats_ptr_type p,</span>
<span class="hl com">   ats_int_type sz,</span>
<span class="hl com">   ats_string_type name,</span>
<span class="hl com">   ats_int_type i) {</span>
<span class="hl com"></span>
<span class="hl com">  tblent_t *ent ; int beg ;</span>
<span class="hl com"></span>
<span class="hl com">  ent = ((tblent_t *)p) + i ;</span>
<span class="hl com"></span>
<span class="hl com">  while (1) {</span>
<span class="hl com">    beg = (ent-&gt;sym).beg ;</span>
<span class="hl com">    if (beg == 0) return 0 ; // the entry is unoccupied</span>
<span class="hl com">    if (strncmp (((char*)dna)+beg-1, (char*)name, (ent-&gt;sym).len) == 0) {</span>
<span class="hl com">      return ent-&gt;cnt ;</span>
<span class="hl com">    }</span>
<span class="hl com">    ++i ; if (i &gt;= sz) { i = 0 ; ent = (tblent_t *)</span>p <span class="hl sym">; }</span> <span class="hl kwa">else</span> <span class="hl sym">++</span>ent <span class="hl sym">;</span>
  <span class="hl sym">}</span>
<span class="hl sym">}</span>

<span class="hl sym">%}</span>

<span class="hl kwa">implement</span> symtbl_search <span class="hl sym">(</span>tbl<span class="hl sym">,</span> name<span class="hl sym">) =</span> <span class="hl kwa">let</span>

<span class="hl kwa">val</span> hash_val <span class="hl sym">=</span> hash_string_33 name
<span class="hl kwa">val</span> <span class="hl sym">(</span>vbox pf_tbl <span class="hl sym">|</span> p_tbl<span class="hl sym">) =</span> tbl
<span class="hl kwa">val</span> i <span class="hl sym">=</span> hash_val uimod p_tbl<span class="hl sym">-&gt;</span>size

<span class="hl kwa">in</span>

symtbl_search_probe <span class="hl sym">(</span>
  p_tbl<span class="hl sym">-&gt;</span>view_arr <span class="hl sym">|</span> p_tbl<span class="hl sym">-&gt;</span>dna<span class="hl sym">,</span> p_tbl<span class="hl sym">-&gt;</span>ptr<span class="hl sym">,</span> p_tbl<span class="hl sym">-&gt;</span>size<span class="hl sym">,</span> name<span class="hl sym">,</span> i
<span class="hl sym">)</span>

<span class="hl kwa">end</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl kwa">extern fun</span> symtbl_insert_probe <span class="hl sym">{</span>sz<span class="hl sym">,</span>i<span class="hl sym">:</span>nat <span class="hl sym">|</span> i <span class="hl sym">&lt;</span> sz<span class="hl sym">} {</span>l<span class="hl sym">:</span>addr<span class="hl sym">}</span>
  <span class="hl sym">(</span>pf<span class="hl sym">: !</span>array_v <span class="hl sym">(</span>tblent_t<span class="hl sym">,</span> sz<span class="hl sym">,</span> l<span class="hl sym">) |</span>
   dna<span class="hl sym">:</span> dna_t<span class="hl sym">,</span> p<span class="hl sym">:</span> ptr l<span class="hl sym">,</span> sz<span class="hl sym">:</span> int sz<span class="hl sym">,</span> sym<span class="hl sym">:</span> symbol_t<span class="hl sym">,</span> cnt<span class="hl sym">:</span> int<span class="hl sym">,</span> i<span class="hl sym">:</span> int i<span class="hl sym">):&lt;&gt;</span> bool
  <span class="hl sym">=</span> <span class="hl str">&quot;symtbl_insert_probe&quot;</span>

<span class="hl sym">%{</span>

ats_bool_type symtbl_insert_probe
  <span class="hl sym">(</span>ats_ptr_type dna<span class="hl sym">,</span>
   ats_ptr_type p<span class="hl sym">,</span> ats_int_type sz<span class="hl sym">,</span>
   symbol_t sym<span class="hl sym">,</span> ats_int_type cnt<span class="hl sym">,</span>
   ats_int_type i<span class="hl sym">) {</span>

  tblent_t <span class="hl sym">*</span>ent <span class="hl sym">;</span>
<span class="hl com">/*</span>
<span class="hl com">  printf (&quot;symtbl_insert_probe: sz = %i\n&quot;, sz) ;</span>
<span class="hl com">*/</span>

  ent <span class="hl sym">= ((</span>tblent_t *)p<span class="hl sym">) +</span> i <span class="hl sym">;</span>
  <span class="hl kwa">while</span> <span class="hl sym">(</span><span class="hl num">1</span><span class="hl sym">) {</span>
    <span class="hl kwa">if</span> <span class="hl sym">(!(</span>ent<span class="hl sym">-&gt;</span>sym<span class="hl sym">).</span>beg<span class="hl sym">) { //</span> the entry is not occupied
      ent<span class="hl sym">-&gt;</span>sym <span class="hl sym">=</span> sym <span class="hl sym">;</span>
      <span class="hl kwa">if</span> <span class="hl sym">(</span>cnt <span class="hl sym">&gt;</span> <span class="hl num">0</span><span class="hl sym">)</span> ent<span class="hl sym">-&gt;</span>cnt <span class="hl sym">=</span> cnt <span class="hl sym">;</span> <span class="hl kwa">else</span> ent<span class="hl sym">-&gt;</span>cnt <span class="hl sym">=</span> <span class="hl num">1</span> <span class="hl sym">;</span>
      return <span class="hl num">1</span> <span class="hl sym">;</span>
    <span class="hl sym">}</span>
<span class="hl com">/*</span>
<span class="hl com">    printf (&quot;symtbl_insert_probe: i = %i\n&quot;, i) ;</span>
<span class="hl com">    fprint_symbol (stdout, dna, ent-&gt;sym) ; printf (&quot;\n&quot;) ;</span>
<span class="hl com">    fprint_symbol (stdout, dna, sym) ; printf (&quot;\n&quot;) ;</span>
<span class="hl com">*/</span>
    <span class="hl sym">//</span> linear probing
    <span class="hl kwa">if</span> <span class="hl sym">(</span>strncmp <span class="hl sym">(</span>dna<span class="hl sym">+(</span>ent<span class="hl sym">-&gt;</span>sym<span class="hl sym">).</span>beg<span class="hl sym">-</span><span class="hl num">1</span><span class="hl sym">,</span> dna<span class="hl sym">+</span>sym<span class="hl sym">.</span>beg<span class="hl sym">-</span><span class="hl num">1</span><span class="hl sym">,</span> sym<span class="hl sym">.</span>len<span class="hl sym">) ==</span> <span class="hl num">0</span><span class="hl sym">) {</span>
      <span class="hl kwa">if</span> <span class="hl sym">(</span>cnt <span class="hl sym">&gt;</span> <span class="hl num">0</span><span class="hl sym">)</span> ent<span class="hl sym">-&gt;</span>cnt <span class="hl sym">=</span> cnt <span class="hl sym">;</span> <span class="hl kwa">else</span> ent<span class="hl sym">-&gt;</span>cnt <span class="hl sym">+=</span> <span class="hl num">1</span> <span class="hl sym">;</span>
      return <span class="hl num">0</span> <span class="hl sym">;</span>
    <span class="hl sym">}</span>
    <span class="hl sym">++</span>i <span class="hl sym">;</span> <span class="hl kwa">if</span> <span class="hl sym">(</span>i <span class="hl sym">&gt;=</span> sz<span class="hl sym">) {</span> i <span class="hl sym">=</span> <span class="hl num">0</span> <span class="hl sym">;</span> ent <span class="hl sym">= (</span>tblent_t *)p <span class="hl sym">; }</span> <span class="hl kwa">else</span> <span class="hl sym">++</span>ent <span class="hl sym">;</span>
  <span class="hl sym">}</span>
<span class="hl sym">}</span>

<span class="hl sym">%}</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl kwa">extern fun</span> symtbl_resize_move <span class="hl sym">{</span>sz<span class="hl sym">:</span>nat<span class="hl sym">} {</span>l<span class="hl sym">,</span>l_new<span class="hl sym">:</span>addr<span class="hl sym">}</span>
  <span class="hl sym">(</span>pf<span class="hl sym">: !</span>array_v<span class="hl sym">(</span>tblent_t<span class="hl sym">,</span> sz<span class="hl sym">,</span> l<span class="hl sym">),</span>
   pf_new<span class="hl sym">: !</span>array_v<span class="hl sym">(</span>tblent_t<span class="hl sym">,</span> sz<span class="hl sym">+</span>sz<span class="hl sym">,</span> l_new<span class="hl sym">) |</span>
   dna<span class="hl sym">:</span> dna_t<span class="hl sym">,</span> p<span class="hl sym">:</span> ptr l<span class="hl sym">,</span> p_new<span class="hl sym">:</span> ptr l_new<span class="hl sym">,</span> sz<span class="hl sym">:</span> int sz<span class="hl sym">):&lt;&gt;</span> void
  <span class="hl sym">=</span> <span class="hl str">&quot;symtbl_resize_move&quot;</span>

<span class="hl sym">%{</span>

ats_void_type symtbl_resize_move
  <span class="hl sym">(</span>ats_ptr_type dna<span class="hl sym">,</span> ats_ptr_type p<span class="hl sym">,</span> ats_ptr_type p_new<span class="hl sym">,</span> ats_int_type sz<span class="hl sym">) {</span>

  int i<span class="hl sym">,</span> sz2<span class="hl sym">,</span> h <span class="hl sym">;</span>
  tblent_t <span class="hl sym">*</span>ent <span class="hl sym">;</span>

  i <span class="hl sym">=</span> <span class="hl num">0</span> <span class="hl sym">;</span> sz2 <span class="hl sym">=</span> sz <span class="hl sym">+</span> sz <span class="hl sym">;</span> ent <span class="hl sym">= (</span>tblent_t *)p <span class="hl sym">;</span>
<span class="hl com">/*</span>
<span class="hl com">  printf (&quot;symtbl_resize_move: sz2 = %i\n&quot;, sz2) ;</span>
<span class="hl com">*/</span>
  <span class="hl kwa">while</span> <span class="hl sym">(</span>i <span class="hl sym">&lt;</span> sz<span class="hl sym">) {</span>
    <span class="hl kwa">if</span> <span class="hl sym">(!(</span>ent<span class="hl sym">-&gt;</span>sym<span class="hl sym">).</span>beg<span class="hl sym">) { ++</span>i <span class="hl sym">; ++</span>ent <span class="hl sym">;</span> <span class="hl kwa">continue</span> <span class="hl sym">; }</span>
    h <span class="hl sym">=</span> hash_symbol_33 <span class="hl sym">(</span>dna<span class="hl sym">,</span> ent<span class="hl sym">-&gt;</span>sym<span class="hl sym">) %</span> sz2 <span class="hl sym">;</span>
    symtbl_insert_probe <span class="hl sym">(</span>dna<span class="hl sym">,</span> p_new<span class="hl sym">,</span> sz2<span class="hl sym">,</span> ent<span class="hl sym">-&gt;</span>sym<span class="hl sym">,</span> ent<span class="hl sym">-&gt;</span>cnt<span class="hl sym">,</span> h<span class="hl sym">) ;</span>
    <span class="hl sym">++</span>i <span class="hl sym">; ++</span>ent <span class="hl sym">;</span>
  <span class="hl sym">}</span>

  return <span class="hl sym">;</span>
<span class="hl sym">}</span>

<span class="hl sym">%}</span>

<span class="hl kwa">fn</span> symtbl_resize <span class="hl sym">(</span>tbl<span class="hl sym">:</span> symtbl_t<span class="hl sym">):&lt;!</span>ref<span class="hl sym">&gt;</span> void <span class="hl sym">=</span> <span class="hl kwa">let</span>

<span class="hl kwa">val</span> <span class="hl sym">(</span>vbox pf_tbl <span class="hl sym">|</span> p_tbl<span class="hl sym">) =</span> tbl
<span class="hl kwa">val</span> p_arr <span class="hl sym">=</span> p_tbl<span class="hl sym">-&gt;</span>ptr
<span class="hl kwa">prval</span> pf_arr <span class="hl sym">=</span> p_tbl<span class="hl sym">-&gt;</span>view_arr
<span class="hl kwa">prval</span> pf_arr_gc <span class="hl sym">=</span> p_tbl<span class="hl sym">-&gt;</span>view_arr_gc
<span class="hl kwa">val</span> sz <span class="hl sym">=</span> p_tbl<span class="hl sym">-&gt;</span>size
<span class="hl kwa">val</span> <span class="hl sym">(</span>pf_arr_gc_new<span class="hl sym">,</span> pf_arr_new <span class="hl sym">|</span> p_arr_new<span class="hl sym">) =</span> tblent_array_make <span class="hl sym">(</span>sz <span class="hl sym">+</span> sz<span class="hl sym">)</span>

<span class="hl kwa">in</span>

symtbl_resize_move <span class="hl sym">(</span>pf_arr<span class="hl sym">,</span> pf_arr_new <span class="hl sym">|</span> p_tbl<span class="hl sym">-&gt;</span>dna<span class="hl sym">,</span> p_arr<span class="hl sym">,</span> p_arr_new<span class="hl sym">,</span> sz<span class="hl sym">);</span>
array_ptr_free <span class="hl sym">{</span>tblent_t<span class="hl sym">} (</span>pf_arr_gc<span class="hl sym">,</span> pf_arr <span class="hl sym">|</span> p_arr<span class="hl sym">);</span>
p_tbl<span class="hl sym">-&gt;</span>ptr <span class="hl sym">:=</span> p_arr_new<span class="hl sym">;</span>
p_tbl<span class="hl sym">-&gt;</span>view_arr <span class="hl sym">:=</span> pf_arr_new<span class="hl sym">;</span>
p_tbl<span class="hl sym">-&gt;</span>view_arr_gc <span class="hl sym">:=</span> pf_arr_gc_new<span class="hl sym">;</span>
p_tbl<span class="hl sym">-&gt;</span>size <span class="hl sym">:=</span> sz <span class="hl sym">+</span> sz<span class="hl sym">;</span>

<span class="hl kwa">end</span> <span class="hl sym">//</span> <span class="hl kwa">end of</span> <span class="hl sym">[</span>symtbl_resize<span class="hl sym">]</span>

<span class="hl kwa">fun</span> symtbl_resize_if <span class="hl sym">(</span>tbl<span class="hl sym">:</span> symtbl_t<span class="hl sym">):</span> void <span class="hl sym">=</span> <span class="hl kwa">let</span>
  <span class="hl kwa">val</span> nitm <span class="hl sym">=</span> <span class="hl kwa">let val</span> <span class="hl sym">(</span>vbox pf_tbl <span class="hl sym">|</span> p_tbl<span class="hl sym">) =</span> tbl <span class="hl kwa">in</span> p_tbl<span class="hl sym">-&gt;</span>nitm <span class="hl kwa">end</span>
  <span class="hl kwa">val</span> size <span class="hl sym">=</span> <span class="hl kwa">let val</span> <span class="hl sym">(</span>vbox pf_tbl <span class="hl sym">|</span> p_tbl<span class="hl sym">) =</span> tbl <span class="hl kwa">in</span> p_tbl<span class="hl sym">-&gt;</span>size <span class="hl kwa">end</span>
<span class="hl kwa">in</span>
  <span class="hl kwa">if</span> <span class="hl sym">(</span><span class="hl num">2</span> <span class="hl sym">*</span> nitm <span class="hl sym">&gt;</span> size<span class="hl sym">)</span> <span class="hl kwa">then</span> symtbl_resize <span class="hl sym">(</span>tbl<span class="hl sym">)</span>
<span class="hl kwa">end</span> <span class="hl sym">//</span> <span class="hl kwa">end of</span> <span class="hl sym">[</span>symtbl_resize<span class="hl sym">]</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl kwa">implement</span> symtbl_insert <span class="hl sym">(</span>tbl<span class="hl sym">,</span> sym<span class="hl sym">,</span> cnt<span class="hl sym">) =</span> <span class="hl kwa">let</span>
<span class="hl kwa">val</span> <span class="hl sym">() =</span> symtbl_resize_if <span class="hl sym">(</span>tbl<span class="hl sym">)</span>
<span class="hl kwa">val</span> <span class="hl sym">(</span>vbox pf_tbl <span class="hl sym">|</span> p_tbl<span class="hl sym">) =</span> tbl
<span class="hl kwa">val</span> hash_val <span class="hl sym">=</span> hash_symbol_33 <span class="hl sym">(</span>p_tbl<span class="hl sym">-&gt;</span>dna<span class="hl sym">,</span> sym<span class="hl sym">)</span>
<span class="hl kwa">val</span> i <span class="hl sym">=</span> hash_val uimod p_tbl<span class="hl sym">-&gt;</span>size
<span class="hl kwa">val</span> is_new <span class="hl sym">=</span> symtbl_insert_probe
  <span class="hl sym">(</span>p_tbl<span class="hl sym">-&gt;</span>view_arr <span class="hl sym">|</span> p_tbl<span class="hl sym">-&gt;</span>dna<span class="hl sym">,</span> p_tbl<span class="hl sym">-&gt;</span>ptr<span class="hl sym">,</span> p_tbl<span class="hl sym">-&gt;</span>size<span class="hl sym">,</span> sym<span class="hl sym">,</span> cnt<span class="hl sym">,</span> i<span class="hl sym">)</span>
<span class="hl kwa">in</span>

<span class="hl kwa">if</span> is_new <span class="hl kwa">then</span> p_tbl<span class="hl sym">-&gt;</span>nitm <span class="hl sym">:=</span> <span class="hl num">1</span> <span class="hl sym">+</span> p_tbl<span class="hl sym">-&gt;</span>nitm <span class="hl kwa">else</span> <span class="hl sym">()</span>

<span class="hl kwa">end</span> <span class="hl sym">//</span> <span class="hl kwa">end of</span> <span class="hl sym">[</span>symtbl_insert<span class="hl sym">]</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl kwa">extern fun</span> tblent_array_fold <span class="hl sym">{</span>a<span class="hl sym">:</span>viewt&#64;ype<span class="hl sym">} {</span>sz<span class="hl sym">:</span> nat<span class="hl sym">} {</span>l<span class="hl sym">:</span>addr<span class="hl sym">}</span>
  <span class="hl sym">(</span>pf<span class="hl sym">: !</span>array_v <span class="hl sym">(</span>tblent_t<span class="hl sym">,</span> sz<span class="hl sym">,</span> l<span class="hl sym">) |</span>
   p<span class="hl sym">:</span> ptr l<span class="hl sym">,</span> sz<span class="hl sym">:</span> int sz<span class="hl sym">,</span> f<span class="hl sym">: !(</span>symbol_t<span class="hl sym">,</span> int<span class="hl sym">, &amp;</span>a<span class="hl sym">) -&lt;</span>cloptr1<span class="hl sym">&gt;</span> void<span class="hl sym">,</span> res<span class="hl sym">: &amp;</span>a<span class="hl sym">)</span>
  <span class="hl sym">:&lt;&gt;</span> void
  <span class="hl sym">=</span> <span class="hl str">&quot;tblent_array_fold&quot;</span>

<span class="hl sym">%{</span>

ats_void_type tblent_array_fold
  <span class="hl sym">(</span>ats_ptr_type p<span class="hl sym">,</span> ats_int_type sz<span class="hl sym">,</span> ats_ptr_type f<span class="hl sym">,</span> ats_ptr_type res<span class="hl sym">) {</span>

  int i <span class="hl sym">;</span> tblent_t <span class="hl sym">*</span>ent <span class="hl sym">;</span>

  i <span class="hl sym">=</span> <span class="hl num">0</span> <span class="hl sym">;</span> ent <span class="hl sym">= (</span>tblent_t *)p <span class="hl sym">;</span>
  <span class="hl kwa">while</span> <span class="hl sym">(</span>i <span class="hl sym">&lt;</span> sz<span class="hl sym">) {</span>
    <span class="hl kwa">if</span> <span class="hl sym">(!(</span>ent<span class="hl sym">-&gt;</span>sym<span class="hl sym">).</span>beg<span class="hl sym">) { ++</span>i <span class="hl sym">; ++</span>ent <span class="hl sym">;</span> <span class="hl kwa">continue</span> <span class="hl sym">; }</span>
    <span class="hl sym">((</span>ats_void_type <span class="hl com">(*)(ats_clo_ptr_type, symbol_t, ats_int_type, ats_ptr_type))(ats_closure_fun(f)))(f, ent-&gt;sym, ent-&gt;cnt, res) ;</span>
<span class="hl com">    ++i ; ++ent ;</span>
<span class="hl com">  }</span>
<span class="hl com">}</span>
<span class="hl com"></span>
<span class="hl com">%}</span>
<span class="hl com"></span>
<span class="hl com">implement symtbl_fold {a} (tbl, f, res) = let</span>
<span class="hl com"></span>
<span class="hl com">val (vbox pf_tbl | p_tbl) = tbl</span>
<span class="hl com"></span>
<span class="hl com">in</span>
<span class="hl com"></span>
<span class="hl com">tblent_array_fold {a}</span>
<span class="hl com">  (p_tbl-&gt;view_arr | p_tbl-&gt;ptr, p_tbl-&gt;size, f, res)</span>
<span class="hl com"></span>
<span class="hl com">end // end of [symtbl_insert]</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">implement symtbl_dna (tbl) = begin</span>
<span class="hl com">  let val (vbox pf_tbl | p_tbl) = tbl in p_tbl-&gt;dna end</span>
<span class="hl com">end</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">(* end of [symtbl.dats] *)</span>
