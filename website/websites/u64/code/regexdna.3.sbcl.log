
Sat, 14 Mar 2009 21:15:11 GMT

MAKE:
cp: `regexdna.sbcl-3.sbcl' and `./regexdna.sbcl-3.sbcl' are the same file
SBCL built with: /usr/local/bin/sbcl --userinit /dev/null --batch --eval '(load "regexdna.sbcl-3.sbcl_compile")'
### START regexdna.sbcl-3.sbcl_compile
(proclaim '(optimize (speed 3) (safety 0) (debug 0) (compilation-speed 0) (space 0)))
(handler-bind ((sb-ext:defconstant-uneql      (lambda (c) (abort c))))      (load (compile-file "regexdna.sbcl-3.sbcl" ))) (save-lisp-and-die "sbcl.core" :purify t)
### END regexdna.sbcl-3.sbcl_compile


; compiling file "/home/dunham/shootout/bench/regexdna/regexdna.sbcl-3.sbcl" (written 11 MAR 2009 02:19:38 PM):
; compiling (REQUIRE :ASDF)
; compiling (REQUIRE :CL-PPCRE)
; compiling (DEFINE-ALIEN-ROUTINE SYSCONF ...)
; file: /home/dunham/shootout/bench/regexdna/regexdna.sbcl-3.sbcl
; in: DEFINE-ALIEN-ROUTINE SYSCONF
;     (DEFINE-ALIEN-ROUTINE SYSCONF LONG (NAME INT))
; --> PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK WITH-ALIEN 
; --> SYMBOL-MACROLET SYMBOL-MACROLET LET SYMBOL-MACROLET VALUES PROG1 LET 
; --> ALIEN-FUNCALL SB-C::INVOKE-WITH-SAVED-FP-AND-PC BLOCK LET* 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%CALLER-FRAME-AND-PC)
; 
; note: doing SAP to pointer coercion (cost 20)

; --> PROGN DEFUN PROGN EVAL-WHEN 
; ==>
;   (SB-IMPL::%DEFUN 'SYSCONF
;                    (SB-INT:NAMED-LAMBDA SYSCONF (NAME)
;                                         (BLOCK SYSCONF
;                                           (WITH-ALIEN (#) (VALUES #))))
;                    NIL 'NIL (SB-C:SOURCE-LOCATION))
; 
; note: doing signed word to integer coercion (cost 20) to "<return value>"

; compiling (USE-PACKAGE :SB-THREAD)
; compiling (DEFCONSTANT +REGEX-LIST+ ...)
; compiling (DEFCONSTANT +ALTERNATIVES+ ...)
; compiling (DEFCONSTANT +CPU-COUNT+ ...)
; compiling (DEFVAR *MUTEX* ...)
; compiling (DEFVAR *AUX-MUTEX* ...)
; compiling (DEFMACRO BG ...)
; compiling (DEFMACRO JOIN-ALL ...)
; compiling (DEFUN READ-ALL ...)
; compiling (DEFUN LENGTH-TO-REPLACE ...)
; compiling (DEFUN REPLACE-AUX ...)
; file: /home/dunham/shootout/bench/regexdna/regexdna.sbcl-3.sbcl
; in: DEFUN REPLACE-AUX
;     (SETF (SUBSEQ RESULT-STRING I)
;             (SUBSEQ TARGET-STRING J (CAR PAIR))
;           I
;             (+ I (- (THE FIXNUM (CAR PAIR)) J))
;           (SUBSEQ RESULT-STRING I)
;             REPLACEMENT
;           J
;             (CDR PAIR)
;           I
;             (+ I LEN))
; --> PROGN SETF LET* MULTIPLE-VALUE-BIND LET PROGN 
; ==>
;   (REPLACE #:G301 #:G303 :START1 #:G302 :END1 NIL)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a VECTOR, not a SIMPLE-BASE-STRING.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a VECTOR, not a (SIMPLE-ARRAY CHARACTER (*)).

; compiling (DEFUN PARTS ...)
; file: /home/dunham/shootout/bench/regexdna/regexdna.sbcl-3.sbcl
; in: DEFUN PARTS
;     (FLOOR LEN PARTS-NUM)
; --> BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   (VALUES SB-KERNEL::TRU REM)
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (VALUES (1- SB-KERNEL::TRU) (+ REM SB-KERNEL::DIVISOR))
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DEFUN REPLACE-ALL ...)
; file: /home/dunham/shootout/bench/regexdna/regexdna.sbcl-3.sbcl
; in: DEFUN REPLACE-ALL
;     (CL-PPCRE:DO-SCANS
;      (MATCH-START MATCH-END REG-STARTS REG-ENDS REGEXP TARGET-STRING NIL)
;      (PUSH (CONS MATCH-START MATCH-END) RMATCH))
; --> LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==>
;   (= MATCH-START MATCH-END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a REAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a REAL.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ MATCH-END 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

; --> LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==>
;   (= MATCH-START MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.

; --> LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ MATCH-END 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN MAIN ...); 
; compilation unit finished
;   printed 22 notes


; /home/dunham/Documents/benchmarksgame_onecore/regexdna/tmp/regexdna.sbcl-3.fasl written
; compilation finished in 0:00:00.690
[undoing binding stack and other enclosing state... done]
[saving current Lisp image into /home/dunham/Documents/benchmarksgame_onecore/regexdna/tmp/sbcl.core:
writing 6272 bytes from the read-only space at 0x20000000
writing 3872 bytes from the static space at 0x20100000
writing 45547520 bytes from the dynamic space at 0x1000000000
done]
### START regexdna.sbcl-3.sbcl_run
(proclaim '(optimize (speed 3) (safety 0) (debug 0) (compilation-speed 0) (space 0)))
(main) (quit)
### END regexdna.sbcl-3.sbcl_run

1.91s to complete and log all make actions

COMMAND LINE:
/usr/local/bin/sbcl  --noinform --core sbcl.core --userinit /dev/null --load regexdna.sbcl-3.sbcl_run 0 < regexdna-input5000000.txt

PROGRAM OUTPUT:
agggtaaa|tttaccct 356
[cgt]gggtaaa|tttaccc[acg] 1250
a[act]ggtaaa|tttacc[agt]t 4252
ag[act]gtaaa|tttac[agt]ct 2894
agg[act]taaa|ttta[agt]cct 5435
aggg[acg]aaa|ttt[cgt]ccct 1537
agggt[cgt]aa|tt[acg]accct 1431
agggta[cgt]a|t[acg]taccct 1608
agggtaa[cgt]|[acg]ttaccct 2178

50833411
50000000
66800214
