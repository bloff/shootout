<span class="hl com">(*</span>
<span class="hl com">** The Computer Language Benchmarks Game</span>
<span class="hl com">** http://shootout.alioth.debian.org/</span>
<span class="hl com">**</span>
<span class="hl com">** contributed by Hongwei Xi</span>
<span class="hl com">**</span>
<span class="hl com">** compilation command:</span>
<span class="hl com">**   atscc -D_GNU_SOURCE -D_ATS_MULTITHREAD -D_ATS_GCATS -O3 -o k-nucleotide3_smp -lpthread k-nucleotide3_smp.dats</span>
<span class="hl com">*)</span>

<span class="hl com">(* ****** ****** *)</span>

staload <span class="hl str">&quot;libc/SATS/stdio.sats&quot;</span>
staload <span class="hl str">&quot;libc/SATS/stdlib.sats&quot;</span>
staload <span class="hl str">&quot;libc/SATS/string.sats&quot;</span>
staload _<span class="hl com">(*anonymous*)</span> <span class="hl sym">=</span> <span class="hl str">&quot;prelude/DATS/array.dats&quot;</span>
staload _<span class="hl com">(*anonymous*)</span> <span class="hl sym">=</span> <span class="hl str">&quot;prelude/DATS/list_vt.dats&quot;</span>

<span class="hl com">(* ****** ****** *)</span>

staload H <span class="hl sym">=</span> <span class="hl str">&quot;libats/SATS/hashtable_chain.sats&quot;</span>
staload _<span class="hl com">(*anon*)</span> <span class="hl sym">=</span> <span class="hl str">&quot;libats/DATS/hashtable_chain.dats&quot;</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl sym">%{</span>^
<span class="hl kwa">typedef</span> char <span class="hl sym">*</span>symbol_t <span class="hl sym">;</span>
<span class="hl sym">%}</span> <span class="hl slc">// end of [%{^]</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl kwa">abstype</span> dna_t <span class="hl slc">// boxed type</span>
abst&#64;ype symbol_t <span class="hl sym">=</span> $extype <span class="hl str">&quot;symbol_t&quot;</span>

<span class="hl com">(* ****** ****** *)</span>

<span class="hl sym">%{</span>^

ats_void_type print_symbol
  <span class="hl sym">(</span>symbol_t sym<span class="hl sym">,</span> ats_size_type len<span class="hl sym">) {</span>
  <span class="hl kwa">while</span> <span class="hl sym">(</span>len <span class="hl sym">&gt;</span> <span class="hl num">0</span><span class="hl sym">) {</span> fputc <span class="hl com">(*sym, stdout) ; --len ; ++sym ; }</span>
<span class="hl com">  return ;</span>
<span class="hl com">} // end of [print_symbol]</span>
<span class="hl com"></span>
<span class="hl com">%} // end of [%{^]</span>
<span class="hl com"></span>
<span class="hl com">extern fun print_symbol</span>
<span class="hl com">  (sym: symbol_t, len: size_t): void = &quot;print_symbol&quot;</span>
<span class="hl com">// end of [print_symbol]</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">%{^</span>
<span class="hl com"></span>
<span class="hl com">size_t the_symlen = 0 ;</span>
<span class="hl com">ats_size_type symlen_get () { return the_symlen ; }</span>
<span class="hl com">ats_void_type symlen_set</span>
<span class="hl com">  (ats_size_type len) { the_symlen = len ; return ; }</span>
<span class="hl com">// end of [symlen_set]</span>
<span class="hl com"></span>
<span class="hl com">%} // end of [%{^]</span>
<span class="hl com">extern fun symlen_get ():&lt;&gt; size_t = &quot;symlen_get&quot;</span>
<span class="hl com">extern fun symlen_set (len: size_t):&lt;&gt; void = &quot;symlen_set&quot;</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">%{^</span>
<span class="hl com"></span>
<span class="hl com">// a commonly used simple hash function</span>
<span class="hl com"></span>
<span class="hl com">static // inline</span>
<span class="hl com">ats_ulint_type hash_symbol_len (</span>
<span class="hl com">  symbol_t sym, ats_size_type len</span>
<span class="hl com">) {</span>
<span class="hl com">  unsigned long int hash_val = 31415927UL ;</span>
<span class="hl com">  while (len &gt;= 4) {</span>
<span class="hl com">    hash_val += hash_val * 33 ;</span>
<span class="hl com">    hash_val += sym[0] &lt;&lt; 24 ;</span>
<span class="hl com">    hash_val += sym[1] &lt;&lt; 16 ;</span>
<span class="hl com">    hash_val += sym[2] &lt;&lt;  8 ;</span>
<span class="hl com">    hash_val += sym[3] ;</span>
<span class="hl com">    sym += 4 ; len -= 4 ;</span>
<span class="hl com">  } // end of [while]</span>
<span class="hl com">  if (len &gt;= 2) {</span>
<span class="hl com">    hash_val = hash_val * 33 + (sym[0] &lt;&lt; 8) + sym[1] ;</span>
<span class="hl com">    sym += 2 ; len -= 2 ;</span>
<span class="hl com">  } // end of [if]</span>
<span class="hl com">  if (len &gt;= 1) {</span>
<span class="hl com">    hash_val = hash_val * 33 + sym[0] ;</span>
<span class="hl com">  } // end of [while]</span>
<span class="hl com">  return hash_val ;</span>
<span class="hl com">} // end of [hash_symbol_len]</span>
<span class="hl com"></span>
<span class="hl com">%} // end of [%{^]</span>
<span class="hl com"></span>
<span class="hl com">extern fun hash_symbol_len</span>
<span class="hl com">  (sym: symbol_t, len: size_t):&lt;&gt; ulint = &quot;hash_symbol_len&quot;</span>
<span class="hl com">// end of [hash_symbol]</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">implement $H.hash_key&lt;symbol_t&gt;</span>
<span class="hl com">  (x, _) = hash_symbol_len (x, symlen_get ())</span>
<span class="hl com">// end of [implement]</span>
<span class="hl com"></span>
<span class="hl com">implement</span>
<span class="hl com">$H.equal_key_key&lt;symbol_t&gt; (x1, x2, _) = let</span>
<span class="hl com">  extern castfn __cast (x: symbol_t):&lt;&gt; string</span>
<span class="hl com">  val x1 = __cast x1 and x2 = __cast x2</span>
<span class="hl com">  val k = symlen_get ()</span>
<span class="hl com">  val k = size1_of_size (k)</span>
<span class="hl com">in</span>
<span class="hl com">  strncmp (x1, x2, k) = 0</span>
<span class="hl com">end // end of [implement]</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">viewtypedef symtbl (l:addr) = $H.HASHTBLptr (symbol_t, int, l)</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">extern fun succ_symbol (x: symbol_t): symbol_t = &quot;#atspre_psucc&quot;</span>
<span class="hl com"></span>
<span class="hl com">fn dna_count {n,k:pos | k &lt;= n} {l:agz}</span>
<span class="hl com">  (tbl: !symtbl l, dna: dna_t, n: size_t n, k: size_t k): void = let</span>
<span class="hl com">  val () = symlen_set (k)</span>
<span class="hl com">  val () = $H.hashtbl_clear (tbl)</span>
<span class="hl com">  var n: size_t = n</span>
<span class="hl com">  var sym: symbol_t =</span>
<span class="hl com">    __cast (dna) where { extern castfn __cast (x: dna_t): symbol_t }</span>
<span class="hl com">  // end of [var]</span>
<span class="hl com">in</span>
<span class="hl com">  while (n &gt;= k) let</span>
<span class="hl com">    val [l_itm:addr] p_itm = $H.hashtbl_search_ref&lt;symbol_t,int&gt; (tbl, sym)</span>
<span class="hl com">    val () = if p_itm &lt;&gt; null then let</span>
<span class="hl com">      prval (fpf, pf) = __assert () where {</span>
<span class="hl com">        extern prfun __assert (): (int&#64;l_itm -&lt;prf&gt; void, int&#64;l_itm)</span>
<span class="hl com">      } // end of [prval]</span>
<span class="hl com">      val () = !p_itm := !p_itm + 1</span>
<span class="hl com">      prval () = fpf (pf)</span>
<span class="hl com">    in</span>
<span class="hl com">      // nothing</span>
<span class="hl com">    end else $H.hashtbl_insert (tbl, sym, 1)</span>
<span class="hl com">  in</span>
<span class="hl com">    n := n - 1; sym := succ_symbol sym</span>
<span class="hl com">  end // end of [while]</span>
<span class="hl com">end // end of [dna_count]</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">typedef symflt = &#64;(symbol_t, float)</span>
<span class="hl com"></span>
<span class="hl com">fn compare_symflt_symflt // [&gt;=]</span>
<span class="hl com">  (x1: &amp;symflt, x2: &amp;symflt):&lt;&gt; Sgn = compare_float_float (x2.1, x1.1)</span>
<span class="hl com">// end of [compare_symflt_symflt]</span>
<span class="hl com"></span>
<span class="hl com">viewtypedef frqlst = List_vt symflt</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">// print and free</span>
<span class="hl com">fun print_free_frqlst</span>
<span class="hl com">  (kfs: frqlst, len: size_t): void = begin case+ kfs of</span>
<span class="hl com">  | ~list_vt_cons (kf, kfs) =&gt; begin print_symbol (kf.0, len);</span>
<span class="hl com">       printf (&quot; %.3f\n&quot;, &#64;(double_of kf.1)); print_free_frqlst (kfs, len)</span>
<span class="hl com">    end // end of [FRQLSTcons]</span>
<span class="hl com">  | ~list_vt_nil () =&gt; ()</span>
<span class="hl com">end // end of [print_free_frqlst]</span>
<span class="hl com"></span>
<span class="hl com">fn write_frequencies {n,k:pos | k &lt;= n} {l:agz}</span>
<span class="hl com">  (tbl: !symtbl l, dna: dna_t, n: size_t n, k: size_t k): void = let</span>
<span class="hl com">  val () = dna_count (tbl, dna, n, k)</span>
<span class="hl com">  var total: int = 0</span>
<span class="hl com">  var !p_clo = &#64;lam (pf: !int&#64;total | k: symbol_t, i: &amp;int): void =&lt;clo&gt;</span>
<span class="hl com">    (total := total + i)</span>
<span class="hl com">  val () = $H.hashtbl_foreach_clo {int&#64;total} (view&#64; total | tbl, !p_clo)</span>
<span class="hl com">  val ftotal = float_of total</span>
<span class="hl com">  var frqs: frqlst = list_vt_nil ()</span>
<span class="hl com">  var !p_clo = &#64;lam</span>
<span class="hl com">    (pf: !frqlst &#64; frqs | k: symbol_t, cnt: &amp;int): void =&lt;clo&gt; let</span>
<span class="hl com">    val f = (float_of 100) * float_of cnt / ftotal; val kf = &#64;(k, f) in</span>
<span class="hl com">    frqs := list_vt_cons (kf, frqs)</span>
<span class="hl com">  end // end of [f]</span>
<span class="hl com">  val () = $H.hashtbl_foreach_clo {frqlst&#64;frqs} (view&#64; frqs | tbl, !p_clo)</span>
<span class="hl com">  val () = list_vt_quicksort (frqs, compare_symflt_symflt)</span>
<span class="hl com">in</span>
<span class="hl com">  print_free_frqlst (frqs, symlen_get ())</span>
<span class="hl com">end // end of [write_frequencies]</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">fn write_count {n,k:pos} {l:agz}</span>
<span class="hl com">  (tbl: !symtbl l, dna: dna_t, n: size_t n, seq: string k): void = let</span>
<span class="hl com">  val k = string1_length seq</span>
<span class="hl com">  val () = assert (k &lt;= n)</span>
<span class="hl com">  val () = dna_count (tbl, dna, n, k)</span>
<span class="hl com">  var res : int</span>
<span class="hl com">  val ans = $H.hashtbl_search</span>
<span class="hl com">    (tbl, __cast seq, res) where { extern castfn __cast (x: string): symbol_t }</span>
<span class="hl com">  // end of [ans]</span>
<span class="hl com">  val () = if ans then let</span>
<span class="hl com">    prval () = opt_unsome {int} (res) in (*none*)</span>
<span class="hl com">  end else let</span>
<span class="hl com">    prval () = opt_unnone {int} (res) in res := 0</span>
<span class="hl com">  end : void // end of [val]</span>
<span class="hl com">in</span>
<span class="hl com">  printf (&quot;%d\t%s\n&quot;, &#64;(res, seq))</span>
<span class="hl com">end // end of [write_count]</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">extern fun getline (): string = &quot;__getline&quot;</span>
<span class="hl com">extern fun getrest (sz: &amp;size_t? &gt;&gt; size_t n): #[n:nat] string n = &quot;__getrest&quot;</span>
<span class="hl com"></span>
<span class="hl com">%{$</span>
<span class="hl com"></span>
<span class="hl com">#define LINEBUFSZ 1024</span>
<span class="hl com">char theLineBuffer[LINEBUFSZ] ;</span>
<span class="hl com">ats_ptr_type __getline () {</span>
<span class="hl com">  fgets (theLineBuffer, LINEBUFSZ, stdin) ; return theLineBuffer ;</span>
<span class="hl com">} /* end of [getline] */</span>
<span class="hl com"></span>
<span class="hl com">#define RESTBUFSZ (128 * 1024 * 1024)</span>
<span class="hl com">char theRestBuffer[RESTBUFSZ] ;</span>
<span class="hl com"></span>
<span class="hl com">ats_ptr_type __getrest (ats_ref_type p_n) {</span>
<span class="hl com">  int c ; size_t i ; char *s ;</span>
<span class="hl com">  s = theRestBuffer ; i = 0 ;</span>
<span class="hl com">  while ((c = fgetc(stdin)) != EOF) {</span>
<span class="hl com">    if (c != '\n') { *s++ = toupper(c) ; i++ ; }</span>
<span class="hl com">  }</span>
<span class="hl com">  *s = '\000' ; *((size_t*)p_n) = i ;</span>
<span class="hl com">  if (i &gt;= RESTBUFSZ) {</span>
<span class="hl com">    fprintf (stderr, &quot;exit(ATS): too much data for processing\n&quot;) ; exit(1) ;</span>
<span class="hl com">  }</span>
<span class="hl com">  return theRestBuffer ;</span>
<span class="hl com">} /* end of [__getrest] */</span>
<span class="hl com"></span>
<span class="hl com">%} // end of [%{^]</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">fun is_three (s: string): bool =</span>
<span class="hl com">  if strncmp (s, &quot;&gt;THREE&quot;, 6) = 0 then true else false</span>
<span class="hl com">// end of [is_three]</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">extern fun dna_of_string (s: string): dna_t = &quot;dna_of_string&quot;</span>
<span class="hl com"></span>
<span class="hl com">implement main (argc, argv) = let</span>
<span class="hl com">  fun dna_three_get</span>
<span class="hl com">    (n: &amp;size_t? &gt;&gt; size_t n): #[n:nat] string n = let</span>
<span class="hl com">    val s = getline (); val is3 = is_three (s)</span>
<span class="hl com">  in</span>
<span class="hl com">    if is3 then getrest (n) else dna_three_get (n)</span>
<span class="hl com">  end // end of [dna_three_get]</span>
<span class="hl com">  var n: size_t // uninitialized</span>
<span class="hl com">  val dna_three = dna_three_get (n)</span>
<span class="hl com">  val () = assert (n &gt;= 2)</span>
<span class="hl com">(*</span>
<span class="hl com">  val () = (prerr &quot;main: n = &quot;; prerr n; prerr_newline ())</span>
<span class="hl com">*)</span>
<span class="hl com">  val dna3 =</span>
<span class="hl com">    dna_of_string dna_three where {</span>
<span class="hl com">    extern castfn dna_of_string (str: string): dna_t</span>
<span class="hl com">  }</span>
<span class="hl com">  val eqfn = $extval ($H.eq symbol_t, &quot;0&quot;)</span>
<span class="hl com">  val fhash = $extval ($H.hash symbol_t, &quot;0&quot;)</span>
<span class="hl com">  val tbl = $H.hashtbl_make_hint (fhash, eqfn, 98317)</span>
<span class="hl com">in</span>
<span class="hl com">  write_frequencies (tbl, dna3, n, 1) ; print_newline () ;</span>
<span class="hl com">  write_frequencies (tbl, dna3, n, 2) ; print_newline () ;</span>
<span class="hl com">  write_count (tbl, dna3, n, &quot;GGT&quot;) ;</span>
<span class="hl com">  write_count (tbl, dna3, n, &quot;GGTA&quot;) ;</span>
<span class="hl com">  write_count (tbl, dna3, n, &quot;GGTATT&quot;) ;</span>
<span class="hl com">  write_count (tbl, dna3, n, &quot;GGTATTTTAATT&quot;) ;</span>
<span class="hl com">  write_count (tbl, dna3, n, &quot;GGTATTTTAATTTATAGT&quot;) ;</span>
<span class="hl com">  $H.hashtbl_free (tbl) ; // hashtable containing only nonlinear items</span>
<span class="hl com">end (* end of [main] *)</span>
<span class="hl com"></span>
<span class="hl com">(* ****** ****** *)</span>
<span class="hl com"></span>
<span class="hl com">(* end of [k-nucleotide3.dats] *)</span>
