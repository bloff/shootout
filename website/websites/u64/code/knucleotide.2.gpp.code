<span class="hl slc">// The Computer Language Benchmarks Game</span>
<span class="hl slc">// http://shootout.alioth.debian.org/</span>

<span class="hl slc">// contributed by James McIlree</span>
<span class="hl slc">// Thanks to The Anh Tran, some code &amp; ideas borrowed from his C++ contribution</span>

<span class="hl dir">#include &lt;algorithm&gt;</span>
<span class="hl dir">#include &lt;vector&gt;</span>
<span class="hl dir">#include &lt;iostream&gt;</span>
<span class="hl dir">#include &lt;sstream&gt;</span>
<span class="hl dir">#include &lt;stdio.h&gt;</span>
<span class="hl dir">#include &lt;stdint.h&gt;</span>

<span class="hl dir">#include &lt;string.h&gt;</span>

<span class="hl dir">#include &lt;ext/pb_ds/assoc_container.hpp&gt;</span>
<span class="hl dir">#include &lt;ext/pb_ds/hash_policy.hpp&gt;</span>

<span class="hl com">/*</span>
<span class="hl com"> * Foward decls</span>
<span class="hl com"> */</span>

<span class="hl kwc">class</span> WorkItem<span class="hl sym">;</span>
<span class="hl kwc">class</span> InputData<span class="hl sym">;</span>

<span class="hl com">/*</span>
<span class="hl com"> * Constants...</span>
<span class="hl com"> */</span>

<span class="hl kwb">const char</span><span class="hl sym">*</span> fragments<span class="hl sym">[] = {</span> <span class="hl str">&quot;*&quot;</span><span class="hl sym">,</span><span class="hl str">&quot;**&quot;</span><span class="hl sym">,</span><span class="hl str">&quot;ggt&quot;</span><span class="hl sym">,</span><span class="hl str">&quot;ggta&quot;</span><span class="hl sym">,</span><span class="hl str">&quot;ggtatt&quot;</span><span class="hl sym">,</span> <span class="hl str">&quot;ggtattttaatt&quot;</span><span class="hl sym">,</span> <span class="hl str">&quot;ggtattttaatttatagt&quot;</span> <span class="hl sym">};</span>
<span class="hl kwb">const size_t</span> BUFFER_SIZE <span class="hl sym">= (</span><span class="hl num">30</span> <span class="hl sym">*</span> <span class="hl num">1024</span> <span class="hl sym">*</span> <span class="hl num">1024</span><span class="hl sym">);</span>
<span class="hl kwb">const size_t</span> BUFFER_BYTES_OVERLAP <span class="hl sym">=</span> <span class="hl num">32</span><span class="hl sym">;</span>

<span class="hl com">/*</span>
<span class="hl com"> * Global state (Ewww)</span>
<span class="hl com"> */</span>

WorkItem<span class="hl sym">*</span> workList <span class="hl sym">=</span> NULL<span class="hl sym">;</span>
<span class="hl kwc">volatile</span> <span class="hl kwb">int</span> moreWorkIsPossible <span class="hl sym">=</span> <span class="hl num">1</span><span class="hl sym">;</span>

<span class="hl com">/*</span>
<span class="hl com"> * Classes</span>
<span class="hl com"> */</span>

<span class="hl kwc">template</span> <span class="hl sym">&lt;</span><span class="hl kwb">int</span> KEY_SIZE<span class="hl sym">&gt;</span>
<span class="hl kwb">struct</span> Key <span class="hl sym">{</span>
    <span class="hl kwb">uint32_t</span> hash<span class="hl sym">;</span>
    <span class="hl kwb">char</span> key<span class="hl sym">[</span>KEY_SIZE<span class="hl sym">];</span>

    <span class="hl kwd">Key</span><span class="hl sym">() :</span> <span class="hl kwd">hash</span><span class="hl sym">(</span><span class="hl num">0</span><span class="hl sym">) {}</span>
    <span class="hl kwd">Key</span><span class="hl sym">(</span><span class="hl kwb">char const</span><span class="hl sym">*</span> str<span class="hl sym">) {</span>
	hash <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span>
	<span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> i <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> i <span class="hl sym">&lt;</span> KEY_SIZE<span class="hl sym">; ++</span>i<span class="hl sym">) {</span>
	    key<span class="hl sym">[</span>i<span class="hl sym">] =</span> str<span class="hl sym">[</span>i<span class="hl sym">];</span>
	    hash <span class="hl sym">= (</span>hash <span class="hl sym">*</span> <span class="hl num">183</span><span class="hl sym">) +</span> key<span class="hl sym">[</span>i<span class="hl sym">];</span>
	<span class="hl sym">}</span>
    <span class="hl sym">}</span>

    <span class="hl kwb">uint32_t</span> <span class="hl kwc">operator</span><span class="hl sym">() (</span><span class="hl kwb">const</span> Key<span class="hl sym">&amp;</span> k<span class="hl sym">)</span> <span class="hl kwb">const</span> <span class="hl sym">{</span> <span class="hl kwa">return</span> k<span class="hl sym">.</span>hash<span class="hl sym">; }</span>

    <span class="hl slc">// specialized for each size</span>
    <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl sym">() (</span><span class="hl kwb">const</span> Key<span class="hl sym">&amp;</span> key1<span class="hl sym">,</span> <span class="hl kwb">const</span> Key<span class="hl sym">&amp;</span> key2<span class="hl sym">)</span> <span class="hl kwb">const</span> <span class="hl sym">{</span> <span class="hl kwa">return false</span><span class="hl sym">; }</span>
<span class="hl sym">};</span>

<span class="hl kwc">template</span><span class="hl sym">&lt;&gt;</span>
<span class="hl kwb">bool</span> Key<span class="hl sym">&lt;</span><span class="hl num">1</span><span class="hl sym">&gt;::</span><span class="hl kwc">operator</span><span class="hl sym">() (</span><span class="hl kwb">const</span> Key<span class="hl sym">&amp;</span> key1<span class="hl sym">,</span> <span class="hl kwb">const</span> Key<span class="hl sym">&amp;</span> key2<span class="hl sym">)</span> <span class="hl kwb">const</span> <span class="hl sym">{</span>
    <span class="hl kwa">return</span> key1<span class="hl sym">.</span>key<span class="hl sym">[</span><span class="hl num">0</span><span class="hl sym">] ==</span> key2<span class="hl sym">.</span>key<span class="hl sym">[</span><span class="hl num">0</span><span class="hl sym">];</span>
<span class="hl sym">}</span>

<span class="hl kwc">template</span><span class="hl sym">&lt;&gt;</span>
<span class="hl kwb">bool</span> Key<span class="hl sym">&lt;</span><span class="hl num">2</span><span class="hl sym">&gt;::</span><span class="hl kwc">operator</span><span class="hl sym">() (</span><span class="hl kwb">const</span> Key<span class="hl sym">&amp;</span> key1<span class="hl sym">,</span> <span class="hl kwb">const</span> Key<span class="hl sym">&amp;</span> key2<span class="hl sym">)</span> <span class="hl kwb">const</span> <span class="hl sym">{</span>
    <span class="hl kwa">return</span> <span class="hl sym">*((</span><span class="hl kwb">uint16_t</span><span class="hl sym">*)</span>key1<span class="hl sym">.</span>key<span class="hl sym">) == *((</span><span class="hl kwb">uint16_t</span><span class="hl sym">*)</span>key2<span class="hl sym">.</span>key<span class="hl sym">);</span>
<span class="hl sym">}</span>

<span class="hl kwc">template</span><span class="hl sym">&lt;&gt;</span>
<span class="hl kwb">bool</span> Key<span class="hl sym">&lt;</span><span class="hl num">3</span><span class="hl sym">&gt;::</span><span class="hl kwc">operator</span><span class="hl sym">() (</span><span class="hl kwb">const</span> Key<span class="hl sym">&amp;</span> key1<span class="hl sym">,</span> <span class="hl kwb">const</span> Key<span class="hl sym">&amp;</span> key2<span class="hl sym">)</span> <span class="hl kwb">const</span> <span class="hl sym">{</span>
    <span class="hl kwa">if</span> <span class="hl sym">((*((</span><span class="hl kwb">uint16_t</span><span class="hl sym">*)</span>key1<span class="hl sym">.</span>key<span class="hl sym">) == *((</span><span class="hl kwb">uint16_t</span><span class="hl sym">*)</span>key2<span class="hl sym">.</span>key<span class="hl sym">)) &amp;&amp;</span>
	key1<span class="hl sym">.</span>key<span class="hl sym">[</span><span class="hl num">2</span><span class="hl sym">] ==</span> key2<span class="hl sym">.</span>key<span class="hl sym">[</span><span class="hl num">2</span><span class="hl sym">])</span>
	<span class="hl kwa">return true</span><span class="hl sym">;</span>

    <span class="hl kwa">return false</span><span class="hl sym">;</span>
<span class="hl sym">}</span>

<span class="hl kwc">template</span><span class="hl sym">&lt;&gt;</span>
<span class="hl kwb">bool</span> Key<span class="hl sym">&lt;</span><span class="hl num">4</span><span class="hl sym">&gt;::</span><span class="hl kwc">operator</span><span class="hl sym">() (</span><span class="hl kwb">const</span> Key<span class="hl sym">&amp;</span> key1<span class="hl sym">,</span> <span class="hl kwb">const</span> Key<span class="hl sym">&amp;</span> key2<span class="hl sym">)</span> <span class="hl kwb">const</span> <span class="hl sym">{</span>
    <span class="hl kwa">return</span> <span class="hl sym">*((</span><span class="hl kwb">uint32_t</span><span class="hl sym">*)</span>key1<span class="hl sym">.</span>key<span class="hl sym">) == *((</span><span class="hl kwb">uint32_t</span><span class="hl sym">*)</span>key2<span class="hl sym">.</span>key<span class="hl sym">);</span>
<span class="hl sym">}</span>

<span class="hl kwc">template</span><span class="hl sym">&lt;&gt;</span>
<span class="hl kwb">bool</span> Key<span class="hl sym">&lt;</span><span class="hl num">6</span><span class="hl sym">&gt;::</span><span class="hl kwc">operator</span><span class="hl sym">() (</span><span class="hl kwb">const</span> Key<span class="hl sym">&amp;</span> key1<span class="hl sym">,</span> <span class="hl kwb">const</span> Key<span class="hl sym">&amp;</span> key2<span class="hl sym">)</span> <span class="hl kwb">const</span> <span class="hl sym">{</span>
    <span class="hl kwa">if</span> <span class="hl sym">((*((</span><span class="hl kwb">uint32_t</span><span class="hl sym">*)</span>key1<span class="hl sym">.</span>key<span class="hl sym">) == *((</span><span class="hl kwb">uint32_t</span><span class="hl sym">*)</span>key2<span class="hl sym">.</span>key<span class="hl sym">)) &amp;&amp;</span>
	<span class="hl sym">(((</span><span class="hl kwb">uint16_t</span><span class="hl sym">*)</span>key1<span class="hl sym">.</span>key<span class="hl sym">)[</span><span class="hl num">2</span><span class="hl sym">] == ((</span><span class="hl kwb">uint16_t</span><span class="hl sym">*)</span>key2<span class="hl sym">.</span>key<span class="hl sym">)[</span><span class="hl num">2</span><span class="hl sym">]))</span>
	<span class="hl kwa">return true</span><span class="hl sym">;</span>

    <span class="hl kwa">return false</span><span class="hl sym">;</span>
<span class="hl sym">}</span>

<span class="hl kwc">template</span><span class="hl sym">&lt;&gt;</span>
<span class="hl kwb">bool</span> Key<span class="hl sym">&lt;</span><span class="hl num">12</span><span class="hl sym">&gt;::</span><span class="hl kwc">operator</span><span class="hl sym">() (</span><span class="hl kwb">const</span> Key<span class="hl sym">&amp;</span> key1<span class="hl sym">,</span> <span class="hl kwb">const</span> Key<span class="hl sym">&amp;</span> key2<span class="hl sym">)</span> <span class="hl kwb">const</span> <span class="hl sym">{</span>
    <span class="hl kwb">uint32_t</span><span class="hl sym">*</span> k1 <span class="hl sym">= (</span><span class="hl kwb">uint32_t</span><span class="hl sym">*)</span>key1<span class="hl sym">.</span>key<span class="hl sym">;</span>
    <span class="hl kwb">uint32_t</span><span class="hl sym">*</span> k2 <span class="hl sym">= (</span><span class="hl kwb">uint32_t</span><span class="hl sym">*)</span>key2<span class="hl sym">.</span>key<span class="hl sym">;</span>
    <span class="hl kwa">if</span> <span class="hl sym">(</span>k1<span class="hl sym">[</span><span class="hl num">0</span><span class="hl sym">] ==</span> k2<span class="hl sym">[</span><span class="hl num">0</span><span class="hl sym">] &amp;&amp;</span>
	k1<span class="hl sym">[</span><span class="hl num">1</span><span class="hl sym">] ==</span> k2<span class="hl sym">[</span><span class="hl num">1</span><span class="hl sym">] &amp;&amp;</span>
	k1<span class="hl sym">[</span><span class="hl num">2</span><span class="hl sym">] ==</span> k2<span class="hl sym">[</span><span class="hl num">2</span><span class="hl sym">])</span>
	<span class="hl kwa">return true</span><span class="hl sym">;</span>

    <span class="hl kwa">return false</span><span class="hl sym">;</span>
<span class="hl sym">}</span>

<span class="hl kwc">template</span><span class="hl sym">&lt;&gt;</span>
<span class="hl kwb">bool</span> Key<span class="hl sym">&lt;</span><span class="hl num">18</span><span class="hl sym">&gt;::</span><span class="hl kwc">operator</span><span class="hl sym">() (</span><span class="hl kwb">const</span> Key<span class="hl sym">&amp;</span> key1<span class="hl sym">,</span> <span class="hl kwb">const</span> Key<span class="hl sym">&amp;</span> key2<span class="hl sym">)</span> <span class="hl kwb">const</span> <span class="hl sym">{</span>
    <span class="hl kwb">uint64_t</span><span class="hl sym">*</span> k1 <span class="hl sym">= (</span><span class="hl kwb">uint64_t</span><span class="hl sym">*)</span>key1<span class="hl sym">.</span>key<span class="hl sym">;</span>
    <span class="hl kwb">uint64_t</span><span class="hl sym">*</span> k2 <span class="hl sym">= (</span><span class="hl kwb">uint64_t</span><span class="hl sym">*)</span>key2<span class="hl sym">.</span>key<span class="hl sym">;</span>
    <span class="hl kwa">if</span> <span class="hl sym">(</span>k1<span class="hl sym">[</span><span class="hl num">0</span><span class="hl sym">] ==</span> k2<span class="hl sym">[</span><span class="hl num">0</span><span class="hl sym">] &amp;&amp;</span>
	k1<span class="hl sym">[</span><span class="hl num">1</span><span class="hl sym">] ==</span> k2<span class="hl sym">[</span><span class="hl num">1</span><span class="hl sym">] &amp;&amp;</span>
	<span class="hl sym">(((</span><span class="hl kwb">uint16_t</span><span class="hl sym">*)</span>key1<span class="hl sym">.</span>key<span class="hl sym">)[</span><span class="hl num">8</span><span class="hl sym">] == ((</span><span class="hl kwb">uint16_t</span><span class="hl sym">*)</span>key2<span class="hl sym">.</span>key<span class="hl sym">)[</span><span class="hl num">8</span><span class="hl sym">]))</span>
	<span class="hl kwa">return true</span><span class="hl sym">;</span>

    <span class="hl kwa">return false</span><span class="hl sym">;</span>
<span class="hl sym">}</span>

<span class="hl kwc">template</span> <span class="hl sym">&lt;</span><span class="hl kwb">int</span> KEY_SIZE<span class="hl sym">&gt;</span>
<span class="hl kwc">class</span> HashTable <span class="hl sym">:</span> <span class="hl kwc">public</span> __gnu_pbds<span class="hl sym">::</span>cc_hash_table <span class="hl sym">&lt;</span> Key<span class="hl sym">&lt;</span>KEY_SIZE<span class="hl sym">&gt;,</span> <span class="hl kwb">uint32_t</span><span class="hl sym">,</span> Key<span class="hl sym">&lt;</span>KEY_SIZE<span class="hl sym">&gt;,</span> Key<span class="hl sym">&lt;</span>KEY_SIZE<span class="hl sym">&gt; &gt; {};</span>

<span class="hl kwc">class</span> WorkerThread <span class="hl sym">{</span>
<span class="hl kwc">public</span><span class="hl sym">:</span>
    HashTable<span class="hl sym">&lt;</span><span class="hl num">1</span><span class="hl sym">&gt;</span> hash1<span class="hl sym">;</span>
    HashTable<span class="hl sym">&lt;</span><span class="hl num">2</span><span class="hl sym">&gt;</span> hash2<span class="hl sym">;</span>
    HashTable<span class="hl sym">&lt;</span><span class="hl num">3</span><span class="hl sym">&gt;</span> hash3<span class="hl sym">;</span>
    HashTable<span class="hl sym">&lt;</span><span class="hl num">4</span><span class="hl sym">&gt;</span> hash4<span class="hl sym">;</span>
    HashTable<span class="hl sym">&lt;</span><span class="hl num">6</span><span class="hl sym">&gt;</span> hash6<span class="hl sym">;</span>
    HashTable<span class="hl sym">&lt;</span><span class="hl num">12</span><span class="hl sym">&gt;</span> hash12<span class="hl sym">;</span>
    HashTable<span class="hl sym">&lt;</span><span class="hl num">18</span><span class="hl sym">&gt;</span> hash18<span class="hl sym">;</span>

    pthread_t pthread<span class="hl sym">;</span>

    <span class="hl slc">// Silly hack for printing</span>
    <span class="hl kwb">void</span><span class="hl sym">*</span> <span class="hl kwd">hashByLength</span><span class="hl sym">(</span><span class="hl kwb">int</span> length<span class="hl sym">) {</span>
	<span class="hl kwa">switch</span> <span class="hl sym">(</span>length<span class="hl sym">) {</span>
	    <span class="hl kwa">case</span> <span class="hl num">1</span><span class="hl sym">:</span> <span class="hl kwa">return</span> <span class="hl sym">&amp;</span>hash1<span class="hl sym">;</span>
	    <span class="hl kwa">case</span> <span class="hl num">2</span><span class="hl sym">:</span> <span class="hl kwa">return</span> <span class="hl sym">&amp;</span>hash2<span class="hl sym">;</span>
	    <span class="hl kwa">case</span> <span class="hl num">3</span><span class="hl sym">:</span> <span class="hl kwa">return</span> <span class="hl sym">&amp;</span>hash3<span class="hl sym">;</span>
	    <span class="hl kwa">case</span> <span class="hl num">4</span><span class="hl sym">:</span> <span class="hl kwa">return</span> <span class="hl sym">&amp;</span>hash4<span class="hl sym">;</span>
	    <span class="hl kwa">case</span> <span class="hl num">6</span><span class="hl sym">:</span> <span class="hl kwa">return</span> <span class="hl sym">&amp;</span>hash6<span class="hl sym">;</span>
	    <span class="hl kwa">case</span> <span class="hl num">12</span><span class="hl sym">:</span> <span class="hl kwa">return</span> <span class="hl sym">&amp;</span>hash12<span class="hl sym">;</span>
	    <span class="hl kwa">case</span> <span class="hl num">18</span><span class="hl sym">:</span> <span class="hl kwa">return</span> <span class="hl sym">&amp;</span>hash18<span class="hl sym">;</span>
	    <span class="hl kwa">default</span><span class="hl sym">:</span> <span class="hl kwd">exit</span><span class="hl sym">(</span><span class="hl num">667</span><span class="hl sym">);</span>
	<span class="hl sym">}</span>
    <span class="hl sym">}</span>
<span class="hl sym">};</span>

<span class="hl kwc">class</span> WorkItem <span class="hl sym">{</span>
  <span class="hl kwc">public</span><span class="hl sym">:</span>
    <span class="hl kwb">int</span> first<span class="hl sym">;</span>
    <span class="hl kwb">int</span> last<span class="hl sym">;</span>
    <span class="hl kwb">int</span> length<span class="hl sym">;</span>
    InputData<span class="hl sym">*</span> data<span class="hl sym">;</span>
    WorkItem<span class="hl sym">*</span> next<span class="hl sym">;</span>

    <span class="hl kwd">WorkItem</span><span class="hl sym">(</span><span class="hl kwb">int</span> f<span class="hl sym">,</span> <span class="hl kwb">int</span> l<span class="hl sym">,</span> <span class="hl kwb">int</span> len<span class="hl sym">,</span> InputData<span class="hl sym">*</span> d<span class="hl sym">,</span> WorkItem<span class="hl sym">*</span> n<span class="hl sym">) :</span> <span class="hl kwd">first</span><span class="hl sym">(</span>f<span class="hl sym">),</span> <span class="hl kwd">last</span><span class="hl sym">(</span>l<span class="hl sym">),</span> <span class="hl kwd">length</span><span class="hl sym">(</span>len<span class="hl sym">),</span> <span class="hl kwd">data</span><span class="hl sym">(</span>d<span class="hl sym">),</span> <span class="hl kwd">next</span><span class="hl sym">(</span>n<span class="hl sym">) {}</span>
<span class="hl sym">};</span>

<span class="hl kwc">class</span> InputData <span class="hl sym">{</span>
<span class="hl kwc">public</span><span class="hl sym">:</span>
    <span class="hl kwb">size_t</span> capacity<span class="hl sym">;</span>
    <span class="hl kwb">size_t</span> length<span class="hl sym">;</span>
    <span class="hl kwb">size_t</span> logicalIndex<span class="hl sym">;</span>
    <span class="hl kwb">char</span> overlapBytes<span class="hl sym">[</span>BUFFER_BYTES_OVERLAP<span class="hl sym">];</span>
    <span class="hl kwb">char</span> buffer<span class="hl sym">[</span>BUFFER_SIZE<span class="hl sym">+</span><span class="hl num">1</span><span class="hl sym">];</span>

    <span class="hl kwd">InputData</span><span class="hl sym">() :</span> <span class="hl kwd">capacity</span><span class="hl sym">(</span>BUFFER_SIZE<span class="hl sym">),</span> <span class="hl kwd">length</span><span class="hl sym">(</span><span class="hl num">0</span><span class="hl sym">),</span> <span class="hl kwd">logicalIndex</span><span class="hl sym">(</span><span class="hl num">0</span><span class="hl sym">) {}</span>
    <span class="hl kwd">InputData</span><span class="hl sym">(</span>InputData<span class="hl sym">&amp;</span> previous<span class="hl sym">) :</span> <span class="hl kwd">capacity</span><span class="hl sym">(</span>BUFFER_SIZE<span class="hl sym">),</span> <span class="hl kwd">length</span><span class="hl sym">(</span><span class="hl num">0</span><span class="hl sym">),</span> <span class="hl kwd">logicalIndex</span><span class="hl sym">(</span>previous<span class="hl sym">.</span>logicalIndex <span class="hl sym">+</span> previous<span class="hl sym">.</span>length<span class="hl sym">) {</span>
	<span class="hl kwd">memcpy</span><span class="hl sym">(</span>overlapBytes<span class="hl sym">, &amp;</span>previous<span class="hl sym">.</span>buffer<span class="hl sym">[</span>previous<span class="hl sym">.</span>length <span class="hl sym">-</span> BUFFER_BYTES_OVERLAP<span class="hl sym">],</span> BUFFER_BYTES_OVERLAP<span class="hl sym">);</span>
    <span class="hl sym">}</span>

    <span class="hl kwb">void</span> <span class="hl kwd">addToWorkList</span><span class="hl sym">() {</span>
	WorkItem<span class="hl sym">*</span> head <span class="hl sym">=</span> NULL<span class="hl sym">;</span>
	<span class="hl kwb">int</span> i<span class="hl sym">,</span>j<span class="hl sym">;</span>

	<span class="hl kwa">for</span> <span class="hl sym">(</span>i<span class="hl sym">=</span><span class="hl num">0</span><span class="hl sym">;</span> i<span class="hl sym">&lt;</span><span class="hl kwa">sizeof</span><span class="hl sym">(</span>fragments<span class="hl sym">) /</span> <span class="hl kwa">sizeof</span><span class="hl sym">(</span><span class="hl kwb">const char</span><span class="hl sym">*);</span> i<span class="hl sym">++) {</span>
	    <span class="hl kwb">size_t</span> fragmentLength <span class="hl sym">=</span> <span class="hl kwd">strlen</span><span class="hl sym">(</span>fragments<span class="hl sym">[</span>i<span class="hl sym">]);</span>
	    <span class="hl kwa">for</span> <span class="hl sym">(</span>j<span class="hl sym">=</span><span class="hl num">0</span><span class="hl sym">;</span> j<span class="hl sym">&lt;</span>fragmentLength<span class="hl sym">;</span> j<span class="hl sym">++) {</span>
		<span class="hl kwb">int</span> firstIndex <span class="hl sym">= (</span>logicalIndex <span class="hl sym">==</span> <span class="hl num">0</span><span class="hl sym">)</span> ?  j <span class="hl sym">: -((</span>logicalIndex <span class="hl sym">-</span> j<span class="hl sym">) %</span> fragmentLength<span class="hl sym">);</span>
		<span class="hl kwb">int</span> lastIndex <span class="hl sym">=</span> length <span class="hl sym">-</span> fragmentLength <span class="hl sym">+</span> <span class="hl num">1</span><span class="hl sym">;</span>
		WorkItem<span class="hl sym">*</span> item <span class="hl sym">=</span> <span class="hl kwa">new</span> <span class="hl kwd">WorkItem</span><span class="hl sym">(</span>firstIndex<span class="hl sym">,</span> lastIndex<span class="hl sym">,</span> fragmentLength<span class="hl sym">,</span> <span class="hl kwa">this</span><span class="hl sym">,</span> head<span class="hl sym">);</span>
		head <span class="hl sym">=</span> item<span class="hl sym">;</span>
	    <span class="hl sym">}</span>
	<span class="hl sym">}</span>

	WorkItem<span class="hl sym">*</span> last <span class="hl sym">=</span> head<span class="hl sym">;</span>
	<span class="hl kwa">while</span> <span class="hl sym">(</span>last<span class="hl sym">-&gt;</span>next<span class="hl sym">)</span>
	    last <span class="hl sym">=</span> last<span class="hl sym">-&gt;</span>next<span class="hl sym">;</span>

	<span class="hl kwa">do</span> <span class="hl sym">{</span>
	    last<span class="hl sym">-&gt;</span>next <span class="hl sym">=</span> workList<span class="hl sym">;</span>
	<span class="hl sym">}</span> <span class="hl kwa">while</span> <span class="hl sym">(!</span><span class="hl kwd">__sync_bool_compare_and_swap</span><span class="hl sym">(&amp;</span>workList<span class="hl sym">,</span> last<span class="hl sym">-&gt;</span>next<span class="hl sym">,</span> head<span class="hl sym">));</span>
    <span class="hl sym">}</span>
<span class="hl sym">};</span>

<span class="hl kwc">template</span> <span class="hl sym">&lt;</span><span class="hl kwb">int</span> KEY_SIZE<span class="hl sym">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">calculateFrequencies</span><span class="hl sym">(</span>InputData<span class="hl sym">*</span> data<span class="hl sym">,</span> HashTable<span class="hl sym">&lt;</span>KEY_SIZE<span class="hl sym">&gt;&amp;</span> map<span class="hl sym">,</span> <span class="hl kwb">int</span> firstIndex<span class="hl sym">,</span> <span class="hl kwb">int</span> lastIndex<span class="hl sym">) {</span>
    <span class="hl kwb">int</span> index<span class="hl sym">;</span>
    <span class="hl kwa">for</span> <span class="hl sym">(</span>index<span class="hl sym">=</span>firstIndex<span class="hl sym">;</span> index<span class="hl sym">&lt;</span>lastIndex<span class="hl sym">;</span> index<span class="hl sym">+=</span>KEY_SIZE<span class="hl sym">) {</span>
	Key<span class="hl sym">&lt;</span>KEY_SIZE<span class="hl sym">&gt;</span> <span class="hl kwd">k</span><span class="hl sym">(&amp;</span>data<span class="hl sym">-&gt;</span>buffer<span class="hl sym">[</span>index<span class="hl sym">]);</span>
	map<span class="hl sym">[</span>k<span class="hl sym">]++;</span>
    <span class="hl sym">}</span>
<span class="hl sym">}</span>

<span class="hl kwb">void</span><span class="hl sym">*</span> <span class="hl kwd">doWork</span><span class="hl sym">(</span>WorkerThread<span class="hl sym">*</span> thread<span class="hl sym">) {</span>
    WorkItem<span class="hl sym">*</span> item<span class="hl sym">;</span>
    <span class="hl kwa">do</span> <span class="hl sym">{</span>
	<span class="hl kwa">if</span> <span class="hl sym">(</span>item <span class="hl sym">=</span> workList<span class="hl sym">) {</span>
	    <span class="hl kwa">if</span> <span class="hl sym">(</span><span class="hl kwd">__sync_bool_compare_and_swap</span><span class="hl sym">(&amp;</span>workList<span class="hl sym">,</span> item<span class="hl sym">,</span> item<span class="hl sym">-&gt;</span>next<span class="hl sym">)) {</span>
		<span class="hl kwa">switch</span> <span class="hl sym">(</span>item<span class="hl sym">-&gt;</span>length<span class="hl sym">) {</span>
		    <span class="hl kwa">case</span> <span class="hl num">1</span><span class="hl sym">:</span>
			<span class="hl kwd">calculateFrequencies</span><span class="hl sym">(</span>item<span class="hl sym">-&gt;</span>data<span class="hl sym">,</span> thread<span class="hl sym">-&gt;</span>hash1<span class="hl sym">,</span> item<span class="hl sym">-&gt;</span>first<span class="hl sym">,</span> item<span class="hl sym">-&gt;</span>last<span class="hl sym">);</span>
			<span class="hl kwa">break</span><span class="hl sym">;</span>
		    <span class="hl kwa">case</span> <span class="hl num">2</span><span class="hl sym">:</span>
			<span class="hl kwd">calculateFrequencies</span><span class="hl sym">(</span>item<span class="hl sym">-&gt;</span>data<span class="hl sym">,</span> thread<span class="hl sym">-&gt;</span>hash2<span class="hl sym">,</span> item<span class="hl sym">-&gt;</span>first<span class="hl sym">,</span> item<span class="hl sym">-&gt;</span>last<span class="hl sym">);</span>
			<span class="hl kwa">break</span><span class="hl sym">;</span>
		    <span class="hl kwa">case</span> <span class="hl num">3</span><span class="hl sym">:</span>
			<span class="hl kwd">calculateFrequencies</span><span class="hl sym">(</span>item<span class="hl sym">-&gt;</span>data<span class="hl sym">,</span> thread<span class="hl sym">-&gt;</span>hash3<span class="hl sym">,</span> item<span class="hl sym">-&gt;</span>first<span class="hl sym">,</span> item<span class="hl sym">-&gt;</span>last<span class="hl sym">);</span>
			<span class="hl kwa">break</span><span class="hl sym">;</span>
		    <span class="hl kwa">case</span> <span class="hl num">4</span><span class="hl sym">:</span>
			<span class="hl kwd">calculateFrequencies</span><span class="hl sym">(</span>item<span class="hl sym">-&gt;</span>data<span class="hl sym">,</span> thread<span class="hl sym">-&gt;</span>hash4<span class="hl sym">,</span> item<span class="hl sym">-&gt;</span>first<span class="hl sym">,</span> item<span class="hl sym">-&gt;</span>last<span class="hl sym">);</span>
			<span class="hl kwa">break</span><span class="hl sym">;</span>
		    <span class="hl kwa">case</span> <span class="hl num">6</span><span class="hl sym">:</span>
			<span class="hl kwd">calculateFrequencies</span><span class="hl sym">(</span>item<span class="hl sym">-&gt;</span>data<span class="hl sym">,</span> thread<span class="hl sym">-&gt;</span>hash6<span class="hl sym">,</span> item<span class="hl sym">-&gt;</span>first<span class="hl sym">,</span> item<span class="hl sym">-&gt;</span>last<span class="hl sym">);</span>
			<span class="hl kwa">break</span><span class="hl sym">;</span>
		    <span class="hl kwa">case</span> <span class="hl num">12</span><span class="hl sym">:</span>
			<span class="hl kwd">calculateFrequencies</span><span class="hl sym">(</span>item<span class="hl sym">-&gt;</span>data<span class="hl sym">,</span> thread<span class="hl sym">-&gt;</span>hash12<span class="hl sym">,</span> item<span class="hl sym">-&gt;</span>first<span class="hl sym">,</span> item<span class="hl sym">-&gt;</span>last<span class="hl sym">);</span>
			<span class="hl kwa">break</span><span class="hl sym">;</span>
		    <span class="hl kwa">case</span> <span class="hl num">18</span><span class="hl sym">:</span>
			<span class="hl kwd">calculateFrequencies</span><span class="hl sym">(</span>item<span class="hl sym">-&gt;</span>data<span class="hl sym">,</span> thread<span class="hl sym">-&gt;</span>hash18<span class="hl sym">,</span> item<span class="hl sym">-&gt;</span>first<span class="hl sym">,</span> item<span class="hl sym">-&gt;</span>last<span class="hl sym">);</span>
			<span class="hl kwa">break</span><span class="hl sym">;</span>
		    <span class="hl kwa">default</span><span class="hl sym">:</span> <span class="hl kwd">exit</span><span class="hl sym">(</span><span class="hl num">666</span><span class="hl sym">);</span>
			<span class="hl kwa">break</span><span class="hl sym">;</span>
		<span class="hl sym">}</span>
		<span class="hl kwa">delete</span> item<span class="hl sym">;</span>
	    <span class="hl sym">}</span>
	<span class="hl sym">}</span> <span class="hl kwa">else</span> <span class="hl sym">{</span>
	    <span class="hl kwa">if</span> <span class="hl sym">(</span>moreWorkIsPossible<span class="hl sym">)</span>
		<span class="hl kwd">usleep</span><span class="hl sym">(</span><span class="hl num">1000</span><span class="hl sym">);</span>
	<span class="hl sym">}</span>
    <span class="hl sym">}</span> <span class="hl kwa">while</span> <span class="hl sym">(</span>workList <span class="hl sym">||</span> moreWorkIsPossible<span class="hl sym">);</span>

    <span class="hl kwa">return</span> NULL<span class="hl sym">;</span>
<span class="hl sym">}</span>

<span class="hl kwc">template</span><span class="hl sym">&lt;</span><span class="hl kwc">class</span> T<span class="hl sym">&gt;</span>
<span class="hl kwb">struct</span> greater_second <span class="hl sym">:</span> std<span class="hl sym">::</span>binary_function<span class="hl sym">&lt;</span>T<span class="hl sym">,</span>T<span class="hl sym">,</span><span class="hl kwb">bool</span><span class="hl sym">&gt; {</span>
    <span class="hl kwc">inline</span> <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl sym">()(</span><span class="hl kwb">const</span> T<span class="hl sym">&amp;</span> lhs<span class="hl sym">,</span> <span class="hl kwb">const</span> T<span class="hl sym">&amp;</span> rhs<span class="hl sym">) {</span>
	<span class="hl kwa">return</span> lhs<span class="hl sym">.</span>second <span class="hl sym">&gt;</span> rhs<span class="hl sym">.</span>second<span class="hl sym">;</span>
    <span class="hl sym">}</span>
<span class="hl sym">};</span>

<span class="hl kwc">template</span> <span class="hl sym">&lt;</span><span class="hl kwb">int</span> KEY_SIZE<span class="hl sym">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">merge_table</span><span class="hl sym">(</span>HashTable<span class="hl sym">&lt;</span>KEY_SIZE<span class="hl sym">&gt;&amp;</span> dest<span class="hl sym">,</span> HashTable<span class="hl sym">&lt;</span>KEY_SIZE<span class="hl sym">&gt;&amp;</span> src<span class="hl sym">) {</span>
    <span class="hl kwa">for</span> <span class="hl sym">(</span>typename HashTable<span class="hl sym">&lt;</span>KEY_SIZE<span class="hl sym">&gt;::</span>iterator it <span class="hl sym">=</span> src<span class="hl sym">.</span><span class="hl kwd">begin</span><span class="hl sym">();</span> it <span class="hl sym">!=</span> src<span class="hl sym">.</span><span class="hl kwd">end</span><span class="hl sym">(); ++</span>it<span class="hl sym">) {</span>
	dest<span class="hl sym">[(*</span>it<span class="hl sym">).</span>first<span class="hl sym">] += (*</span>it<span class="hl sym">).</span>second<span class="hl sym">;</span>
    <span class="hl sym">}</span>
<span class="hl sym">}</span>

<span class="hl kwc">template</span> <span class="hl sym">&lt;</span><span class="hl kwb">int</span> KEY_SIZE<span class="hl sym">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">printFreq</span><span class="hl sym">(</span>WorkerThread<span class="hl sym">*</span> threads<span class="hl sym">,</span> <span class="hl kwb">int</span> cpus<span class="hl sym">,</span> <span class="hl kwb">float</span> totalCount<span class="hl sym">) {</span>
    HashTable<span class="hl sym">&lt;</span>KEY_SIZE<span class="hl sym">&gt;</span> sum<span class="hl sym">;</span>
    <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> i<span class="hl sym">=</span><span class="hl num">0</span><span class="hl sym">;</span> i<span class="hl sym">&lt;</span>cpus<span class="hl sym">;</span> i<span class="hl sym">++) {</span>
	<span class="hl kwd">merge_table</span><span class="hl sym">(</span>sum<span class="hl sym">, *((</span>HashTable<span class="hl sym">&lt;</span>KEY_SIZE<span class="hl sym">&gt;*)</span>threads<span class="hl sym">[</span>i<span class="hl sym">].</span><span class="hl kwd">hashByLength</span><span class="hl sym">(</span>KEY_SIZE<span class="hl sym">)));</span>
    <span class="hl sym">}</span>

    <span class="hl kwc">typedef</span> std<span class="hl sym">::</span>pair<span class="hl sym">&lt;</span> Key<span class="hl sym">&lt;</span>KEY_SIZE<span class="hl sym">&gt;,</span> <span class="hl kwb">uint32_t</span> <span class="hl sym">&gt;</span> hash_pair_t<span class="hl sym">;</span>
    std<span class="hl sym">::</span>vector<span class="hl sym">&lt;</span>hash_pair_t<span class="hl sym">&gt;</span> <span class="hl kwd">list</span><span class="hl sym">(</span>sum<span class="hl sym">.</span><span class="hl kwd">begin</span><span class="hl sym">(),</span> sum<span class="hl sym">.</span><span class="hl kwd">end</span><span class="hl sym">());</span>
    std<span class="hl sym">::</span><span class="hl kwd">sort</span><span class="hl sym">(</span>list<span class="hl sym">.</span><span class="hl kwd">begin</span><span class="hl sym">(),</span> list<span class="hl sym">.</span><span class="hl kwd">end</span><span class="hl sym">(),</span> greater_second<span class="hl sym">&lt;</span>hash_pair_t<span class="hl sym">&gt;());</span>

    <span class="hl kwa">for</span> <span class="hl sym">(</span>typename std<span class="hl sym">::</span>vector<span class="hl sym">&lt;</span>hash_pair_t<span class="hl sym">&gt;::</span>iterator it <span class="hl sym">=</span> list<span class="hl sym">.</span><span class="hl kwd">begin</span><span class="hl sym">();</span> it <span class="hl sym">&lt;</span> list<span class="hl sym">.</span><span class="hl kwd">end</span><span class="hl sym">(); ++</span>it<span class="hl sym">) {</span>
	<span class="hl kwb">char</span> key<span class="hl sym">[</span>KEY_SIZE<span class="hl sym">+</span><span class="hl num">1</span><span class="hl sym">];</span>
	<span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> i<span class="hl sym">=</span><span class="hl num">0</span><span class="hl sym">;</span> i<span class="hl sym">&lt;</span>KEY_SIZE<span class="hl sym">;</span> i<span class="hl sym">++)</span> key<span class="hl sym">[</span>i<span class="hl sym">] =</span> <span class="hl kwd">toupper</span><span class="hl sym">((*</span>it<span class="hl sym">).</span>first<span class="hl sym">.</span>key<span class="hl sym">[</span>i<span class="hl sym">]);</span>
	key<span class="hl sym">[</span>KEY_SIZE<span class="hl sym">] =</span> <span class="hl num">0</span><span class="hl sym">;</span>
	<span class="hl kwd">printf</span><span class="hl sym">(</span><span class="hl str">&quot;%s %.3f</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl sym">,</span> key<span class="hl sym">, (</span><span class="hl kwb">float</span><span class="hl sym">)((*</span>it<span class="hl sym">).</span>second<span class="hl sym">) *</span> <span class="hl num">100.0</span>f <span class="hl sym">/</span> totalCount<span class="hl sym">);</span>
    <span class="hl sym">}</span>
    <span class="hl kwd">printf</span><span class="hl sym">(</span><span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl sym">);</span>

<span class="hl sym">}</span>

<span class="hl kwc">template</span> <span class="hl sym">&lt;</span><span class="hl kwb">int</span> KEY_SIZE<span class="hl sym">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">printCount</span><span class="hl sym">(</span>WorkerThread<span class="hl sym">*</span> threads<span class="hl sym">,</span> <span class="hl kwb">int</span> cpus<span class="hl sym">,</span> <span class="hl kwb">const char</span><span class="hl sym">*</span> fragment<span class="hl sym">) {</span>
    Key<span class="hl sym">&lt;</span>KEY_SIZE<span class="hl sym">&gt;</span> <span class="hl kwd">k</span><span class="hl sym">(</span>fragment<span class="hl sym">);</span>
    <span class="hl kwb">int</span> count <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span>
    <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> i<span class="hl sym">=</span><span class="hl num">0</span><span class="hl sym">;</span> i<span class="hl sym">&lt;</span>cpus<span class="hl sym">;</span> i<span class="hl sym">++) {</span>
	count <span class="hl sym">+= (*(</span>HashTable<span class="hl sym">&lt;</span>KEY_SIZE<span class="hl sym">&gt;*)</span>threads<span class="hl sym">[</span>i<span class="hl sym">].</span><span class="hl kwd">hashByLength</span><span class="hl sym">(</span>KEY_SIZE<span class="hl sym">))[</span>k<span class="hl sym">];</span>
    <span class="hl sym">}</span>

    <span class="hl kwb">char</span> key<span class="hl sym">[</span>KEY_SIZE<span class="hl sym">+</span><span class="hl num">1</span><span class="hl sym">];</span>
    <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> i<span class="hl sym">=</span><span class="hl num">0</span><span class="hl sym">;</span> i<span class="hl sym">&lt;</span>KEY_SIZE<span class="hl sym">;</span> i<span class="hl sym">++)</span> key<span class="hl sym">[</span>i<span class="hl sym">] =</span> <span class="hl kwd">toupper</span><span class="hl sym">(</span>fragment<span class="hl sym">[</span>i<span class="hl sym">]);</span>
    key<span class="hl sym">[</span>KEY_SIZE<span class="hl sym">] =</span> <span class="hl num">0</span><span class="hl sym">;</span>
    <span class="hl kwd">printf</span><span class="hl sym">(</span><span class="hl str">&quot;%d</span><span class="hl esc">\t</span><span class="hl str">%s</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl sym">,</span> count<span class="hl sym">,</span> key<span class="hl sym">);</span>
<span class="hl sym">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">numCPUS</span><span class="hl sym">() {</span>
    cpu_set_t cs<span class="hl sym">;</span>
    <span class="hl kwd">CPU_ZERO</span><span class="hl sym">(&amp;</span>cs<span class="hl sym">);</span>
    <span class="hl kwd">sched_getaffinity</span><span class="hl sym">(</span><span class="hl num">0</span><span class="hl sym">,</span> <span class="hl kwa">sizeof</span><span class="hl sym">(</span>cs<span class="hl sym">), &amp;</span>cs<span class="hl sym">);</span>

    <span class="hl kwb">int</span> count <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span>
    <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> i <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> i <span class="hl sym">&lt;</span> <span class="hl num">16</span><span class="hl sym">; ++</span>i<span class="hl sym">) {</span>
	<span class="hl kwa">if</span> <span class="hl sym">(</span><span class="hl kwd">CPU_ISSET</span><span class="hl sym">(</span>i<span class="hl sym">, &amp;</span>cs<span class="hl sym">))</span>
	    <span class="hl sym">++</span>count<span class="hl sym">;</span>
    <span class="hl sym">}</span>
    <span class="hl kwa">return</span> count<span class="hl sym">;</span>
<span class="hl sym">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl sym">() {</span>
    InputData<span class="hl sym">*</span> data <span class="hl sym">=</span> <span class="hl kwa">new</span> <span class="hl kwd">InputData</span><span class="hl sym">();</span>

    <span class="hl kwa">while</span> <span class="hl sym">(</span><span class="hl kwd">fgets</span><span class="hl sym">(</span>data<span class="hl sym">-&gt;</span>buffer<span class="hl sym">,</span> data<span class="hl sym">-&gt;</span>capacity<span class="hl sym">,</span> stdin<span class="hl sym">))</span>
	<span class="hl kwa">if</span> <span class="hl sym">(</span><span class="hl kwd">strncmp</span><span class="hl sym">(</span>data<span class="hl sym">-&gt;</span>buffer<span class="hl sym">,</span> <span class="hl str">&quot;&gt;THREE&quot;</span><span class="hl sym">,</span> <span class="hl num">6</span><span class="hl sym">) ==</span> <span class="hl num">0</span><span class="hl sym">)</span>
	    <span class="hl kwa">break</span><span class="hl sym">;</span>

    <span class="hl kwb">int</span> cpus <span class="hl sym">=</span> <span class="hl kwd">numCPUS</span><span class="hl sym">();</span>
    WorkerThread threads<span class="hl sym">[</span>cpus<span class="hl sym">];</span>
    <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> i <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span> i<span class="hl sym">&lt;</span>cpus<span class="hl sym">-</span><span class="hl num">1</span><span class="hl sym">;</span> i<span class="hl sym">++) {</span>
	<span class="hl kwd">pthread_create</span><span class="hl sym">(&amp;(</span>threads<span class="hl sym">[</span>i<span class="hl sym">].</span>pthread<span class="hl sym">),</span> NULL<span class="hl sym">, (</span><span class="hl kwb">void</span> <span class="hl sym">*(*)(</span><span class="hl kwb">void</span> <span class="hl sym">*))</span>doWork<span class="hl sym">, &amp;</span>threads<span class="hl sym">[</span>i<span class="hl sym">]);</span>
    <span class="hl sym">}</span>

    <span class="hl kwb">size_t</span> totalBytesRead <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span>
    <span class="hl kwa">while</span> <span class="hl sym">(</span><span class="hl kwd">fgets</span><span class="hl sym">(&amp;</span>data<span class="hl sym">-&gt;</span>buffer<span class="hl sym">[</span>data<span class="hl sym">-&gt;</span>length<span class="hl sym">], (</span>data<span class="hl sym">-&gt;</span>capacity <span class="hl sym">+</span> <span class="hl num">1</span><span class="hl sym">) -</span> data<span class="hl sym">-&gt;</span>length<span class="hl sym">,</span> stdin<span class="hl sym">)) {</span>
	data<span class="hl sym">-&gt;</span>length <span class="hl sym">+=</span> <span class="hl kwd">strlen</span><span class="hl sym">(&amp;</span>data<span class="hl sym">-&gt;</span>buffer<span class="hl sym">[</span>data<span class="hl sym">-&gt;</span>length<span class="hl sym">]);</span>
	<span class="hl kwa">if</span> <span class="hl sym">(</span>data<span class="hl sym">-&gt;</span>buffer<span class="hl sym">[</span>data<span class="hl sym">-&gt;</span>length<span class="hl sym">-</span><span class="hl num">1</span><span class="hl sym">] ==</span> <span class="hl str">'</span><span class="hl esc">\n</span><span class="hl str">'</span><span class="hl sym">) {</span>
	    data<span class="hl sym">-&gt;</span>buffer<span class="hl sym">[--(</span>data<span class="hl sym">-&gt;</span>length<span class="hl sym">)] ==</span> <span class="hl num">0</span><span class="hl sym">;</span>
	<span class="hl sym">}</span>

	<span class="hl kwa">if</span> <span class="hl sym">(</span>data<span class="hl sym">-&gt;</span>length <span class="hl sym">==</span> data<span class="hl sym">-&gt;</span>capacity<span class="hl sym">) {</span>
	    data<span class="hl sym">-&gt;</span><span class="hl kwd">addToWorkList</span><span class="hl sym">();</span>
	    totalBytesRead <span class="hl sym">+=</span> data<span class="hl sym">-&gt;</span>length<span class="hl sym">;</span>
	    data <span class="hl sym">=</span> <span class="hl kwa">new</span> <span class="hl kwd">InputData</span><span class="hl sym">(*</span>data<span class="hl sym">);</span>
	<span class="hl sym">}</span>
    <span class="hl sym">}</span>

    <span class="hl kwa">if</span> <span class="hl sym">(</span>data<span class="hl sym">-&gt;</span>length<span class="hl sym">) {</span>
	totalBytesRead <span class="hl sym">+=</span> data<span class="hl sym">-&gt;</span>length<span class="hl sym">;</span>
	data<span class="hl sym">-&gt;</span><span class="hl kwd">addToWorkList</span><span class="hl sym">();</span>
    <span class="hl sym">}</span>

    moreWorkIsPossible <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">;</span>
    <span class="hl kwd">doWork</span><span class="hl sym">(&amp;</span>threads<span class="hl sym">[</span>cpus<span class="hl sym">-</span><span class="hl num">1</span><span class="hl sym">]);</span>
    <span class="hl kwa">for</span> <span class="hl sym">(</span><span class="hl kwb">int</span> i<span class="hl sym">=</span><span class="hl num">0</span><span class="hl sym">;</span> i<span class="hl sym">&lt;</span>cpus<span class="hl sym">-</span><span class="hl num">1</span><span class="hl sym">;</span> i<span class="hl sym">++) {</span>
	<span class="hl kwd">pthread_join</span><span class="hl sym">(</span>threads<span class="hl sym">[</span>i<span class="hl sym">].</span>pthread<span class="hl sym">,</span> NULL<span class="hl sym">);</span>
    <span class="hl sym">}</span>

    printFreq<span class="hl sym">&lt;</span><span class="hl num">1</span><span class="hl sym">&gt;(</span>threads<span class="hl sym">,</span> cpus<span class="hl sym">, (</span><span class="hl kwb">float</span><span class="hl sym">)</span>totalBytesRead<span class="hl sym">);</span>
    printFreq<span class="hl sym">&lt;</span><span class="hl num">2</span><span class="hl sym">&gt;(</span>threads<span class="hl sym">,</span> cpus<span class="hl sym">, (</span><span class="hl kwb">float</span><span class="hl sym">)(</span>totalBytesRead <span class="hl sym">-</span> <span class="hl num">1</span><span class="hl sym">));</span>

    printCount<span class="hl sym">&lt;</span><span class="hl num">3</span><span class="hl sym">&gt;(</span>threads<span class="hl sym">,</span> cpus<span class="hl sym">,</span> fragments<span class="hl sym">[</span><span class="hl num">2</span><span class="hl sym">]);</span>
    printCount<span class="hl sym">&lt;</span><span class="hl num">4</span><span class="hl sym">&gt;(</span>threads<span class="hl sym">,</span> cpus<span class="hl sym">,</span> fragments<span class="hl sym">[</span><span class="hl num">3</span><span class="hl sym">]);</span>
    printCount<span class="hl sym">&lt;</span><span class="hl num">6</span><span class="hl sym">&gt;(</span>threads<span class="hl sym">,</span> cpus<span class="hl sym">,</span> fragments<span class="hl sym">[</span><span class="hl num">4</span><span class="hl sym">]);</span>
    printCount<span class="hl sym">&lt;</span><span class="hl num">12</span><span class="hl sym">&gt;(</span>threads<span class="hl sym">,</span> cpus<span class="hl sym">,</span> fragments<span class="hl sym">[</span><span class="hl num">5</span><span class="hl sym">]);</span>
    printCount<span class="hl sym">&lt;</span><span class="hl num">18</span><span class="hl sym">&gt;(</span>threads<span class="hl sym">,</span> cpus<span class="hl sym">,</span> fragments<span class="hl sym">[</span><span class="hl num">6</span><span class="hl sym">]);</span>

    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl sym">;</span>
<span class="hl sym">}</span>
