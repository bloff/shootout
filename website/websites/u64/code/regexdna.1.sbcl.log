
Fri, 02 Apr 2010 21:39:06 GMT

MAKE:
cp: `regexdna.sbcl' and `./regexdna.sbcl' are the same file
SBCL built with: /usr/local/bin/sbcl --userinit /dev/null --batch --eval '(load "regexdna.sbcl_compile")'
### START regexdna.sbcl_compile
(proclaim '(optimize (speed 3) (safety 0) (debug 0) (compilation-speed 0) (space 0)))
(handler-bind ((sb-ext:defconstant-uneql      (lambda (c) (abort c))))      (load (compile-file "regexdna.sbcl" ))) (save-lisp-and-die "sbcl.core" :purify t)
### END regexdna.sbcl_compile


; compiling file "/home/dunham/shootout/bench/regexdna/regexdna.sbcl" (written 21 FEB 2009 04:20:24 PM):
; compiling (REQUIRE :ASDF)
; compiling (REQUIRE :CL-PPCRE)
; compiling file "/usr/local/lib/sbcl/site/cl-ppcre-2.0.3/packages.lisp" (written 17 SEP 2009 12:17:31 PM):

; /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/packages.fasl written
; compilation finished in 0:00:00.002
; compiling file "/usr/local/lib/sbcl/site/cl-ppcre-2.0.3/specials.lisp" (written 28 OCT 2009 12:36:15 AM):

; file: /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/specials.lisp
; in:
;      LET ((EXPORTED-SYMBOLS-ALIST
;        (LOOP FOR SYMBOL BEING THE EXTERNAL-SYMBOLS OF :CL-PPCRE
;              COLLECT (CONS SYMBOL (CONCATENATE 'STRING "#" #)))))
;     (LOOP CL-PPCRE::FOR SYMBOL CL-PPCRE::BEING THE CL-PPCRE::EXTERNAL-SYMBOLS CL-PPCRE::OF :CL-PPCRE
;           CL-PPCRE::COLLECT (CONS SYMBOL
;                                   (CONCATENATE 'STRING "#"
;                                                (STRING-DOWNCASE SYMBOL))))
; --> BLOCK LET WITH-PACKAGE-ITERATOR LET* MACROLET WHEN IF PROGN FLET BLOCK > 
; --> IF 
; ==>
;   (> NUMBER 1)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/specials.fasl written
; compilation finished in 0:00:00.078
; compiling file "/usr/local/lib/sbcl/site/cl-ppcre-2.0.3/util.lisp" (written 28 OCT 2009 12:36:15 AM):

; file: /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/util.lisp
; in: DEFUN WHITESPACEP
;     (FIND CL-PPCRE::CHR CL-PPCRE::+WHITESPACE-CHAR-STRING+ :TEST #'CHAR=)
; --> NTH-VALUE MULTIPLE-VALUE-BIND LET 
; ==>
;   (SB-KERNEL:%FIND-POSITION SB-C::ITEM SEQUENCE SB-C::FROM-END SB-C::START
;                             SB-C::END
;                             (SB-KERNEL:EFFECTIVE-FIND-POSITION-KEY SB-C::KEY)
;                             (SB-KERNEL:EFFECTIVE-FIND-POSITION-TEST SB-C::TEST
;                                                                     SB-C::TEST-NOT))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a CHARACTER.

; in: DEFUN NSUBSEQ
;     (LENGTH SEQUENCE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; in: DEFUN STRING-LIST-TO-SIMPLE-STRING
;     (REPLACE CL-PPCRE::RESULT-STRING STRING :START1 CL-PPCRE::CURR-POS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a STRING, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a STRING, not a SIMPLE-BASE-STRING.

; in: DEFUN COMPLEMENT*
;     (FUNCALL CL-PPCRE::TEST-FUNCTION CHAR)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

; /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/util.fasl written
; compilation finished in 0:00:00.049
; compiling file "/usr/local/lib/sbcl/site/cl-ppcre-2.0.3/errors.lisp" (written 17 SEP 2009 12:17:31 PM):

; file: /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/errors.lisp
; in: DEFINE-CONDITION PPCRE-SYNTAX-ERROR
;     (FORMAT STREAM "~?~@[ at position ~A~]~@[ in string ~S~]"
;             (SIMPLE-CONDITION-FORMAT-CONTROL CONDITION)
;             (SIMPLE-CONDITION-FORMAT-ARGUMENTS CONDITION)
;             (CL-PPCRE:PPCRE-SYNTAX-ERROR-POS CONDITION)
;             (CL-PPCRE:PPCRE-SYNTAX-ERROR-STRING CONDITION))
; ==>
;   (FORMAT SB-C::DEST (FORMATTER "~?~@[ at position ~A~]~@[ in string ~S~]")
;           #:G3 #:G4 #:G5 #:G6)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (MEMBER NIL T) STREAM (VECTOR CHARACTER)
;                               (VECTOR NIL) BASE-STRING), not a STREAM.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (MEMBER NIL T) STREAM (VECTOR CHARACTER)
;                               (VECTOR NIL) BASE-STRING), not a (MEMBER T).

; /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/errors.fasl written
; compilation finished in 0:00:00.027
; compiling file "/usr/local/lib/sbcl/site/cl-ppcre-2.0.3/charset.lisp" (written 17 SEP 2009 12:17:30 PM):

; file: /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/charset.lisp
; in: DEFUN MIX
;     (+ CL-PPCRE::CODE CL-PPCRE::HASH)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (SIGNED-BYTE 64) &REST
;                                                          T).
;       etc.

;     (LOGAND MOST-POSITIVE-FIXNUM (+ CL-PPCRE::CODE CL-PPCRE::HASH))
; ==>
;   (LOGAND SB-C::Y 1152921504606846975)
; 
; note: forced to do static-fun Two-arg-and (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

; in: DEFUN COMPUTE-INDEX
;     (LENGTH VECTOR)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (1+ (MOD CL-PPCRE::HASH (1- (LENGTH VECTOR))))
; ==>
;   (+ (MOD CL-PPCRE::HASH (1- (LENGTH VECTOR))) 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR
;                            (RATIONAL (-1152921504606846972)
;                                      (2305843009213693942))
;                            (DOUBLE-FLOAT (-1.152921504606847d18)
;                             (2.305843009213694d18))
;                            (SINGLE-FLOAT (-1.1529215e18))), not a FLOAT.

;     (MOD CL-PPCRE::HASH (1- (LENGTH VECTOR)))
; --> BLOCK LET IF AND IF NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR
;                            (RATIONAL (-1152921504606846971)
;                                      (1152921504606846971))
;                            (DOUBLE-FLOAT (-1.152921504606847d18)
;                             (1.152921504606847d18))
;                            (SINGLE-FLOAT (-1.1529215e18)
;                             (1.1529215e18))), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> BLOCK LET IF AND IF AND THE IF PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK LET IF 
; ==>
;   (+ REM SB-KERNEL::DIVISOR)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR
;                            (RATIONAL (-1152921504606846971)
;                                      (1152921504606846971))
;                            (DOUBLE-FLOAT (-1.152921504606847d18)
;                             (1.152921504606847d18))
;                            (SINGLE-FLOAT (-1.1529215e18)
;                             (1.1529215e18))), not a FLOAT.

; --> BLOCK LET REM BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-KERNEL::DIVISOR)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   convert division by 2^k to shift
; due to type uncertainty:
;   The first argument is a REAL, not a INTEGER.

; --> BLOCK LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> BLOCK LET IF AND IF AND THE IF PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> BLOCK LET IF 
; ==>
;   (+ REM SB-KERNEL::DIVISOR)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR
;                                (RATIONAL (-1152921504606846971)
;                                          (1152921504606846971))
;                                (DOUBLE-FLOAT (-1.152921504606847d18)
;                                 (1.152921504606847d18))
;                                (SINGLE-FLOAT (-1.1529215e18) (1.1529215e18))), not a FIXNUM.
;       The result is a (VALUES
;                        (OR (SINGLE-FLOAT (-1.1529215e18))
;                            (DOUBLE-FLOAT (-1.152921504606847d18)
;                             (2.305843009213694d18))
;                            (RATIONAL (-1152921504606846972)
;                                      (2305843009213693942)))
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a (OR
;                                (RATIONAL (-1152921504606846971)
;                                          (1152921504606846971))
;                                (DOUBLE-FLOAT (-1.152921504606847d18)
;                                 (1.152921504606847d18))
;                                (SINGLE-FLOAT (-1.1529215e18) (1.1529215e18))), not a (SIGNED-BYTE
;                                                                                       64).
;       The result is a (VALUES
;                        (OR (SINGLE-FLOAT (-1.1529215e18))
;                            (DOUBLE-FLOAT (-1.152921504606847d18)
;                             (2.305843009213694d18))
;                            (RATIONAL (-1152921504606846972)
;                                      (2305843009213693942)))
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (1+ (MOD CL-PPCRE::HASH (1- (LENGTH VECTOR))))
; ==>
;   (+ (MOD CL-PPCRE::HASH (1- (LENGTH VECTOR))) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR
;                                (RATIONAL (-1152921504606846972)
;                                          (2305843009213693942))
;                                (DOUBLE-FLOAT (-1.152921504606847d18)
;                                 (2.305843009213694d18))
;                                (SINGLE-FLOAT (-1.1529215e18))), not a FIXNUM.
;       The result is a (VALUES
;                        (OR (SINGLE-FLOAT (-1.1529215e18))
;                            (DOUBLE-FLOAT (-1.152921504606847d18)
;                             (2.305843009213694d18))
;                            (RATIONAL (-1152921504606846971)
;                                      (2305843009213693943)))
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR
;                                (RATIONAL (-1152921504606846972)
;                                          (2305843009213693942))
;                                (DOUBLE-FLOAT (-1.152921504606847d18)
;                                 (2.305843009213694d18))
;                                (SINGLE-FLOAT (-1.1529215e18))), not a FIXNUM.
;       The result is a (VALUES
;                        (OR (SINGLE-FLOAT (-1.1529215e18))
;                            (DOUBLE-FLOAT (-1.152921504606847d18)
;                             (2.305843009213694d18))
;                            (RATIONAL (-1152921504606846971)
;                                      (2305843009213693943)))
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; in: DEFUN %ADD-TO-CHARSET/EXPAND
;     (* 2 CL-PPCRE::NEW-SIZE)
; ==>
;   (* SB-C::Y 2)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
; 
; note: unable to
;   recode as leas, shifts and adds
; due to type uncertainty:
;   The first argument is a NUMBER, not a (UNSIGNED-BYTE 64).
;   The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (UNSIGNED-BYTE 64)
;                                                            &REST T).
; 
; note: unable to
;   recode as leas, shifts and adds
; due to type uncertainty:
;   The first argument is a NUMBER, not a FIXNUM.
;   The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).

;     (>= CL-PPCRE::NEW-SIZE 371370)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (* 2 CL-PPCRE::NEW-SIZE)
; ==>
;   (* SB-C::Y 2)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64)
;                                                                &REST T).
;       etc.

;     (>= CL-PPCRE::NEW-SIZE 371370)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (LET* ((CL-PPCRE::OLD-VECTOR (CL-PPCRE::CHARSET-VECTOR SET))
;            (CL-PPCRE::NEW-SIZE (* 2 (LENGTH CL-PPCRE::OLD-VECTOR))))
;       (TAGBODY
;        :RETRY
;         (MULTIPLE-VALUE-BIND (CL-PPCRE::NEW-DEPTH CL-PPCRE::NEW-VECTOR)
;             (IF (>= CL-PPCRE::NEW-SIZE 371370)
;                 (VALUES 0 #)
;                 (VALUES CL-PPCRE::+PROBE-DEPTH+ #))
;           (SETF # CL-PPCRE::NEW-DEPTH
;                 # CL-PPCRE::NEW-VECTOR)
;           (FLET (#)
;             (CL-PPCRE::TRY-ADD CHAR)
;             (DOTIMES # #))))
;       (INCF (CL-PPCRE::CHARSET-COUNT SET))
;       T)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of MAKE-VALUE-CELL

; in: DEFUN MAP-CHARSET
;     (DECF CL-PPCRE::N)
; --> LET* 
; ==>
;   (- CL-PPCRE::N #:G120)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.

;     (ZEROP (DECF CL-PPCRE::N))
; ==>
;   (= (DECF CL-PPCRE::N) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (DECF CL-PPCRE::N)
; --> LET* 
; ==>
;   (- CL-PPCRE::N #:G120)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; ==>
;   (SETQ CL-PPCRE::N #:NEW116)
; 
; note: doing signed word to integer coercion (cost 20) to N

; in: DEFUN CREATE-CHARSET-FROM-TEST-FUNCTION
;     (FUNCALL CL-PPCRE::TEST-FUNCTION CHAR)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

;     (LOOP CL-PPCRE::WITH CL-PPCRE::CHARSET = (CL-PPCRE::MAKE-CHARSET)
;           CL-PPCRE::FOR CL-PPCRE::CODE CL-PPCRE::FROM CL-PPCRE::START CL-PPCRE::BELOW
;           CL-PPCRE::END
;           CL-PPCRE::FOR ...)
; --> BLOCK LET LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

; --> BLOCK LET LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE 
; --> = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> BLOCK LET LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> BLOCK LET LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE 
; --> = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/charset.fasl written
; compilation finished in 0:00:00.078
; compiling file "/usr/local/lib/sbcl/site/cl-ppcre-2.0.3/charmap.lisp" (written 17 SEP 2009 12:17:30 PM):

; file: /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/charmap.lisp
; in: DEFUN MAKE-CHARMAP
;     (FUNCALL CL-PPCRE::TEST-FUNCTION CHAR)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

; in: DEFUN CREATE-CHARMAP-FROM-TEST-FUNCTION
;     (1- CL-PPCRE::END)
; ==>
;   (- CL-PPCRE::END 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (LOOP CL-PPCRE::FOR CL-PPCRE::CODE CL-PPCRE::FROM (1-
;                                                        CL-PPCRE::END) CL-PPCRE::DOWNTO CL-PPCRE::START
;           CL-PPCRE::FOR CHAR = (CODE-CHAR CL-PPCRE::CODE)
;           CL-PPCRE::UNTIL ...)
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; ==>
;   (< CL-PPCRE::CODE #:LOOP-LIMIT-83)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION CHAR)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

;     (LOOP CL-PPCRE::FOR CL-PPCRE::CODE CL-PPCRE::FROM CL-PPCRE::START CL-PPCRE::BELOW
;           CL-PPCRE::END
;           CL-PPCRE::FOR CHAR = (CODE-CHAR CL-PPCRE::CODE)
;           CL-PPCRE::UNTIL ...)
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (1- CL-PPCRE::END)
; ==>
;   (- CL-PPCRE::END 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (LOOP CL-PPCRE::FOR CL-PPCRE::CODE CL-PPCRE::FROM (1-
;                                                        CL-PPCRE::END) CL-PPCRE::DOWNTO CL-PPCRE::START
;           CL-PPCRE::FOR CHAR = (CODE-CHAR CL-PPCRE::CODE)
;           CL-PPCRE::UNTIL ...)
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; ==>
;   (< CL-PPCRE::CODE #:LOOP-LIMIT-83)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/charmap.fasl written
; compilation finished in 0:00:00.053
; compiling file "/usr/local/lib/sbcl/site/cl-ppcre-2.0.3/chartest.lisp" (written 17 SEP 2009 12:17:30 PM):

; file: /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/chartest.lisp
; in: DEFUN CREATE-HASH-TABLE-FROM-TEST-FUNCTION
;     (FUNCALL CL-PPCRE::TEST-FUNCTION CHAR)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

;     (LOOP CL-PPCRE::WITH HASH-TABLE = (MAKE-HASH-TABLE)
;           CL-PPCRE::FOR CL-PPCRE::CODE CL-PPCRE::FROM CL-PPCRE::START CL-PPCRE::BELOW
;           CL-PPCRE::END
;           CL-PPCRE::FOR ...)
; --> BLOCK LET LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

; --> BLOCK LET LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE 
; --> = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> BLOCK LET LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> BLOCK LET LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE 
; --> = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; in: DEFUN CREATE-OPTIMIZED-TEST-FUNCTION
;     (CEILING (- CL-PPCRE::END CL-PPCRE::START) 2)
; --> BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF NOT IF 
; --> ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF AND THE 
; --> IF MINUSP 
; ==>
;   (< SB-KERNEL::DIVISOR 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; ==>
;   (< NUMBER 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF AND THE 
; --> IF PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF VALUES 
; ==>
;   (- REM SB-KERNEL::DIVISOR)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a RATIONAL.
;   The second argument is a REAL, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.

; --> BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-KERNEL::DIVISOR)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a (OR SINGLE-FLOAT INTEGER).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a (OR DOUBLE-FLOAT SINGLE-FLOAT INTEGER).
; 
; note: unable to
;   convert division by 2^k to shift
; due to type uncertainty:
;   The first argument is a REAL, not a INTEGER.
;   The second argument is a REAL, not a INTEGER.

;     (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

;     (CEILING (- CL-PPCRE::END CL-PPCRE::START) 2)
; --> BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF AND THE 
; --> IF MINUSP 
; ==>
;   (< SB-KERNEL::DIVISOR 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF AND THE 
; --> IF PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF AND THE 
; --> IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF VALUES 
; ==>
;   (+ SB-KERNEL::TRU 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; ==>
;   (- REM SB-KERNEL::DIVISOR)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST
;                                                              T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST
;                                                              T).
;       etc.

;     (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (<= (HASH-TABLE-COUNT HASH-TABLE)
;         (CEILING (- CL-PPCRE::END CL-PPCRE::START) 2))
; --> IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a INTEGER, not a FIXNUM.

;     (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (<= (CL-PPCRE::CHARSET-COUNT CL-PPCRE::CHARSET)
;         (CEILING (- CL-PPCRE::END CL-PPCRE::START) 2))
; --> IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a INTEGER, not a FIXNUM.

; /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/chartest.fasl written
; compilation finished in 0:00:00.036
; compiling file "/usr/local/lib/sbcl/site/cl-ppcre-2.0.3/lexer.lisp" (written 17 SEP 2009 12:17:31 PM):

; file: /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/lexer.lisp
; in: DEFUN MAKE-LEXER
;     (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING STRING)
; --> LET COND IF COND THE PROGN COERCE THE IF 
; ==>
;   (REPLACE (MAKE-ARRAY (LENGTH SB-C::X) :ELEMENT-TYPE 'CHARACTER) SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a STRING, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a STRING, not a SIMPLE-BASE-STRING.

; in: DEFUN NEXT-CHAR
;     (CL-PPCRE::SIGNAL-SYNTAX-ERROR* CL-PPCRE::ERROR-POS
;                                     "Comment group not closed.")
; ==>
;   (ERROR 'CL-PPCRE:PPCRE-SYNTAX-ERROR :POS CL-PPCRE::ERROR-POS :FORMAT-CONTROL
;          "Comment group not closed." :FORMAT-ARGUMENTS (LIST))
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN MAKE-CHAR-FROM-CODE
;     (CL-PPCRE::SIGNAL-SYNTAX-ERROR* CL-PPCRE::ERROR-POS
;                                     "No character for hex-code ~X." NUMBER)
; --> ERROR 
; ==>
;   CL-PPCRE::ERROR-POS
; 
; note: deleting unreachable code

; ==>
;   "No character for hex-code ~X."
; 
; note: deleting unreachable code
; 
; note: deleting unreachable code

; in: DEFUN UNESCAPE-CHAR
;     (CHAR-UPCASE CL-PPCRE::NEXT-CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

; in: DEFUN PARSE-REGISTER-NAME-AUX
;     (EVERY #'(LAMBDA (CHAR) (OR (ALPHANUMERICP CHAR) (CHAR= #\- CHAR)))
;            CL-PPCRE::NAME)
; --> LET BLOCK MAP TRULY-THE 
; ==>
;   (SB-KERNEL:%MAP SB-C::RESULT-TYPE-ARG SB-C::FUN #:G523)
; 
; note: unable to open code because: can't determine sequence argument type

;     (CL-PPCRE::SIGNAL-SYNTAX-ERROR* (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER))
;                                     "Opening #< in named group has no closing #>.")
; ==>
;   (ERROR 'CL-PPCRE:PPCRE-SYNTAX-ERROR :POS
;          (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER)) :FORMAT-CONTROL
;          "Opening #< in named group has no closing #>." :FORMAT-ARGUMENTS
;          (LIST))
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN MAKE-CHAR-FROM-CODE
;     (CL-PPCRE::SIGNAL-SYNTAX-ERROR* CL-PPCRE::ERROR-POS
;                                     "No character for hex-code ~X." NUMBER)
; --> ERROR 
; ==>
;   "No character for hex-code ~X."
; 
; note: deleting unreachable code

; ==>
;   CL-PPCRE::ERROR-POS
; 
; note: deleting unreachable code

; in: DEFUN GET-TOKEN
;     (CL-PPCRE::SIGNAL-SYNTAX-ERROR "End of string following '(?<'.")
; --> CL-PPCRE::SIGNAL-SYNTAX-ERROR* ERROR 
; ==>
;   "End of string following '(?<'."
; 
; note: deleting unreachable code

;     (CL-PPCRE::SIGNAL-SYNTAX-ERROR* (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER))
;                                     "Character '~A' may not follow '(?<'."
;                                     CL-PPCRE::NEXT-CHAR)
; ==>
;   (ERROR 'CL-PPCRE:PPCRE-SYNTAX-ERROR :POS
;          (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER)) :FORMAT-CONTROL
;          "Character '~A' may not follow '(?<'." :FORMAT-ARGUMENTS
;          (LIST CL-PPCRE::NEXT-CHAR))
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

;     (CL-PPCRE::SIGNAL-SYNTAX-ERROR* (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER))
;                                     "Character '~A' may not follow '(?'."
;                                     CL-PPCRE::NEXT-CHAR)
; ==>
;   (ERROR 'CL-PPCRE:PPCRE-SYNTAX-ERROR :POS
;          (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER)) :FORMAT-CONTROL
;          "Character '~A' may not follow '(?'." :FORMAT-ARGUMENTS
;          (LIST CL-PPCRE::NEXT-CHAR))
; 
; note: doing signed word to integer coercion (cost 20)

;     (CL-PPCRE::SIGNAL-SYNTAX-ERROR* (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER))
;                                     "Quantifier '~A' not allowed."
;                                     CL-PPCRE::NEXT-CHAR)
; ==>
;   (ERROR 'CL-PPCRE:PPCRE-SYNTAX-ERROR :POS
;          (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER)) :FORMAT-CONTROL
;          "Quantifier '~A' not allowed." :FORMAT-ARGUMENTS
;          (LIST CL-PPCRE::NEXT-CHAR))
; 
; note: doing signed word to integer coercion (cost 20)

; /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/lexer.fasl written
; compilation finished in 0:00:00.271
; compiling file "/usr/local/lib/sbcl/site/cl-ppcre-2.0.3/parser.lisp" (written 17 SEP 2009 12:17:31 PM):

; file: /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/parser.lisp
; in: DEFUN GROUP
;     (CL-PPCRE::SIGNAL-SYNTAX-ERROR* (+ CL-PPCRE::OPEN-PAREN-POS 2)
;                                     "Opening paren has no matching closing paren.")
; ==>
;   (ERROR 'CL-PPCRE:PPCRE-SYNTAX-ERROR :POS (+ CL-PPCRE::OPEN-PAREN-POS 2)
;          :FORMAT-CONTROL "Opening paren has no matching closing paren."
;          :FORMAT-ARGUMENTS (LIST))
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN SEQ
;     (SETF (AREF STRING 0) CL-PPCRE::CHAR1)
; --> SB-KERNEL:%ASET 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR CHARACTER), not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR CHARACTER), not a SIMPLE-ARRAY.

;     (SETF (AREF STRING 1) CL-PPCRE::CHAR2)
; --> SB-KERNEL:%ASET 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR CHARACTER), not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR CHARACTER), not a SIMPLE-ARRAY.

; /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/parser.fasl written
; compilation finished in 0:00:00.039
; compiling file "/usr/local/lib/sbcl/site/cl-ppcre-2.0.3/regex-class.lisp" (written 28 OCT 2009 12:36:15 AM):

; file: /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/regex-class.lisp
; in: DEFMETHOD INITIALIZE-INSTANCE :AFTER (STR)
;     (COERCE CL-PPCRE::STR-SLOT 'SIMPLE-STRING)
; --> THE IF REPLACE MAKE-ARRAY LOCALLY MAKE-ARRAY 
; ==>
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> THE IF 
; ==>
;   (REPLACE (MAKE-ARRAY (LENGTH SB-C::X) :ELEMENT-TYPE 'CHARACTER) SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.

;     (LENGTH (CL-PPCRE::STR CL-PPCRE::STR))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/regex-class.fasl written
; compilation finished in 0:00:00.029
; compiling file "/usr/local/lib/sbcl/site/cl-ppcre-2.0.3/regex-class-util.lisp" (written 17 SEP 2009 12:17:31 PM):

; file: /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/regex-class-util.lisp
; in: DEFMETHOD CASE-MODE (STR T)
;     (ZEROP (CL-PPCRE::LEN CL-PPCRE::STR))
; ==>
;   (= (CL-PPCRE::LEN CL-PPCRE::STR) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; in: DEFMETHOD EVERYTHINGP (SEQ)
;     (LENGTH CL-PPCRE::CLEANED-ELEMENTS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY
;                                                                    * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

; in: DEFMETHOD EVERYTHINGP (ALTERNATION)
;     (DEFMETHOD CL-PPCRE::EVERYTHINGP
;                ((CL-PPCRE::ALTERNATION CL-PPCRE::ALTERNATION))
;                (DECLARE
;                 (OPTIMIZE SPEED (SAFETY 0) (SPACE 0) (DEBUG 1)
;                  (COMPILATION-SPEED 0)))
;                (WITH-SLOTS (CL-PPCRE::CHOICES)
;                    CL-PPCRE::ALTERNATION
;                  (AND (= 1 (LENGTH CL-PPCRE::CHOICES))
;                       (CL-PPCRE::EVERYTHINGP (FIRST CL-PPCRE::CHOICES)))))
; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF = 
; ==>
;   (LENGTH
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G196 'CL-PPCRE::CHOICES)
;                                  CL-PPCRE::ALTERNATION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 0)
;                                                         CL-PPCRE::ALTERNATION 0
;                                                         'CL-PPCRE::CHOICES
;                                                         '#<STANDARD-CLASS
;                                                            CL-PPCRE::ALTERNATION>)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; in: DEFMETHOD EVERYTHINGP (REPETITION)
;     (DEFMETHOD CL-PPCRE::EVERYTHINGP
;                ((CL-PPCRE::REPETITION CL-PPCRE::REPETITION))
;                (DECLARE
;                 (OPTIMIZE SPEED (SAFETY 0) (SPACE 0) (DEBUG 1)
;                  (COMPILATION-SPEED 0)))
;                (WITH-SLOTS (CL-PPCRE::MAXIMUM CL-PPCRE::MINIMUM CL-PPCRE::REGEX)
;                    CL-PPCRE::REPETITION
;                  (AND CL-PPCRE::MAXIMUM (= 1 CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM)
;                       (CL-PPCRE::EVERYTHINGP CL-PPCRE::REGEX))))
; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF = 
; --> (LAMBDA (#:G223 #:G222 #:G221) (DECLARE (TYPE NUMBER #:G223 #:G222 #:G221)) (IF (= #:G223 #:G222) (IF (= #:G222 #:G221) T NIL) NIL)) 
; --> IF = = IF 
; ==>
;   (= SB-C::Y SB-C::X)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF = 
; --> (LAMBDA (#:G223 #:G222 #:G221) (DECLARE (TYPE NUMBER #:G223 #:G222 #:G221)) (IF (= #:G223 #:G222) (IF (= #:G222 #:G221) T NIL) NIL)) 
; --> IF IF 
; ==>
;   (= #:G222 #:G221)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; in: DEFMETHOD REGEX-LENGTH (SEQ)
;     (LOOP CL-PPCRE::FOR CL-PPCRE::SUB-REGEX CL-PPCRE::IN (CL-PPCRE::ELEMENTS
;                                                           CL-PPCRE::SEQ)
;           CL-PPCRE::FOR CL-PPCRE::LEN = (CL-PPCRE::REGEX-LENGTH
;                                          CL-PPCRE::SUB-REGEX)
;           IF (NOT CL-PPCRE::LEN)
;           DO ...)
; --> BLOCK LET LET LET SB-LOOP::LOOP-BODY TAGBODY SETQ THE 
; ==>
;   (+ #:LOOP-SUM-254 CL-PPCRE::LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; in: DEFMETHOD REGEX-LENGTH (ALTERNATION)
;     (/= CL-PPCRE::LEN CL-PPCRE::OLD-LEN)
; --> IF 
; ==>
;   (= CL-PPCRE::LEN CL-PPCRE::OLD-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; in: DEFMETHOD REGEX-LENGTH (BRANCH)
;     (EQL CL-PPCRE::THEN-LENGTH
;          (CL-PPCRE::REGEX-LENGTH (CL-PPCRE::ELSE-REGEX CL-PPCRE::BRANCH)))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; in: DEFMETHOD REGEX-LENGTH (REPETITION)
;     (DEFMETHOD CL-PPCRE::REGEX-LENGTH
;                ((CL-PPCRE::REPETITION CL-PPCRE::REPETITION))
;                (DECLARE
;                 (OPTIMIZE SPEED (SAFETY 0) (SPACE 0) (DEBUG 1)
;                  (COMPILATION-SPEED 0)))
;                (WITH-SLOTS (CL-PPCRE::LEN CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM)
;                    CL-PPCRE::REPETITION
;                  (IF (AND CL-PPCRE::LEN
;                           (EQL CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM))
;                      (* CL-PPCRE::MINIMUM CL-PPCRE::LEN)
;                      NIL)))
; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF 
; ==>
;   (*
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G271 'CL-PPCRE::MINIMUM)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 4)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MINIMUM
;                                                         '#<STANDARD-CLASS
;                                                            CL-PPCRE::REPETITION>))
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G271 'CL-PPCRE::LEN)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 0)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::LEN
;                                                         '#<STANDARD-CLASS
;                                                            CL-PPCRE::REPETITION>)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF THE 
; ==>
;   (EQL
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G271 'CL-PPCRE::MINIMUM)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 4)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MINIMUM
;                                                         '#<STANDARD-CLASS
;                                                            CL-PPCRE::REPETITION>))
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G271 'CL-PPCRE::MAXIMUM)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 2)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MAXIMUM
;                                                         '#<STANDARD-CLASS
;                                                            CL-PPCRE::REPETITION>)))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF 
; ==>
;   (*
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G271 'CL-PPCRE::MINIMUM)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 4)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MINIMUM
;                                                         '#<STANDARD-CLASS
;                                                            CL-PPCRE::REPETITION>))
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G271 'CL-PPCRE::LEN)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 0)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::LEN
;                                                         '#<STANDARD-CLASS
;                                                            CL-PPCRE::REPETITION>)))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES
;                                                         (COMPLEX SINGLE-FLOAT)
;                                                         &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; in: DEFMETHOD REGEX-MIN-LENGTH (SEQ)
;     (LOOP CL-PPCRE::FOR CL-PPCRE::SUB-REGEX CL-PPCRE::IN (CL-PPCRE::ELEMENTS
;                                                           CL-PPCRE::SEQ)
;           CL-PPCRE::FOR CL-PPCRE::LEN = (CL-PPCRE::REGEX-MIN-LENGTH
;                                          CL-PPCRE::SUB-REGEX)
;           CL-PPCRE::SUM CL-PPCRE::LEN)
; --> BLOCK LET LET LET SB-LOOP::LOOP-BODY TAGBODY SETQ THE 
; ==>
;   (+ #:LOOP-SUM-332 CL-PPCRE::LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; in: DEFMETHOD REGEX-MIN-LENGTH (ALTERNATION)
;     (LOOP CL-PPCRE::FOR CL-PPCRE::SUB-REGEX CL-PPCRE::IN (CL-PPCRE::CHOICES
;                                                           CL-PPCRE::ALTERNATION)
;           CL-PPCRE::FOR CL-PPCRE::LEN = (CL-PPCRE::REGEX-MIN-LENGTH
;                                          CL-PPCRE::SUB-REGEX)
;           CL-PPCRE::MINIMIZE CL-PPCRE::LEN)
; --> BLOCK LET LET SB-LOOP::WITH-MINIMAX-VALUE LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF OR THE < 
; --> IF 
; ==>
;   (< #:LOOP-MAXMIN-TEMP-344 #:LOOP-MAXMIN-343)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; in: DEFMETHOD REGEX-MIN-LENGTH (BRANCH)
;     (MIN (CL-PPCRE::REGEX-MIN-LENGTH (CL-PPCRE::THEN-REGEX CL-PPCRE::BRANCH))
;          (CL-PPCRE::REGEX-MIN-LENGTH (CL-PPCRE::ELSE-REGEX CL-PPCRE::BRANCH)))
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; in: DEFMETHOD REGEX-MIN-LENGTH (REPETITION)
;     (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;        (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES
;                                                         (COMPLEX SINGLE-FLOAT)
;                                                         &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (ALTERNATION T)
;     (/= CL-PPCRE::CURR-OFFSET CL-PPCRE::OLD-OFFSET)
; --> IF 
; ==>
;   (= CL-PPCRE::CURR-OFFSET CL-PPCRE::OLD-OFFSET)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (BRANCH T)
;     (EQL CL-PPCRE::THEN-OFFSET
;          (CL-PPCRE::COMPUTE-OFFSETS (CL-PPCRE::ELSE-REGEX CL-PPCRE::BRANCH)
;           CL-PPCRE::START-POS))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (REPETITION T)
;     (DEFMETHOD CL-PPCRE::COMPUTE-OFFSETS
;                ((CL-PPCRE::REPETITION CL-PPCRE::REPETITION) CL-PPCRE::START-POS)
;                (DECLARE
;                 (OPTIMIZE SPEED (SAFETY 0) (SPACE 0) (DEBUG 1)
;                  (COMPILATION-SPEED 0)))
;                (WITH-SLOTS (CL-PPCRE::LEN CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM)
;                    CL-PPCRE::REPETITION
;                  (IF (AND CL-PPCRE::LEN (EQ CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM))
;                      (+ CL-PPCRE::START-POS (* CL-PPCRE::MINIMUM CL-PPCRE::LEN))
;                      NIL)))
; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF + 
; ==>
;   (*
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G414 'CL-PPCRE::MINIMUM)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 4)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MINIMUM
;                                                         '#<STANDARD-CLASS
;                                                            CL-PPCRE::REPETITION>))
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G414 'CL-PPCRE::LEN)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 0)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::LEN
;                                                         '#<STANDARD-CLASS
;                                                            CL-PPCRE::REPETITION>)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF 
; ==>
;   (+ CL-PPCRE::START-POS
;      (*
;       (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G414 'CL-PPCRE::MINIMUM)
;                                     CL-PPCRE::REPETITION
;                                     (SB-PCL::INSTANCE-READ
;                                      (SB-PCL::PV-OFFSET 4) CL-PPCRE::REPETITION
;                                      0 'CL-PPCRE::MINIMUM
;                                      '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
;       (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G414 'CL-PPCRE::LEN)
;                                     CL-PPCRE::REPETITION
;                                     (SB-PCL::INSTANCE-READ
;                                      (SB-PCL::PV-OFFSET 0) CL-PPCRE::REPETITION
;                                      0 'CL-PPCRE::LEN
;                                      '#<STANDARD-CLASS CL-PPCRE::REPETITION>))))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF + 
; ==>
;   (*
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G414 'CL-PPCRE::MINIMUM)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 4)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MINIMUM
;                                                         '#<STANDARD-CLASS
;                                                            CL-PPCRE::REPETITION>))
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G414 'CL-PPCRE::LEN)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 0)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::LEN
;                                                         '#<STANDARD-CLASS
;                                                            CL-PPCRE::REPETITION>)))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES
;                                                         (COMPLEX SINGLE-FLOAT)
;                                                         &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF 
; ==>
;   (+ CL-PPCRE::START-POS
;      (*
;       (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G414 'CL-PPCRE::MINIMUM)
;                                     CL-PPCRE::REPETITION
;                                     (SB-PCL::INSTANCE-READ
;                                      (SB-PCL::PV-OFFSET 4) CL-PPCRE::REPETITION
;                                      0 'CL-PPCRE::MINIMUM
;                                      '#<STANDARD-CLASS CL-PPCRE::REPETITION>))
;       (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G414 'CL-PPCRE::LEN)
;                                     CL-PPCRE::REPETITION
;                                     (SB-PCL::INSTANCE-READ
;                                      (SB-PCL::PV-OFFSET 0) CL-PPCRE::REPETITION
;                                      0 'CL-PPCRE::LEN
;                                      '#<STANDARD-CLASS CL-PPCRE::REPETITION>))))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (CHAR-CLASS T)
;     (1+ CL-PPCRE::START-POS)
; ==>
;   (+ CL-PPCRE::START-POS 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (EVERYTHING T)
;     (1+ CL-PPCRE::START-POS)
; ==>
;   (+ CL-PPCRE::START-POS 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (STR T)
;     (+ CL-PPCRE::START-POS (CL-PPCRE::LEN CL-PPCRE::STR))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (FILTER T)
;     (+ CL-PPCRE::START-POS CL-PPCRE::LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/regex-class-util.fasl written
; compilation finished in 0:00:00.264
; compiling file "/usr/local/lib/sbcl/site/cl-ppcre-2.0.3/convert.lisp" (written 17 SEP 2009 12:17:31 PM):

; file: /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/convert.lisp
; in: DEFGENERIC RESOLVE-PROPERTY
;     (FUNCALL CL-PPCRE:*PROPERTY-RESOLVER* CL-PPCRE::PROPERTY-NAME)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE:*PROPERTY-RESOLVER*)
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

; in: DEFUN CONVERT-CHAR-CLASS-TO-TEST-FUNCTION
;     (FUNCALL CL-PPCRE::TEST-FUNCTION (CHAR-DOWNCASE CHAR))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

;     (CHAR-DOWNCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION (CHAR-UPCASE CHAR))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

;     (CHAR-UPCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION (CHAR-DOWNCASE CHAR))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

;     (CHAR-DOWNCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION (CHAR-UPCASE CHAR))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

;     (CHAR-UPCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION CHAR)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

;     (CHAR-DOWNCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (CHAR-UPCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION CL-PPCRE::CHAR-DOWN)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

;     (FUNCALL CL-PPCRE::TEST-FUNCTION CL-PPCRE::CHAR-UP)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

;     (CHAR-DOWNCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (CHAR-UPCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION CL-PPCRE::CHAR-DOWN)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

;     (FUNCALL CL-PPCRE::TEST-FUNCTION CL-PPCRE::CHAR-UP)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

; in: DEFUN MAYBE-SPLIT-REPETITION
;     (- CL-PPCRE::MAXIMUM CL-PPCRE::MINIMUM)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN MAYBE-ACCUMULATE
;     (SETF (SUBSEQ (SLOT-VALUE CL-PPCRE::STARTS-WITH 'CL-PPCRE::STR)
;                   (- (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH)
;                      (CL-PPCRE::LEN CL-PPCRE::STR)))
;             (CL-PPCRE::STR CL-PPCRE::STR)
;           (CL-PPCRE::SKIP CL-PPCRE::STR) T)
; --> PROGN SETF LET* MULTIPLE-VALUE-BIND LET PROGN 
; ==>
;   (REPLACE #:G111 #:G113 :START1 #:G112 :END1 NIL)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES SIMPLE-BASE-STRING
;                                                              &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY CHARACTER
;                                                        (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        SINGLE-FLOAT (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY DOUBLE-FLOAT (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY DOUBLE-FLOAT (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        DOUBLE-FLOAT (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-BIT-VECTOR.
;   The second argument is a SEQUENCE, not a SIMPLE-BIT-VECTOR.
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES SIMPLE-BIT-VECTOR
;                                                              &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 2) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 2) (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 2) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 4) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 4) (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 4) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 7) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 7) (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 7) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 8) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 15) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 15)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 15) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 16) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 16)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 16) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 31) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 31)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 31) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 32) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 32)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 32) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 60) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 60)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 60) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 63) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 63)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 63) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 64) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 64)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 64) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 8) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 8) (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (SIGNED-BYTE 8) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 16) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 16) (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (SIGNED-BYTE 16) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 32) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 32) (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (SIGNED-BYTE 32) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY FIXNUM (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY FIXNUM (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY FIXNUM (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 64) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 64) (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (SIGNED-BYTE 64) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (COMPLEX SINGLE-FLOAT)
;                                            (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (COMPLEX SINGLE-FLOAT)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (COMPLEX SINGLE-FLOAT)
;                                                        (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (COMPLEX DOUBLE-FLOAT)
;                                            (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (COMPLEX DOUBLE-FLOAT)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (COMPLEX DOUBLE-FLOAT)
;                                                        (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-VECTOR.
;   The second argument is a SEQUENCE, not a SIMPLE-VECTOR.
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES SIMPLE-VECTOR
;                                                              &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES SIMPLE-BASE-STRING
;                                                              &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY CHARACTER
;                                                        (*))
;                                                       &REST T).

;     (SETF (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH)
;             (+ (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH)
;                (CL-PPCRE::LEN CL-PPCRE::STR)))
; --> LET* MULTIPLE-VALUE-BIND LET FUNCALL SB-C::%FUNCALL 
; ==>
;   (#<SB-C::GLOBAL-VAR
;      :%SOURCE-NAME (SETF CL-PPCRE::LEN)
;      :TYPE #<SB-KERNEL:FUN-TYPE (FUNCTION # *)>
;      :WHERE-FROM :DEFINED-METHOD
;      :KIND :GLOBAL-FUNCTION {10037C67F1}>
;    #:NEW109 #:TMP110)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ((EQL :BRANCH) T)
;     (LENGTH (CL-PPCRE::CHOICES CL-PPCRE::ALTERNATIONS))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (1- (THE FIXNUM CL-PPCRE::TEST-CANDIDATE))
; ==>
;   (- (THE FIXNUM CL-PPCRE::TEST-CANDIDATE) 1)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ((EQL :GREEDY-REPETITION) T)
;     (ZEROP LENGTH)
; --> = IF 
; ==>
;   (= LENGTH 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (1- CL-PPCRE::MAXIMUM)
; ==>
;   (- CL-PPCRE::MAXIMUM 1)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ((EQL :NAMED-REGISTER) T)
;     (COPY-SEQ (SECOND CL-PPCRE::PARSE-TREE))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

; in: DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ((EQL :BACK-REFERENCE) T)
;     (STRING= CL-PPCRE::NAME CL-PPCRE::BACKREF-NAME)
; ==>
;   (SB-KERNEL:STRING=* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.
;   The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                                SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.

;     (- CL-PPCRE::REG-NUM CL-PPCRE::REG-INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.

;     (1- CL-PPCRE::BACKREF-NUMBER)
; ==>
;   (- CL-PPCRE::BACKREF-NUMBER 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.

;     (COPY-SEQ CL-PPCRE::BACKREF-NAME)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

;     (1- CL-PPCRE::BACKREF-NUMBER)
; ==>
;   (- CL-PPCRE::BACKREF-NUMBER 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (- CL-PPCRE::REG-NUM CL-PPCRE::REG-INDEX)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The second argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The second argument is a UNSIGNED-BYTE, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64)
;                                                                &REST T).
;       etc.

;     (LOOP CL-PPCRE::FOR CL-PPCRE::NAME CL-PPCRE::IN CL-PPCRE::REG-NAMES
;           CL-PPCRE::FOR CL-PPCRE::REG-INDEX CL-PPCRE::FROM 0
;           WHEN (STRING= CL-PPCRE::NAME CL-PPCRE::BACKREF-NAME)
;           CL-PPCRE::COLLECT ...)
; --> BLOCK LET LET SB-LOOP::WITH-LOOP-LIST-COLLECTION-HEAD LET* 
; --> SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 1+ 
; ==>
;   (+ CL-PPCRE::REG-INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; in: DEFUN CONVERT
;     (COERCE (SLOT-VALUE CL-PPCRE::STARTS-WITH 'CL-PPCRE::STR) 'SIMPLE-STRING)
; --> THE IF REPLACE MAKE-ARRAY LOCALLY MAKE-ARRAY 
; ==>
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> THE IF 
; ==>
;   (REPLACE (MAKE-ARRAY (LENGTH SB-C::X) :ELEMENT-TYPE 'CHARACTER) SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.

; /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/convert.fasl written
; compilation finished in 0:00:00.304
; compiling file "/usr/local/lib/sbcl/site/cl-ppcre-2.0.3/optimize.lisp" (written 17 SEP 2009 12:17:31 PM):

; file: /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/optimize.lisp
; in: DEFMETHOD GATHER-STRINGS (SEQ)
;     (INCF CL-PPCRE::COLLECTOR-LENGTH (CL-PPCRE::LEN CL-PPCRE::ELEMENT))
; --> LET* 
; ==>
;   (+ CL-PPCRE::COLLECTOR-LENGTH #:G164)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a NUMBER, not a FLOAT.

;     (SETF (SUBSEQ CL-PPCRE::COLLECTOR CL-PPCRE::OLD-COLLECTOR-LENGTH)
;             (CL-PPCRE::STR CL-PPCRE::ELEMENT)
;           CL-PPCRE::SKIP (CL-PPCRE::SKIP CL-PPCRE::ELEMENT))
; --> PROGN SETF LET* MULTIPLE-VALUE-BIND LET PROGN 
; ==>
;   (REPLACE #:G165 #:G167 :START1 #:G166 :END1 NIL)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-BASE-STRING.
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES SIMPLE-BASE-STRING
;                                                            &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY CHARACTER
;                                                      (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY SINGLE-FLOAT
;                                                      (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY DOUBLE-FLOAT (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY DOUBLE-FLOAT (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY DOUBLE-FLOAT
;                                                      (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-BIT-VECTOR.
;   The second argument is a SEQUENCE, not a SIMPLE-BIT-VECTOR.
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES SIMPLE-BIT-VECTOR
;                                                            &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 2) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 2) (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 2) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 4) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 4) (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 4) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 7) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 7) (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 7) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 8) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 15) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 15)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 15) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 16) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 16)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 16) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 31) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 31)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 31) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 32) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 32)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 32) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 60) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 60)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 60) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 63) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 63)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 63) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 64) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 64)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 64) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (SIGNED-BYTE 8) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 8) (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (SIGNED-BYTE 8) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (SIGNED-BYTE 16) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 16) (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (SIGNED-BYTE 16) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (SIGNED-BYTE 32) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 32) (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (SIGNED-BYTE 32) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY FIXNUM (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY FIXNUM (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY FIXNUM (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (SIGNED-BYTE 64) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 64) (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (SIGNED-BYTE 64) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (COMPLEX SINGLE-FLOAT)
;                                          (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (COMPLEX SINGLE-FLOAT)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (COMPLEX SINGLE-FLOAT)
;                                                      (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (COMPLEX DOUBLE-FLOAT)
;                                          (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (COMPLEX DOUBLE-FLOAT)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (COMPLEX DOUBLE-FLOAT)
;                                                      (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-VECTOR.
;   The second argument is a SEQUENCE, not a SIMPLE-VECTOR.
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES SIMPLE-VECTOR &REST
;                                                            T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-BASE-STRING.
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES SIMPLE-BASE-STRING
;                                                            &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY CHARACTER
;                                                      (*))
;                                                     &REST T).

;     (INCF CL-PPCRE::COLLECTOR-LENGTH (CL-PPCRE::LEN CL-PPCRE::ELEMENT))
; --> LET* 
; ==>
;   (+ CL-PPCRE::COLLECTOR-LENGTH #:G164)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a NUMBER, not a FIXNUM.
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       etc.

; in: DEFMETHOD START-ANCHORED-P (REPETITION)
;     (PLUSP (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION))
; ==>
;   (> (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; in: DEFMETHOD START-ANCHORED-P (REGEX)
;     (ZEROP (CL-PPCRE::LEN CL-PPCRE::REGEX))
; ==>
;   (= (CL-PPCRE::LEN CL-PPCRE::REGEX) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; in: DEFMETHOD END-STRING-AUX (SEQ)
;     (ZEROP (CL-PPCRE::LEN CL-PPCRE::ELEMENT-END))
; --> = IF 
; ==>
;   (= (CL-PPCRE::LEN CL-PPCRE::ELEMENT-END) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (CHAR CL-PPCRE::STR CL-PPCRE::I)
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-ARRAY.

; in: DEFMETHOD COMPUTE-MIN-REST (ALTERNATION T)
;     (LOOP CL-PPCRE::FOR CL-PPCRE::CHOICE CL-PPCRE::IN (CL-PPCRE::CHOICES
;                                                        CL-PPCRE::ALTERNATION)
;           CL-PPCRE::MINIMIZE (CL-PPCRE::COMPUTE-MIN-REST CL-PPCRE::CHOICE
;                               CL-PPCRE::CURRENT-MIN-REST))
; --> BLOCK LET SB-LOOP::WITH-MINIMAX-VALUE LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF OR THE < 
; --> IF 
; ==>
;   (< #:LOOP-MAXMIN-TEMP-415 #:LOOP-MAXMIN-414)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; in: DEFMETHOD COMPUTE-MIN-REST (BRANCH T)
;     (MIN
;      (CL-PPCRE::COMPUTE-MIN-REST (CL-PPCRE::THEN-REGEX CL-PPCRE::BRANCH)
;       CL-PPCRE::CURRENT-MIN-REST)
;      (CL-PPCRE::COMPUTE-MIN-REST (CL-PPCRE::ELSE-REGEX CL-PPCRE::BRANCH)
;       CL-PPCRE::CURRENT-MIN-REST))
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; in: DEFMETHOD COMPUTE-MIN-REST (STR T)
;     (+ CL-PPCRE::CURRENT-MIN-REST (CL-PPCRE::LEN CL-PPCRE::STR))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; in: DEFMETHOD COMPUTE-MIN-REST (FILTER T)
;     (+ CL-PPCRE::CURRENT-MIN-REST (OR (CL-PPCRE::LEN CL-PPCRE::FILTER) 0))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; in: DEFMETHOD COMPUTE-MIN-REST (REPETITION T)
;     (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;        (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.

;     (+ CL-PPCRE::CURRENT-MIN-REST
;        (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;           (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

;     (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;        (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES
;                                                         (COMPLEX SINGLE-FLOAT)
;                                                         &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (+ CL-PPCRE::CURRENT-MIN-REST
;        (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;           (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; in: DEFMETHOD COMPUTE-MIN-REST (LOOKBEHIND T)
;     (+ CL-PPCRE::CURRENT-MIN-REST (CL-PPCRE::LEN CL-PPCRE::LOOKBEHIND))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; in: DEFMETHOD COMPUTE-MIN-REST (REGEX T)
;     (1+ CL-PPCRE::CURRENT-MIN-REST)
; ==>
;   (+ CL-PPCRE::CURRENT-MIN-REST 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/optimize.fasl written
; compilation finished in 0:00:00.196
; compiling file "/usr/local/lib/sbcl/site/cl-ppcre-2.0.3/closures.lisp" (written 17 SEP 2009 12:17:30 PM):

; file: /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/closures.lisp
; in: DEFMETHOD CREATE-MATCHER-AUX (LOOKBEHIND T)
;     (FUNCALL CL-PPCRE::TEST-MATCHER (- CL-PPCRE::START-POS CL-PPCRE::LEN))
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-MATCHER)
;                   (- CL-PPCRE::START-POS CL-PPCRE::LEN))
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFMETHOD CREATE-MATCHER-AUX (CHAR-CLASS T)
;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::CHAR-CLASS
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::START-POS))
;       (LAMBDA (CL-PPCRE::START-POS)
;         (DECLARE (FIXNUM CL-PPCRE::START-POS))
;         (AND (< CL-PPCRE::START-POS CL-PPCRE::*END-POS*)
;              (CL-PPCRE::CHAR-CLASS-TEST)
;              (FUNCALL CL-PPCRE::NEXT-FN (1+ CL-PPCRE::START-POS)))))
; --> LET LET LAMBDA FUNCTION AND IF AND IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN #:TEST-FUNCTION185)
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

; in: DEFMETHOD CREATE-MATCHER-AUX (STR T)
;     (LENGTH CL-PPCRE::END-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (FUNCALL CL-PPCRE::NEXT-FN (+ CL-PPCRE::START-POS CL-PPCRE::LEN))
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::NEXT-FN)
;                   (+ CL-PPCRE::START-POS CL-PPCRE::LEN))
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFMETHOD CREATE-MATCHER-AUX (FILTER T)
;     (FUNCALL CL-PPCRE::FN CL-PPCRE::START-POS)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::FN)
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

;     (FUNCALL CL-PPCRE::NEXT-FN CL-PPCRE::NEXT-POS)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::NEXT-FN)
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

; /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/closures.fasl written
; compilation finished in 0:00:00.214
; compiling file "/usr/local/lib/sbcl/site/cl-ppcre-2.0.3/repetition-closures.lisp" (written 17 SEP 2009 12:17:31 PM):

; file: /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/repetition-closures.lisp
; in: DEFMETHOD CREATE-GREEDY-CONSTANT-LENGTH-MATCHER (REPETITION T)
;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE (CL-PPCRE::CHAR-CLASS-TEST)))
; --> LET LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --> BLOCK TAGBODY WHEN IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN #:TEST-FUNCTION159)
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

; in: DEFMETHOD CREATE-GREEDY-NO-ZERO-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0)
; --> SB-KERNEL:%ASET 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* + AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* - AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; in: DEFMETHOD CREATE-GREEDY-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0
;           (SVREF CL-PPCRE::*LAST-POS-STORES* CL-PPCRE::ZERO-LENGTH-NUM) NIL)
; --> PROGN SETF SB-KERNEL:%ASET 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* + AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* - AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; in: DEFMETHOD CREATE-NON-GREEDY-CONSTANT-LENGTH-MATCHER (REPETITION T)
;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE (CL-PPCRE::CHAR-CLASS-TEST)))
; --> LET LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION 
; --> LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY UNLESS IF FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN #:TEST-FUNCTION567)
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

; in: DEFMETHOD CREATE-NON-GREEDY-NO-ZERO-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0)
; --> SB-KERNEL:%ASET 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* + AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* - AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; in: DEFMETHOD CREATE-NON-GREEDY-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0
;           (SVREF CL-PPCRE::*LAST-POS-STORES* CL-PPCRE::ZERO-LENGTH-NUM) NIL)
; --> PROGN SETF SB-KERNEL:%ASET 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* + AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* - AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; in:
;      DEFMETHOD CREATE-CONSTANT-REPETITION-CONSTANT-LENGTH-MATCHER (REPETITION T)
;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE
;        (AND (CL-PPCRE::CHAR-CLASS-TEST) (1+ CL-PPCRE::CURR-POS))))
; --> LET LET CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE LAMBDA 
; --> FUNCTION LET AND IF AND IF LOOP BLOCK LET SB-LOOP::LOOP-BODY TAGBODY 
; --> UNLESS IF AND IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN #:TEST-FUNCTION872)
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

; in: DEFMETHOD CREATE-CONSTANT-REPETITION-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0)
; --> SB-KERNEL:%ASET 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* + AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* - AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0
;           (AREF CL-PPCRE::*LAST-POS-STORES* CL-PPCRE::ZERO-LENGTH-NUM) NIL)
; --> PROGN SETF SB-KERNEL:%ASET 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (ZEROP (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION))
; ==>
;   (= (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* + AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* - AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* SB-KERNEL:%ASET 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; in: DEFMETHOD CREATE-MATCHER-AUX (REPETITION T)
;     (DEFMETHOD CL-PPCRE::CREATE-MATCHER-AUX
;                ((CL-PPCRE::REPETITION CL-PPCRE::REPETITION) CL-PPCRE::NEXT-FN)
;                (DECLARE
;                 (OPTIMIZE SPEED (SAFETY 0) (SPACE 0) (DEBUG 1)
;                  (COMPILATION-SPEED 0)))
;                (WITH-SLOTS (CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM CL-PPCRE::LEN
;                                               CL-PPCRE::MIN-LEN CL-PPCRE::GREEDYP
;                                               CL-PPCRE::CONTAINS-REGISTER-P)
;                    CL-PPCRE::REPETITION
;                  (COND
;                   ((AND CL-PPCRE::MAXIMUM #)
;                    (ERROR "Got REPETITION with MAXIMUM 0 (should not happen)"))
;                   ((AND CL-PPCRE::MAXIMUM #)
;                    (ERROR
;                     "Got REPETITION with MAXIMUM 1 and MINIMUM 1 (should not happen)"))
;                   ((AND # CL-PPCRE::LEN #)
;                    (CL-PPCRE::CREATE-CONSTANT-REPETITION-CONSTANT-LENGTH-MATCHER
;                     CL-PPCRE::REPETITION CL-PPCRE::NEXT-FN))
;                   ((EQL CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM)
;                    (CL-PPCRE::CREATE-CONSTANT-REPETITION-MATCHER
;                     CL-PPCRE::REPETITION CL-PPCRE::NEXT-FN))
;                   ((AND CL-PPCRE::GREEDYP CL-PPCRE::LEN #)
;                    (CL-PPCRE::CREATE-GREEDY-CONSTANT-LENGTH-MATCHER
;                     CL-PPCRE::REPETITION CL-PPCRE::NEXT-FN))
;                   ((AND CL-PPCRE::GREEDYP #)
;                    (CL-PPCRE::CREATE-GREEDY-NO-ZERO-MATCHER CL-PPCRE::REPETITION
;                     CL-PPCRE::NEXT-FN))
;                   (CL-PPCRE::GREEDYP
;                    (CL-PPCRE::CREATE-GREEDY-MATCHER CL-PPCRE::REPETITION
;                     CL-PPCRE::NEXT-FN))
;                   ((AND CL-PPCRE::LEN # #)
;                    (CL-PPCRE::CREATE-NON-GREEDY-CONSTANT-LENGTH-MATCHER
;                     CL-PPCRE::REPETITION CL-PPCRE::NEXT-FN))
;                   ((OR # #)
;                    (CL-PPCRE::CREATE-NON-GREEDY-NO-ZERO-MATCHER
;                     CL-PPCRE::REPETITION CL-PPCRE::NEXT-FN))
;                   (T
;                    (CL-PPCRE::CREATE-NON-GREEDY-MATCHER CL-PPCRE::REPETITION
;                     CL-PPCRE::NEXT-FN)))))
; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF THE ZEROP 
; ==>
;   (=
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G1016 'CL-PPCRE::MAXIMUM)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 6)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MAXIMUM
;                                                         '#<STANDARD-CLASS
;                                                            CL-PPCRE::REPETITION>))
;    0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF IF THE = 
; --> (LAMBDA (#:G1073 #:G1072 #:G1071) (DECLARE (TYPE NUMBER #:G1073 #:G1072 #:G1071)) (IF (= #:G1073 #:G1072) (IF (= #:G1072 #:G1071) T NIL) NIL)) 
; --> IF 
; ==>
;   (= #:G1073 #:G1072)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF IF THE = 
; --> (LAMBDA (#:G1073 #:G1072 #:G1071) (DECLARE (TYPE NUMBER #:G1073 #:G1072 #:G1071)) (IF (= #:G1073 #:G1072) (IF (= #:G1072 #:G1071) T NIL) NIL)) 
; --> IF IF 
; ==>
;   (= #:G1072 #:G1071)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF IF IF IF IF IF 
; --> THE LET PLUSP > IF 
; ==>
;   (>
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G1016 'CL-PPCRE::MIN-LEN)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 8)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MIN-LEN
;                                                         '#<STANDARD-CLASS
;                                                            CL-PPCRE::REPETITION>))
;    0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF IF IF IF IF IF 
; --> IF IF IF PLUSP 
; ==>
;   (>
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G1016 'CL-PPCRE::LEN)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 4)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::LEN
;                                                         '#<STANDARD-CLASS
;                                                            CL-PPCRE::REPETITION>))
;    0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF IF IF IF IF IF 
; --> IF IF LET PLUSP > IF 
; ==>
;   (>
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G1016 'CL-PPCRE::MIN-LEN)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 8)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MIN-LEN
;                                                         '#<STANDARD-CLASS
;                                                            CL-PPCRE::REPETITION>))
;    0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF IF THE = 
; --> (LAMBDA (#:G1073 #:G1072 #:G1071) (DECLARE (TYPE NUMBER #:G1073 #:G1072 #:G1071)) (IF (= #:G1073 #:G1072) (IF (= #:G1072 #:G1071) T NIL) NIL)) 
; --> IF 
; ==>
;   (= #:G1073 #:G1072)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF IF IF 
; ==>
;   (EQL
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G1016 'CL-PPCRE::MINIMUM)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 10)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MINIMUM
;                                                         '#<STANDARD-CLASS
;                                                            CL-PPCRE::REPETITION>))
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G1016 'CL-PPCRE::MAXIMUM)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 6)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MAXIMUM
;                                                         '#<STANDARD-CLASS
;                                                            CL-PPCRE::REPETITION>)))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF IF IF IF IF IF 
; --> THE LET PLUSP > IF 
; ==>
;   (>
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G1016 'CL-PPCRE::MIN-LEN)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 8)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MIN-LEN
;                                                         '#<STANDARD-CLASS
;                                                            CL-PPCRE::REPETITION>))
;    0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF IF IF IF IF IF 
; --> IF IF IF PLUSP 
; ==>
;   (>
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G1016 'CL-PPCRE::LEN)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 4)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::LEN
;                                                         '#<STANDARD-CLASS
;                                                            CL-PPCRE::REPETITION>))
;    0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER PROGN SB-PCL::LOAD-DEFMETHOD 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS LOCALLY SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET SB-PCL::PV-BINDING SB-PCL::PV-BINDING1 
; --> SB-PCL::PV-ENV LOCALLY LET BLOCK LET SYMBOL-MACROLET IF IF IF IF IF IF IF 
; --> IF IF LET PLUSP > IF 
; ==>
;   (>
;    (SB-PCL::OPTIMIZED-SLOT-VALUE (SLOT-VALUE #:G1016 'CL-PPCRE::MIN-LEN)
;                                  CL-PPCRE::REPETITION
;                                  (SB-PCL::INSTANCE-READ (SB-PCL::PV-OFFSET 8)
;                                                         CL-PPCRE::REPETITION 0
;                                                         'CL-PPCRE::MIN-LEN
;                                                         '#<STANDARD-CLASS
;                                                            CL-PPCRE::REPETITION>))
;    0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/repetition-closures.fasl written
; compilation finished in 0:00:00.544
; compiling file "/usr/local/lib/sbcl/site/cl-ppcre-2.0.3/scanner.lisp" (written 17 SEP 2009 12:17:31 PM):

; file: /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/scanner.lisp
; in: DEFUN CREATE-BMH-MATCHER
;     (LENGTH CL-PPCRE::PATTERN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CHAR-UPCASE (SCHAR CL-PPCRE::PATTERN CL-PPCRE::K))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (CHAR-DOWNCASE (SCHAR CL-PPCRE::PATTERN CL-PPCRE::K))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (SEARCH CL-PPCRE::PATTERN CL-PPCRE::*STRING* :START2 CL-PPCRE::START-POS
;             :END2 CL-PPCRE::*END-POS* :TEST CL-PPCRE::TEST)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; in: DEFMACRO INSERT-ADVANCE-FN
;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;        CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G239)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;        CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G229)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;        CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G219)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;        CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G209)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;        CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G199)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;        CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G189)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;        CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G179)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;        CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G165)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.

;     (<= CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: unable to open code because: The operands might not be the same type.

; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;        CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G239)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;        CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G229)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;        CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G219)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;        CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G209)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;        CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G199)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;        CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G189)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;        CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G165)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= CL-PPCRE::*START-POS* CL-PPCRE::*END-STRING-POS*)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;        CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CL-PPCRE::*END-STRING-POS*)
; --> LET* 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* #:G179)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS) CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND
;    '#<SB-C::GLOBAL-VAR
;       :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;       :KIND :SPECIAL {1003EC4481}>
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {1003EC4481}>
;      {10047171F1}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

; in: DEFMACRO INSERT-ADVANCE-FN
;     (FUNCALL CL-PPCRE::END-STRING-TEST (1- CL-PPCRE::END-TEST-POS))
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::END-STRING-TEST)
;                   (1- CL-PPCRE::END-TEST-POS))
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (IF (<= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND
;    '#<SB-C::GLOBAL-VAR
;       :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;       :KIND :SPECIAL {1003EC4481}>
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {1003EC4481}>
;      {100471C5A1}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

; in: DEFMACRO INSERT-ADVANCE-FN
;     (FUNCALL CL-PPCRE::END-STRING-TEST (1- CL-PPCRE::END-TEST-POS))
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::END-STRING-TEST)
;                   (1- CL-PPCRE::END-TEST-POS))
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND
;    '#<SB-C::GLOBAL-VAR
;       :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;       :KIND :SPECIAL {1003EC4481}>
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {1003EC4481}>
;      {10047235A1}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

; in: DEFMACRO INSERT-ADVANCE-FN
;     (FUNCALL CL-PPCRE::END-STRING-TEST (1- CL-PPCRE::END-TEST-POS))
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::END-STRING-TEST)
;                   (1- CL-PPCRE::END-TEST-POS))
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::START-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND
;    '#<SB-C::GLOBAL-VAR
;       :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;       :KIND :SPECIAL {1003EC4481}>
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {1003EC4481}>
;      {100472A5A1}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

; in: DEFMACRO INSERT-ADVANCE-FN
;     (FUNCALL CL-PPCRE::END-STRING-TEST (1- CL-PPCRE::END-TEST-POS))
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::END-STRING-TEST)
;                   (1- CL-PPCRE::END-TEST-POS))
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       (IF (<= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND
;    '#<SB-C::GLOBAL-VAR
;       :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;       :KIND :SPECIAL {1003EC4481}>
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {1003EC4481}>
;      {10047315A1}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

; in: DEFMACRO INSERT-ADVANCE-FN
;     (FUNCALL CL-PPCRE::END-STRING-TEST (1- CL-PPCRE::END-TEST-POS))
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::END-STRING-TEST)
;                   (1- CL-PPCRE::END-TEST-POS))
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       (IF (<= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND
;    '#<SB-C::GLOBAL-VAR
;       :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;       :KIND :SPECIAL {1003EC4481}>
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {1003EC4481}>
;      {10047385A1}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

; in: DEFMACRO INSERT-ADVANCE-FN
;     (FUNCALL CL-PPCRE::END-STRING-TEST (1- CL-PPCRE::END-TEST-POS))
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::END-STRING-TEST)
;                   (1- CL-PPCRE::END-TEST-POS))
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET)
;                (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND
;    '#<SB-C::GLOBAL-VAR
;       :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;       :KIND :SPECIAL {1003EC4481}>
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {1003EC4481}>
;      {100473AB21}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

;     (SETQ CL-PPCRE::TRY-POS (1+ CL-PPCRE::*END-STRING-POS*))
; 
; note: doing signed word to integer coercion (cost 20) to TRY-POS
; 
; note: doing signed word to integer coercion (cost 20) to TRY-POS

; in: DEFMACRO INSERT-ADVANCE-FN
;     (FUNCALL CL-PPCRE::END-STRING-TEST (1- CL-PPCRE::END-TEST-POS))
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::END-STRING-TEST)
;                   (1- CL-PPCRE::END-TEST-POS))
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET CL-PPCRE::STARTS-WITH-LEN)
;                (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND
;    '#<SB-C::GLOBAL-VAR
;       :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;       :KIND :SPECIAL {1003EC4481}>
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {1003EC4481}>
;      {100473D141}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

;     (FUNCALL CL-PPCRE::END-STRING-TEST CL-PPCRE::TRY-POS)
; --> SB-C::%FUNCALL 
; ==>
;   CL-PPCRE::TRY-POS
; 
; note: doing signed word to integer coercion (cost 20) from TRY-POS
; 
; note: doing signed word to integer coercion (cost 20) from TRY-POS

; in: DEFMACRO INSERT-ADVANCE-FN
;     (FUNCALL CL-PPCRE::END-STRING-TEST (1- CL-PPCRE::END-TEST-POS))
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::END-STRING-TEST)
;                   (1- CL-PPCRE::END-TEST-POS))
; 
; note: doing signed word to integer coercion (cost 20)

; /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/scanner.fasl written
; compilation finished in 0:00:01.036
; compiling file "/usr/local/lib/sbcl/site/cl-ppcre-2.0.3/api.lisp" (written 17 SEP 2009 12:17:30 PM):

; file: /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/api.lisp
; in: DEFMETHOD CREATE-SCANNER (STRING)
;     (COPY-SEQ CL-PPCRE::QUOTED-REGEX-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

; in: DEFMETHOD CREATE-SCANNER (T)
;     (PLUSP (CL-PPCRE::LEN CL-PPCRE::END-STRING))
; ==>
;   (> (CL-PPCRE::LEN CL-PPCRE::END-STRING) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (= 1 (CL-PPCRE::LEN CL-PPCRE::END-STRING))
; --> = IF 
; ==>
;   (= SB-C::Y SB-C::X)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (PLUSP (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH))
; ==>
;   (> (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (= 1 (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH))
; --> = IF 
; ==>
;   (= SB-C::Y SB-C::X)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (PLUSP (CL-PPCRE::LEN CL-PPCRE::END-STRING))
; ==>
;   (> (CL-PPCRE::LEN CL-PPCRE::END-STRING) 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (PLUSP (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH))
; ==>
;   (> (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH) 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; in: DEFMETHOD SCAN (STRING T)
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (FUNCALL (CL-PPCRE:CREATE-SCANNER CL-PPCRE::REGEX-STRING)
;              (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING CL-PPCRE::TARGET-STRING)
;              CL-PPCRE::START CL-PPCRE::END)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN
;    (CL-PPCRE:CREATE-SCANNER CL-PPCRE::REGEX-STRING))
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

;     (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING CL-PPCRE::TARGET-STRING)
; --> LET COND IF COND THE PROGN COERCE THE IF REPLACE MAKE-ARRAY LOCALLY 
; --> MAKE-ARRAY 
; ==>
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> LET COND IF COND THE PROGN COERCE THE IF 
; ==>
;   (REPLACE (MAKE-ARRAY (LENGTH SB-C::X) :ELEMENT-TYPE 'CHARACTER) SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.

; in: DEFMETHOD SCAN #'T
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING CL-PPCRE::TARGET-STRING)
; --> LET COND IF COND THE PROGN COERCE THE IF REPLACE MAKE-ARRAY LOCALLY 
; --> MAKE-ARRAY 
; ==>
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> LET COND IF COND THE PROGN COERCE THE IF 
; ==>
;   (REPLACE (MAKE-ARRAY (LENGTH SB-C::X) :ELEMENT-TYPE 'CHARACTER) SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.

; in: DEFMETHOD SCAN (T T)
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (FUNCALL (CL-PPCRE:CREATE-SCANNER CL-PPCRE::PARSE-TREE)
;              (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING CL-PPCRE::TARGET-STRING)
;              CL-PPCRE::START CL-PPCRE::END)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN
;    (CL-PPCRE:CREATE-SCANNER CL-PPCRE::PARSE-TREE))
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

;     (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING CL-PPCRE::TARGET-STRING)
; --> LET COND IF COND THE PROGN COERCE THE IF REPLACE MAKE-ARRAY LOCALLY 
; --> MAKE-ARRAY 
; ==>
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> LET COND IF COND THE PROGN COERCE THE IF 
; ==>
;   (REPLACE (MAKE-ARRAY (LENGTH SB-C::X) :ELEMENT-TYPE 'CHARACTER) SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.

; in: DEFUN SCAN-TO-STRINGS
;     (MAP 'VECTOR
;          (LAMBDA (CL-PPCRE::REG-START CL-PPCRE::REG-END)
;            (IF CL-PPCRE::REG-START
;                (FUNCALL CL-PPCRE::SUBSTR-FN CL-PPCRE::TARGET-STRING
;                         CL-PPCRE::REG-START CL-PPCRE::REG-END)
;                NIL))
;          CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS)
; --> TRULY-THE 
; ==>
;   (SB-KERNEL:%MAP SB-C::RESULT-TYPE-ARG SB-C::FUN #:G253 #:G254)
; 
; note: unable to open code because: can't determine sequence argument type

;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; in: DEFMACRO REGISTER-GROUPS-BIND
;     (LOOP CL-PPCRE::FOR #'CL-PPCRE::VAR CL-PPCRE::IN (CL-PPCRE::NORMALIZE-VAR-LIST
;                                                       CL-PPCRE::VAR-LIST)
;           CL-PPCRE::FOR CL-PPCRE::COUNTER CL-PPCRE::FROM 0
;           WHEN CL-PPCRE::VAR
;           CL-PPCRE::COLLECT ...)
; --> BLOCK LET LET SB-LOOP::WITH-LOOP-LIST-COLLECTION-HEAD LET* 
; --> SB-LOOP::LOOP-BODY LET TAGBODY IF SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 1+ 
; ==>
;   (+ CL-PPCRE::COUNTER 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; in: DEFMACRO DO-REGISTER-GROUPS
;     (LOOP CL-PPCRE::FOR #'CL-PPCRE::VAR CL-PPCRE::IN (CL-PPCRE::NORMALIZE-VAR-LIST
;                                                       CL-PPCRE::VAR-LIST)
;           CL-PPCRE::FOR CL-PPCRE::COUNTER CL-PPCRE::FROM 0
;           WHEN CL-PPCRE::VAR
;           CL-PPCRE::COLLECT ...)
; --> BLOCK LET LET SB-LOOP::WITH-LOOP-LIST-COLLECTION-HEAD LET* 
; --> SB-LOOP::LOOP-BODY LET TAGBODY IF SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 1+ 
; ==>
;   (+ CL-PPCRE::COUNTER 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; in: DEFUN ALL-MATCHES
;     (CL-PPCRE:DO-MATCHES (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                           CL-PPCRE::REGEX CL-PPCRE::TARGET-STRING
;                           (NREVERSE CL-PPCRE::RESULT-LIST) :START CL-PPCRE::START
;                           :END CL-PPCRE::END)
;       (PUSH CL-PPCRE::MATCH-START CL-PPCRE::RESULT-LIST)
;       (PUSH CL-PPCRE::MATCH-END CL-PPCRE::RESULT-LIST))
; --> CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK TAGBODY PROGN 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==>
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK TAGBODY PROGN 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.

;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE:DO-MATCHES (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                           CL-PPCRE::REGEX CL-PPCRE::TARGET-STRING
;                           (NREVERSE CL-PPCRE::RESULT-LIST) :START CL-PPCRE::START
;                           :END CL-PPCRE::END)
;       (PUSH CL-PPCRE::MATCH-START CL-PPCRE::RESULT-LIST)
;       (PUSH CL-PPCRE::MATCH-END CL-PPCRE::RESULT-LIST))
; --> CL-PPCRE:DO-SCANS LET BLOCK LET* OR LET IF OR THE 
; ==>
;   (LENGTH #:TARGET-STRING370)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> CL-PPCRE:DO-SCANS LET BLOCK LET* SETQ THE 
; --> CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND IF COND THE PROGN COERCE 
; --> THE IF REPLACE MAKE-ARRAY LOCALLY MAKE-ARRAY 
; ==>
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> CL-PPCRE:DO-SCANS LET BLOCK LET* SETQ THE 
; --> CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND IF COND THE PROGN COERCE 
; --> THE IF 
; ==>
;   (REPLACE (MAKE-ARRAY (LENGTH SB-C::X) :ELEMENT-TYPE 'CHARACTER) SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.

; --> CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK TAGBODY PROGN 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==>
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; --> CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK TAGBODY PROGN 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; in: DEFUN ALL-MATCHES-AS-STRINGS
;     (CL-PPCRE:DO-MATCHES-AS-STRINGS (CL-PPCRE::MATCH CL-PPCRE::REGEX
;                                      CL-PPCRE::TARGET-STRING
;                                      (NREVERSE CL-PPCRE::RESULT-LIST) :START
;                                      CL-PPCRE::START :END CL-PPCRE::END :SHAREDP
;                                      CL-PPCRE::SHAREDP)
;       (PUSH CL-PPCRE::MATCH CL-PPCRE::RESULT-LIST))
; --> LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK 
; --> TAGBODY PROGN MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE 
; --> IF 
; ==>
;   (= #:MATCH-START427 #:MATCH-END428)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK 
; --> TAGBODY PROGN MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE 
; --> IF 1+ 
; ==>
;   (+ #:MATCH-END428 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.

;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE:DO-MATCHES-AS-STRINGS (CL-PPCRE::MATCH CL-PPCRE::REGEX
;                                      CL-PPCRE::TARGET-STRING
;                                      (NREVERSE CL-PPCRE::RESULT-LIST) :START
;                                      CL-PPCRE::START :END CL-PPCRE::END :SHAREDP
;                                      CL-PPCRE::SHAREDP)
;       (PUSH CL-PPCRE::MATCH CL-PPCRE::RESULT-LIST))
; --> LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* OR LET IF OR 
; --> THE 
; ==>
;   (LENGTH #:TARGET-STRING432)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* SETQ THE 
; --> CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND IF COND THE PROGN COERCE 
; --> THE IF REPLACE MAKE-ARRAY LOCALLY MAKE-ARRAY 
; ==>
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* SETQ THE 
; --> CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND IF COND THE PROGN COERCE 
; --> THE IF 
; ==>
;   (REPLACE (MAKE-ARRAY (LENGTH SB-C::X) :ELEMENT-TYPE 'CHARACTER) SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.

; --> LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK 
; --> TAGBODY PROGN MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE 
; --> IF 
; ==>
;   (= #:MATCH-START427 #:MATCH-END428)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; --> LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK 
; --> TAGBODY PROGN MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE 
; --> IF 1+ 
; ==>
;   (+ #:MATCH-END428 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; in: DEFUN SPLIT
;     (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (LOOP CL-PPCRE::FOR CL-PPCRE::REG-START CL-PPCRE::ACROSS CL-PPCRE::REG-STARTS
;           CL-PPCRE::FOR CL-PPCRE::REG-END CL-PPCRE::ACROSS CL-PPCRE::REG-ENDS
;           IF CL-PPCRE::REG-START
;           DO ...)
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> THE AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

;     (CL-PPCRE:DO-SCANS (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                         CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS CL-PPCRE::REGEX
;                         CL-PPCRE::TARGET-STRING NIL :START CL-PPCRE::START :END
;                         CL-PPCRE::END)
;       (UNLESS
;           (AND (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
;                (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST)))
;         (WHEN (AND CL-PPCRE::LIMIT (>= # CL-PPCRE::LIMIT)) (RETURN))
;         (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;         (WHEN CL-PPCRE::WITH-REGISTERS-P
;           (LOOP CL-PPCRE::FOR CL-PPCRE::REG-START CL-PPCRE::ACROSS CL-PPCRE::REG-STARTS
;                 CL-PPCRE::FOR CL-PPCRE::REG-END CL-PPCRE::ACROSS CL-PPCRE::REG-ENDS
;                 IF CL-PPCRE::REG-START
;                 DO ...))
;         (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)))
; --> LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==>
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.

;     (> CL-PPCRE::THIS-END CL-PPCRE::THIS-START)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE:DO-SCANS (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                         CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS CL-PPCRE::REGEX
;                         CL-PPCRE::TARGET-STRING NIL :START CL-PPCRE::START :END
;                         CL-PPCRE::END)
;       (UNLESS
;           (AND (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
;                (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST)))
;         (WHEN (AND CL-PPCRE::LIMIT (>= # CL-PPCRE::LIMIT)) (RETURN))
;         (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;         (WHEN CL-PPCRE::WITH-REGISTERS-P
;           (LOOP CL-PPCRE::FOR CL-PPCRE::REG-START CL-PPCRE::ACROSS CL-PPCRE::REG-STARTS
;                 CL-PPCRE::FOR CL-PPCRE::REG-END CL-PPCRE::ACROSS CL-PPCRE::REG-ENDS
;                 IF CL-PPCRE::REG-START
;                 DO ...))
;         (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)))
; --> LET BLOCK LET* OR LET IF OR THE 
; ==>
;   (LENGTH #:TARGET-STRING487)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> LET BLOCK LET* SETQ THE CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND 
; --> IF COND THE PROGN COERCE THE IF REPLACE MAKE-ARRAY LOCALLY MAKE-ARRAY 
; ==>
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> LET BLOCK LET* SETQ THE CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND 
; --> IF COND THE PROGN COERCE THE IF 
; ==>
;   (REPLACE (MAKE-ARRAY (LENGTH SB-C::X) :ELEMENT-TYPE 'CHARACTER) SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.

;     (>= (INCF CL-PPCRE::COUNTER) CL-PPCRE::LIMIT)
; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

;     (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST))
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

;     (INCF CL-PPCRE::COUNTER)
; --> LET* 
; ==>
;   (+ CL-PPCRE::COUNTER #:G496)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

;     (>= (INCF CL-PPCRE::COUNTER) CL-PPCRE::LIMIT)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (> CL-PPCRE::THIS-END CL-PPCRE::THIS-START)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (CL-PPCRE:DO-SCANS (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                         CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS CL-PPCRE::REGEX
;                         CL-PPCRE::TARGET-STRING NIL :START CL-PPCRE::START :END
;                         CL-PPCRE::END)
;       (UNLESS
;           (AND (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
;                (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST)))
;         (WHEN (AND CL-PPCRE::LIMIT (>= # CL-PPCRE::LIMIT)) (RETURN))
;         (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;         (WHEN CL-PPCRE::WITH-REGISTERS-P
;           (LOOP CL-PPCRE::FOR CL-PPCRE::REG-START CL-PPCRE::ACROSS CL-PPCRE::REG-STARTS
;                 CL-PPCRE::FOR CL-PPCRE::REG-END CL-PPCRE::ACROSS CL-PPCRE::REG-ENDS
;                 IF CL-PPCRE::REG-START
;                 DO ...))
;         (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)))
; --> LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==>
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; --> LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; in: DEFUN STRING-CASE-MODIFIER
;     (CHAR CL-PPCRE::STR (1- CL-PPCRE::FROM))
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-ARRAY.

;     (CHAR CL-PPCRE::STR CL-PPCRE::FROM)
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-ARRAY.

;     (CHAR CL-PPCRE::STR CL-PPCRE::TO)
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-ARRAY.

;     (CHAR CL-PPCRE::STR (1- CL-PPCRE::TO))
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-ARRAY.

;     (CHAR CL-PPCRE::STR CL-PPCRE::INDEX)
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-ARRAY.

; in: DEFMETHOD BUILD-REPLACEMENT-TEMPLATE (STRING)
;     (POSITION-IF #'CL-PPCRE::DIGIT-CHAR-P CL-PPCRE::REPLACEMENT-STRING :START
;                  CL-PPCRE::MATCH-START :END CL-PPCRE::MATCH-END)
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%FIND-POSITION-IF
;    (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-C:PREDICATE) SEQUENCE SB-C::FROM-END
;    SB-C::START SB-C::END (SB-KERNEL:EFFECTIVE-FIND-POSITION-KEY SB-C::KEY))
; 
; note: unable to
;   expand inline
; because:
;   upgraded array element type not known at compile time

;     (CHAR CL-PPCRE::REPLACEMENT-STRING (1+ CL-PPCRE::MATCH-START))
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-ARRAY.

;     (CL-PPCRE:DO-MATCHES (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                           CL-PPCRE::REG-SCANNER CL-PPCRE::REPLACEMENT-STRING)
;       (WHEN (< CL-PPCRE::FROM CL-PPCRE::MATCH-START)
;         (PUSH
;          (SUBSEQ CL-PPCRE::REPLACEMENT-STRING CL-PPCRE::FROM
;                  CL-PPCRE::MATCH-START)
;          CL-PPCRE::COLLECTOR))
;       (LET* ((CL-PPCRE::PARSE-START
;               (POSITION-IF #'CL-PPCRE::DIGIT-CHAR-P CL-PPCRE::REPLACEMENT-STRING
;                            :START CL-PPCRE::MATCH-START :END
;                            CL-PPCRE::MATCH-END))
;              (CL-PPCRE::TOKEN
;               (IF CL-PPCRE::PARSE-START
;                   #
;                   #)))
;         (WHEN (AND (NUMBERP CL-PPCRE::TOKEN) (< CL-PPCRE::TOKEN 0))
;           (CL-PPCRE::SIGNAL-INVOCATION-ERROR
;            "Illegal substring ~S in replacement string."
;            (SUBSEQ CL-PPCRE::REPLACEMENT-STRING CL-PPCRE::MATCH-START
;                    CL-PPCRE::MATCH-END)))
;         (PUSH CL-PPCRE::TOKEN CL-PPCRE::COLLECTOR))
;       (SETQ CL-PPCRE::FROM CL-PPCRE::MATCH-END))
; --> CL-PPCRE:DO-SCANS LET BLOCK LET* SETQ THE 
; --> CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND IF COND THE PROGN COERCE 
; --> THE IF 
; ==>
;   (REPLACE (MAKE-ARRAY (LENGTH SB-C::X) :ELEMENT-TYPE 'CHARACTER) SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a STRING, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a STRING, not a SIMPLE-BASE-STRING.

;     (< CL-PPCRE::FROM CL-PPCRE::MATCH-START)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (1-
;      (PARSE-INTEGER CL-PPCRE::REPLACEMENT-STRING :START CL-PPCRE::PARSE-START
;                     :JUNK-ALLOWED T))
; ==>
;   (-
;    (PARSE-INTEGER CL-PPCRE::REPLACEMENT-STRING :START CL-PPCRE::PARSE-START
;                   :JUNK-ALLOWED T)
;    1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (< CL-PPCRE::TOKEN 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

; in: DEFUN BUILD-REPLACEMENT
;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::REG-START
;                        CL-PPCRE::REG-END)
; --> BLOCK MAKE-ARRAY LOCALLY MAKE-ARRAY 
; ==>
;   (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::MATCH-START
;                        CL-PPCRE::MATCH-END)
; --> BLOCK MAKE-ARRAY LOCALLY MAKE-ARRAY 
; ==>
;   (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

;     (ARRAY-DIMENSION CL-PPCRE::REG-STARTS 0)
; 
; note: unable to
;   optimize
; because:
;   The array dimensions are unknown; must call ARRAY-DIMENSION at runtime.

;     (MAP 'LIST
;          (LAMBDA (CL-PPCRE::REG-START CL-PPCRE::REG-END)
;            (AND CL-PPCRE::REG-START
;                 (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::REG-START
;                                    CL-PPCRE::REG-END)))
;          CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS)
; --> TRULY-THE 
; ==>
;   (SB-KERNEL:%MAP SB-C::RESULT-TYPE-ARG SB-C::FUN #:G731 #:G732)
; 
; note: unable to open code because: can't determine sequence argument type

;     (APPLY CL-PPCRE::TOKEN
;            (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::MATCH-START
;                               CL-PPCRE::MATCH-END)
;            (MAP 'LIST
;                 (LAMBDA (CL-PPCRE::REG-START CL-PPCRE::REG-END)
;                   (AND CL-PPCRE::REG-START
;                        (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING
;                                           CL-PPCRE::REG-START
;                                           CL-PPCRE::REG-END)))
;                 CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS))
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TOKEN)
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

;     (MAP 'LIST
;          (LAMBDA (CL-PPCRE::REG-START CL-PPCRE::REG-END)
;            (AND CL-PPCRE::REG-START
;                 (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::REG-START
;                                    CL-PPCRE::REG-END)))
;          CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS)
; --> TRULY-THE 
; ==>
;   (SB-KERNEL:%MAP SB-C::RESULT-TYPE-ARG SB-C::FUN #:G733 #:G734)
; 
; note: unable to open code because: can't determine sequence argument type

;     (FUNCALL CL-PPCRE::TOKEN CL-PPCRE::TARGET-STRING CL-PPCRE::START
;              CL-PPCRE::END CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;              CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TOKEN)
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

;     (>= CL-PPCRE::TOKEN CL-PPCRE::REG-BOUND)
; --> IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.

;     (1+ CL-PPCRE::TOKEN)
; ==>
;   (+ CL-PPCRE::TOKEN 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::MATCH-START
;                        CL-PPCRE::MATCH-END)
; --> BLOCK MAKE-ARRAY LOCALLY MAKE-ARRAY 
; ==>
;   (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::REG-START
;                        CL-PPCRE::REG-END)
; --> BLOCK MAKE-ARRAY LOCALLY MAKE-ARRAY 
; ==>
;   (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; in: DEFUN REPLACE-AUX
;     (FUNCALL
;      (CL-PPCRE::STRING-CASE-MODIFIER CL-PPCRE::TARGET-STRING CL-PPCRE::FROM
;       CL-PPCRE::TO CL-PPCRE::START CL-PPCRE::END)
;      CL-PPCRE::CURR-REPLACEMENT)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN
;    (CL-PPCRE::STRING-CASE-MODIFIER CL-PPCRE::TARGET-STRING CL-PPCRE::FROM
;     CL-PPCRE::TO CL-PPCRE::START CL-PPCRE::END))
; 
; note: unable to
;   optimize
; because:
;   optimize away possible call to FDEFINITION at runtime

; in: DEFUN REGEX-REPLACE
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (SUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::START CL-PPCRE::END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

; in: DEFUN REGEX-REPLACE-ALL
;     (CL-PPCRE:DO-SCANS (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                         CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS CL-PPCRE::REGEX
;                         CL-PPCRE::TARGET-STRING NIL :START CL-PPCRE::START :END
;                         CL-PPCRE::END)
;       (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;       (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)
;       (PUSH CL-PPCRE::REG-STARTS CL-PPCRE::REG-LIST)
;       (PUSH CL-PPCRE::REG-ENDS CL-PPCRE::REG-LIST))
; --> LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==>
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.

;     (SUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::START CL-PPCRE::END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE:DO-SCANS (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                         CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS CL-PPCRE::REGEX
;                         CL-PPCRE::TARGET-STRING NIL :START CL-PPCRE::START :END
;                         CL-PPCRE::END)
;       (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;       (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)
;       (PUSH CL-PPCRE::REG-STARTS CL-PPCRE::REG-LIST)
;       (PUSH CL-PPCRE::REG-ENDS CL-PPCRE::REG-LIST))
; --> LET BLOCK LET* OR LET IF OR THE 
; ==>
;   (LENGTH #:TARGET-STRING804)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> LET BLOCK LET* SETQ THE CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND 
; --> IF COND THE PROGN COERCE THE IF REPLACE MAKE-ARRAY LOCALLY MAKE-ARRAY 
; ==>
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> LET BLOCK LET* SETQ THE CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND 
; --> IF COND THE PROGN COERCE THE IF 
; ==>
;   (REPLACE (MAKE-ARRAY (LENGTH SB-C::X) :ELEMENT-TYPE 'CHARACTER) SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.

; --> LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==>
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; --> LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; in: DEFUN PRINT-SYMBOL-INFO
;     (FORMAT T "~&~S ~<~;~^~A~@{~:@_~A~}~;~:>" SYMBOL CL-PPCRE::OUTPUT-LIST)
; --> FORMAT FORMATTER FUNCTION BLOCK LET PPRINT-LOGICAL-BLOCK 
; --> SB-PRETTY::WITH-PRETTY-STREAM FLET BLOCK LET IF 
; --> SB-KERNEL:WITH-CIRCULARITY-DETECTION LABELS BLOCK SB-KERNEL:DESCEND-INTO 
; --> FLET COND IF COND THE PROGN LET 1+ 
; ==>
;   (+ SB-KERNEL:*CURRENT-LEVEL-IN-PRINT* 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.

; --> FORMAT FORMATTER FUNCTION BLOCK LET PPRINT-LOGICAL-BLOCK 
; --> SB-PRETTY::WITH-PRETTY-STREAM FLET BLOCK LET IF 
; --> SB-KERNEL:WITH-CIRCULARITY-DETECTION LABELS BLOCK SB-KERNEL:DESCEND-INTO 
; --> FLET COND IF AND IF AND IF AND THE >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> FORMAT FORMATTER FUNCTION BLOCK LET PPRINT-LOGICAL-BLOCK 
; --> SB-PRETTY::WITH-PRETTY-STREAM FLET BLOCK LET IF 
; --> SB-KERNEL:WITH-CIRCULARITY-DETECTION LABELS BLOCK SB-KERNEL:DESCEND-INTO 
; --> FLET COND IF AND IF AND IF AND THE >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> FORMAT FORMATTER FUNCTION BLOCK LET PPRINT-LOGICAL-BLOCK 
; --> SB-PRETTY::WITH-PRETTY-STREAM 
; ==>
;   (FLET ((#:WITH-PRETTY-STREAM1312 (STREAM)
;            (LET (#)
;              (IF #
;                  #
;                  #))))
;     (LET ((STREAM
;            (LET #
;              #)))
;       (IF (SB-PRETTY:PRETTY-STREAM-P STREAM)
;           (#:WITH-PRETTY-STREAM1312 STREAM)
;           (CATCH 'SB-PRETTY::LINE-LIMIT-ABBREVIATION-HAPPENED
;             (LET #
;               #
;               #))))
;     NIL)
; 
; note: Return type not fixed values, so can't use known return convention:
;   *

; --> FORMAT FORMATTER FUNCTION BLOCK LET PPRINT-LOGICAL-BLOCK 
; --> SB-PRETTY::WITH-PRETTY-STREAM FLET BLOCK LET IF 
; --> SB-KERNEL:WITH-CIRCULARITY-DETECTION LABELS BLOCK SB-KERNEL:DESCEND-INTO 
; --> FLET BLOCK LET BLOCK FLET BLOCK WHEN IF AND IF AND THE 
; ==>
;   (EQL #:PPRINT-LOGICAL-BLOCK-LENGTH-1310 *PRINT-LENGTH*)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a (OR UNSIGNED-BYTE NULL), not a FIXNUM.

; --> FORMAT FORMATTER FUNCTION BLOCK LET PPRINT-LOGICAL-BLOCK 
; --> SB-PRETTY::WITH-PRETTY-STREAM FLET BLOCK LET IF 
; --> SB-KERNEL:WITH-CIRCULARITY-DETECTION LABELS BLOCK SB-KERNEL:DESCEND-INTO 
; --> FLET COND IF AND IF AND IF AND THE >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       The second argument is a UNSIGNED-BYTE, not a FIXNUM.

; --> FORMAT FORMATTER FUNCTION BLOCK LET PPRINT-LOGICAL-BLOCK 
; --> SB-PRETTY::WITH-PRETTY-STREAM FLET BLOCK LET IF 
; --> SB-KERNEL:WITH-CIRCULARITY-DETECTION LABELS BLOCK SB-KERNEL:DESCEND-INTO 
; --> FLET COND IF COND THE PROGN LET 1+ 
; ==>
;   (+ SB-KERNEL:*CURRENT-LEVEL-IN-PRINT* 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; in: DEFUN QUOTE-META-CHARS
;     (LENGTH STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; in: DEFUN CLEAN-COMMENTS
;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::MATCH-START
;                        CL-PPCRE::MATCH-END)
; --> BLOCK MAKE-ARRAY LOCALLY MAKE-ARRAY 
; ==>
;   (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; /usr/local/lib/sbcl/site/cl-ppcre-2.0.3/api.fasl written
; compilation finished in 0:00:00.814
; compiling (DEFPARAMETER *REGEX-LIST* ...)
; compiling (DEFPARAMETER *ALTERNATIVES* ...)
; compiling (DEFUN GET-INPUT-CHARS ...)
; compiling (DEFUN MAIN ...)
; file: /home/dunham/shootout/bench/regexdna/regexdna.sbcl
; in: DEFUN MAIN
;     (LENGTH SEQUENCE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (LENGTH (CL-PPCRE:ALL-MATCHES REGEX SEQUENCE))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; compilation unit finished
;   printed 756 notes


; /home/dunham/benchmarksgame_onecore/regexdna/tmp/regexdna.fasl written
; compilation finished in 0:00:04.501
[undoing binding stack and other enclosing state... done]
[saving current Lisp image into sbcl.core:
writing 6352 bytes from the read-only space at 0x20000000
writing 4064 bytes from the static space at 0x20100000
writing 48832512 bytes from the dynamic space at 0x1000000000
done]
### START regexdna.sbcl_run
(proclaim '(optimize (speed 3) (safety 0) (debug 0) (compilation-speed 0) (space 0)))
(main) (quit)
### END regexdna.sbcl_run

5.78s to complete and log all make actions

COMMAND LINE:
/usr/local/bin/sbcl  --noinform --core sbcl.core --userinit /dev/null --load regexdna.sbcl_run 0 < regexdna-input5000000.txt

PROGRAM OUTPUT:
agggtaaa|tttaccct 356
[cgt]gggtaaa|tttaccc[acg] 1250
a[act]ggtaaa|tttacc[agt]t 4252
ag[act]gtaaa|tttac[agt]ct 2894
agg[act]taaa|ttta[agt]cct 5435
aggg[acg]aaa|ttt[cgt]ccct 1537
agggt[cgt]aa|tt[acg]accct 1431
agggta[cgt]a|t[acg]taccct 1608
agggtaa[cgt]|[acg]ttaccct 2178

50833411
50000000
66800214
